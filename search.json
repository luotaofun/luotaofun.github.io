[{"title":"Spring基础","url":"/2021/11/29/2021-11-29-Spring%E5%9F%BA%E7%A1%80/","content":"Ioc\r\n将目标对象的创建的控制权由最初的消费者转嫁给一个中间的角色,这个中间角色负责将对象创建并集中管理,对集中管理的容器叫Ioc容器，顾客在获取对象的过程中，不再对对象直接操作，而是通过Ioc容器提取，拿到所需要的对象。\r\n\r\nIoc控制反转, inverse of\r\ncontrol是一种宏观的设计理念。\r\n由代理人来创建与管理对象，消费者通过代理人来获取对象。\r\nloc的目的是降低对象之间直接耦合（通过代理人解耦，对象之间可以灵活变化）；加入IoC容器将对象统一管理，让对象关联变为弱耦合。\r\n\r\n\r\nimage-20211129100634336\r\n\r\n在生活中的典型体现:\r\n1.如何在众多品种中挑选出最脆甜的苹果呢?\r\n只需要问老板（代理人）哪些苹果（对象）是最脆甜的,听取老板的采购意见,将获取对象的权力交给水果老板,有老板做出决定,如果老板说这种苹果也不错,那么这种苹果极有可能出现在我的采购清单里。\r\n\r\n\r\nimage-20211129093609962\r\n\r\n\r\n​\r\n2.在一个陌生城市安居，大多数人都回去找中介，而不是房东，因为中介有足够多的房源，足够多的选择，我们可以根据中介提供的信息选择自己心仪的，虽然会收取中介费，但避免了许多麻烦，节约了时间成本。\r\nDI依赖注入\r\n\r\nDependency\r\ninjection是具体技术实现，是微观实现。\r\nDI在不同语言中使用的具体技术是不一样的，在Java中实现DI是基于Java的反射技术。\r\n\r\nSpring\r\n\r\n\r\nimage-20211130104735708\r\n\r\n\r\nSpring Framework的核心是IoC容器与AOP面向切面编程\r\nspring IoC负责创建与管理系统对象,并在此基础上扩展功能\r\nSpring生态体系\r\n\r\nSpring IoC\r\n运行时运用Java反射技术动态的将对象实例化以及对对象进行注入\r\n职责\r\n\r\n对象的控制权交由第三方统一管理(IoC控制反转)\r\n利用Java反射技术实现运行时对象创建与关联(DI依赖注入)\r\n基于配置提高应用程序的可维护性与扩展性\r\n\r\nSpring IoC初体验\r\n妈妈在早餐后给三个孩子分发餐后水果,\r\n盘子里由三个苹果: 红富士/青苹果/金帅,\r\n孩子们口味不同: 莉莉喜欢甜的/安迪喜欢酸的/露娜喜欢软软的,\r\n孩子们如何得到喜欢的苹果?\r\n(一)使用传统的编码方式\r\n\r\n新建maven工程\r\n\r\n\r\n\r\nimage-20211129111517457\r\n\r\n\r\n\r\n\r\nimage-20211129125924501\r\n\r\nApple类\r\n\r\npackage com.kuroneko.spring.ioc.entity;public class Apple &#123;    private String title; // 品种    private String color;    private String origin; // 产地    public Apple() &#123;    &#125;    public Apple(String title, String color, String origin) &#123;        this.title = title;        this.color = color;        this.origin = origin;    &#125;    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getColor() &#123;        return color;    &#125;    public void setColor(String color) &#123;        this.color = color;    &#125;    public String getOrigin() &#123;        return origin;    &#125;    public void setOrigin(String origin) &#123;        this.origin = origin;    &#125;&#125;\r\n\r\nChild类\r\npackage com.kuroneko.spring.ioc.entity;public class Child &#123;    private String name;    private Apple apple;    public Child() &#123;    &#125;    public Child(String name, Apple apple) &#123;        this.name = name;        this.apple = apple;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Apple getApple() &#123;        return apple;    &#125;    public void setApple(Apple apple) &#123;        this.apple = apple;    &#125;    public void eat()&#123;        System.out.println(name+ &quot;吃到了&quot;+ apple.getOrigin()+ &quot;种植的&quot;+ apple.getTitle());    &#125;&#125;\r\nApplication类\r\npackage com.kuroneko.spring.ioc;import com.kuroneko.spring.ioc.entity.Apple;import com.kuroneko.spring.ioc.entity.Child;public class Application &#123;    public static void main(String[] args) &#123;        Apple apple1 = new Apple(&quot;红富士&quot;, &quot;红色&quot; ,&quot;欧洲&quot;);        Apple apple2 = new Apple(&quot;青苹果&quot;, &quot;绿色&quot; ,&quot;中亚&quot;);        Apple apple3 = new Apple(&quot;金帅&quot;, &quot;黄色&quot; ,&quot;中国&quot;);        Child lily = new Child(&quot;莉莉&quot;, apple1);        Child andy = new Child(&quot;安迪&quot;, apple2);        Child luna = new Child(&quot;露娜&quot;, apple3);        lily.eat();        andy.eat();        luna.eat();    &#125;&#125;\r\n运行Application\r\n\r\n\r\nimage-20211129143658399\r\n\r\n这种传统的编码方式一旦涉及到代码的修改就必须要重新上线,这不利于软件的维护性和可扩展性,根本原因就是运用了new关键字，在编译期间就将对象与对象之间进行了强制绑定。那如何解决这些问题呢？这时Spring\r\nIoC容器就应运而生了，通过配置的形式完成对象的实例化以及对象和对象之间的依赖关系。\r\n\r\n（二）引入Spring IoC容器\r\n\r\npom.xml\r\n&lt;!--    添加阿里云的镜像,可以大幅提高maven远程下载的速度--&gt;    &lt;repositories&gt;       &lt;repository&gt;           &lt;id&gt;aliyun&lt;/id&gt;           &lt;name&gt;aliyun&lt;/name&gt;&lt;!--           阿里云对外开放的公共仓库,可以有效的提高组件下载速度--&gt;           &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;       &lt;/repository&gt;    &lt;/repositories&gt;    &lt;dependencies&gt;        &lt;dependency&gt;&lt;!--            机构名字--&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;!--        使用Spring IoC容器最小的依赖范围--&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\r\n\r\n\r\nimage-20211129145601026\r\n\r\n创建Spring IoC核心配置文件applicationContext.xml\r\n所有对象的创建以及关联的设置都是在这个文件中进行的\r\n访问Spring官网\r\n\r\n\r\nimage-20211129151333399\r\n\r\n\r\n\r\n\r\nimage-20211129151358092\r\n\r\n\r\n\r\nimage-20211129151456767\r\n\r\n复制作为文档说明部分,schema规定了在当前xml中可以书写哪些标签\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;\r\n\r\n\r\nimage-20211129151626183\r\n\r\n\r\n粘贴到applicationContext.xml中\r\n\r\n\r\nimage-20211129152300940\r\n\r\n有三种苹果,需要使用bean创建三个对象,bean是用于实例化Java对象的标签。\r\n\r\n&lt;!--    在IoC容器启动时,自动由Spring实例化Apple对象,取名sweetApple放入到容器中--&gt;    &lt;bean id=&quot;sweetApple&quot; class=&quot;com.kuroneko.spring.ioc.entity.Apple&quot;&gt;        &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--酸苹果--&gt;    &lt;bean id=&quot;sourApple&quot; class=&quot;com.kuroneko.spring.ioc.entity.Apple&quot;&gt;        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;!--软苹果--&gt;    &lt;bean id=&quot;softApple&quot; class=&quot;com.kuroneko.spring.ioc.entity.Apple&quot;&gt;        &lt;property name=&quot;title&quot; value=&quot;金帅&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;color&quot; value=&quot;黄色&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;origin&quot; value=&quot;中国&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;\r\n\r\nioc这个包下创建SpringApplication类\r\npackage com.kuroneko.spring.ioc;import com.kuroneko.spring.ioc.entity.Apple;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringApplication &#123;    public static void main(String[] args) &#123;//        启动IoC容器后才能对刚才配置的bean实例化        // 创建Spring IoC容器，加载指定的xml文件来初始化IoC容器,classpath:代表在当前类路径下查找applicationContext.xml文件。此时context指代IoC容器        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);        /**        *使用getBean()将对应标签的苹果从容器中提取出来,Apple.class是提取的类型        *也可以写成Apple sweetApple = (Apple)context.getBean(&quot;sweetApple&quot;);        object类型强制转换为Apple类型        */        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);        //打印输出苹果的品种        System.out.println(sweetApple.getTitle());    &#125;&#125;\r\n运行SpringApplication\r\n\r\n\r\nimage-20211129161941253\r\n\r\n到applicationContext.xml创建三个Child对象\r\n&lt;!--    创建三个Child对象--&gt;    &lt;bean id=&quot;lily&quot; class=&quot;com.kuroneko.spring.ioc.entity.Child&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;&lt;!--        IoC容器运行后自动通过反射技术将容器中的sweetApple的apple对象赋予到lily的apple属性中--&gt;        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;andy&quot; class=&quot;com.kuroneko.spring.ioc.entity.Child&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;安迪&quot;/&gt;        &lt;property name=&quot;apple&quot; ref=&quot;sourApple&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;luna&quot; class=&quot;com.kuroneko.spring.ioc.entity.Child&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;露娜&quot;/&gt;        &lt;property name=&quot;apple&quot; ref=&quot;softApple&quot;/&gt;    &lt;/bean&gt;\r\n到SpringApplication中从IoC容器中提取三个孩子对象\r\n//        从IoC容器中提取三个孩子对象        Child lily = context.getBean(&quot;lily&quot;, Child.class);        lily.eat();        Child andy = context.getBean(&quot;andy&quot;, Child.class);        andy.eat();        Child luna = context.getBean(&quot;luna&quot;, Child.class);        luna.eat();\r\n运行SpringApplication\r\n\r\n\r\nimage-20211129170119981\r\n\r\n\r\n配置Bean的三种方式\r\n基于XML配置Bean\r\n上面例子的applicationContext.xml\r\n// 创建Spring IoC容器，加载指定的xml文件来初始化IoC容器,classpath:代表在当前类路径下查找applicationContext.xml文件。此时context指代IoC容器,使用ApplicationContext的实现类ClassPathXmlApplicationContext来加载配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);\r\n\r\n基于构造方法实例化对象\r\n\r\nbean标签默认通过默认构造方法创建对象\r\n&lt;!--    bean标签默认通过默认构造方法创建对象--&gt;    &lt;bean id=&quot;apple1&quot; class=&quot;com.kuroneko.spring.ioc.entity.Apple&quot;&gt;            &lt;/bean&gt;\r\npublic Apple() &#123;    System.out.println(&quot;Apple对象已创建,&quot;+ this);&#125;    \r\n利用构造方法参数名实例化,使用constructor-arg\r\nname=“构造方法参数名” value=“”\r\n    &lt;bean id=&quot;apple2&quot; class=&quot;com.kuroneko.spring.ioc.entity.Apple&quot;&gt;&lt;!--        没有constructor-arg则代表调用默认构造方法实例化--&gt;        &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士&quot;/&gt;        &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;        &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;    &lt;/bean&gt;\r\npublic Apple(String title, String color, String origin) &#123;    System.out.println(&quot;通过带参构造方法创建对象,&quot;+ this);    this.title = title;    this.color = color;    this.origin = origin;&#125;\r\n利用构造方法参数位置实例化\r\n    &lt;bean id=&quot;apple3&quot; class=&quot;com.kuroneko.spring.ioc.entity.Apple&quot;&gt;&lt;!--     利用构造方法参数位置实现对象实例化--&gt;      &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;        &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;        &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;    &lt;/bean&gt;\r\n\r\n工厂模式\r\n用途 :\r\n隐藏创建类的细节,通过一个额外的工厂类来组织创建我们需要的对象。\r\n\r\n基于静态工厂实例化对象\r\n\r\nioc包下创建factory用于保存工厂类，然后创建AppleStaticFactory类代表苹果的静态工厂\r\npackage com.kuroneko.spring.ioc.factory;import com.kuroneko.spring.ioc.entity.Apple;public class AppleStaticFactory &#123;/** * 静态工厂通过静态方法创建对象,隐藏创建对象的细节,static意味着这个方法是属于工厂类的 * 创建static的 甜苹果对象 */    public static Apple createSweetApple()&#123;        Apple apple =new Apple();        apple.setTitle(&quot;红富士&quot;);        apple.setOrigin(&quot;欧洲&quot;);        apple.setColor(&quot;红色&quot;);        return apple;    &#125;&#125;\r\n&lt;!--    利用静态工厂获取对象--&gt;    &lt;bean id=&quot;apple4&quot; class=&quot;com.kuroneko.spring.ioc.factory.AppleStaticFactory&quot;          factory-method=&quot;createSweetApple&quot;&gt;&lt;/bean&gt;\r\n\r\n基于工厂实例方法实例化对象\r\n工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程\r\n\r\nfactory包下创建AppleFactoryInstance类\r\npackage com.kuroneko.spring.ioc.factory;import com.kuroneko.spring.ioc.entity.Apple;/** * 工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程 *不用static关键字意味着这个方法是属于这个工厂对象的,而不是属于工厂类的 */public class AppleFactoryInstance &#123;    public Apple createSweetApple() &#123;        Apple apple = new Apple();        apple.setTitle(&quot;红富士&quot;);        apple.setOrigin(&quot;欧洲&quot;);        apple.setColor(&quot;红色&quot;);        return apple;    &#125;&#125;\r\n&lt;!--    利用工厂实例方法获取对象--&gt;    &lt;bean id=&quot;factoryInstance&quot; class=&quot;com.kuroneko.spring.ioc.factory.AppleFactoryInstance&quot;/&gt;    &lt;bean id=&quot;apple5&quot; factory-bean=&quot;factoryInstance&quot; factory-method=&quot;createSweetApple&quot;/&gt;\r\n      \r\n\r\n\r\n\r\n扩展\r\nbean id与name属性\r\n\r\n都是设置对象在IoC容器中唯一标识\r\n两者在同一个配置文件中都不允许重复出现\r\n多个配置文件运行重复,新对象会覆盖旧对象\r\n驼峰命名书写\r\nname可以一次性设置多个标识,而id只能设置一个,如 bean name=“apple2,\r\napple7”\r\n在没有Id与name的bean默认使用类名全称作为bean标识\r\n\r\n基于注解配置Bean\r\n基于Java代码配置Bean\r\nbean scope属性详解\r\n用于决定对象何时被创建与作用范围\r\n配置将影响容器内对象的数量\r\n默认值singleton(单例),指全局共享同一个对象实例\r\n\r\n\r\nimage-20211130162157940\r\n\r\n\r\nsingleton(单例模式)\r\nsingleton在容器是单例多线程执行，存在线程安全风险\r\n为什么spring默认使用单例模式?\r\n如果每一次在需要某个对象的时候都去创建它,会额外占用内存空间和cpu的计算资源,频繁创建对象会带来的资源损耗,使用单例模式可以有效的解决创建对象时占用资源的问题,在IoC启动时会自动的默认实例化对象。\r\n\r\nioc包下创建dao.UserDao\r\npackage com.kuroneko.spring.ioc.dao;public class UserDao &#123;    public UserDao()&#123;        System.out.println(&quot;UserDao已创建:&quot;+ this);    &#125;&#125;\r\nioc包下创建service.UserService\r\npackage com.kuroneko.spring.ioc.service;import com.kuroneko.spring.ioc.dao.UserDao;public class UserService &#123;    private UserDao userDao;    public UserService()&#123;        System.out.println(&quot;UserService已创建:&quot;+ this);    &#125;    public UserDao getUserDao() &#123;        return userDao;    &#125;    public void setUserDao(UserDao userDao) &#123;        System.out.println(&quot;调用setUserDao&quot;+ userDao);        this.userDao = userDao;    &#125;&#125;\r\n```java\r\n\r\n\r\n      以上配置在Ioc初始化过程中会产生几个对象呢?    会创建两个对象,第一个对象是UserService,因为它使用的是单例模式,会在IoC容器初始化过程中创建UserService对象,又由于UserService**引入了UserDao对象**(UserDao在初始化过程中是不存在的)于是容器又对UserDao实例化。    ![image-20211201162952316](2021-11-29-Spring基础/image-20211201162952316.png)* prototype多例  **在getBean（）或对象注入时才会实例化对象**  prototype在容器中多实例，占用更多资源，不存在线程安全问题* singleton线程安全解决方案  ![image-20211130165142101](2021-11-29-Spring基础/image-20211130165142101.png)  * 为每一个线程加锁，在设置和读取的过程中，让当前代码处于独占的状态用户2只有当用户1处理完以后才可以继续处理，相当于把多线程并行的运行改为串形的排队执行  * 为每一个用户都分配一个只属于它自己的对象，各操作各的互不影响，就不会产生信息错乱的问题，创建多个对象的设置放在Spring IoC容器中就称之为prototype多例    ![image-20211130165601977](2021-11-29-Spring基础/image-20211130165601977.png)![image-20211130165710503](2021-11-29-Spring基础/image-20211130165710503.png)当看到一份配置文件时,你要能马上反应出来,当前的IoC容器在初始化过程中到底实例化了几个对象。如果在单例模式下，IoC初始化时是按照bean的前后顺序依次进行的，但如果第一个bean增加了prototype，第一个bean并不会在IoC容器初始化自动实例化，而在某一个属性关联到一个多例对象的时候同样会触发实例化对象的操作。# 单例和多例的使用场景作为某一个属性，如果在运行过程中它是恒定不变的，那就可以在当前容器中进行单例的设置，如果在运行过程中它在不断的变化，那就使用多例模式# bean的生命周期![image-20211201165512806](2021-11-29-Spring基础/image-20211201165512806.png)* init-methodentity包下创建Order菜单类```javapackage com.kuroneko.spring.ioc.entity;public class Order &#123;    private Float price;    private Integer quantity;    private Float total;    public Order() &#123;        System.out.println(&quot;创建Order对象,&quot; + this);    &#125;    public void init()&#123;        System.out.println(&quot;执行init()方法&quot;);        total = price * quantity;    &#125;    public void pay()&#123;        System.out.println(&quot;订单金额为:&quot; + total);    &#125;    public Float getPrice() &#123;        return price;    &#125;    public void setPrice(Float price) &#123;        System.out.println(&quot;设置price&quot; + price);        this.price = price;    &#125;    public Integer getQuantity() &#123;        return quantity;    &#125;    public void setQuantity(Integer quantity) &#123;        System.out.println(&quot;设置quantity&quot; + quantity);        this.quantity = quantity;    &#125;    public Float getTotal() &#123;        return total;    &#125;    public void setTotal(Float total) &#123;        this.total = total;    &#125;&#125;\r\n\r\n\r\n&lt;bean id=&quot;order1&quot; class=&quot;com.kuroneko.spring.ioc.entity.Order&quot; init-method=&quot;init&quot;&gt;        &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;        &lt;property name=&quot;quantity&quot; value=&quot;1000&quot;/&gt;    &lt;/bean&gt;\r\npublic class SpringApplication &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);        System.out.println(&quot;======IoC容器已初始化======&quot;);        Order Order1 = context.getBean(&quot;order1&quot;, Order.class);        Order1.pay();    &#125;\r\n\r\n\r\nimage-20211202145304272\r\n\r\n\r\n销毁IoC容器\r\nOrder类添加destory方法\r\npublic void destroy()&#123;        System.out.println(&quot;释放与订单对象相关的资源&quot;);    &#125;\r\n&lt;bean id=&quot;order1&quot; class=&quot;com.kuroneko.spring.ioc.entity.Order&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;        &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;        &lt;property name=&quot;quantity&quot; value=&quot;1000&quot;/&gt;    &lt;/bean&gt;\r\n/**         * registerShutdownHook()用于销毁IoC容器,会自动调用我们在bean中设置的destroy-method方法         *  registerShutdownHook()放在了ClassPathXmlApplicationContext这个ApplicationContext的具体实现类中,因此在调用时强制转换回具体的实现类         */        ((ClassPathXmlApplicationContext)context).registerShutdownHook();\r\n\r\n\r\nimage-20211202152937798\r\n\r\n\r\n实现极简IoC容器\r\n","tags":["Spring"]},{"title":"English-Study","url":"/2025/04/13/English-Study/","content":"be动词（is are）\r\n\r\nis\r\n\r\n第三人称单数： He/She/It is here.\r\n不可数名词： Water is important.\r\n集体名词强调整体： The team is strong.\r\n存在句单数： There is a pen on the desk.\r\n\r\nare\r\n\r\nI/You/We/They are friends. You and I are good partners.\r\n复数名词：The books are on the table.\r\n集体名词强调成员： The team are arguing.\r\n存在句复数： There are three pens on the desk.\r\n\r\n\r\nbe动词的过去式（was were）\r\n\r\nwas\r\n\r\n第一人单数: I was tired yesterday.\r\n第三人称（he,she,it,单数名称）单数: The cate was hungry.\r\n\r\nwere\r\n\r\nyou 无论单双固定搭配were: You were late.\r\n虚拟语气，在表示假设、愿望或与事实相反的情况中无论主语是什么人称都were\r\nif 引导的非真实条件句：If I were you，I would study harder.\r\nwish表达愿望：I wish she were here.\r\n\r\n\r\n时态\r\n1.一般过去时\r\n\r\n定义：\r\n\r\n过去某时刻发生的动作或所处的状态\r\n过去常常发生的动作\r\n\r\n结构：\r\n\r\n主语 + was\r\n主语 + V过去式\r\n\r\n标志词：昨天上个XX前，in+过去年份别忘记\r\n​ yesterday the day before yesterday\r\n​ last week last year last month\r\n​ five days ago two minutes ago\r\n​ in 1998\r\n\r\n\r\n+ed\r\n\r\nlooked\r\n// live lived 不发音的e结尾要去e+d\r\n\r\n辅元辅结构并且音调重读：双写+ed\r\n\r\nplan planned stop stopped\r\n// open opened 没有音调重读\r\n\r\n辅+y结尾：y变i + ed\r\n\r\nstudy studied\r\n// stay stayed 没有满足辅音结构\r\n\r\n特殊变化\r\n\r\ngo went\r\nget got\r\nsay said\r\ncome came\r\n\r\n\r\n1.1句型转换\r\n\r\nI was a student ten years ago.\r\n否定句-be动词+not: I wasn’t a student ten years age.\r\n一般疑问句-be动词提前: Were you a student ten years ago?\r\nI went to the theatre last week.\r\n否定句-助动词后面+照妖镜原型: I didn’t go to the theatre last\r\nweek.\r\n一般疑问句-助动词提前: Did you go to the theatre last week?\r\n\r\n"},{"title":"面向对象之单例模式与多态","url":"/2022/02/09/2022-02-09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E6%80%81/","content":"设计模式\r\n设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。\r\n\r\n\r\nimage-20220209214001437\r\n\r\n单例模式\r\n\r\n目的：使得类的对象成为该类系统中的唯一实例\r\n定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供\r\n\r\n实现：\r\n\r\n只提供私有的构造方法（类当中的构造方法的访问权限是private，无法在类外通过new关键字直接实例化，相当于限定了这个类实例化产生的渠道）\r\n含有一个该类的静态私有对象（static满足有且只有一个实例的要求，随着类的实例化产生而产生，无论该类实例了多少对象，都共享同一个静态成员）\r\n提供一个静态的公有方法用于创建、获取静态私有对象\r\n\r\n代码实现\r\n饿汉式：\r\n\r\nSingletonOne类\r\npackage com.kuroneko.singleton;//饿汉式：对象创建过程中实例化（不管你用不用我先实例化，放在那） //空间换时间（类加载时就完成实例化，速度快，但存在周期长，空间大），线程安全public class SingletonOne &#123;\t//1.创建类中私有构造\tprivate SingletonOne() &#123;\t\t\t&#125;\t\t//2.创建该类型的私有静态实例\tprivate static SingletonOne instance=new SingletonOne();\t\t//3.创建公有静态方法返回实例对象\tpublic static SingletonOne getInstance() &#123;\t\treturn instance;\t&#125;&#125;\r\n懒汉式：* SingletonTwo类  ```java  package com.kuroneko.singleton;  //懒汉式：在静态公有方法中实例化（类内实例对象创建时不直接初始化，直到第一次调用get方法时，才完成初始化操作）   //时间换空间，存在线程风险  public class SingletonTwo &#123;  \t// 1.创建私有构造方法  \tprivate SingletonTwo() &#123;    \t&#125;    \t// 2.创建静态的该类实例对象  \tprivate static SingletonTwo instance=null;    \t// 3.创建静态公有方法，提供实例对象  \tpublic static SingletonTwo getInstance() &#123;  \t\tif (instance == null)  \t\t\tinstance = new SingletonTwo();  \t\treturn instance;  \t&#125;  &#125;  \r\nTest类\r\npackage com.kuroneko.test;import com.kuroneko.singleton.SingletonOne;import com.kuroneko.singleton.SingletonTwo;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\t SingletonOne one=SingletonOne.getInstance();\t\t SingletonOne two=SingletonOne.getInstance();\t\t System.out.println(one);\t\t System.out.println(two);\t\t System.out.println(one==two);//ture,说明one和two的引用相同，都指向同一块空间\t\t System.out.println(&quot;=============================================&quot;);\t\t SingletonTwo one1=SingletonTwo.getInstance();\t\t SingletonTwo two1=SingletonTwo.getInstance();\t\t System.out.println(one1);\t\t System.out.println(two1);\t\t System.out.println(one1==two1);\t&#125;&#125;\r\n\r\n特点及使用场景\r\n优点：\r\n1. 在内存中只有一个对象，节省内存空间\r\n2. 避免频繁的创建销毁对象，提高性能\r\n3. 避免对共享资源的多重占用\r\n缺点：\r\n1. 扩展困难\r\n2. 如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失\r\n使用场景：\r\n1. 创建对象时占用资源过多，但同时又需要用到该类对象\r\n2. 对系统内资源要求统一读写，如读写配置信息\r\n3. 当多个实例存在可能引起程序逻辑错误，如号码生成器\r\n关于单例模式的常见问题\r\n\r\n\r\n4-2 关于单例模式的常见问题\r\n\r\nJava多态\r\n意味着允许不同类的对象对同一消息做出不同的响应\r\n\r\n\r\nimage-20220210115350954\r\n\r\n必要条件：\r\n1. 满足继承关系\r\n2. 父类引用指向子类对象\r\n案例\r\n\r\n\r\nimage-20220210115755908\r\n\r\n\r\nAnimal类\r\n\r\npackage com.kuroneko.animal;public class Animal &#123; \t//属性：昵称、年龄\tprivate String name;\tprivate int month;\t\tpublic Animal() &#123;\t\t\t&#125;\t\tpublic Animal(String name,int month) &#123;\t\tthis.setName(name);\t\tthis.setMonth(month);\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tthis.month = month;\t&#125;\t\t\t//方法：吃东西\tpublic void eat() &#123;\t\tSystem.out.println(&quot;动物都有吃东西的能力&quot;);\t&#125;\t&#125;\r\n\r\nCat类\r\npackage com.kuroneko.animal;public class Cat extends Animal &#123;\t// 属性：体重\tprivate double weight;\tpublic Cat() &#123;\t&#125;\tpublic Cat(String name,int month,double weight) &#123;\t\tsuper(name,month);\t\tthis.weight=weight;\t&#125;\tpublic double getWeight() &#123;\t\treturn weight;\t&#125;\tpublic void setWeight(double weight) &#123;\t\tthis.weight = weight;\t&#125;\t\t// 方法：跑动\tpublic void run() &#123;\t\tSystem.out.println(&quot;小猫快乐的奔跑&quot;);\t&#125;\t// 方法：吃东西（重写父类方法）\t@Override\tpublic void eat() &#123;\t\tSystem.out.println(&quot;猫吃鱼~~&quot;);\t&#125;&#125;\r\nDog类\r\npackage com.kuroneko.animal;public class Dog extends Animal &#123;\t// 属性：性别\tprivate String sex;\tpublic Dog() &#123;\t&#125;\tpublic Dog(String name, int month, String sex) &#123;\t\tsuper(name, month);\t\tthis.setSex(sex);\t&#125;\tpublic String getSex() &#123;\t\treturn sex;\t&#125;\tpublic void setSex(String sex) &#123;\t\tthis.sex = sex;\t&#125;\t// 方法：睡觉\tpublic void sleep() &#123;\t\tSystem.out.println(&quot;小狗有午睡的习惯&quot;);\t&#125;\t// 方法：吃东西（重写父类方法）\t@Override\tpublic void eat() &#123;\t\tSystem.out.println(&quot;狗吃肉~~&quot;);\t&#125;&#125;\r\nTests类\r\npackage com.kuroneko.test;import com.kuroneko.animal.Animal;import com.kuroneko.animal.Cat;import com.kuroneko.animal.Dog;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tAnimal one = new Animal();// 1\t\t/*\t\t * 向上转型、隐式转型、自动转型 父类引用指向子类实例，可以调用子类重写父类的方法以及父类派生的方法，无法调用子类独有方法 小类转型为大类\t\t 注意：父类中的静态方法无法被子类重写，所以向上转型后，只能调用父类原有的静态方法\t\t */\t\tAnimal two = new Cat();// 2\t\tAnimal three = new Dog();// 3\t\tone.eat();\t\ttwo.eat();\t\tthree.eat();\t\tSystem.out.println(&quot;========================&quot;);\t\t/*\t\t * 向下转型、强制类型转换 子类的引用指向父类对象，此处必须进行强转，这时可以调用子类特有的方法 必须满足转型条件才能进行转换\t\t * instanceof运算符：判断对象是否具有一个特定类型的实例特征（true/false）\t\t */\t\tif (two instanceof Cat) &#123;\t\t\tCat temp = (Cat) two;// 相当于把two还原成Cat类型，two具有Cat的实例特征\t\t\ttemp.eat();\t\t\ttemp.run();\t\t\tSystem.out.println(&quot;two可以转换为Cat类型&quot;);\t\t&#125;\t\tif (two instanceof Dog) &#123;\t\t\tDog temp2 = (Dog) two;// 没有满足转型条件,two不是Dog的实例，不具有Dog的实例特征\t\t\ttemp2.eat();\t\t\ttemp2.sleep();\t\t\tSystem.out.println(&quot;two可以转换为Dog类型&quot;);\t\t&#125;\t\t//two 具有Animal的特征，也具有Object的特征\t\tif (two instanceof Animal) &#123;\t\t\tSystem.out.println(&quot;Animal&quot;);\t\t&#125;\t\tif (two instanceof Object) &#123;\t\t\tSystem.out.println(&quot;Object&quot;);\t\t&#125;\t&#125;&#125;\r\n    # 向上转型和动态绑定机制![向上转型和动态绑定机制](2022-02-09-面向对象之单例模式与多态/向上转型和动态绑定机制.png)# 关于类型转换的应用问题![image-20220210204831150](2022-02-09-面向对象之单例模式与多态/image-20220210204831150.png)![3-10 关于类型转换的应用问题](2022-02-09-面向对象之单例模式与多态/关于类型转换的应用问题.png)# 关于向下转型易出现错误总结![3-11 关于向下转型易出现错误总结](2022-02-09-面向对象之单例模式与多态/关于向下转型易出现错误总结.png)# 类型转换案例* Master类  ```java  package com.kuroneko.animal;    public class Master &#123;  \t/*  \t * 喂宠物 喂猫咪：吃完东西后，主人会带着去玩线球 喂狗狗：吃完东西后，主人会带着狗狗去睡觉  \t */  \t//方案1：编写方法，传入不同类型的动物，调用各自的方法  //\tpublic void feed(Cat cat) &#123;  //\t\tcat.eat();  //\t\tcat.playBall();  //\t&#125;  //  //\tpublic void feed(Dog dog) &#123;  //\t\tdog.eat();  //\t\tdog.sleep();  //\t&#125;  \t//方案2：编写方法传入动物的父类，方法中通过类型转换，调用指定子类的方法  \tpublic void feed(Animal obj) &#123;  \t\tif(obj instanceof Cat) &#123;  \t\t\tCat temp=(Cat)obj;  \t\t\ttemp.eat();  \t\t\ttemp.playBall();  \t\t&#125;else if(obj instanceof Dog) &#123;  \t\t\tDog temp=(Dog)obj;  \t\t\ttemp.eat();  \t\t\ttemp.sleep();  \t\t&#125;   \t&#125;  \t  \t/*  \t * 饲养何种宠物  \t * 空闲时间多：养狗狗  \t * 空闲时间少：养猫咪  \t */  \t//方案1：  //\tpublic Dog hasManyTime() &#123;  //\t\tSystem.out.println(&quot;主人休闲时间比较充足，适合养狗狗&quot;);  //\t\treturn new Dog();  //\t&#125;  //\t  //\tpublic Cat hasLittleTime() &#123;  //\t\tSystem.out.println(&quot;主人平时比较忙碌，适合养喵咪&quot;);  //\t\treturn new Cat();  //\t&#125;  \t//方案2：  \tpublic Animal raise(boolean isManyTime) &#123;  \t\tif(isManyTime) &#123;  \t\t\tSystem.out.println(&quot;主人休闲时间比较充足，适合养狗狗&quot;);  \t\t\treturn new Dog();  \t\t&#125;else &#123;  \t\t\tSystem.out.println(&quot;主人平时比较忙碌，适合养喵咪&quot;);  \t\t\treturn new Cat();  \t\t&#125;  \t&#125;  &#125;  \r\nMasterTest类\r\n\r\npackage com.kuroneko.test;import com.kuroneko.animal.Animal;import com.kuroneko.animal.Cat;import com.kuroneko.animal.Dog;import com.kuroneko.animal.Master;public class MasterTest &#123;\tpublic static void main(String[] args) &#123;\t\tMaster master=new Master();\t\tCat one=new Cat();\t\tDog two=new Dog();\t\tmaster.feed(one);\t\tmaster.feed(two);\t\tSystem.out.println(&quot;=================&quot;);\t\tboolean isManyTime=true;\t\tAnimal temp=master.raise(isManyTime);//\t\tif(isManyTime) &#123;//\t\t\ttemp=master.hasManyTime(); //\t\t&#125;else &#123;//\t\t\ttemp=master.hasLittleTime();//\t\t&#125;\t\tSystem.out.println(temp);\t&#125;&#125;\r\n练习\r\n\r\n\r\n3-20 编程练习\r\n\r\n抽象类&amp;抽象方法\r\n当一个类中没有包含足够的信息以描绘一个具体的对象时，这样的类就是抽象类\r\n\r\n\r\nimage-20220210192447144\r\n\r\n语法本身没问题，但实例化pet没有意义，具体干活的是它的子类\r\n\r\n\r\nimage-20220210192253760\r\n\r\n抽象类避免了子类设计随意性和无意义父类的实例化\r\n抽象类不能直接实例化（因为没有意义），只能被继承，可以通过向上转型完成对象实例\r\n抽象方法不需要具体实现\r\n包含抽象方法的类一定是抽象类，抽象类中可以没有抽象方法\r\n当一个类中包含抽象方法后，这个类的子类必须要重写这个抽象方法\r\n\r\nAnimal2类\r\npackage com.kuroneko.animal;public abstract class Animal2 &#123; \tprivate String name;\tprivate int month;\t\tpublic Animal2() &#123;\t\t\t&#125;\t\tpublic Animal2(String name,int month) &#123;\t\tthis.setName(name);\t\tthis.setMonth(month);\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tthis.month = month;\t&#125;\t\t\t//抽象方法：没有方法体；子类中需要重写父类的抽象方法，否则子类也要是抽象类\t//static final private不可以和abstract并存，因为抽象方法必须在子类中重写，而static final private修饰的方法都不可以被重写\tpublic abstract void eat();&#125;\r\nDog2类\r\npackage com.kuroneko.animal;public class Dog2 extends Animal2 &#123;\tprivate String sex;\tpublic Dog2() &#123;\t&#125;\tpublic Dog2(String name, int month, String sex) &#123;\t\tsuper(name, month);\t\tthis.setSex(sex);\t&#125;\tpublic String getSex() &#123;\t\treturn sex;\t&#125;\tpublic void setSex(String sex) &#123;\t\tthis.sex = sex;\t&#125;\tpublic void sleep() &#123;\t\tSystem.out.println(&quot;小狗有午睡的习惯&quot;);\t&#125;\t// 重写父类的抽象方法\t@Override\tpublic void eat() &#123;\t\tSystem.out.println(&quot;狗吃肉~~&quot;);\t&#125;\t&#125;\r\n\r\n\r\nimage-20220210204116891\r\n\r\n关于抽象类应用总结\r\n\r\n\r\n\r\n4-5 关于抽象类应用总结\r\n\r\n练习\r\n\r\n\r\n4-6 编程练习\r\n\r\n案例\r\n\r\n\r\nimage-20220210205344021\r\n\r\n都有相同的行为能力\r\n\r\n\r\nimage-20220210211806575\r\n\r\n接口\r\n我们可以通过接口来描述不同的类型具有相识的行为特征，从而建立关系之后，以接口引用指向实现类的方式来描述不同类型对于接口行为的具体表现\r\n接口定义了某一批类所需要遵守的规范，当类去实现接口时，就表明这个类具有了接口当中所设定的行为能力\r\n接口不关心这些类的内部数据，也不关心这些类里的方法的实现细节，它只规定这些类里必须提供某些方法\r\n\r\nTelphone类\r\npackage com.kuroneko.tel;/** * 原始手机 * @author kuroneko * */public class Telphone &#123;\tprivate String brand;//品牌\tprivate int price;\t\tpublic Telphone() &#123;\t\t\t&#125;\t\tpublic String getBrand() &#123;\t\treturn brand;\t&#125;\tpublic void setBrand(String brand) &#123;\t\tthis.brand = brand;\t&#125;\tpublic int getPrice() &#123;\t\treturn price;\t&#125;\tpublic void setPrice(int price) &#123;\t\tthis.price = price;\t&#125;\t\t//打电话\tpublic void call() &#123;\t\tSystem.out.println(&quot;手机可以打电话&quot;);\t&#125;&#125;\r\nSecondPhone类\r\npackage com.kuroneko.tel;public class SecondPhone extends Telphone &#123;\tpublic void message() &#123;\t\tSystem.out.println(&quot;手机可以发短信&quot;);\t&#125;&#125;\r\nThirdPhone类\r\npackage com.kuroneko.tel;public class ThirdPhone extends SecondPhone &#123;\tpublic void vedio() &#123;\t\tSystem.out.println(&quot;手机可以看视频&quot;);\t&#125;\t\tpublic void music() &#123;\t\tSystem.out.println(&quot;手机可以听音乐&quot;);\t&#125;\t\tpublic void connection() &#123;\t\tSystem.out.println(&quot;我是ThirdPhone的connection&quot;);\t&#125;&#125;\r\nFourthPhone类\r\npackage com.kuroneko.tel;public class FourthPhone extends ThirdPhone implements IPhoto,INet&#123;//\tpublic void photo() &#123;//\t\tSystem.out.println(&quot;手机可以拍照&quot;);//\t&#125;\t\tpublic void network() &#123;\t\tSystem.out.println(&quot;手机可以上网&quot;);\t&#125;\t\tpublic void game() &#123;\t\tSystem.out.println(&quot;手机可以玩游戏&quot;);\t&#125;\t@Override\tpublic void photo() &#123; \t\tSystem.out.println(&quot;手机可以拍照&quot;);\t&#125;&#125;\r\nINet接口\r\npackage com.kuroneko.tel;//接口访问修饰符：public 默认，不可以使用protectedpublic interface INet &#123;\t/*\t * 默认加上public abstract，所以可以省略不写\t * 当类实现接口时，需要去实现接口中所有的抽象方法，否则需要将该类设置为抽象类\t * 没有方法体\t */\tpublic abstract void network();\t//接口中可以包含常量，默认加上public static final\t int TEMP=20;\t //default: 默认方法，可以带方法体，可以在实现类中重写，也可以不重写，可以通过接口的引用调用\t default void connection() &#123;\t\t System.out.println(&quot;我是接口中的默认连接方法&quot;);\t &#125;\t //static：静态方法，可以带方法体,不可以在实现类中重写，可以通过接口名调用\t static void stop() &#123;\t\t System.out.println(&quot;我是接口中的静态方法&quot;);\t &#125;&#125;\r\nIPhoto接口\r\npackage com.kuroneko.tel;/** * 具有照相能力的接口 * @author kuroneko * */public interface IPhoto &#123;\t//具有拍照的能力\t//接口中抽象方法可以不写abstract关键字\tpublic void photo();\t\tdefault void connection() &#123;\t\tSystem.out.println(&quot;我是IPhoto的connection默认方法&quot;);\t&#125;&#125;\r\nComputer类\r\npackage com.kuroneko.tel;public class Computer implements INet&#123;//\tpublic void network() &#123;//\t\tSystem.out.println(&quot;电脑可以上网&quot;);//\t&#125;\t\tpublic void game() &#123;\t\tSystem.out.println(&quot;电脑可以玩游戏&quot;);\t&#125;\t\tpublic void vedio() &#123;\t\tSystem.out.println(&quot;电脑可以看视频&quot;);\t&#125;\t\tpublic void music() &#123;\t\tSystem.out.println(&quot;电脑可以听音乐&quot;);\t&#125;\t@Override\tpublic void network() &#123;\t\tSystem.out.println(&quot;电脑可以上网&quot;);\t&#125;\t@Override\tpublic void connection() &#123;\t\t// TODO Auto-generated method stub\t\t\t&#125;&#125;\r\nSmartWatch类\r\npackage com.kuroneko.tel;public class SmartWatch implements INet,IPhoto&#123;\tpublic static final int TEMP=30;//定义和接口中同名的信息\tpublic void call() &#123;\t\tSystem.out.println(&quot;智能手表可以打电话&quot;);\t&#125;\tpublic void message() &#123;\t\tSystem.out.println(&quot;智能手表可以发短信&quot;);\t&#125;\tpublic void network() &#123;\t\tSystem.out.println(&quot;智能手表可以上网&quot;);\t&#125;\t@Override\tpublic void photo() &#123;\t&#125;\tpublic void connection() &#123;\t\tSystem.out.println(&quot;SmartWatch中的connection&quot;);\t&#125;\t\t&#125;\r\nCamera类\r\npackage com.kuroneko.tel;public class Camera implements IPhoto&#123;\t@Override\tpublic void photo() &#123;\t\tSystem.out.println(&quot;相机可以拍照&quot;);\t&#125;//\tpublic void photo() &#123;//\t\tSystem.out.println(&quot;相机可以拍照&quot;);//\t&#125;&#125;\r\nPhoneTest类\r\npackage com.kuroneko.test;import com.kuroneko.tel.Camera;import com.kuroneko.tel.FourthPhone;import com.kuroneko.tel.INet;import com.kuroneko.tel.IPhoto;import com.kuroneko.tel.SmartWatch;public class PhoneTest &#123;\tpublic static void main(String[] args) &#123;\t\tFourthPhone phone=new FourthPhone();\t\tphone.call();\t\tphone.message();\t\tphone.vedio();\t\tphone.music();\t\tphone.photo();\t\tphone.network();\t\tSystem.out.println(&quot;====================&quot;);\t\tIPhoto ip=new FourthPhone();\t\tip.photo();\t\tip=new Camera();\t\tip.photo();\t\tSystem.out.println(&quot;====================&quot;);\t\t//访问接口中的常量\t\tSystem.out.println(INet.TEMP);\t\t//通过接口的引用指向具体的实现类\t\tINet net=new SmartWatch();\t\t//如果实现类中存在和接口中同名的信息，使用接口的引用指向实现类时，打印的是接口中定义的信息\t\tSystem.out.println(net.TEMP);\t\t//通过接口的引用调用接口中的默认方法\t\tnet.connection();\t\t//通过接口名调用接口中的静态方法\t\tINet.stop();\t\t//通过实现类对象调用和接口中同名信息，打印的是实现类中定义的信息\t\tSmartWatch sw=new SmartWatch();\t\tSystem.out.println(sw.TEMP);\t\tSystem.out.println(&quot;====================&quot;);//调用实现类SmartWatch中的重写的connection\t\tINet net2=new SmartWatch();net2.connection();\t\tIPhoto ip2=new SmartWatch();\t\tip2.connection();\t\tSystem.out.println(&quot;====================&quot;);\t\t//默认调用父类thirdPhone中的connection\t\tINet net3=new FourthPhone();\t\tnet3.connection();\t\tIPhoto ip3=new FourthPhone();\t\tip3.connection();\t&#125;&#125;\r\n关于接口应用常见问题\r\n\r\n\r\n1-5\r\n关于接口应用常见问题（Ⅰ）\r\n\r\n\r\n\r\n\r\n1-10 关于接口应用常见问题（Ⅱ\r\n）\r\n\r\n\r\n\r\n1-15 关于接口应用常见问题（Ⅲ\r\n）\r\n\r\n练习\r\n\r\n\r\n1-8 编程练习\r\n\r\n\r\n\r\nimage-20220211162627812\r\n\r\n\r\n\r\nimage-20220211162807922\r\n\r\n接口的继承\r\n\r\nIFather接口\r\n\r\npackage com.kuroneko.test;public interface IFather &#123;\tvoid say();\t\tdefault void connection() &#123;\t\tSystem.out.println(&quot;IFather中的connection&quot;);\t&#125;&#125;\r\n\r\nIFather2接口\r\npackage com.kuroneko.test;public interface IFather2 &#123;\tvoid fly();\t\tdefault void connection() &#123;\t\tSystem.out.println(&quot;IFather2中的connection&quot;);\t&#125;&#125;\r\nISon接口\r\npackage com.kuroneko.test;//接口可以继承多个接口public interface ISon extends IFather,IFather2&#123;\tvoid run();\tdefault void connection() &#123;\t\tSystem.out.println(&quot;ISon中的connection&quot;);\t&#125;&#125;\r\nDemo类\r\npackage com.kuroneko.test;public class Demo implements ISon &#123;\t@Override\tpublic void say() &#123;\t\t// TODO Auto-generated method stub\t&#125;\t@Override\tpublic void run() &#123;\t\t// TODO Auto-generated method stub\t&#125;\t@Override\tpublic void fly() &#123;\t\t// TODO Auto-generated method stub\t\t\t&#125;&#125;\r\n\r\n接口和抽象类的比较\r\n\r\n\r\n1-16 接口和抽象类的比较\r\n\r\nUML中的类关系表示（上）\r\n\r\n\r\n1-18 UML中的类关系表示（上）\r\n\r\n\r\n\r\n1-19 UML中的类关系表示（下）\r\n\r\n内部类\r\n将一个类定义在另一个类里面或者一个方法里面\r\n内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类，更好的实现了信息隐藏\r\n\r\n\r\nimage-20220211173251790\r\n\r\n\r\n成员内部类\r\n静态内部类\r\n方法内部类\r\n匿名内部类\r\n\r\n成员内部类\r\n\r\nPerson类\r\npackage com.kuroneko.people;//外部类public class Person &#123;\tint age;\t//在外部类设置一个获取内部类的方法，以便于内部类的实例化操作\tpublic Heart getHeart() &#123;\t\tnew Heart().temp=15;//通过内部类实例修改内部类的temp\t\treturn new Heart();\t&#125;\t\tpublic void eat() &#123;\t\tSystem.out.println(&quot;人会吃东西&quot;);\t&#125;\t//成员内部类\t/*\t * 1. 内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化\t * 2. 内部类可以直接访问外部类的成员；如果出现同名属性，优先访问内部类中定义的\t * 3. 可以使用外部类.this.成员的方式，访问外部类中同名的信息\t * 4. 外部类无法直接访问内部类信息，需要通过内部类实例\t * 5. 内部类编译后.class文件命名：外部类$内部类.class\t * 6. 内部类是否可以包含与外部类相同方法签名的方法,在内部类可以通过外部类.this.方法名调用\t */\tclass Heart&#123;\t\tint age=13;\t\tint temp=14;\t\tpublic String beat() &#123;\t\t\teat();\t\t\tPerson.this.eat();\t\t\treturn Person.this.age+&quot;岁的心脏在跳动&quot;;\t\t&#125;\t\t\t\tpublic void eat() &#123;\t\t\tSystem.out.println(&quot;人会吃东西(内部类)&quot;);\t\t&#125;\t&#125;&#125;\r\nPeopleTest类\r\npackage com.kuroneko.people;public class PeopleTest &#123;\tpublic static void main(String[] args) &#123;\t\tPerson lili=new Person();\t\tlili.age=12;\t\t\t\t//获取内部类对象实例，方式1：new 外部类.new 内部类\t\tPerson.Heart myHeart=new Person().new Heart();\t\tSystem.out.println(myHeart.beat());\t\t\t\t//获取内部类对象实例，方式2： 外部类对象.new 内部类\t\tmyHeart=lili.new Heart();\t\tSystem.out.println(myHeart.beat());\t\t\t\t//获取内部类对象实例，方式3： 外部类对象.获取方法\t\tmyHeart=lili.getHeart();\t\tSystem.out.println(myHeart.beat());\t&#125;&#125;\r\n\r\n静态内部类\r\n静态内部类对象可以不依赖外部类对象，直接创建\r\n\r\nPerson类\r\npackage com.kuroneko.people;//外部类public class Person &#123;\tint age;\tpublic Heart getHeart() &#123;\t\tnew Heart().temp=15;\t\treturn new Heart();\t&#125;\t\tpublic void eat() &#123;\t\tSystem.out.println(&quot;人会吃东西&quot;);\t&#125;\t//静态内部类\t/*\t * 1. 静态内部类中，只能直接访问外部类的静态成员，如果选哟调用非静态成员，可以通过对象实例调用\t * 2. 静态内部类对象实例时，可以不依赖外部类对象\t * 3. 可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员 \t */\tstatic class Heart&#123;\t\tint age=13;\t\tint temp=14;\t\t//内部类的静态方法\t\tpublic static void say() &#123;\t\t\tSystem.out.println(&quot;hello&quot;);\t\t&#125;\t\tpublic String beat() &#123;\t\t\tnew Person().eat();//1\t\t\treturn new Person().age+&quot;岁的心脏在跳动&quot;;\t\t&#125;\t\t\t&#125;&#125;\r\nPeopleTest类\r\npackage com.kuroneko.people;public class PeopleTest &#123;\tpublic static void main(String[] args) &#123;\t\tPerson lili=new Person();\t\tlili.age=12;\t\t\t\t\t\t//获取静态内部类对象实例\t\tPerson.Heart myHeart=new Person.Heart();\t\tSystem.out.println(myHeart.beat());\t\t//调用静态内部类的静态方法\t\tPerson.Heart.say();\t&#125;&#125;\r\n\r\n方法内部类\r\n局部内部类\r\n\r\n\r\nimage-20220211185510736\r\n\r\n\r\nPerson类\r\npackage com.kuroneko.people;//外部类public class Person &#123;\tint age;\tpublic Object getHeart() &#123;\t\t//方法内部类\t\t/*\t\t * 1. 定义在方法内部，作用范围也在方法内\t\t * 2. 和方法内部成员使用规则一样，class前面不可以添加public、private、protected、static\t\t * 3. 类中不能包含静态成员\t\t * 4. 类中可以包含final、abstract修饰的成员\t\t */\t\tclass Heart &#123;\t\t\tint age = 13;\t\t\tint temp = 14;\t\t\tpublic void say() &#123;\t\t\t\tSystem.out.println(&quot;hello&quot;);\t\t\t&#125;\t\t\t\t\t\tpublic void eat() &#123;\t\t\t&#125;\t\t\tpublic String beat() &#123;\t\t\t\tnew Person().eat();\t\t\t\treturn new Person().age + &quot;岁的心脏在跳动&quot;;\t\t\t&#125;\t\t&#125;\t\treturn new Heart().beat();\t&#125;\tpublic void eat() &#123;\t\tSystem.out.println(&quot;人会吃东西&quot;);\t&#125;&#125;\r\nPeopleTest类\r\npackage com.kuroneko.people;public class PeopleTest &#123;\tpublic static void main(String[] args) &#123;\t\tPerson lili=new Person();\t\tlili.age=12;\t\t\t\t\t\tSystem.out.println(lili.getHeart());\t&#125;&#125;\r\n\r\n匿名内部类\r\n需求：根据传入的不同的人的类型，调用对应的read方法\r\n\r\nPerson类\r\npackage com.kuroneko.anonymous;public abstract class Person &#123;\tprivate String name;\t\tpublic Person() &#123;\t\t\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t\tpublic abstract void read();&#125;\r\nMan类\r\npackage com.kuroneko.anonymous;public class Man extends Person &#123;\t@Override\tpublic void read() &#123;\t\tSystem.out.println(&quot;男生喜欢看科幻类书籍&quot;);\t&#125;&#125;\r\nWoman类\r\npackage com.kuroneko.anonymous;public class Woman extends Person &#123;\t@Override\tpublic void read() &#123;\t\tSystem.out.println(&quot;女生喜欢读言情小说&quot;);\t&#125;&#125;\r\nPersonTest类\r\npackage com.kuroneko.test;import com.kuroneko.anonymous.Man;import com.kuroneko.anonymous.Person;import com.kuroneko.anonymous.Woman;public class PersonTest &#123;\t// 需求：根据传入的不同的人的类型，调用对应的read方法\t// 方案1：重载//\tpublic void getRead(Man man) &#123;//\t\tman.read();//\t&#125;////\tpublic void getRead(Woman woman) &#123;//\t\twoman.read();//\t&#125;\t\t//方案2：向上转型\tpublic void getRead(Person person) &#123;\t\tperson.read();\t&#125;\tpublic static void main(String[] args) &#123;\t\tPersonTest test=new PersonTest();\t\tMan one=new Man();\t\tWoman two=new Woman();\t\ttest.getRead(one);\t\ttest.getRead(two);\t&#125;&#125;\r\n方案3：匿名内部类：在实例对象的同时，完成对于对象内容的编写\r\npackage com.kuroneko.test;import com.kuroneko.anonymous.Person;public class PersonTest &#123;\tpublic void getRead(Person person) &#123;\t\tperson.read();\t&#125;\tpublic static void main(String[] args) &#123;\t\tPersonTest test = new PersonTest();\t\t/*\t\t * 方案3：匿名内部类：在实例对象的同时，完成对于对象内容的编写\t\t * 适用场景：只用到类的一个实例；类在定义后马上用到；给类命名并不会导致代码更容易被理解\t\t * 编译后的文件命名：外部类$数字.class\t\t * 无法使用private、public、protected、abstract、static修饰\t\t * 无法编写构造方法，可以添加构造代码块\t\t * 不能出现静态成员\t\t * 匿名内部类可以实现接口也可以继承父类，但不可兼得\t\t */\t\ttest.getRead(new Person() &#123;\t\t\t&#123;\t\t\t\t//构造代码块\t\t\t&#125;\t\t\t@Override\t\t\tpublic void read() &#123;\t\t\t\tSystem.out.println(&quot;男生喜欢看科幻类书籍&quot;);\t\t\t&#125;\t\t&#125;);\t\ttest.getRead(new Person() &#123;\t\t\t@Override\t\t\tpublic void read() &#123;\t\t\t\tSystem.out.println(&quot;女生喜欢读言情小说&quot;);\t\t\t&#125;\t\t&#125;);\t&#125;&#125;\r\n\r\n\r\nimage-20220211224301627\r\n\r\n\r\n练习\r\n\r\n\r\n2-9 编程练习\r\n\r\n接口中的内部类应用\r\n\r\n\r\n2-10 接口中的内部类应用\r\n\r\n常见内部类的比较\r\n\r\n\r\n2-11 常见内部类的比较\r\n\r\n关于内部类的常见问题\r\n\r\n\r\n2-12 关于内部类的常见问题\r\n\r\n项目作业\r\n\r\n\r\n3-2 项目作业\r\n\r\n拓展：枚举的基本使用\r\n\r\n\r\n3-3 拓展：枚举的基本使用\r\n\r\n\r\n\r\nimage-20220211224859766\r\n\r\n\r\n\r\n3-5\r\n拓展：枚举在switch结构中的应用\r\n\r\n"},{"title":"面向对象之封装与继承","url":"/2022/01/21/2022-01-21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF/","content":"类和对象\r\n宠物商店买猫:\r\n向店员描述自己期望中猫的模型(小一点,短毛,可爱的),然后店员带你去看了两只猫\r\n\r\n\r\nimage-20220121123638369\r\n\r\n\r\n\r\nimage-20220121123720647\r\n\r\n对应Java程序设计中:\r\n类就是模子,确定对象将会拥有的特征(属性)和行为(方法)\r\n对象是具有属性和行为的实体\r\n对象是类的实例表现\r\n对象是特定类型的数据\r\n\r\n\r\nimage-20220121124103219\r\n\r\n属性和方法\r\n属性: 对象具有的各种静态特征(对象有什么)\r\n方法: 对象具有的各种动态行为(对象能做什么)\r\n类和对象的关系\r\n对象: 用来描述客观事物的一个实体\r\n类: 具有相同属性和方法的一组对象的集合\r\n\r\n\r\nimage-20220121124711034\r\n\r\n\r\n创建类\r\npackage com.kuroneko.animal;/** * 宠物猫类 * @author kuroneko * */public class Cat &#123;\t//成员属性: 昵称,年龄,体重,品种\tString name;\tint month;//年龄\tdouble weight;\tString species;//品种\t//成员方法: 跑动,吃东西\tpublic void run() &#123;\t\tSystem.out.println(&quot;小猫快跑&quot;);\t&#125;\tpublic void eat() &#123;\t\tSystem.out.println(&quot;小猫吃鱼&quot;);\t&#125;&#125;\r\n实例化对象\r\npackage com.kuroneko.animal;public class CatTest &#123;\tpublic static void main(String[] args) &#123;\t\t//对象实例化\t\tCat one=new Cat();\t\t//测试\t\tone.eat();\t\tone.run();\t\t//当把一个变量所在类中作为成员属性存在时,它是有默认初始值的\t\tSystem.out.println(&quot;昵称:&quot;+one.name);\t\tSystem.out.println(&quot;年龄:&quot;+one.month);\t\tSystem.out.println(&quot;体重:&quot;+one.weight);\t\tSystem.out.println(&quot;品种:&quot;+one.species);\t\t//重新赋值\t\tone.name=&quot;花花&quot;; \t\tone.month=2;\t\tone.weight=1000;\t\tone.species=&quot;英国短毛猫&quot;;\t\t//调用重载的run方法\t\tone.run(one.name);\t&#125;&#125;\r\n\r\n单一职责原则\r\n为什么main方法要放在CatTest类中？\r\n又叫单一功能原则,有且只有一个引起功能变化的原因。\r\n即一个类只有一个功能，只干一件事，因为如果在一个类当中，承担的功能越多，他的交融，耦合性就越高，被复用的可能性就大大降低\r\n尽量将不同的职责放到不同的类中，把不同的，能引发变化的原因封装在不同的类中，这样在某一方发生变化的时候，会降低对其他的影响。\r\nCatTest是如何找到Cat的？（拆分的类是如何交互的？类间如何识别）\r\njava的搜索机制，主方法在运行时，会先在它所在类里面查找相关的类是否存在，也就是会先在CatTest里面找cat，如果找不到，会向上，进而找他同一个包里的（com.kuroneko.animal）有没有一个叫Cat的类，如果找到能被允许访问的，会找它里面的成员属性和方法，若属性和方法也是能访问的，CatTest就会顺利执行。\r\n单一职责原则（SRP：Single responsibility\r\nprinciple）又称单一功能原则，面向对象五个基本原则（SOLID： SRP 单一责\r\n任原则、OCP 开放封闭原则、LSP 里氏替换原则、DIP 依赖倒置原则、ISP\r\n接口分离原则）之一。它规定一个类应该只有\r\n一个发生变化的原因。该原则由罗伯特·C·马丁（Robert\r\nC.Martin）于《敏捷软件开发：原则、模式和实践》一书中给出\r\n的。马丁表示此原则是基于汤姆·狄马克(Tom DeMarco)和 Meilir Page-Jones\r\n的著作中的内聚性原则发展出的。\r\n所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就\r\n是指一个类或者模块应该有且只有一个改变的原因。\r\n单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的\r\n可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职\r\n责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多\r\n个职责总是同时发生改变则可将它们封装在同一类中。\r\n之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：T负责两个不同的职责：职责\r\nP1，职责 P2。当由 于职责 P1 需求发生改变而需要修改类 T\r\n时，有可能会导致原本运行正常的职责P2 功能发生故障。也就是说职责 P1 和 P2\r\n被耦合在了一起。\r\n解决办法：遵守单一职责原则，将不同的职责封装到不同的类或模块中。分别建立两个类\r\nT1、T2，使 T1 完成职责 P1 功 能，T2 完成职责 P2 功能。这样，当修改类 T1\r\n时，不会使职责 P2 发生故障风险；同理，当修改 T2 时，也不会使职责 P1\r\n发生故障风险。\r\nnew关键字\r\n对象实例化就是对象创建的过程\r\n实例化对象的过程可以分为两部分：\r\n\r\n声明对象 Cat one；\r\n\r\n\r\nimage-20220121145018237\r\n\r\n在内存的栈空间里开辟了一块\r\n区域叫做one，这时还不是一个有效的对象，因为这时one是null的，是一个空盒子，什么都没有，进行属性和方法的调用是不被允许的，当我们实例化操作new\r\nCat（）；时就可以真正使用对象了\r\n实例化对象 new Cat（）；\r\n\r\n\r\nimage-20220121145636485\r\n\r\n内存的堆空间里开辟了一块空间，完成了这个对象相关信息的初始化操作。\r\n\r\njava程序是运行在jvm虚拟机上的\r\n\r\n\r\nimage-20220121145820587\r\n\r\n栈是内存空间中的一块区域，主要用于保存局部变量的值，堆是内存空间的另一快区域，主要\r\n用于存放动态数据，譬如说，new出来的实例化的具体的对象，无论是通过基本数据类型声明的对象，还是通过引用数据声明的，都是可以出现在栈当中的，基本数据类型的变量在栈里面是直接保存它所对应的值\r\n\r\n\r\nimage-20220121150730255\r\n\r\n\r\n\r\nimage-20220121150932743\r\n\r\n在栈内存中开辟一块空间取名a，里面直接存放数字10，而引用数据类型声明的one保存的只是一个指向堆里面\r\n具体空间的地址，根据这个地址，我们继而可以找到这个实例在堆当中对应的对象信息，因此，基本数据类型的变量是在栈当中占用一块内存，而引用数据类型的变量在堆和栈当中会各占一块内存\r\n\r\n\r\nimage-20220121152237511\r\n\r\n\r\n\r\n初识Java内存管理之堆和栈\r\n\r\n\r\n\r\nimage-20220121153824984\r\n\r\n需要多次访问同一对象时，必须进行声明\r\n否则，可以省略声明，匿名对象进行方法调用，如下\r\n\r\n\r\nimage-20220121154402015\r\n\r\n同一作用范围内，不能定义同名对象.\r\n\r\n\r\nimage-20220121155004297\r\n\r\n\r\n\r\nimage-20220121194201452\r\n\r\none\r\n和two对象指的是同一块内存区域,所以第二次的操作会覆盖第一次的信息\r\n\r\n\r\nimage-20220121195522291\r\n\r\n\r\n\r\nimage-20220121195601631\r\n\r\n构造方法\r\n使用构造方法完成对象初始化的相关设置\r\n\r\nnew关键字的好搭档,只能在对象实例化的时候调用,不能被对象单独调用\r\n构造方法名与类名相同且没有返回值\r\n\r\n\r\nimage-20220121200846648\r\n\r\n当没有指定构造方法时,系统会自动添加无参的构造方法,当有指定构造方法时优先使用指定的构造方法\r\n一个类中可以有多个构造方法\r\n\r\npackage com.kuroneko.animal;/** * 宠物猫类 * @author kuroneko * */  public class Cat &#123;\t//成员属性: 昵称,年龄,体重,品种\tString name;\tint month;//年龄\tdouble weight;\tString species;//品种\t//成员方法: 跑动,吃东西\tpublic Cat() &#123;\t\tSystem.out.println(&quot;我是无参构造方法!在对象实例化时,会完成构造方法的调用&quot;);\t&#125;\tpublic Cat(String name) &#123;\t\tSystem.out.println(&quot;我是带参构造方法!&quot;);\t&#125;\tpublic void run() &#123;\t\tSystem.out.println(&quot;小猫快跑&quot;);\t&#125;\tpublic void run(String name) &#123;\t\tSystem.out.println(name+ &quot;快跑&quot;);\t&#125;\tpublic void eat() &#123;\t\tSystem.out.println(&quot;小猫吃鱼&quot;);\t&#125;&#125;\r\npackage com.kuroneko.animal;public class CatTest &#123;\tpublic static void main(String[] args) &#123;\t\t// 对象实例化\t\tCat one = new Cat();//使用无参构造方法\t\tCat two = new Cat(&quot;花花&quot;);//使用带参构造方法\t\tone.run();\t&#125;&#125;\r\nthis关键字代表当前对象\r\n给属性赋值\r\n\r\n\r\nimage-20220122135419271\r\n\r\n谁调用了this,谁就是当前对象,当前对象是one\r\n\r\n\r\nimage-20220122135821390\r\n\r\nthis可以调用方法,this.eat();表示调用当前类当中小猫eat的方法\r\n\r\n\r\nimage-20220122140103381\r\n\r\n同一个类的构造方法之间可以用this();调用无参构造方法\r\n\r\n\r\nimage-20220122145229749\r\n\r\n\r\n\r\nthis关键字的应用—调用构造方法\r\n\r\n\r\n\r\nthis关键字的应用—方法参数和返回值\r\n\r\n\r\n\r\n构造方法常见问题总结\r\n\r\n就近原则\r\n\r\n\r\n就近原则总结\r\n\r\n面向对象\r\n\r\n\r\nimage-20220122160948419\r\n\r\n\r\n\r\nimage-20220122161212063\r\n\r\n\r\n\r\nimage-20220122161343739\r\n\r\n封装\r\n将类的某些信息隐藏在类的内部,不允许外部程序直接访问,通过该类提供的方法来实现对隐藏信息的操作和访问。\r\n\r\n\r\nimage-20220123162120474\r\n\r\n封装的意义\r\n1）便于使用者正确的方便的理解和使用系统，防止使用者错误修改系统的属性。如果属性变为\r\npublic，就好比，到银行去存钱，不是通过柜面进行操作的，而是直接跑到银行的金库里面自己去拿钱了，这样就很不安全，这个例子中，可以把银行金库中的钱看作是某一对象的属性，而柜面的工作人员、出纳柜台就可以看作是set\r\n/get 方法了，也就是让对外服务提供某些接口，具体里面的操作就隐藏起来了。\r\n再比如电视机系统，尽管它本身的实现很复杂，但用户使用起来却非常简单，只要通过遥控器上的几个按钮就能享受电视机提供的服务。电视机的实现细节被藏在它的大壳子里，没有必要向用户公开。\r\n（2）有助于建立各个系统之间的松耦合关系，提高系统的独立性。当某一个系统的实现发生变化，只要它的接口不变，就不会影响到其他的系统。\r\n（3）提高软件的可重用性，每个系统都是一个相对独立的整体，可以在多种环境中得到重用。例如干电池就是一个可重用的独立系统，在相机、手电筒、电动剃须刀和玩具赛车中都能发挥作用。\r\n（4）降低了构建大型系统的风险，即使整个系统不成功，个别的独立子系统有可能依然是有价值的。例如相机损坏了，它的干电池依然有用，可以安装到手电筒中。\r\n一个设计良好的系统会封装所有的实现细节，把它的接口与实现清晰的隔离开来，系统之间只通过接口进行通信。面向对象的编程语言主要是通过访问控制机制来进行封装，这种机制能控制对象的属性和方法的可访问性。\r\n封装的代码实现\r\nprivate 限定只能在当前类内访问\r\n\r\n\r\nimage-20220127111721498\r\n\r\npackage com.kuroneko.animal;public class Cat &#123;\t//修改属性的可见性---private 限定只能在当前类内访问\tprivate String name;\tprivate int month;\tprivate double weight;\tprivate String species;\t\t//构造方法\tpublic Cat() &#123;\t\t\t&#125;\t//通过带参构造完成属性的设定\tpublic Cat(int month) &#123;\t\tthis.setMonth(month);//调用当前类中setMonth方法\t&#125;\t//创建公有的get/set方法来完成对外的开放接口\t//在get/set方法中添加对属性的限定\tpublic void setName(String name) &#123;\t\tthis.name=name;\t&#125;\tpublic String getName() &#123;\t\treturn &quot;我是一只名叫&quot;+this.name+&quot;的猫咪!&quot;;  //返回当前类的name属性\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tif(month&lt;=0)\t\t\tSystem.out.println(&quot;输入信息有误,小猫的年龄必须大于0!&quot;);\t\telse\t\t\tthis.month = month;\t&#125;\tpublic double getWeight() &#123;\t\treturn weight;\t&#125;\tpublic void setWeight(double weight) &#123;\t\tthis.weight = weight;\t&#125;\tpublic String getSpecies() &#123;\t\treturn species;\t&#125;\tpublic void setSpecies(String species) &#123;\t\tthis.species = species;\t&#125;\t&#125;\r\npackage com.kuroneko.animal;public class CatTest &#123;\tpublic static void main(String[] args) &#123;\t\t//对象实例化\t\tCat one=new Cat();\t\tCat two=new Cat(-3);\t\tone.setName(&quot;凡凡&quot;);\t\tSystem.out.println(one.getName());\t&#125;&#125;\r\n\r\n\r\n关于封装应用中的常见问题\r\n\r\n\r\n\r\n1-9 编程练习\r\n\r\npackage com.kuroneko.exercise;public class Book &#123;\tprivate String title;\tprivate String author;\tprivate String press;\tprivate double price;\tpublic Book() &#123;\t&#125;\tpublic Book(String title,String author,String press,double price) &#123;\t\tthis.title=title;\t\tthis.author=author;\t\tthis.setPress(press);\t\tthis.setPrice(price);\t&#125;\tpublic String getTitle() &#123;\t\treturn this.title;\t&#125;\tpublic String getAuthor() &#123;\t\treturn author;\t&#125;\tpublic String getPress() &#123;\t\treturn press;\t&#125;\tpublic void setPress(String press) &#123;\t\tthis.press=press;\t&#125;\tpublic double getPrice() &#123;\t\treturn price;\t&#125;\tpublic void setPrice(double price) &#123;\t\tif(price&lt;=10) &#123;\t\t\tthis.price=10;\t\t\tSystem.out.println(&quot;图书价格必须大于10!&quot;);\t\t&#125;else\t\t\tthis.price=price;\t&#125;\t\tpublic void information() &#123;\t\tSystem.out.println(&quot;书名:&quot;+ title);\t\tSystem.out.println(&quot;作者:&quot;+ author);\t\tSystem.out.println(&quot;出版社:&quot;+ press);\t\tSystem.out.println(&quot;价格:&quot;+price+&quot;元&quot;);\t\t\t\tSystem.out.println(&quot;==========================================&quot;);\t&#125;\t&#125;\r\npackage com.kuroneko.exercise;public class BookTest &#123;\tpublic static void main(String[] args) &#123;\t\tBook book1,book2;\t\tbook1=new Book(&quot;红楼梦&quot;,&quot;曹雪芹&quot;,&quot;人民文学出版社&quot;,10);\t\tbook1.information();\t\tbook2=new Book(&quot;小李飞刀&quot;,&quot;古龙&quot;,&quot;中国长安出版社&quot;,55.5);\t\tbook2.information();\t&#125;&#125;\r\n引用数据类型的应用–方法参数\r\n\r\n\r\n引用数据类型的应用—方法参数\r\n\r\n\r\n\r\n1-11编程练习\r\n\r\n使用包进行类管理\r\n包名: 域名小写倒序+模块+功能 必须放在java源文件中的第一行\r\n\r\n\r\nimage-20220125143237587\r\n\r\n系统会优先使用定位清晰路径的类\r\n\r\n\r\nimage-20220125143455301\r\n\r\n\r\n\r\n1-15\r\npackage和import应用的常见问题\r\n\r\nstatic关键字\r\nclass前不可以使用static作为修饰符\r\n不能用static修饰方法中的局部变量,因为static是成员变量及方法的修饰符,是属于类本身的数据字段,在加载类时就已经初始化,为内存中保存.在方法体内声明的只是局部临时变量,当方法体结束后,这些临时变量会自动销毁,释放缓存空间,所以用static来修饰临时变量,是说不过去的!\r\n无论实例出多少宠物猫,对于静态的价格而言,他们是共用同一块存储空间的,这就是为什么花花的价格原来是2000,但在凡凡的价格修改为150后,两只猫最终的售价都是150的原因,因为他们操作的是内存中的同一块空间\r\n\r\n\r\nimage-20220125150356264\r\n\r\n\r\n\r\nimage-20220125150451590\r\n\r\n\r\n\r\nimage-20220125150539656\r\n\r\n\r\n\r\nimage-20220125151103827\r\n\r\n\r\n\r\n2-2\r\nstatic关键字的应用—静态属性\r\n\r\npackage com.kuroneko.animal;public class Cat &#123;\tprivate String name;\tprivate int month;\tprivate double weight;\tprivate String species;\t/**\t * static: 静态,静态成员,类成员\t * 无论这个类实例化出多少对象,都会共用同一块静态空间\t */\t//static+属性: 静态属性,类属性\tpublic  static int price;\t\tpublic Cat() &#123;\t\tSystem.out.println(&quot;我是一只宠物猫!&quot;);\t&#125;\t\tpublic Cat(int month) &#123;\t\tthis.setMonth(month);\t&#125;\t\tpublic void setName(String name) &#123;\t\tthis.name=name;\t&#125;\tpublic String getName() &#123;\t\treturn &quot;我是一只名叫&quot;+this.name+&quot;的猫咪!&quot;;  \t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tif(month&lt;=0)\t\t\tSystem.out.println(&quot;输入信息有误,小猫的年龄必须大于0!&quot;);\t\telse\t\t\tthis.month = month;\t&#125;\tpublic double getWeight() &#123;\t\treturn weight;\t&#125;\tpublic void setWeight(double weight) &#123;\t\tthis.weight = weight;\t&#125;\tpublic String getSpecies() &#123;\t\treturn species;\t&#125;\tpublic void setSpecies(String species) &#123;\t\tthis.species = species;\t&#125;\t//static+方法: 静态方法,类方法\tpublic static void eat() &#123;\t\t//run();//错误,静态方法中不能直接访问同一个类中的非静态成员,但是同一个类中的静态成员之间可以调用\t\t//可以通过对象实例化后,对象.成员方法的方式访问非静态成员\t\tCat temp=new Cat();\t\ttemp.run();\t\tSystem.out.println(&quot;小猫吃鱼!&quot;);\t&#125;\t//在成员方法中,可以直接访问类中静态方法\tpublic void run() &#123;\t\teat();\t\tthis.price=200;\t\tSystem.out.println(&quot;售价是&quot;+this.price+&quot;的&quot;+this.name+&quot;快跑!&quot;);\t&#125;&#125;\r\npackage com.kuroneko.test;import com.kuroneko.animal.Cat;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tCat one=new Cat();\t\tone.setName(&quot;花花&quot;);\t\tone.setMonth(2);\t\tone.setSpecies(&quot;英国短毛猫&quot;);\t\t//静态成员访问的两种访问方式:1对象.成员 2类.成员 推荐使用类.成员\t\t//one.price=2000;\t\tCat.price=2000;\t\t//one.eat();\t\tCat.eat();\t\t\t\tCat two=new Cat();\t\ttwo.setName(&quot;凡凡&quot;);\t\ttwo.setMonth(1);\t\ttwo.setSpecies(&quot;中华田园猫&quot;);\t\ttwo.price=150;\t\tSystem.out.println(one.getName()+&quot;的售价是&quot;+one.price);\t\tSystem.out.println(two.getName()+&quot;的售价是&quot;+two.price);\t&#125;&#125;\r\n\r\n\r\n2-5\r\nstatic关键字的应用—静态方法\r\n\r\n判断:\r\n\r\n\r\nimage-20220125160451575\r\n\r\n以上编译出错,因为静态方法不能访问非静态成员\r\n代码块\r\n静态代码块只能出现在类内，不能出现在方法内。\r\npackage com.kuroneko.exercise;public class Cat &#123;\tprivate String name;\tprivate int month;\tprivate double weight;\tprivate String species;\tpublic static int price;\tpublic Cat() &#123;\t\tSystem.out.println(&quot;我是一只宠物猫!&quot;);\t&#125;\tpublic Cat(int month) &#123;\t\tthis.setMonth(month);\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\tpublic String getName() &#123;\t\treturn &quot;我是一只名叫&quot; + this.name + &quot;的猫咪!&quot;;\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tif (month &lt;= 0)\t\t\tSystem.out.println(&quot;输入信息有误,小猫的年龄必须大于0!&quot;);\t\telse\t\t\tthis.month = month;\t&#125;\tpublic double getWeight() &#123;\t\treturn weight;\t&#125;\tpublic void setWeight(double weight) &#123;\t\tthis.weight = weight;\t&#125;\tpublic String getSpecies() &#123;\t\treturn species;\t&#125;\tpublic void setSpecies(String species) &#123;\t\tthis.species = species;\t&#125;\tpublic void run(String name) &#123;\t\t&#123;\t\t\tSystem.out.println(&quot;我是普通代码块1,顺序执行&quot;);\t\t&#125;\t\tSystem.out.println(name + &quot;快跑&quot;);\t\t&#123;\t\t\tSystem.out.println(&quot;我是普通代码块2,顺序执行&quot;);\t\t&#125;\t&#125;\t&#123;\t\tSystem.out.println(&quot;我是构造代码块,创建对象时调用,优先于构造方法执行,在每次实例化的时候都会执行一次&quot;);\t\t//构造代码块可以直接访问静态成员或非静态成员\t\tprice=120;\t\tname=&quot;花花&quot;;\t&#125;\t\tstatic&#123;\t\tSystem.out.println(&quot;我是静态代码块,类加载时调用,优先于构造代码块执行,无论实例化多少个对象,静态代码块在类加载时只执行一次,希望只执行一次的代码可以放在静态代码块中,易提高执行效率&quot;);\t\tprice=100;\t\t//静态代码块访问非静态成员,可以实例化对象,通过对象.属性赋值,跟之前学的静态方法一样\t\tCat temp=new Cat();\t\ttemp.name=&quot;凡凡&quot;;\t&#125;&#125;\r\npackage com.kuroneko.exercise;public class CatTest &#123;\tpublic static void main(String[] args) &#123;\t\tCat one=new Cat();\t\tCat two=new Cat();\t&#125;&#125;\r\n\r\n\r\n2-11\r\nstatic关键字的应用—静态代码块（上）\r\n\r\n\r\n\r\n2-12\r\nstatic关键字的应用—静态代码块（下）\r\n\r\n代码块中的变量应用\r\n\r\n\r\nimage-20220127111058790\r\n\r\n综合案例: 学生信息管理\r\n\r\n\r\nimage-20220127112528792\r\n\r\n\r\n\r\nimage-20220127112628441\r\n\r\n案例分析：\r\n\r\n\r\nimage-20220127112930991\r\n\r\n\r\nSubject类\r\npackage com.kuroneko.model;/** * 专业类 * @author kuroneko * */public class Subject &#123;\tprivate String subjectName;//专业名称\tprivate String subjectNo;//专业编号\tprivate int subjectLife;//学制年限\tprivate Student [] myStudents;//报名选修的学生信息\tprivate int studentNum;//报名选修的学生个数\t// 构造方法\tpublic Subject() &#123;\t&#125;\t//带参构造,实现对学科名称、编号、学制年限赋值\tpublic Subject(String subjectName, String subjectNo, int SubjectLife) &#123;\t\tthis.setSubjectName(subjectName);\t\tthis.setSubjectNo(subjectNo);\t\tthis.setSubjectLife(SubjectLife);\t&#125;\t\t//带参构造,实现对全部属性赋值\t\tpublic Subject(String subjectName, String subjectNo, int SubjectLife,Student [] myStudents) &#123;\t\t\tthis.setSubjectName(subjectName);\t\t\tthis.setSubjectNo(subjectNo);\t\t\tthis.setSubjectLife(SubjectLife);\t\t\tthis.setMyStudents(myStudents);\t\t&#125;\t\t// get/set\tpublic void setSubjectName(String subjectName) &#123;\t\tthis.subjectName = subjectName;\t&#125;\tpublic String getSubjectName() &#123;\t\treturn this.subjectName;\t&#125;\tpublic void setSubjectNo(String subjectNo) &#123;\t\tthis.subjectNo = subjectNo;\t&#125;\tpublic String getSubjectNo() &#123;\t\treturn this.subjectNo;\t&#125;//学制必须大于0\tpublic void setSubjectLife(int subjectLife) &#123;\t\tif (subjectLife &lt;= 0)\t\t\treturn;\t\tthis.subjectLife = subjectLife;\t&#125;\tpublic int getSubjectLife() &#123;\t\treturn this.subjectLife;\t&#125;\t/**\t * 获取选修专业的学生信息,如果保存学生信息的数组未初始化,则先初始化长度为200;\t * @return 保存学生信息的数组\t */\tpublic Student[] getMyStudents() &#123;\t\tif(this.myStudents==null)\t\t\tthis.myStudents=new Student[200];\t\treturn myStudents;\t&#125;\tpublic void setMyStudents(Student[] myStudents) &#123;\t\tthis.myStudents = myStudents;\t&#125;\tpublic int getStudentNum() &#123;\t\treturn studentNum;\t&#125;\tpublic void setStudentNum(int studentNum) &#123;\t\tthis.studentNum = studentNum;\t&#125;\t/**\t * 专业介绍方法\t * @return 专业的相关信息,包括名称、编号、学制\t */\tpublic String info() &#123;\t\tString str = &quot;专业信息如下:\\n专业名称: &quot; + this.getSubjectName() + &quot;\\n专业编号: &quot; + this.getSubjectNo() + &quot;\\n学制年限: &quot;\t\t\t\t+ this.getSubjectLife() + &quot;年&quot;;\t\treturn str;\t&#125;\tpublic void addStudent(Student stu) &#123;\t\t//1、将学生保存到数组中\t\tfor(int i=0;i&lt;this.getMyStudents().length;i++) &#123;\t\t\tif(this.getMyStudents()[i]==null) &#123;\t\t\t\tstu.setStudentSubject(this);//找到空位置后，实现专业与学生的双向关联\t\t\t\tthis.getMyStudents()[i]=stu;\t\t\t\t//2.将学生个数保存到studentNum\t\t\t\tthis.studentNum=i+1;//由于我们的数据是依次存放的，所以新添加进去的数据的位置下标加1，就是实际存储的个数了\t\t\t\treturn;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\r\nStudent类\r\npackage com.kuroneko.model;public class Student &#123;\t// 学号、姓名、性别、年龄\tprivate String studentNo;\tprivate String studentName;\tprivate String studentSex;\tprivate int studentAge;\t\tprivate Subject studentSubject;//学生选修的专业对象\tpublic Student() &#123;\t&#125;\t////多参构造,实现对编号,名称,性别,年龄的赋值\tpublic Student(String studentNo, String studentName, String studentSex, int studentAge) &#123;\t\tthis.setStudentNo(studentNo);\t\tthis.setStudentName(studentName);\t\tthis.setStudentSex(studentSex);\t\tthis.setStudentAge(studentAge);\t&#125;//多参构造,实现对全部属性的赋值\tpublic Student(String studentNo, String studentName, String studentSex, int studentAge,Subject studentSubject) &#123;\t\tthis.setStudentNo(studentNo);\t\tthis.setStudentName(studentName);\t\tthis.setStudentSex(studentSex);\t\tthis.setStudentAge(studentAge);\t\tthis.setStudentSubject(studentSubject);\t&#125;\tpublic void setStudentNo(String studentNo) &#123;\t\tthis.studentNo = studentNo;\t&#125;\tpublic String getStudentNo() &#123;\t\treturn this.studentNo;\t&#125;\tpublic void setStudentName(String studentName) &#123;\t\tthis.studentName = studentName;\t&#125;\tpublic String getStudentName() &#123;\t\treturn this.studentName;\t&#125;\t/**\t * 限定性别只能是男，否则强制赋值为男\t * \t * @param studentSex 传入的性别\t */\tpublic void setStudentSex(String studentSex) &#123;\t\tif (studentSex.equals(&quot;男&quot;) || studentSex.equals(&quot;女&quot;))\t\t\tthis.studentSex = studentSex;\t\telse\t\t\tthis.studentSex = &quot;男&quot;;\t&#125;\tpublic String getStudentSex() &#123;\t\treturn this.studentSex;\t&#125;\t/**\t * 给年龄赋值，限定必须在10~100之间，反之赋值为18\t * \t * @param studentAge 传入的年龄\t */\tpublic void setStudentAge(int studentAge) &#123;\t\tif (studentAge &lt; 10 || studentAge &gt; 100)\t\t\tthis.studentAge = 18;\t\telse\t\t\tthis.studentAge = studentAge;\t&#125;\tpublic int getStudentAge() &#123;\t\treturn this.studentAge;\t&#125;\t/**\t * \t * 通过方法实现学生与专业关联--方案3\t * 在类中添加专业对象作为属性,通过其属性获得相关信息\t *\t * 获取专业对象，如果没有实例化，先实例化后再返回\t * @return 专业对象信息\t */\tpublic Subject getStudentSubject() &#123;\t\tif(this.studentSubject==null)//null说明还没有实例化,需要实例化\t\t\tthis.studentSubject=new Subject();\t\treturn studentSubject;\t&#125;\tpublic void setStudentSubject(Subject studentSubject) &#123;\t\tthis.studentSubject = studentSubject;\t&#125;\t/**\t * 学生自我介绍的方法\t * \t * @return 自我介绍的信息，包括姓名、学号、性别、年龄\t */\tpublic String introduction() &#123;\t\tString str = &quot;学生信息如下：\\n姓名：&quot; + this.getStudentName() + &quot;\\n学号：&quot; + this.getStudentNo() + &quot;\\n性别：&quot;\t\t\t\t+ this.getStudentSex() + &quot;\\n年龄：&quot; + this.getStudentAge()+ &quot;\\n所报专业名称：&quot; +this.studentSubject.getSubjectName()+ &quot;\\n学制年限：&quot;\t\t\t\t\t\t+ this.studentSubject.getSubjectLife()+&quot;\\n专业编号&quot;+this.studentSubject.getSubjectNo();\t\treturn str;\t&#125;\t/**\t * 学生自我介绍的方法\t * 通过方法实现学生与专业关联--方案1\t * @param subjectName 专业名称\t * @param subjectLife 学制年限\t * @return 自我介绍的信息，包括姓名、学号、性别、年龄、专业名称、学制年限\t */\tpublic String introduction(String subjectName, int subjectLife,String subjectNo) &#123;\t\tString str = &quot;学生信息如下：\\n姓名：&quot; + this.getStudentName() + &quot;\\n学号：&quot; + this.getStudentNo() + &quot;\\n性别：&quot;\t\t\t\t+ this.getStudentSex() + &quot;\\n年龄：&quot; + this.getStudentAge() + &quot;\\n所报专业名称：&quot; + subjectName + &quot;\\n学制年限：&quot;\t\t\t\t+ subjectLife+&quot;\\n专业编号: &quot;+subjectNo;\t\treturn str;\t&#125;\t\t/**\t * 学生自我介绍的方法\t * 通过方法实现学生与专业关联--方案2\t * 在方法中添加1个专业对象作为参数，通过其属性获得相关信息\t * @param mySubject 所选专业的对象\t * @return 自我介绍的信息，包括姓名、学号、性别、年龄、专业名称、学制年限\t */\tpublic String introduction(Subject mySubject) &#123;\t\tString str = &quot;学生信息如下：\\n姓名：&quot; + this.getStudentName() + &quot;\\n学号：&quot; + this.getStudentNo() + &quot;\\n性别：&quot;\t\t\t\t+ this.getStudentSex() + &quot;\\n年龄：&quot; + this.getStudentAge() + &quot;\\n所报专业名称：&quot; + mySubject.getSubjectName() + &quot;\\n学制年限：&quot;\t\t\t\t+ mySubject.getSubjectLife()+&quot;\\n专业编号: &quot;+mySubject.getSubjectNo();\t\treturn str;\t&#125;&#125;\r\nSchoolTest类\r\npackage com.kuroneko.test;import com.kuroneko.model.Student;import com.kuroneko.model.Subject;public class SchoolTest &#123;\tpublic static void main(String[] args) &#123;\t\t//测试Subject\t\tSubject sub1=new Subject(&quot;大数据技术与应用&quot;,&quot;1902437&quot;,3);\t\tSystem.out.println(sub1.info());\t\tSystem.out.println(&quot;==================================&quot;);\t\t//测试Student\t\tStudent stu1=new Student(&quot;s01&quot;,&quot;张三&quot;,&quot;女&quot;,200,sub1);\t\tSystem.out.println(stu1.introduction());\t\tSystem.out.println(&quot;==================================&quot;);\t\tStudent stu2=new Student(&quot;s02&quot;,&quot;李四&quot;,&quot;女&quot;,17);\t\tSystem.out.println(stu2.introduction(&quot;大数据技术与应用&quot;, 3,&quot;1902437&quot;));\t\tSystem.out.println(&quot;==================================&quot;);\t\tStudent stu3=new Student(&quot;s03&quot;,&quot;王五&quot;,&quot;男&quot;,18);\t\tSystem.out.println(stu3.introduction(sub1));\t\tSystem.out.println(&quot;==================================&quot;);\t\t//测试指定专业有多少学生报名选修\t\tsub1.addStudent(stu1);\t\tsub1.addStudent(stu2);\t\tsub1.addStudent(stu3);\t\tSystem.out.println(sub1.getSubjectName()+&quot;专业已经有&quot;+sub1.getStudentNum()+&quot;名学生报名选修！&quot;);\t&#125;&#125;\r\n\r\n关于类型创建阶段常见问题\r\n\r\n\r\n2-4 关于类型创建阶段常见问题\r\n\r\n引用数据类型应用—成员属性\r\n\r\n\r\n2-8\r\n引用数据类型应用—成员属性\r\n\r\n\r\n\r\nimage-20220128111623539\r\n\r\n\r\n\r\nimage-20220128112707306\r\n\r\n关于类型关联阶段常见问题\r\n\r\n\r\n2-11\r\n关于类型关联阶段常见问题\r\n\r\n新增需求: 学生信息存储\r\n大数据专业有多少个学生进行了报名?\r\n\r\n\r\nimage-20220128114817020\r\n\r\n\r\n\r\nimage-20220128121926742\r\n\r\n引用数据类型应用—对象数组\r\n\r\n\r\n3-3\r\n引用数据类型应用—对象数组\r\n\r\njava中推荐的命名规则\r\n\r\n\r\n3-10 Java中推荐的命名规范\r\n\r\n项目作业\r\n\r\n\r\n3-11 项目作业\r\n\r\n继承\r\n\r\n\r\nimage-20220130120100965\r\n\r\n方法重写\r\n\r\nAnimal类\r\n\r\npackage com.kuroneko.animal;public class Animal &#123;\tprivate String Name;//姓名\tprivate int month;//月份\tprivate String species;//品种    public int temp=15;\t//父类的构造不允许被继承、不允许被重写\tpublic Animal() &#123;\t\t\t&#125;\tpublic String getName() &#123;\t\treturn Name;\t&#125;\tpublic void setName(String name) &#123;\t\tName = name;\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tthis.month = month;\t&#125;\tpublic String getSpecies() &#123;\t\treturn species;\t&#125;\tpublic void setSpecies(String species) &#123;\t\tthis.species = species;\t&#125;//3个方法重载\tpublic void eat() &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t&#125;\tpublic int eat(String name) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn 1;\t&#125;\t\tpublic Animal eat(int month) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn new Animal();\t&#125;&#125;\r\n\r\nDog类\r\n\r\npackage com.kuroneko.animal;public class Dog extends Animal &#123;\tprivate String sex;\t//在子类中可以定义与父类重名的属性\tpublic int temp=300;    \tpublic String getSex() &#123;\t\treturn sex;\t&#125;\tpublic void setSex(String sex) &#123;\t\tthis.sex = sex;\t&#125;\t\t//睡觉的方法\tpublic void Sleep() &#123;\t\tSystem.out.println(this.getName()+&quot;现在&quot;+this.getMonth()+&quot;个月大&quot;+&quot;它在睡觉~~&quot;);\t&#125;\t\t/*\t *方法重载：\t *1、同一个类中\t *2、方法名相同、参数列表不同（参数顺序、个数、类型）\t *3、与方法的参数名、返回值、访问修饰符无关\t *方法重写：\t *1、在有继承关系的子类中\t *2、方法名、参数列表相同（参数顺序，个数、类型）\t *3、与方法的参数名无关\t *4、当方法的返回值是void或基本数据类型时，必须相同；当返回值是引用数据类型时，可以是父类或其子类。（返回值要么都是void，要么都是相同的基本数据类型，要么都是引用数据类型\t *5、访问修饰符的访问权限要大于等于父类的访问权限，因为私有方法不能被子类访问， 所以不能重写\t */\t//3个方法重写(重写父类3个的eat方法\t//重写父类中返回值都是void的方法\tpublic void eat() &#123;\t\t//当子类重写父类方法后，子类对象调用的是重写后的方法\t\t\tSystem.out.println(this.getName()+&quot;最近没有食欲~&quot;);\t&#125;\t//重写父类中返回值都是int的方法\tpublic int eat(String name) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn 1;\t&#125;\t//重写父类中返回值都是引用数据类型的方法1\tpublic Dog eat(int month) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn new Dog();\t&#125;\t//重写父类中返回值都是引用数据类型的方法2//\tpublic Cat eat(int month) &#123;//\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);//\t\treturn new Cat();//\t&#125;//\t&#125;\r\n\r\nCat类\r\n\r\npackage com.kuroneko.animal;public class Cat extends Animal&#123;\tprivate double weight;\t\tpublic Cat() &#123;\t\t\t&#125;\tpublic double getWeight() &#123;\t\treturn weight;\t&#125;\tpublic void setWeight(double weight) &#123;\t\tthis.weight = weight;\t&#125;\t\t//跑动的方法\tpublic void run() &#123;\t\tSystem.out.println(this.getName()+&quot;是一只&quot;+this.getSpecies()+&quot;它在快乐地奔跑&quot;);\t&#125;&#125;\r\n\r\nTest类\r\npackage com.kuroneko.test;import com.kuroneko.animal.Cat;import com.kuroneko.animal.Dog;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tCat one=new Cat();\t\tone.setName(&quot;花花&quot;);\t\tone.setSpecies(&quot;中华田园猫&quot;);\t\tone.eat();\t\tone.run();\t\tDog two=new Dog();\t\ttwo.setName(&quot;妞妞&quot;);\t\ttwo.setMonth(1);\t\ttwo.eat();\t\ttwo.Sleep();        System.out.println(two.temp);\t&#125;&#125;\r\n编程练习\r\n\r\n\r\n\r\n2-8 编程练习\r\n\r\n访问修饰符\r\nprivate: 只允许在本类中进行访问\r\n默认：同包访问，跨包不允许\r\nprotected:\r\n跨包子类可以访问，跨包非子类不允许（有血缘关系都可以访问\r\npublic: 允许在任意位置访问\r\n继承的初始化顺序\r\n\r\nAnimal类\r\n\r\npackage com.kuroneko.animal;public class Animal &#123;\tprivate String Name=&quot;妮妮&quot;;//姓名\tprivate int month=2;//月份\tprivate String species=&quot;动物&quot;;//品种\tpublic int temp=15;\t//类在加载时优先加载父类的静态信息，然后是子类的\tprivate static int st1=22;\tpublic static int st2=23;\t\tstatic &#123;\t\tSystem.out.println(&quot;我是父类的静态代码块&quot;);\t&#125;\t\t&#123;\t\tSystem.out.println(&quot;我是父类的构造代码块&quot;);\t&#125;\t\t//父类的构造不允许被继承、不允许被重写\tpublic Animal() &#123;\t\tSystem.out.println(&quot;我是父类的无参构造方法&quot;);\t&#125;\tpublic String getName() &#123;\t\treturn Name;\t&#125;\tpublic void setName(String name) &#123;\t\tName = name;\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tthis.month = month;\t&#125;\tpublic String getSpecies() &#123;\t\treturn species;\t&#125;\tpublic void setSpecies(String species) &#123;\t\tthis.species = species;\t&#125;//3个方法重载\tpublic void eat() &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t&#125;\tpublic int eat(String name) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn 1;\t&#125;\t\tpublic Animal eat(int month) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn new Animal();\t&#125;&#125;\r\n\r\nCat类\r\npackage com.kuroneko.animal;public class Cat extends Animal&#123;\tprivate double weight;\t\tpublic static int st3=44;\t\tstatic &#123;\t\tSystem.out.println(&quot;我是子类的静态代码块&quot;);\t&#125;\t\t&#123;\t\tSystem.out.println(&quot;我是子类的构造代码块&quot;);\t&#125;\t\tpublic Cat() &#123;\t\tSystem.out.println(&quot;我是子类的无参构造方法&quot;);\t&#125;\tpublic double getWeight() &#123;\t\treturn weight;\t&#125;\tpublic void setWeight(double weight) &#123;\t\tthis.weight = weight;\t&#125;\t\t//跑动的方法\tpublic void run() &#123;\t\tSystem.out.println(this.getName()+&quot;是一只&quot;+this.getSpecies()+&quot;它在快乐地奔跑&quot;);\t&#125;&#125;\r\nTest类\r\npackage com.kuroneko.test;import com.kuroneko.animal.Cat;public class TestTwo &#123;\tpublic static void main(String[] args) &#123;\t\tCat one=new Cat();\t\tSystem.out.print(one.temp);\t&#125;&#125;\r\n打断点\r\n\r\n\r\n\r\nimage-20220203125253595\r\n\r\n\r\n单步调试\r\n通过ClassLoade把相关的类加载到虚拟机中\r\n\r\n\r\nimage-20220203125410092\r\n\r\n在加载类型时，先进入父类加载父类的静态成员\r\n\r\n\r\nimage-20220203125949617\r\n\r\n继续往下，结束了父类的操作，同样进入到了子类的静态成员的执行过程当中\r\n\r\n\r\nimage-20220203130300259\r\n\r\n综上，类在进行加载时优先加载父类的静态信息，然后是子类的\r\n\r\n回到main方法，继续进行对象实例化构造，找到了Cat构造，但并没有执行构造，转而去找到父类的构造，又转而找到object类\r\n（老祖宗类）\r\n\r\n\r\nimage-20220203130546772\r\n\r\n\r\n\r\nimage-20220203130736769\r\n\r\n\r\n\r\nimage-20220203131100604\r\n\r\n对象产生，相关信息都是默认值\r\n\r\n\r\nimage-20220203131202277\r\n\r\n赋值\r\n\r\n\r\nimage-20220203131342943\r\n\r\n加载父类的成员属性后， 执行父类的构造代码块\r\n\r\n\r\nimage-20220203131427085\r\n\r\n执行父类的构造方法\r\n\r\n\r\nimage-20220203131452429\r\n\r\n加载子类的成员属性后，执行子类的构造代码块和构造方法\r\n\r\n\r\nimage-20220203131916732\r\n\r\n\r\n\r\nimage-20220203132217565\r\n\r\ntip： 访问修饰符不影响成员加载顺序，跟书写位置有关\r\nsuper关键字\r\n父类对象的引用\r\n\r\nAnimal类\r\npackage com.kuroneko.animal;public class Animal &#123;\tprivate String Name=&quot;妮妮&quot;;//姓名\tprivate int month=2;//月份\tprivate String species=&quot;动物&quot;;//品种\tpublic int temp=15;\t//类在加载时优先加载父类的静态信息，然后是子类的\tprivate static int st1=22;\tpublic static int st2=23;\t\tstatic &#123;\t\tSystem.out.println(&quot;我是父类的静态代码块&quot;);\t&#125;\t\t&#123;\t\tSystem.out.println(&quot;我是父类的构造代码块&quot;);\t&#125;\t\t//父类的构造不允许被继承、不允许被重写，但可以影响子类对象实例化的过程\tpublic Animal() &#123;\t\t//在子类构造中没有显示标注时，默认调用父类的无参构造\t\tSystem.out.println(&quot;我是父类的无参构造方法&quot;);\t&#125;\t//带参构造\tpublic Animal(String name,int month) &#123;\t\t//在子类构造中没有显示标注时，默认调用父类的无参构造\t\tSystem.out.println(&quot;我是父类的带参构造&quot;);\t&#125;\tpublic String getName() &#123;\t\treturn Name;\t&#125;\tpublic void setName(String name) &#123;\t\tName = name;\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tthis.month = month;\t&#125;\tpublic String getSpecies() &#123;\t\treturn species;\t&#125;\tpublic void setSpecies(String species) &#123;\t\tthis.species = species;\t&#125;//3个方法重载\tpublic void eat() &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t&#125;\tpublic int eat(String name) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn 1;\t&#125;\t\tpublic Animal eat(int month) &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t\treturn new Animal();\t&#125;&#125;\r\nCat类\r\npackage com.kuroneko.animal;public class Cat extends Animal&#123;\tprivate double weight;\t\tpublic static int st3=44;\t\tstatic &#123;\t\tSystem.out.println(&quot;我是子类的静态代码块&quot;);\t&#125;\t\t&#123;\t\tSystem.out.println(&quot;我是子类的构造代码块&quot;);\t&#125;\t\tpublic Cat() &#123;\t\tSystem.out.println(&quot;我是子类的无参构造方法&quot;);\t&#125;\t/*\t * 子类的构造过程中必须调用其父类的构造方法\t * 如果子类的构造中没有用super显示标注，则系统默认调用父类的无参构造\t * 可以使用super()调用父类允许访问的其他构造\t * super()必须放在子类构造的有效代码的第一行\t */\t\tpublic Cat(String name,int month) &#123;//\t\t\tsuper(name,month);//显示指定调用父类的双参构造\t\t\tSystem.out.println(&quot;我是子类的带参构造&quot;);\t\t&#125;\tpublic double getWeight() &#123;\t\treturn weight;\t&#125;\tpublic void setWeight(double weight) &#123;\t\tthis.weight = weight;\t&#125;\t\t//跑动的方法\tpublic void run() &#123;\t\tSystem.out.println(this.getName()+&quot;是一只&quot;+this.getSpecies()+&quot;它在快乐地奔跑&quot;);\t&#125;&#125;\r\nTest类\r\npackage com.kuroneko.test;import com.kuroneko.animal.Cat;public class TestTwo &#123;\tpublic static void main(String[] args) &#123;\t\tCat one=new Cat(&quot;花花&quot;,2);\t&#125;&#125;\r\n\r\n\r\n\r\n2-19 关于super的常见问题\r\n\r\nsuper PK this\r\n\r\n都不能在静态方法中使用\r\n构造方法调用时，super和this不能同时出现\r\n必须放在构造方法的有效代码的第一行\r\n\r\n编程练习\r\n\r\n\r\n2-22 编程练习\r\n\r\nobject类\r\nobject类是所有类的父类，一个类没有使用extends关键字明确标识继承关系，则默认继承object类（包括数组），java中的每个类都可以使用object中定义的方法\r\nequals\r\npackage com.kuroneko.test;import com.kuroneko.animal.Animal;public class TestThree &#123;\tpublic static void main(String[] args) &#123;\t\tAnimal one=new Animal(&quot;花花&quot;,2);\t\tAnimal two=new Animal(&quot;花花&quot;,2);\t\t/*\t\t * 继承Objec类中的equals方法时，\t\t * equals和“==”比较的都是两个引用是否指向同一个对象（操作的是否是同一块空间\t\t * 字符串比较时，\t\t * String重写了Object类中的equals方法，equals和“==”比较的都是字符串中的内容是否相同\t\t */\t\tboolean flag=one.equals(two);\t\tSystem.out.println(&quot;one 和 two的引用比较：&quot;+flag);//引用不同，false\t\tSystem.out.println(&quot;one 和 two的引用比较：&quot;+(one==two));//引用不同，false\t\tSystem.out.println(&quot;=================================&quot;);\t\tString str1=new String(&quot;hello&quot;);\t\tString str2=new String(&quot;hello&quot;);\t\tflag=str1.equals(str2);\t\tSystem.out.println(&quot;str1 和 str2的引用比较：&quot;+flag);//字符串内容相同，flag为true\t\tSystem.out.println(&quot;str1 和 str2的引用比较：&quot;+(str1==str2));\t//引用不同，false\t&#125;&#125;\r\n\r\n\r\nimage-20220204140034029\r\n\r\n比较 one 和 two 这两个对象的值是否相同\r\n重写Object类里的equals方法\r\npackage com.kuroneko.animal;public class Animal &#123;\tprivate String Name=&quot;妮妮&quot;;\tprivate int month=2;\tprivate String species=&quot;动物&quot;;\tpublic int temp=15;\tprivate static int st1=22;\tpublic static int st2=23;\t\tstatic &#123;\t\tSystem.out.println(&quot;我是父类的静态代码块&quot;);\t&#125;\t\t&#123;\t\tSystem.out.println(&quot;我是父类的构造代码块&quot;);\t&#125;\t\tpublic Animal() &#123;\t\tSystem.out.println(&quot;我是父类的无参构造方法&quot;);\t&#125;\tpublic Animal(String name,int month) &#123;\t\tSystem.out.println(&quot;我是父类的带参构造&quot;);\t&#125;\tpublic String getName() &#123;\t\treturn Name;\t&#125;\tpublic void setName(String name) &#123;\t\tName = name;\t&#125;\tpublic int getMonth() &#123;\t\treturn month;\t&#125;\tpublic void setMonth(int month) &#123;\t\tthis.month = month;\t&#125;\tpublic String getSpecies() &#123;\t\treturn species;\t&#125;\tpublic void setSpecies(String species) &#123;\t\tthis.species = species;\t&#125;\t\tpublic void eat() &#123;\t\tSystem.out.println(this.getName()+&quot;在吃东西&quot;);\t&#125;\t\tpublic void eat(String name) &#123;\t\tSystem.out.println(name+&quot;在吃东西&quot;);\t&#125;\t//重写Object类里的equals方法,定义全新的比对规则\tpublic boolean equals(Object obj) &#123;\t\t//如果传入的对象为null，则返回false\t\tif(obj==null)\t\t\treturn false;\t\tAnimal temp=(Animal)obj;//把Object类型强转为Animal类型\t\tif(this.getName().equals(temp.getName()) &amp;&amp; (this.getMonth()==temp.getMonth()))\t\t\treturn true; \t\telse\t\t\treturn false;\t&#125;\t//重载equals方法\tpublic boolean equals(Animal obj) &#123;\t\t//如果传入的对象为null，则返回false\t\tif(obj==null)\t\t\treturn false;\t\tif(this.getName().equals(obj.getName()) &amp;&amp; (this.getMonth()==obj.getMonth()))\t\t\treturn true; \t\telse\t\t\treturn false;\t&#125;\t\t\t\t\t&#125;\r\ntoString\r\npackage com.kuroneko.test;import com.kuroneko.animal.Animal;public class TestThree &#123;\tpublic static void main(String[] args) &#123;\t\tAnimal one=new Animal(&quot;花花&quot;,2);\t\tString str1=new String(&quot;hello&quot;);\t\tSystem.out.println(&quot;=================================&quot;);\t\t/*\t\t * 1、输出对象名时，默认会直接调用Object类中toString\t\t * 2、继承Object类中toString方法时，输出对象的字符串表现形式：类型信息+@+地址信息\t\t * 3、子类可以通过重写toString方法，改变输出的内容以及表现形式\t\t */\t\tSystem.out.println(one.toString());\t\tSystem.out.println(one);\t\tSystem.out.println(&quot;=================================&quot;);\t\tSystem.out.println(str1);\t&#125;&#125;\r\n\r\n重写toString方法\r\n\t//重写Object类里的toString方法,改变输出的内容以及表现形式\tpublic String toString() &#123;\t\treturn &quot;昵称：&quot;+this.getName()+&quot;,年龄：&quot;+this.getMonth();\t&#125;&#125;\r\n\r\n关于Object的常见问题\r\n\r\n\r\n2-6 关于Object的常见问题\r\n\r\n2-8编程练习\r\n\r\n\r\n2-8 编程练习\r\n\r\n2-9 编程练习\r\n\r\n\r\n2-9 编程练习\r\n\r\nfinal关键字\r\n不可以修饰构造方法\r\npackage com.kuroneko.test;//final class：不允许继承，无子类，修饰符和final可以位置互换public final class Animal &#123;\tprivate String Name=&quot;妮妮&quot;;\tprivate int month=2;\t//静态的不可更改的全局变量，随着类的加载而加载\tprivate final static String species=&quot;动物&quot;;\t//final 成员属性：要么在定义时就赋值初始化，要么在构造代码块中初始化，再要么在构造方法中初始化\tpublic final int temp;\t&#123;\t\ttemp = 15;\t&#125;\tpublic Animal() &#123;\t\t//temp = 20;\t&#125;\t\tpublic Animal(String name,int month) &#123;\t\tSystem.out.println(&quot;我是父类的带参构造&quot;);\t&#125;//final 方法：不允许子类重写,但并不影响子类调用这个方法\tfinal public void eat() &#123;\t\t// final 方法内局部变量: 只要在具体被使用之前进行赋值即可，一旦赋值不允许被修改\t\tfinal int temp;\t\ttemp = 12;\t\tSystem.out.println(temp);\t\t//final 引用数据类型：引用地址不可更改，属性值可以改变（初始化之后不能再指向另一个对象，但对象的内容是可变\t\tfinal Animal animal=new Animal(&quot;凡凡&quot;,1);\t\t//animal=new Animal();//错误，引用地址不可更改\t\tanimal.Name=&quot;豆豆&quot;;//属性可更改\t\tanimal.month=2;//属性可更改\t&#125;&#125;\r\n注解\r\n\r\n\r\nimage-20220204191122111\r\n\r\n按照运行机制分：\r\n\r\n源码注解 ===&gt;注解只在源码阶段保留，在编译阶段会被丢弃，如 @Override\r\n编译时注解\r\n===&gt;注解会在编译时期保留，在加载class文件时会被丢弃，如 @NotNull\r\n运行时注解 ===&gt;在运行阶段还起作用，甚至会影响运行逻辑的注解，如\r\n@Autowired\r\n\r\n按照来源分：\r\n\r\n来自jdk的注解\r\n来自第三方的注解\r\n我们自己定义的注解\r\n\r\n4-4 编程练习\r\n\r\n\r\n4-4 编程练习\r\n\r\n"},{"title":"GithubPagesHexo","url":"/2024/01/15/GithubPagesHexo/","content":"一、安装环境\r\nNodejs安装\r\n\r\nNodejs下载入口\r\n修改全局模块下载路径。\r\n// 命令指定到路径npm config set prefix &quot;D:\\workspace\\node_global&quot;npm config set cache &quot;D:\\workspace\\node_cache&quot;\r\n用户变量Path修改为\r\nD:\\workspace\\node_cache\r\n\r\n\r\nimage-20240103222132310\r\n\r\n系统变量新建：\r\n变量名：NODE_PATH变量值：D:\\workspace\\node_global\\node_modules\r\n\r\n\r\nimage-20240103222423534\r\n\r\n系统变量Path修改为\r\nD:\\workspace\\node_global\r\n\r\n\r\nimage-20240103222828876\r\n\r\n扩权：\r\n验证下载到自定义目录\r\nnpm install express -g     # -g是全局安装的意思\r\n\r\n\r\nimage-20240103223406111\r\n\r\n更换npm源为淘宝镜像\r\n\r\nnpm默认的registry即下载npm包是从国外服务器下载，遂更换为淘宝源。\r\n\r\nnpm config set registry https://registry.npm.taobao.org/ # 淘宝源npm install -g cnpm --registry=https://registry.npm.taobao.org # 全局安装基于淘宝源的cnpm\r\n\r\n\r\nimage-20240103224038357\r\n\r\n\r\nGit安装\r\n\r\nGit下载入口\r\n\r\n\r\ncd76ed04785e48f7aefd1248e3a53758\r\n\r\n\r\n第一种是仅从 Git Bash 使用 Git。这个的意思就是你只能通过 Git 安装后的\r\nGit Bash 来使用 Git ，其他的什么命令提示符啊等第三方软件都不行。\r\n第二种是从命令行以及第三方软件进行\r\nGit。这个就是在第一种基础上进行第三方支持，你将能够从 Git\r\nBash，命令提示符(cmd) 和 Windows PowerShell 以及可以从 Windows\r\n系统环境变量中寻找 Git 的任何第三方软件中使用 Git。推荐使用这个。\r\n第三种是从命令提示符使用 Git 和可选的 Unix 工具。选择这种将覆盖\r\nWindows 工具，如 “ find 和 sort\r\n”。只有在了解其含义后才使用此选项。一句话，适合比较懂的人折腾。\r\n\r\n\r\n\r\nimage-20240103230307449\r\n\r\n\r\n\r\nimage-20240103231126378\r\n\r\n\r\nHexo安装\r\n\r\n博客根目录【D:_blog】\r\n# 安装hexo$ npm install hexo-cli -g $ npm install hexo-deployer-git --save\r\n根目录下新建hexo目录【D:_blog】\r\n# 初始化hexo inithexo generatehexo server\r\n验证\r\n\r\n二、部署到GithubPages\r\n\r\n创建项目库\r\n配置SSH密钥\r\n\r\n使得可以通过git操作实现本地代码库与github代码库同步\r\n\r\n【D:_blog】下输入命令\r\nssh-keygen -t rsa -C &quot;coder.luotao@outlook.com&quot; //引号里面填写你的邮箱地址clip &lt; ~/.ssh/id_rsa.pub //将公钥复制到剪贴板\r\n在github账户中添加复制的公钥\r\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDtrcGHS/IpJsxvksgzO8jJJKTbx4T9C9S2XqW56nibAFUsZlHRtM4L68r1Y7ZMkl5A+4uO8T+FTFOByw5k3vucKfLOqAj953QFAQmVs/JMW7+bpZaeuMYqrZ2BEazHpOJeJdy8tUGkN9Uavtn3z0Y5K4/VGgZcTwf0QsYPl2p8uA5qmM0p5xSY1xGSC1TZot6n7RFtZgrYuy0tW7lRAmnygbDNcl9U92gKgPsvxE4nVUdGnRt4U2i2gKnL8AubzlalGyhT1IOBgmPd/26UoazJ8JLwmlltxpA3A/67DxN+Hqcq8aaPCcViOVKD299j2JB3Mgldhnh7AR2oMdyFGGeOCH7wB4PJgiLRrdUgBdUiGbVYN+hN0rxxlDGLpgFba5juyId2UKaQdqu6La13/HUGwXcgAfJeV3YSQAI6a+JDmu8qZkwLKPWLFqd157XR2OtE1XhhbgJUEidlFrpGUAo7JTNlXAr9E13sVp0HuDLP3bE23NQ9T4YHBr+G0EvuE+s= coder.luotao@outlook.com\r\n测试\r\nssh -T git@github.com\r\n配置git个人信息\r\n\r\nGit 会根据用户的名字和邮箱来记录提交，GitHub\r\n也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置\r\n\r\ngit config --global user.name &quot;luotaofun&quot;git config --global user.email &quot;coder.luotao@outlook.com&quot;\r\n配置推送到github\r\n\r\n\r\nimage-20240114042950776\r\n\r\nhexo n &#x27;helloWorld&#x27; //生成文章hexo g -d //推送到服务器\r\n\r\n\r\nimage-20240114044213334\r\n\r\n访问博客https://luotaofun.github.io\r\n\r\n图片显示问题\r\n\r\ntypora配置\r\n在_config.yml配置文件把false改成true\r\npost_asset_folder: true\r\n安装hexo-asset-image的依赖\r\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\t\r\n\r\n关于本地git通过ssh链接github时\r\ntime out问题的解决方法\r\n\r\n\r\nimage-20240324213207217\r\n\r\nHost github.comHostName ssh.github.com  # 这是最重要的部分User gitPort 443PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa\r\n绑定域名托管cf\r\n\r\nsource目录下指定域名\r\n\r\n\r\nimage-20250415013932546\r\n\r\ncf新建dns记录\r\n\r\n"},{"title":"Java常用工具类","url":"/2022/02/11/2022-02-11-Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"异常\r\n背离我们程序本身的意图的表现，都可以理解为异常\r\n\r\n\r\nimage-20220212140410199\r\n\r\n异常的根类：Throwable\r\nThrowable的两个直接子类：Error、Exception\r\nError是程序无法处理的错误\r\nException是程序本身可以处理的异常，异常处理通常指针对这种类型异常的处理\r\nUnchecked Exception\r\n：非检查异常，编译器不要求强制处理的异常，允许忽略异常，包含RuntimeException\r\nChecked\r\nException：检查异常，编译器要求必须捕捉、或者声明抛出异常，包含IOException、SQLException\r\n\r\n\r\nimage-20220212141835901\r\n\r\n\r\n\r\nimage-20220212142431710\r\n\r\ntry-catch-finally\r\ntry快后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块\r\nTryDemoOne类\r\npackage com.kuroneko.test;import java.util.InputMismatchException;import java.util.Scanner;public class TryDemoOne &#123;\tpublic static void main(String[] args) &#123;\t\t/*\t\t * // 要求：定义两个整数，输出两数之商\t\t * \t\t * int one = 12; int two = 2; System.out.println(&quot;one和two的商是：&quot; + (one / two));\t\t */\t\t// 要求：定义两个整数，接收用户的键盘输入，输出两数之商\t\tScanner input = new Scanner(System.in);\t\tSystem.out.println(&quot;=====运算开始=====&quot;);\t\ttry &#123;\t\t\tSystem.out.print(&quot;请输入第一个整数：&quot;);\t\t\tint one = input.nextInt();\t\t\tSystem.out.print(&quot;请输入第二个整数：&quot;);\t\t\tint two = input.nextInt();\t\t\tSystem.out.println(&quot;one和two的商是：&quot; + (one / two));\t\t&#125; catch (ArithmeticException e) &#123;//算术异常\t\t\t//System.exit(1);//终止当前正在运行的java虚拟机，此时后面的finally也不会执行\t\t\tSystem.out.println(&quot;除数不能为零！&quot;);\t\t\te.printStackTrace();// 打印异常的堆栈信息\t\t&#125; catch (InputMismatchException e) &#123;//输入格式异常\t\t\tSystem.out.println(&quot;请输入整数！&quot;);\t\t\te.printStackTrace();\t\t&#125;catch (Exception e) &#123;//用父类Exception追踪前面的子类中无法捕获的异常信息，处理漏网之鱼\t\t\tSystem.out.println(&quot;程序出错啦~~&quot;);\t\t\te.printStackTrace();\t\t&#125;finally &#123;\t\t\tSystem.out.println(&quot;=====运算结束=====&quot;);\t\t&#125;\t&#125;&#125;\r\n常见异常类型及原因分析\r\n\r\n\r\n4-3\r\n常见异常类型及原因分析（Ⅰ）\r\n\r\n\r\n关于try\r\ncatch应用中的常见问题\r\n\r\n\r\n4-8\r\n关于try…catch应用中的常见问题\r\n\r\n\r\n\r\nimage-20220212152822144\r\n\r\nreturn在异常中的作用\r\nTryDemoTwo类\r\npackage com.kuroneko.test;import java.util.Scanner;public class TryDemoTwo &#123;\tpublic static void main(String[] args) &#123;\t\tint result = test();\t\tSystem.out.println(&quot;one和two的商是：&quot; + result);\t&#125;\tpublic static int test() &#123;\t\tScanner input = new Scanner(System.in);\t\tSystem.out.println(&quot;=====运算开始=====&quot;);\t\ttry &#123;\t\t\tSystem.out.print(&quot;请输入第一个整数：&quot;);\t\t\tint one = input.nextInt();\t\t\tSystem.out.print(&quot;请输入第二个整数：&quot;);\t\t\tint two = input.nextInt();\t\t\treturn one/two;\t\t&#125; catch (ArithmeticException e) &#123;\t\t\tSystem.out.println(&quot;除数不能为零！&quot;);\t\t\treturn 0;\t\t&#125; finally &#123;//由于finally语句块强制执行的作用，导致无论上面两个块怎么运作，return回去的都是finally里的内容，若要程序正常执行，注释掉finally中的return语句即可\t\t\tSystem.out.println(&quot;=====运算结束=====&quot;);\t\t\treturn -100000;\t\t&#125;\t&#125;&#125;\r\n异常处理中的返回操作\r\n\r\n\r\n4-14 异常处理中的返回操作\r\n\r\n使用throws声明异常类型\r\n可以通过throws声明将要抛出何种类型的异常，通过throw将产生的异常抛出\r\n\r\n\r\nimage-20220212160725680\r\n\r\n\r\nTryDemoThree类\r\n\r\npackage com.kuroneko.test;import java.util.InputMismatchException;import java.util.Scanner;public class TryDemoThree &#123;\tpublic static void main(String[] args) &#123;\t\t/*\t\t * try &#123; int result = test(); System.out.println(&quot;one和two的商是：&quot; + result); &#125;\t\t * catch (ArithmeticException e) &#123; System.out.println(&quot;除数不能为零！&quot;);\t\t * e.printStackTrace(); &#125; catch (InputMismatchException e) &#123;\t\t * System.out.println(&quot;请输入整数！&quot;); e.printStackTrace(); &#125;\t\t */\t\ttry &#123;\t\t\tint result = test();\t\t\tSystem.out.println(&quot;one和two的商是：&quot; + result);\t\t&#125; catch (ArithmeticException e) &#123;\t\t\tSystem.out.println(&quot;除数不能为零！&quot;);\t\t\te.printStackTrace();\t\t&#125; catch (InputMismatchException e) &#123;\t\t\tSystem.out.println(&quot;请输入整数！&quot;);\t\t\te.printStackTrace();\t\t&#125; catch (Exception e) &#123;\t\t\tSystem.out.println(&quot;程序出错啦~~&quot;);\t\t&#125;\t&#125;\t/*\t * 通过throws抛出异常时，针对可能出现的多种异常情况，解决方案： 1、throws后面接多个异常类型，中间用逗号分隔\t * 2、throws后面接Exception，包含了检查异常和非检查异常\t */\t//\t/**//\t * //\t * @return\t商//\t * @throws ArithmeticException//\t * @throws InputMismatchException//\t *///\t// 接非检查异常，非检查异常编译器不会强制要求处理异常//\tpublic static int test() throws ArithmeticException, InputMismatchException &#123;//\t\tScanner input = new Scanner(System.in);//\t\tSystem.out.println(&quot;=====运算开始=====&quot;);//\t\tSystem.out.print(&quot;请输入第一个整数：&quot;);//\t\tint one = input.nextInt();//\t\tSystem.out.print(&quot;请输入第二个整数：&quot;);//\t\tint two = input.nextInt();//\t\tSystem.out.println(&quot;=====运算结束=====&quot;);//\t\treturn one / two;//\t&#125;\t//由于Exception包含了检查异常和非检查异常，检查异常编译器会强制要求处理异常\tpublic static int test() throws Exception &#123;\t\tScanner input = new Scanner(System.in);\t\tSystem.out.println(&quot;=====运算开始=====&quot;);\t\tSystem.out.print(&quot;请输入第一个整数：&quot;);\t\tint one = input.nextInt();\t\tSystem.out.print(&quot;请输入第二个整数：&quot;);\t\tint two = input.nextInt();\t\tSystem.out.println(&quot;=====运算结束=====&quot;);\t\treturn one / two;\t&#125;&#125;\r\n# 使用throw抛出异常对象\r\nthrow抛出的只能够是可抛出类Throwable或者其子类的实例对象\r\n\r\n\r\nimage-20220212165653678\r\n\r\n\r\n\r\nimage-20220212165824383\r\n\r\nTryDemoFour类\r\npackage com.kuroneko.test;import java.util.Scanner;public class TryDemoFour &#123;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\ttestAge();\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t/*\t * throw抛出异常对象的处理方案： \t * 1、通过try..catch包含throw语句：自己抛自己处理\t * 2、通过throws在方法声明处抛出异常类型：谁调用谁处理，调用者可以自己处理，也可以继续往上抛；可以抛出与throw对象相同的类型或者其父类\t */\t// 描述酒店的入住规则：限定年龄，18岁以下，80岁以上的住客必须由亲友陪同\t\t/*public static void testAge() &#123;\t\t// 自己处理自己抛出的异常\t\ttry &#123;\t\t\tSystem.out.println(&quot;请输入年龄：&quot;);\t\t\tScanner input = new Scanner(System.in);\t\t\tint age = input.nextInt();\t\t\tif (age &lt; 18 || age &gt; 80) &#123;\t\t\t\tthrow new Exception(&quot;18岁以下，80岁以上的住客必须由亲友陪同&quot;);\t\t\t&#125; else &#123;\t\t\t\tSystem.out.println(&quot;欢迎入住本酒店!&quot;);\t\t\t&#125;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;*/\tpublic static void testAge() throws Exception&#123;\t\tSystem.out.println(&quot;请输入年龄：&quot;);\t\tScanner input = new Scanner(System.in);\t\tint age = input.nextInt();\t\tif (age &lt; 18 || age &gt; 80) &#123;\t\t\tthrow new Exception(&quot;18岁以下，80岁以上的住客必须由亲友陪同&quot;);\t\t&#125; else &#123;\t\t\tSystem.out.println(&quot;欢迎入住本酒店!&quot;);\t\t&#125;\t&#125;&#125;\r\nthrow和throws的区别\r\n\r\n\r\n5-5 throw和throws的区别\r\n\r\n自定义异常\r\n定义一个类，去继承Throwable类或者它的子类\r\n\r\n自定义异常HotelAgeException类\r\n\r\npackage com.kuroneko.test;public class HotelAgeException extends Exception &#123;\tpublic HotelAgeException() &#123;\t\t//调用Exception的带参构造，描述异常信息\t\tsuper(&quot;18岁以下，80岁以上的住客必须由亲友陪同&quot;);\t&#125;\t&#125;\r\n\r\nTryDemoFour类\r\n\r\npackage com.kuroneko.test;import java.util.Scanner;public class TryDemoFour &#123;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\ttestAge();\t\t&#125; catch (HotelAgeException e) &#123;\t\t\tSystem.out.println(e.getMessage());//打印异常描述信息\t\t\tSystem.out.println(&quot;酒店前台工作人员不允许办理入住登记&quot;);\t\t&#125;catch(Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\tpublic static void testAge() throws HotelAgeException&#123;\t\tSystem.out.println(&quot;请输入年龄：&quot;);\t\tScanner input = new Scanner(System.in);\t\tint age = input.nextInt();\t\tif (age &lt; 18 || age &gt; 80) &#123;\t\t\tthrow new HotelAgeException();\t\t&#125; else &#123;\t\t\tSystem.out.println(&quot;欢迎入住本酒店!&quot;);\t\t&#125;\t&#125;&#125;\r\n\r\n\r\nimage-20220212181013879\r\n\r\n关于自定义异常的常见问题\r\n\r\n\r\n6-2 关于自定义异常的常见问题\r\n\r\n异常链\r\n将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出\r\n\r\n\r\nimage-20220212183810354\r\n\r\nTryDemoFive类\r\npackage com.kuroneko.test;public class TryDemoFive &#123;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\ttestThree();\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\tpublic static void testOne() throws HotelAgeException &#123;\t\tthrow new HotelAgeException();\t&#125;\tpublic static void testTwo() throws Exception &#123;\t\ttry &#123;\t\t\ttestOne();\t\t&#125; catch (HotelAgeException e) &#123;\t\t\tthrow new Exception(&quot;我是新产生的异常1&quot;,e);\t\t&#125;\t&#125;\tpublic static void testThree() throws Exception &#123;\t\ttry &#123;\t\t\ttestTwo();\t\t&#125; catch (Exception e) &#123;\t\t\tException e1=new Exception(&quot;我是新产生的异常2&quot;);\t\t\te1.initCause(e);//封装捕获到的testTwo的异常\t\t\tthrow e1;//\t\t\tthrow new Exception(&quot;我是新产生的异常2&quot;,e);\t\t&#125;\t&#125;&#125;\r\n关于异常链的常见问题\r\n\r\n\r\n7-2 关于异常链的常见问题\r\n\r\n\r\n\r\nimage-20220212190309367\r\n\r\n当子类重写父类抛出异常的方法时，声明的异常必须是父类方法所声明异常的同类或子类\r\n\r\nFatherTest类\r\npackage com.kuroneko.test;public class FatherTest &#123;\tpublic void test() throws HotelAgeException&#123;\t\tthrow new HotelAgeException();\t&#125;&#125;\r\nSubTest类\r\npackage com.kuroneko.test;public class SubTest extends FatherTest &#123;//\t@Override//\tpublic void test() throws HotelAgeException &#123;//\t\t//\t&#125;//\t//\t@Override//\tpublic void test() throws RuntimeException &#123;//\t\t//\t&#125;\t\t@Override\tpublic void test() throws SubException &#123;\t\t\t&#125;&#125;\r\n\r\n包装类\r\n让基本数据类型可以和像对象一样，拥有属性、方法，可以对象化交互\r\n\r\n\r\nimage-20220212194236576\r\n\r\n包装类方法\r\n由于是final定义的，所以不可以继承，也就没有子类\r\n\r\n\r\nimage-20220212194807522\r\n\r\n数值型的直接父类是Number类\r\nchar和boolean的直接父类是Object类\r\n"},{"title":"Java语法之循环、数组与方法","url":"/2021/12/13/2021-12-13-Java%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%BE%AA%E7%8E%AF%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/","content":"while循环\r\n\r\n\r\nimage-20211213153144623\r\n\r\npackage com.kuroneko.flow1;public class PlusDemo &#123;\tpublic static void main(String[] args) &#123;\t\t//求1到5的累加和\t\tint n=1;\t\tint sum=0;//sum是存放和的变量\t\twhile(n&lt;=5) &#123;\t\t\tsum=sum+n;\t\t\tn++;\t\t&#125;\t\tSystem.out.println(&quot;1到5的累加和为:&quot;+sum);\t&#125;&#125;\r\n\r\n\r\nimage-20211213154435344\r\n\r\npackage com.kuroneko.flow1;public class CharDemo &#123;\tpublic static void main(String[] args) &#123;\t\t//循环输出26个英文字母,分两行输出\t\tchar ch=&#x27;a&#x27;;\t\tint count=1;//控制换行\t\twhile(ch&lt;=&#x27;z&#x27;) &#123;\t\t\tSystem.out.print(ch+&quot; &quot;);\t\t\tif(count%13==0)\t\t\t\tSystem.out.println();\t\t\tcount++;\t\t\tch++;\t\t&#125;\t&#125;&#125;\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\tint j=9,i=6;\t\twhile(i--&gt;3)\t\t\t--j;\t\tSystem.out.println(&quot;&quot;+i+j);\t\t&#125;\t\t&#125;\r\npackage com.kuroneko.flow1;import java.util.Scanner;public class NumberInput &#123;\tpublic static void main(String[] args) &#123;\t\t//循环输入数字1-10并输出,如果输入0则跳出循环\t\tScanner sc=new Scanner(System.in);\t\tint n;\t\twhile(true) &#123;\t\t\tn=sc.nextInt();\t\t\tif(n==0)break;\t\t\tSystem.out.print(n);\t\t&#125;\t&#125;&#125;\r\ndo-while循环\r\n\r\n\r\nimage-20211213162855547\r\n\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\t//1到5的累加和\t\tint n=1;\t\tint sum=0;\t\tdo &#123;\t\t\tsum=sum+n;\t\t\tn++;\t\t&#125;while(n&lt;=5);\t\tSystem.out.println(sum);\t&#125;&#125;\r\n案例:猜字游戏\r\n猜一个介于1-10之间的数字,然后将猜测的值与实际值进行比较,并给出提升,以便能更接近实际值,直到猜中为止。\r\n\r\n\r\nimage-20211213164128683\r\n\r\npackage com.kuroneko.flow1;import java.util.Scanner;public class GuessDemo &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 猜一个介于1-10之间的数字,然后将猜测的值与实际值进行比较,并给出提升,以便能更接近实际值,直到猜中为止。\t\t */\t\t//Math.random()表示得到[0,1)之间的随机数,Math.random()*10表示[0,10)之间的随机数\t\tint number=(int)Math.random()*10+1;\t\tSystem.out.println(&quot;number=&quot;+number);\t\tint guess;\t\tSystem.out.println(&quot;猜一个介于1到10之间的数&quot;);\t\tdo &#123;\t\t\tSystem.out.println(&quot;请输入您猜测的数:&quot;);\t\t\tScanner sc=new Scanner(System.in);\t\t\tguess=sc.nextInt();\t\t\tif(guess&gt;number) &#123;\t\t\t\tSystem.out.println(&quot;太大!&quot;);\t\t\t&#125;else if(guess&lt;number)&#123;\t\t\t\tSystem.out.println(&quot;太小!&quot;);\t\t\t&#125;\t\t&#125;while(number!=guess);\t\tSystem.out.println(&quot;您猜中了!答案为:&quot;+number);\t&#125;&#125;\r\nfor循环\r\n\r\n\r\nimage-20211213171734257\r\n\r\npackage com.kuroneko.flow1;public class ForDemo &#123;\tpublic static void main(String[] args) &#123;\t\tint sum=0;\t\tfor(int n=1;n&lt;=5;n++) &#123;\t\t\tsum=sum+n;\t\t&#125;\t\tSystem.out.println(&quot;sum=&quot;+sum);\t&#125;&#125;\r\n表达式123可以省略\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\t// 将1-10的整数打印输出\t\tint i = 1;\t\tfor (;;) &#123;\t\t\tSystem.out.print(i + &quot; &quot;);\t\t\tif(i==10)break; \t\t\ti++;\t\t&#125;\t&#125;&#125;\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 编写一个程序,求出200到300之间的数,且满足条件: 三个数字之积为42,和为12\t\t */\t\t// 定义变量ge,shi,bai,用于存放个位,十位,百位上的数字\t\tint ge, shi, bai;\t\t// 使用for循环\t\tfor (int i = 200; i &lt;= 300; i++) &#123;\t\t\t// 取出百位数\t\t\tbai = i / 100;\t\t\t// 取出十位数\t\t\tshi = i / 10 % 10;\t\t\t// 取出个位数\t\t\tge = i%10;\t\t\t// 如果积等于42并且和为12,则将满足条件的数输出\t\t\tif(bai*shi*ge==42 &amp; bai+shi+ge==12) &#123;\t\t\t\tSystem.out.println(i);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\r\n\r\n\r\n三种循环结构的应用场景\r\n\r\n嵌套循环\r\n\r\n\r\nimage-20211222160655961\r\n\r\npackage com.kuroneko.flow;public class StarDemo1 &#123;\tpublic static void main(String[] args) &#123;\t\t//使用嵌套while循环输出4行4列的星号\t\tint m=1;//外重循环的循环变量\t\tint n=1;//内重循环的循环变量\t\tSystem.out.println(&quot;输出4行4列的星号&quot;);\t\t//外重循环控制输出几行\t\twhile(m&lt;=4) &#123; \t\t\t//内重循环控制每行输出几个星号\t\t\tn=1;//m=2时,n赋值为1,继续执行循环,若不加n=1,那么n就一直等于5,循环也就不执行了\t\t\twhile(n&lt;=4) &#123;\t\t\t\tSystem.out.print(&quot;*&quot;);\t\t\t\tn++;\t\t\t&#125;\t\t\tSystem.out.println();\t\t\tm++;\t\t&#125;\t&#125;&#125;\r\n\r\n\r\nimage-20211222161943582\r\n\r\npackage com.kuroneko.flow;public class StarDemo1 &#123;\tpublic static void main(String[] args) &#123;\t\t//使用嵌套while循环输出直角三角形\t\tint m=1;//外重循环的循环变量\t\tint n=1;//内重循环的循环变量\t\tSystem.out.println(&quot;输出直角三角形&quot;);\t\t//外重循环控制输出几行\t\twhile(m&lt;=4) &#123; \t\t\t//内重循环控制每行输出几个星号\t\t\tn=1;//m=2时,n赋值为1,继续执行循环,若不加n=1,那么n就一直等于5,循环也就不执行了\t\t\twhile(n&lt;=m) &#123;\t\t\t\tSystem.out.print(&quot;*&quot;);\t\t\t\tn++;\t\t\t&#125;\t\t\tSystem.out.println();\t\t\tm++;\t\t&#125;\t&#125;&#125;\r\npackage com.kuroneko.flow1;public class JiechengPlus &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 求1!+2!+3!+......+10!\t\t * 外重求和,内重求阶乘\t\t */\t\tint s=1,sum=0;\t\tfor(int i=1;i&lt;=10;i++) &#123;\t\t\ts=1;\t\t\tfor(int j=1;j&lt;=i;j++) &#123;\t\t\t\ts=s*j;//s存放阶乘计算结果\t\t\t&#125;\t\t\tsum=sum+s;\t\t&#125;\t\tSystem.out.println(&quot;1!+2!+3!+......+10!=&quot;+sum);\t&#125;&#125;\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 用嵌套for循环输出一个梯形\t\t * 外重循环控制输出行数\t\t * 第一个内重循环控制输出的空格数,依次递减.\t\t * 注意:由于星号和空格在屏幕上所占 的空间不同,可以适当调整空格的输出,比如每次循环都输出两个空格.这样输出出来的图形会更加接近梯形\t\t * 第二个内重循环控制每行输出的星号数\t\t * 输出完一行的星号和空格后换行\t\t */\t\tfor(int i=1;i&lt;=5;i++) &#123;\t\t\tfor(int j=1;j&lt;=5-i;j++) &#123;\t\t\t\tSystem.out.print(&quot; &quot;);\t\t\t&#125;\t\t\tfor(int t=1;t&lt;=11-(5-i)*2;t++) &#123;\t\t\t\tSystem.out.print(&quot;*&quot;);\t\t\t&#125;\t\t\tSystem.out.println();\t\t&#125;\t&#125;&#125;\r\nbreak语句\r\n跳出当前循环结构\r\n只能在循环体内和switch语句体内使用break语句\r\n\r\n\r\nimage-20211222173055924\r\n\r\ncontinue语句\r\n只能用在循环里\r\n可以结束当前循环的执行,但是要继续下一次循环的执行\r\n\r\n\r\nimage-20211222173636489\r\n\r\n\r\n\r\nimage-20211222174234892\r\n\r\n\r\n\r\nimage-20211222174316144\r\n\r\n数组\r\n数组是相同类型的数据按顺序组成的一种引用数据类型。\r\n数组声明\r\n语法格式：\r\n //数据类型［］ 数组名；char[] myIntArray;//数据类型　数组名［］；String strArray[];\r\n数组创建\r\n\r\n语法格式一：先声明后创建\r\n数据类型[] 数组名；\r\n数组名 = new 数据类型[数组长度]；\r\nint[] arr;arr=new int[10];\r\n语法格式二：声明的同时创建数组\r\n数据类型[] 数组名=new 数据类型[数组长度]；\r\n//数组的长度必须指定int[] arr=new int[10];\r\n\r\n数组在内存中的存储\r\n定义一个变量后,变量会在内存中存储,同样定义一个数组后,也会在内存中分配\r\n内存空间用来存储数组当中的数据。\r\n特殊的是，数组会被分配连续的内存空间。\r\n数组的名字a指向数组的第一个元素\r\n\r\n\r\nimage-20220112130035782\r\n\r\n数组的初始化\r\n声明数组的同时给数组赋值，叫做数组的初始化。\r\nint[] arr=&#123;1,2,3,4,5,6,7,8,9,10&#125;;\r\n数组元素的引用\r\n\r\n语法格式：\r\n数组名[下标];注意小标从0开始\r\n\r\n\r\nimage-20220112130910334\r\n\r\n属性length表示数组的长度，如a.length\r\n\r\n一维数组的应用\r\npackage com.kuroneko.array;public class ArrayDemo &#123;\tpublic static void main(String[] args) &#123;\t\t//声明一个整型数组\t\tint[] intArray;\t\t//声明一个字符串类型的数组\t\tString strArray[];\t\t//创建数组\t\tintArray=new int[5];\t\tstrArray=new String[10];\t\t//声明数组的同时进行创建\t\tfloat[] floatArray=new float[4];\t\t//初始化数组\t\tchar[] ch= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;\t\tSystem.out.println(&quot;ch数组的长度为:&quot;+ ch.length);\t\tSystem.out.println(&quot;intArray数组的第二个元素为:&quot;+ intArray[1]);\t\tSystem.out.println(&quot;strArray数组的第五个元素为:&quot;+ strArray[4]);\t\tSystem.out.println(&quot;floatArray数组的最后一个元素为:&quot;+ floatArray[floatArray.length-1]);\t\t//循环为整型数组赋值\t\tfor(int i=0;i&lt;5;i++) &#123;\t\t\tintArray[i]=i+1;\t\t&#125;\t\t//循环输出整型数组中的元素\t\tSystem.out.println(&quot;整型数组intArray的元素为:&quot;);\t\tfor(int i=0;i&lt;5;i++) &#123;\t\t\tSystem.out.print(intArray[i]+ &quot; &quot;);\t\t&#125;\t&#125;&#125;\r\n案例: 求数组元素的累加和\r\npackage com.kuroneko.array;import java.util.Scanner;public class ArrayDemo1 &#123;\tpublic static void main(String[] args) &#123;\t\t//求整型数组的累加和\t\t//定义整型数组\t\tint[] a=new int[5];\t\tScanner sc=new Scanner(System.in);\t\t//从键盘接受数据,为数组元素赋值\t\tfor(int i=0;i&lt;a.length;i++) &#123;\t\t\tSystem.out.println(&quot;请输入第&quot;+ (i+1)+&quot;个元素:&quot;);\t\t\ta[i]=sc.nextInt();\t\t&#125;\t\tSystem.out.println(&quot;数组元素的内容为:&quot;);\t\tfor(int i=0;i&lt;a.length;i++) &#123;\t\t\tSystem.out.print(a[i]+&quot; &quot;);\t\t&#125;\t\tSystem.out.println();\t\tSystem.out.println(&quot;使用增强型for循环输出数组内容:&quot;);\t\tfor(int n:a)\t\t\tSystem.out.print(n+&quot; &quot;);\t\t//求数组元素的累加和\t\tint sum=0;\t\tfor(int i=0;i&lt;a.length;i++) &#123;\t\t\tsum=sum+a[i];\t\t&#125;\t\tSystem.out.println();\t\tSystem.out.println(&quot;数组元素的累加和为:&quot;+ sum);\t&#125;&#125;\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t//定义一个整型数组并初始化\t\tint[] a= &#123;2,4,5,6,12,44,15,67&#125;;\t\t//循环遍历数组,找出能被3整除的元素并打印输出\t\tfor(int i=0;i&lt;a.length;i++) &#123;\t\t\tif(a[i]%3==0) &#123;\t\t\t\tSystem.out.println(a[i]);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\r\n求数组元素的最大值\r\npackage com.kuroneko.array;public class ArrayDemo2 &#123;\tpublic static void main(String[] args) &#123;\t\t//求数组元素的最大值\t\tint[] a= &#123;34,23,78,56,31&#125;;\t\tint max=a[0];\t\tfor(int i=1;i&lt;a.length;i++) &#123;\t\t\tif(max&lt;a[i]) &#123;\t\t\t\tmax=a[i];\t\t\t&#125;\t\t&#125;\t\tSystem.out.println(&quot;max=&quot;+ max);\t&#125;&#125;\r\n增强型for循环\r\n又叫foreach循环\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\tint[] arr= &#123;1,2,3,4,5&#125;;\tfor(int n:arr)\t\tSystem.out.println(n);\t&#125;&#125;\r\n如何对变量a,b的值进行交换\r\n\r\n\r\nimage-20220112141530724\r\n\r\n增强型for循环与普通for循环的区别\r\n\r\n\r\nimage-20220112141845348\r\n\r\n冒泡排序\r\n\r\n对一组整数按照由小到大的顺序进行排序\r\n\r\n\r\n\r\nimage-20220112142315715\r\n\r\n\r\n\r\nimage-20220112142512890\r\n\r\n\r\n\r\nimage-20220112142606228\r\n\r\n\r\n\r\nimage-20220112142640222\r\n\r\n\r\n\r\nimage-20220112142718731\r\n\r\n\r\n\r\nimage-20220112142809602\r\n\r\npackage com.kuroneko.array;public class SortDemo &#123;\tpublic static void main(String[] args) &#123;\t\t// 冒泡排序\t\tint[] a= &#123;34,53,12,32,56,17&#125;;\t\tSystem.out.println(&quot;排序前的数组元素为:&quot;);\t\tfor(int n:a) &#123;\t\t\tSystem.out.print(n+&quot; &quot;);\t\t&#125;\t\tSystem.out.println();\t\tint temp;\t\t//外重循环控制排序的次数\t\tfor(int i=0;i&lt;a.length-1;i++) &#123;\t\t\t//内重循环控制每趟排序\t\t\t//第一趟排序6个元素两两比较了5次,所以第一次循环5次,第二次循环比第一次都要少一次循环,因为最后一个元素不用比较了\t\t\t for(int j=0;j&lt;a.length-i-1;j++) &#123;\t\t\t\t if(a[j]&gt;a[j+1]) &#123;\t\t\t\t\t temp=a[j];\t\t\t\t\t a[j]=a[j+1];\t\t\t\t\t a[j+1]=temp;\t\t\t\t\t \t\t\t\t &#125;\t\t\t &#125;\t\t&#125;\t\tSystem.out.println(&quot;从小到大排序后的数组元素为&quot;);\t\tfor(int n:a) &#123;\t\t\tSystem.out.print(n+&quot; &quot;);\t\t&#125;\t&#125;&#125;\r\n统计字符数\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t//定义一个字符数组ch并初始化\t\tchar[] ch= &#123;&#x27;a&#x27;,&#x27;A&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;A&#x27;,&#x27;D&#x27;,&#x27;F&#x27;&#125;;\t\t//循环遍历数组,统计字符&#x27;a&#x27;或&#x27;A&#x27;出现的次数\t\tint count1=0;\t\tint count2=0;\t\tfor(int i=0;i&lt;ch.length;i++) &#123;\t\t\tif(ch[i]==&#x27;a&#x27;) &#123;\t\t\t\tcount1++;\t\t\t&#125;\t\t\tif(ch[i]==&#x27;A&#x27;) &#123;\t\t\t\tcount2++;\t\t\t&#125;\t\t&#125;\t\t//打印输出统计数据\t\tSystem.out.println(&quot;字符数组中字符&#x27;a&#x27;或&#x27;A&#x27;的个数为:&quot;+(count1+count2));\t&#125;&#125;\r\n二维数组\r\n\r\n\r\nimage-20220113235212113\r\n\r\n\r\n\r\nimage-20220114001120178\r\n\r\npackage com.kuroneko.array;public class ArrayDemo5 &#123;\tpublic static void main(String[] args) &#123;\t\t//二维数组的声明有三种形式\t\t//声明int类型的二维数组\t\tint[][] intArray;\t\t//声明float类型的二维数组\t\tfloat floatArray[][];\t\t//声明double类型的二维数组\t\tdouble[] doubleArray[];\t\t//创建一个三行三列的int类型的数组\t\tintArray=new int[3][3];\t\t//输出默认值\t\tSystem.out.println(&quot;intArray数组的第3行第2列的元素为:&quot;+intArray[2][1]);\t\t//为第2行第3个元素赋值为9\t\tintArray[1][2]=9;\t\tSystem.out.println(&quot;intArray数组第2行第3列的元素为&quot;+intArray[1][2]);\t\t//声明数组的同时进行创建\t\tchar[][] ch=new char[3][5];\t\t//创建float类型的数组,可以只指定行数\t\tfloatArray=new float[3][];\t\t//System.out.println(floatArray[0][0]);//空指针异常\t\t//每行相当于一个一维数组,需要创建\t\tfloatArray[0]=new float[3];//第一行有三列\t\tfloatArray[1]=new float[4];//第二行有四列\t\tfloatArray[2]=new float[5];//第三行有五列\t\t//System.out.println();//数组下标越界异常\t\t//二维数组的初始化\t\tint[][] num= &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;\t\tSystem.out.println(&quot;num数组第一行第二列的元素为:&quot;+num[0][1]);\t\tSystem.out.println(&quot;num数组的行数为:&quot;+num.length);\t\tSystem.out.println(&quot;num数组的列数为:&quot;+num[0].length);\t\tint[][] num1= &#123;&#123;78,98&#125;,&#123;65,75,63&#125;,&#123;98&#125;&#125;;\t\tSystem.out.println(&quot;num1数组的第一行的列数为:&quot;+num1[0].length);\t\t//循环输出二维数组的内容\t\tfor(int i=0;i&lt;num1.length;i++) &#123;\t\t\tfor(int j=0;j&lt;num1[i].length;j++) &#123;\t\t\t\tSystem.out.print(num1[i][j]+&quot; &quot;);\t\t\t&#125;\t\t\tSystem.out.println();\t\t&#125;\t&#125;                  &#125;\r\n编程练习\r\n\r\n\r\nimage-20220114143243596\r\n\r\nimport java.util.Scanner;public class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 在一个二维数组中存放了三名学生的语文和数学的成绩,\t\t * 从键盘输入三名学生的成绩存储到二维数组中,\t\t * 分别求语文和数学的总成绩及平均分并输出。\t\t */\t\t//定义一个三行两列的整型二维数组intArray\t\tint[][] intArray=new int[3][2];\t\t//从键盘输入学生成绩，要求输入顺序与效果图一致\t\tScanner sc=new Scanner(System.in);\t\tfor(int i=0;i&lt;intArray.length;i++) &#123;\t\t\tfor(int j=0;j&lt;intArray[i].length;j++) &#123;\t\t\t\tif(j==0) &#123;\t\t\t\t\tSystem.out.println(&quot;请输入第&quot;+(i+1)+&quot;个学生的语文成绩：&quot;);\t\t\t\t\tintArray[i][j]=sc.nextInt();\t\t\t\t&#125;else &#123;\t\t\t\t\tSystem.out.println(&quot;请输入第&quot;+(i+1)+&quot;个学生的数学成绩：&quot;);\t\t\t\t\tintArray[i][j]=sc.nextInt();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t//求语文的总成绩和平均分\t\tint sum1=0;\t\tfloat avg1;\t\tfor(int i=0;i&lt;intArray.length;i++) &#123;\t\t\tsum1+=intArray[i][0];\t\t&#125;\t\tavg1 = sum1/intArray.length;\t\tSystem.out.println(&quot;语文的总成绩为：&quot;+sum1);\t\tSystem.out.println(&quot;语文的平均分为：&quot;+avg1);\t\t//求数学的总成绩和平均分\t\tint sum2=0;\t\tfloat avg2;\t\tfor(int i=0;i&lt;intArray.length;i++) &#123;\t\t\tsum2+=intArray[i][1];\t\t&#125;\t\tavg2=sum2/intArray.length;\t\tSystem.out.println(&quot;数学的总成绩为：&quot;+sum2);\t\tSystem.out.println(&quot;数学的平均分为：&quot;+avg2);\t&#125;&#125;\r\n方法\r\n方法在类的内部定义\r\n方法是用来解决一类问题的代码的有序组合,是一个功能模块。\r\n方法声明\r\n\r\n\r\nimage-20220117110313463\r\n\r\n方法分类\r\n无参无返回值方法\r\npackage com.kuroneko.method;import java.util.Scanner;public class MethodDemo &#123;\t// 打印输出星号的方法\tpublic void printStar() &#123;\t\tSystem.out.println(&quot;********************&quot;);\t&#125;\tpublic static void main(String[] args) &#123;\t\t//创建一个MethodDemo类的对象myMethodDemo\t\tMethodDemo myMethodDemo=new MethodDemo();\t\t//使用对象名.方法名去调用方法\t\tmyMethodDemo.printStar();\t\tSystem.out.println(&quot;欢迎来到Java的世界!&quot;);\t\tmyMethodDemo.printStar();\t&#125;&#125;\r\n无参带返回值方法\r\npackage com.kuroneko.method;public class Rectangle &#123;\t\t//求长方形面积的方法\tpublic int area() &#123;\t\tint length=10;\t\tint width=5;\t\tint getArea=length*width;\t\treturn getArea;//返回语句\t&#125;\tpublic static void main(String[] args) &#123;\t\tRectangle rc=new Rectangle();\t\tSystem.out.println(&quot;长方形的面积为:&quot;+ rc.area());\t&#125;&#125;\r\n带参无返回值方法\r\npackage com.kuroneko.method;/** * 定义一个求两个float类型数据最大值的方法, * 在方法中将最大值打印输出 */public class MaxDemo &#123;\t//求最大值的方法\tpublic void max(float a,float b) &#123;\t\tfloat max;\t\tif(a&gt;b) &#123;\t\t\tmax=a;\t\t&#125;else &#123;\t\t\tmax=b;\t\t&#125;\t\tSystem.out.println(&quot;两个数&quot;+a+&quot;和&quot;+b+&quot;的最大值为:&quot;+max);\t&#125;\tpublic static void main(String[] args) &#123;\t\t//创建对象\t\tMaxDemo maxDemo=new MaxDemo();\t\tmaxDemo.max(5.6f,8.9f);\t&#125;&#125;\r\n带参带返回值方法\r\npackage com.kuroneko.method;public class FacDemo &#123;\t/*\t *定义一个求n！的方法，\t *然后再求1！+2！+3！+4！+5！\t */\t//求阶乘的方法\tpublic int fac(int n) &#123;\t\tint s=1;\t\tfor(int i=1;i&lt;=n;i++) &#123;\t\t\ts*=i;\t\t&#125;\t\treturn s;\t&#125;\tpublic static void main(String[] args) &#123;\t\tFacDemo facDemo=new FacDemo();\t\tint fac=facDemo.fac(3);\t\tSystem.out.println(&quot;3!=&quot;+fac);\t\tint sum=0;\t\t//求1！+2！+3！+4！+5！\t\tfor(int i=1;i&lt;=5;i++) &#123;\t\t\tfac=facDemo.fac(i);\t\t\tsum=sum+fac;\t\t&#125;\t\tSystem.out.println(&quot;1！+2！+3！+4！+5！=&quot;+sum);\t&#125;&#125;\r\n\r\n\r\nimage-20220117131050736\r\n\r\n数组作为方法参数\r\npackage com.kuroneko.method;public class ArrayMethod &#123;\t//打印输出数组元素的值\tpublic void printArray(int[] arr) &#123;\t\tfor(int i=0;i&lt;arr.length;i++) &#123;\t\t\tSystem.out.print(arr[i]+&quot; &quot;);\t\t&#125;\t\tSystem.out.println();\t&#125;\tpublic static void main(String[] args) &#123;\t\tint[] arr= &#123;10,20,30,40,50&#125;;\t\tArrayMethod am=new ArrayMethod();\t\tam.printArray(arr);\t&#125;&#125;\r\n\r\n\r\nimage-20220117134150070\r\n\r\npackage com.kuroneko.method;import java.util.Scanner;public class ArraySearch &#123;\t//查找数组元素值的方法\tpublic boolean search(int n,int[] arr) &#123;\t\tboolean flag=false;//默认是没\t\tfor(int i=0;i&lt;arr.length;i++) &#123;\t\t\tif(arr[i]==n) &#123;\t\t\t\tflag=true;//找到了\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\treturn flag;\t&#125;\tpublic static void main(String[] args) &#123;\t\tint[] arr1= &#123;10,20,30,40,50,60&#125;;\t\tScanner sc=new Scanner(System.in);\t\tSystem.out.println(&quot;请输入要查找的数据:&quot;);\t\tint n1=sc.nextInt();\t\tArraySearch as=new ArraySearch();\t\tboolean flag=as.search(n1,arr1);\t\tif(flag) &#123;\t\t\tSystem.out.println(&quot;找到了!&quot;);\t\t&#125;else &#123;\t\t\tSystem.out.print(&quot;没找到!&quot;);\t\t&#125;\t&#125;&#125;\r\n编程练习\r\n求数组平均值\r\npackage com.kuroneko.method;public class AverageDemo &#123;\t//求数组元素的平均值\tpublic void avgArray(float[] a) &#123;\t\tfloat sum=0;\t\tfor(int i=0;i&lt;a.length;i++) &#123;\t\t\tsum+=a[i];\t\t&#125;\t\tSystem.out.println(&quot;数组的平均值为:&quot;+ sum/a.length);\t&#125;\tpublic static void main(String[] args) &#123;\t\t// 定义对象\t\tAverageDemo averageDemo =new AverageDemo();\t\t//创建float类型的数组并初始化\t\tfloat[] a= &#123;78.5f,98.5f,65.5f,32.5f,75.5f&#125;;\t\t//调用方法求平均值并打印输出\t\taverageDemo.avgArray(a);\t&#125;&#125;\r\n方法重载\r\n同一个类中\r\n方法名相同，参数列表不同(参数顺序,个数,类型),与参数名无关\r\n定义三个方法,实现int,double和数组类型和的问题\r\npackage com.kuroneko.method;public class MathDemo &#123;\t\t//求两个int类型数的和\tpublic int plus(int m,int n) &#123;\t\treturn m+n;\t&#125;\t//求两个double类型数的和\tpublic double plus(double m,double n) &#123;\t\treturn m+n;\t&#125;\t//求数组元素的累加和\tpublic int plus(int[] arr) &#123;\t\tint sum=0;\t\tfor(int i=0;i&lt;arr.length;i++) &#123;\t\t\tsum=sum+arr[i];\t\t&#125;\t\treturn sum;\t&#125;\tpublic static void main(String[] args) &#123;\t\tint m=5,n=10;\t\tint[] arr= &#123;1,2,3,4,5,6&#125;;\t\tMathDemo mathDemo=new MathDemo();\t\tSystem.out.println(&quot;int类型的和:&quot;+mathDemo.plus(m, n));\t\tSystem.out.println(&quot;double类型的和&quot;+ mathDemo.plus(5.6,7.8));\t\tSystem.out.println(&quot;数组元素的和:&quot;+mathDemo.plus(arr));\t\t\t&#125;&#125;\r\n\r\n\r\nimage-20220117143306869\r\n\r\n参数的传递问题\r\n\r\n基本数据类型传值:\r\n方法中对参数的修改,不会对主方法中传来的变量值产生影响\r\n引用数据类型传值: 方法中对数组的改变,会影响主方法中传来的数组\r\n\r\n例: 对两个变量的值进行交换并打印输出\r\npackage com.kuroneko.method;public class ExchangeDemo &#123;\t//交换的方法\tpublic void swap(int a,int b) &#123;\t\tint temp;\t\tSystem.out.println(&quot;交换前:a=&quot;+a+&quot;b=&quot;+b);\t\ttemp=a;a=b;b=temp;\t\tSystem.out.println(&quot;交换后:a=&quot;+a+&quot;b=&quot;+b);\t&#125;\tpublic static void main(String[] args) &#123;\t\tint m=4,n=5;\t\tExchangeDemo ed=new ExchangeDemo();\t\tSystem.out.println(&quot;交换前:m=&quot;+m+&quot;n=&quot;+n);\t\ted.swap(m, n);\t\tSystem.out.println(&quot;交换后:m=&quot;+m+&quot;n=&quot;+n);\t&#125;&#125;\r\n\r\n\r\nimage-20220117145937907\r\n\r\n主方法中定义的mn是在内存中开辟了空间\r\n把4放到m中,把5放到n中,在方法调用时把m和\r\nn的值4和5传给a和b,并没有把m和n这两个变量传过去,所以a和b收到4和5后执行方法体的内容,进行交换,a和b分别换成了5和4,而m和n始终没有改变\r\n\r\n\r\nimage-20220117150458014\r\n\r\npackage com.kuroneko.method;public class ExchangeDemo1 &#123;\tpublic void add(int n) &#123;\t\tn++;\t\tSystem.out.println(&quot;方法中n=&quot;+n);\t&#125;\tpublic static void main(String[] args) &#123;\t\tint n=10;\t\tSystem.out.println(&quot;方法调用前n的值:&quot;+n);\t\tExchangeDemo1 ed1=new ExchangeDemo1();\t\ted1.add(n);\t\tSystem.out.println(&quot;方法调用后n的值:&quot;+n);\t&#125;&#125;\r\n数组作为方法参数的传值问题\r\npackage com.kuroneko.method;public class ArrayDemo &#123;\t//定义一个用于修改某个数组元素值的方法\tpublic void updateArray(int[] a) &#123;\t\ta[3]=15;\t\tSystem.out.println(&quot;数组a的元素为:&quot;);\t\tfor(int n:a)&#123;\t\t\tSystem.out.print(n+&quot; &quot;);\t\t&#125;\t\tSystem.out.println();\t&#125;\tpublic static void main(String[] args) &#123;\t\tArrayDemo ad=new ArrayDemo();\t\tint[] a1= &#123;1,2,3,4,5&#125;;\t\tSystem.out.println(&quot;方法调用前数组a1的元素为:&quot;);\t\tfor(int n:a1) &#123;\t\t\tSystem.out.print(n+&quot; &quot;);\t\t&#125;\t\tSystem.out.println();\t\tad.updateArray(a1);\t\tSystem.out.println(&quot;方法调用后数组a1的元素为:&quot;);\t\tfor(int n:a1) &#123;\t\t\tSystem.out.print(n+&quot; &quot;);\t\t&#125;\t&#125;&#125;\r\n数组名a1指向内存空间中第一个元素1,在调用方法进行数组传值时,\r\n方法中的参数,也就是数组名字a也指向了第一个元素1,会发现,数组a和a1指向了同一片内存空间,也就指向了同一个数组,所以当我们在方法中对数组的某个元素修改时也影响到了主方法中的a1数组\r\n数组是引用数据类型,数组作为变量传值时会影响主方法中的值,而基本数据类型不会。\r\n可变参数列表\r\n​ 当可变参数列表作为方法参数时，可以将数组传递给可变参数列表\r\n一个方法中，只能有一个可变参数列表作为参数\r\n数组作为方法参数时，不能将多个值同时传递给数组\r\n方法的参数列表中，如果有两个以上的参数，可变参数列表一定是放在最后的\r\npackage com.kuroneko.method;public class ArgsDemo &#123;\t//求累加和\tpublic void sum(int... n) &#123;\t\tint sum=0;\t\tfor(int i:n) &#123;\t\t\tsum+=i;\t\t&#125;\t\tSystem.out.println(&quot;sum=&quot;+sum);\t&#125;\tpublic static void main(String[] args) &#123;\t\tArgsDemo ad=new ArgsDemo();\t\tad.sum(1);\t\tad.sum(1,2);\t\tad.sum(1,2,3);\t&#125;&#125;\r\npackage com.kuroneko.method;public class ArgsDemo1 &#123;\t//查找\tpublic void search(int n,int... a) &#123;\t\tboolean flag=false;\t\tfor(int a1:a) &#123;\t\t\tif(a1==n) &#123;\t\t\t\tflag=true;break;\t\t\t&#125;\t\t&#125;\t\tif(flag) &#123;\t\t\tSystem.out.println(&quot;找到了!&quot;+n);\t\t&#125;else &#123;\t\t\tSystem.out.println(&quot;没找到!&quot;+n);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tArgsDemo1 ad1=new ArgsDemo1();\t\tad1.search(3,1,2,3,4,5);\t\t//当可变参数列表作为方法参数时，可以将数组传递给可变参数列表\t\tint[] a= &#123;1,2,3,4,5&#125;;\t\tad1.search(3, a);\t&#125;&#125;\r\n\r\n\r\n可变参数列表与数组作为参数的区别\r\n\r\n可变参数列表作为方法参数的重载问题\r\npackage com.kuroneko.method;public class ArgsDemo3 &#123;\t//可变参数列表所在的方法是最后被访问的\tpublic int plus(int a, int b) &#123;\t\tSystem.out.println(&quot;不带可变参数的方法被调用!&quot;);\t\treturn a + b;\t&#125;\tpublic int plus(int... a) &#123;\t\t int sum=0;\t\t for(int n:a) &#123;\t\t\t sum+=n;\t\t &#125;\t\t System.out.print(&quot;带可变参数的方法被调用&quot;);\t\t return sum;\t&#125;\tpublic static void main(String[] args) &#123;\t\tArgsDemo3 ad=new ArgsDemo3();\t\tSystem.out.print(&quot;和为:&quot;+ ad.plus(1,2));\t\t&#125;&#125;\r\n生成文档\r\njavadoc -d doc HelloWorld.java\r\n\r\n\r\n关于javadoc命令\r\n\r\n方法的调试\r\neclipse快捷键\r\nF6单步调试\r\nF5进入方法内部\r\nF7由方法内部返回调用处\r\n综合案例\r\n\r\n\r\nimage-20220118140846487\r\n\r\n\r\n\r\nimage-20220118140904649\r\n\r\n\r\n\r\nimage-20220118151720076\r\n\r\n\r\n\r\nimage-20220118152407457\r\n\r\n\r\n\r\nimage-20220118151431751\r\n\r\n\r\n\r\n项目作业\r\n\r\npackage com.kuroneko.datamanage;import java.util.Scanner;/** * 从键盘接收整型数据存放到数组中,并对数组中的数据进行管理 *  * @author kuroneko * */public class DataManage &#123;\t/**\t * 从键盘接收数据\t * \t * @return 接收数据的数组\t */\tpublic int[] insertData() &#123;\t\tint[] a = new int[10];// 因为数组的长度是不能动态变化的,所以我们在定义数组时必须给一个数组长度的,这里我们要插入9个数据,还有一个数据是为后面在指定位置处插入数据做准备的\t\tScanner sc = new Scanner(System.in);\t\t// 少接收一个数据,为在指定位置处插入数据做准备\t\tfor (int i = 0; i &lt; a.length - 1; i++) &#123;\t\t\tSystem.out.println(&quot;请输入第&quot; + (i + 1) + &quot;个数据:&quot;);\t\t\t// 捕获输入不匹配异常,当输入非数字时,sc.nextInt()语句会发生异常,执行catch后面的语句\t\t\ttry &#123;\t\t\t\ta[i] = sc.nextInt();\t\t\t&#125; catch (java.util.InputMismatchException e) &#123;\t\t\t\tSystem.out.println(&quot;输入的数据格式有误,不能有非数字!&quot;);\t\t\t\t// next()接收字符串数据\t\t\t\tsc.next();\t\t\t\t// 重新输入\t\t\t\ti--;\t\t\t&#125;\t\t&#125;\t\treturn a;\t&#125;\t/**\t * 显示数组中元素的内容\t * \t * @param a      :数组\t * @param length :要显示的数组元素个数\t */\tpublic void showData(int[] a,int length) &#123;\t\tfor (int i = 0; i &lt; length; i++) &#123;\t\t\tSystem.out.print(a[i] + &quot; &quot;);\t\t&#125;\t\tSystem.out.println();\t&#125;\t/**\t * 从键盘接收一个数据,插入到数组的指定位置处\t * \t * @param a 要插入数据的数组\t * @param n 要插入的数据\t * @param k 要插入的位置,从0开始\t */\tpublic void insertAtArray(int[] a, int n, int k) &#123;\t\t// 注意从最后一个数据开始移动,避免数据覆盖\t\tfor (int i = a.length - 1; i &gt; k; i--) &#123;\t\t\ta[i] = a[i - 1];// 元素向后移\t\t&#125;\t\ta[k] = n;\t&#125;\t/**\t * 输出数组中能被3整除的元素\t * \t * @param a\t */\tpublic void divThree(int[] a) &#123;\t\tString str = &quot;&quot;;// 用来把所有能被3整除的数组元素连在一起\t\tint count = 0;// 统计多少个数组元素能被3整除\t\tfor (int n : a) &#123;\t\t\tif (n % 3 == 0) &#123;\t\t\t\tstr = str + n + &quot; &quot;;\t\t\t\tcount++;\t\t\t&#125;\t\t&#125;\t\tif (count == 0) &#123;\t\t\tSystem.out.println(&quot;数组中没有能被3整除的元素!&quot;);\t\t&#125; else &#123;\t\t\tSystem.out.println(&quot;数组中能被3整除的元素为:&quot; + str);\t\t&#125;\t&#125;\t/**\t * 提示信息\t */\tpublic void notice() &#123;\t\tSystem.out.println(&quot;***********************************************&quot;);\t\tSystem.out.println(&quot;      1--插入数据&quot;);\t\tSystem.out.println(&quot;      2--显示所有数据&quot;);\t\tSystem.out.println(&quot;      3--在指定位置处插入数据&quot;);\t\tSystem.out.println(&quot;      4--查询能被3整除的数据&quot;);\t\tSystem.out.println(&quot;      0--退出&quot;);\t\tSystem.out.println(&quot;***********************************************&quot;);\t&#125;\tpublic static void main(String[] args) &#123;\t\tDataManage dm = new DataManage();//\t\tint[] a = dm.insertData();// 把返回值用数组a接收//\t\tdm.showData(a, a.length - 1);//\t\tScanner sc=new Scanner(System.in);//\t\tSystem.out.println(&quot;请输入要插入的数据:&quot;);//\t\tint n=sc.nextInt();//\t\tSystem.out.println(&quot;请输入要插入的位置:&quot;);//\t\tint k=sc.nextInt();//\t\tdm.insertAtArray(a, n, k);//\t\tdm.showData(a, a.length);//\t\tdm.divThree(a);\t\tScanner sc = new Scanner(System.in);\t\tint input=0; \t\tint[] a=null;//数组a为null说明是没有插入数据的情况\t\tint n=0,k=0;//n表示要插入的数据,k表示插入位置\t\twhile (true) &#123;\t\t\tdm.notice();\t\t\tSystem.out.println(&quot;请输入对应的数字进行操作:&quot;);\t\t\ttry &#123;\t\t\tinput = sc.nextInt();\t\t\t&#125;catch(java.util.InputMismatchException e)&#123;\t\t\t\tSystem.out.println(&quot;输入的数据格式有误,不能有非数字!&quot;);\t\t\t\tsc.next();//接收输错的字符串\t\t\t\tcontinue;\t\t\t&#125;\t\t\tif (input == 0) &#123;\t\t\t\tSystem.out.println(&quot;退出程序!&quot;);\t\t\t\tbreak;\t\t\t&#125;\t\t\tswitch (input) &#123;\t\t\tcase 1:\t\t\t\t//插入数据\t\t\t\ta=dm.insertData();\t\t\t\t//显示数据\t\t\t\tSystem.out.println(&quot;数组元素为:&quot;);\t\t\t\tdm.showData(a,a.length-1);\t\t\t\tbreak;\t\t\tcase 2:\t\t\t\tif(a!=null) &#123;\t\t\t\t\tSystem.out.println(&quot;数组元素为:&quot;);\t\t\t\t\tif(a[a.length-1]==0) &#123;\t\t\t\t\t\t//如果最后一个元素为0,说明还没有插入数据,因此不显示最后一个元素\t\t\t\t\t\tdm.showData(a, a.length-1);\t\t\t\t\t&#125;else &#123;\t\t\t\t\t\tdm.showData(a, a.length);\t\t\t\t\t&#125;\t\t\t\t&#125;else &#123;\t\t\t\t\tSystem.out.println(&quot;还未在数组中插入数据,请重新选择操作!&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase 3:\t\t\t\t//在指定位置处插入数据\t\t\t\tif(a!=null) &#123;\t\t\t\t\tSystem.out.println(&quot;请输入要插入的数据:&quot;);\t\t\t\t\ttry &#123;\t\t\t\t\tn=sc.nextInt();\t\t\t\t\tSystem.out.println(&quot;请输入要插入数据的位置:&quot;);\t\t\t\t\tk=sc.nextInt();\t\t\t\t\t&#125;catch(java.util.InputMismatchException e) &#123;\t\t\t\t\t\tSystem.out.println(&quot;输入的格式有误,不能有非数字!&quot;);\t\t\t\t\t\tsc.next();//接收输错的字符串\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t\tdm.insertAtArray(a, n, k);\t\t\t\t\tdm.showData(a, a.length);\t\t\t\t&#125;else &#123;\t\t\t\t\tSystem.out.println(&quot;还未在数组中插入数据,请重新选择操作!&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase 4:\t\t\t\t//查询数组中能被3整除的元素\t\t\t\tif(a!=null) &#123;\t\t\t\t\tdm.divThree(a);\t\t\t\t&#125;else &#123;\t\t\t\t\tSystem.out.println(&quot;还未在数组中插入数据,请重新选择操作!&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\r\n","tags":["java"]},{"title":"Git学习笔记","url":"/2023/04/21/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"glfs大文件上传\r\nwhere git1.start 到git的bin目录，并将gitlfs安装到该目录\r\n# 将所有文件标记为使用 Git LFS（Large File Storage）进行版本控制git lfs track *# 查看分支git branch -vv# 重命名分支为maingit branch -m master main# 添加远程仓库git remote add origin https://github.com/luotaofun/_posts.git# 推送到远程仓库git push  origin &lt;本地分支名&gt;:&lt;远程分支名&gt;\r\nGit的诞生\r\n​\r\nLinus在1991年创建了开源的Linux，为了维护代码库，选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。开发Samba的Andrew试图破解BitKeeper的协议被BitMover公司发现了，于是BitMover公司收回Linux社区的免费使用权。Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git。Git迅速成为最流行的分布式版本控制系统，2008年，GitHub网站上线为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub。\r\n集中式VS分布式\r\n1 集中式\r\n​\r\n版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\r\n\r\n\r\nimage-20230421094548814\r\n\r\n缺点：\r\n\r\n必须联网工作(网速慢导致提交慢)。\r\n若中央服务器出现问题，所有人无法工作。\r\n\r\n2 分布式\r\n每个人的电脑都是一个完整的版本库，无需联网。多人协作时，若A在自己电脑上修改了F文件，B也在自己电脑上修改了F文件，只需将各自的修改推送给对方就可以看到对方的修改了。\r\n在推送版本库的修改时，可能电脑相互间访问不了，所以分布式通常有一台充当”中央服务器”的电脑用来方便”交换”修改。\r\n优点：\r\n\r\n安全性高(因为每个人电脑都有完整的版本库，某一台电脑坏掉可以从其他人那里复制)\r\n分支管理\r\n\r\nGit配置\r\n# 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门$ git config --global user.name &quot;luotao&quot;$ git config --global user.email &quot;coder@luotao@gmail.com&quot;\r\n工作区、暂存区和版本库\r\n\r\n\r\nimage-20250410164410797\r\n\r\n工作区和暂存区\r\n工作区：能看到的目录，如例子中的learngit\r\n暂存区：版本库中的stage(或者叫index)\r\n版本库\r\n工作区有个隐藏目录.git是Git的版本库。版本库repository即仓库(目录),库里所有文件都被git管理起来，每个文件的更新都能跟踪，以便在将来某个时刻可以还原。\r\n# 创建工作区mkdir learngitcd learngitpwd# Git管理该仓库git init \r\n\r\n\r\nimage-20230421103015235\r\n\r\n\r\n\r\nimage-20230421103005144\r\n\r\n把文件添加到版本库\r\n创建readme.txt文件\r\n\r\n\r\nimage-20230421103617658\r\n\r\n# 将文件添加到仓库git add readme.txt# 将文件提交到仓库,-m &lt;提交说明&gt;git commit -m &quot;wrote a readme file&quot;\r\n\r\n\r\nimage-20230421104350344\r\n\r\n添加和提交\r\n需要提交的文件修改全部放到暂存区，然后一次性提交暂存区的所有修改。\r\n往版本库添加时分两步：\r\n\r\ngit add 把文件修改添加到暂存区\r\ngit commit 把暂存区的所有内容提交到当前分支\r\n\r\n创建版本库时git自动创建唯一master分支。\r\n\r\n\r\nimage-20230421114654775\r\n\r\n修改readme.txt文件\r\n\r\n\r\nimage-20230421104605464\r\n\r\n# 查看修改结果git status# 查看上次是如何修改的，修改内容git diff readme.txt# 添加修改git add readme.txt# 查看添加状态git status# 提交修改git commit -m &quot;add 666&quot;# 查看提交状态git status\r\n\r\n\r\nimage-20230421105618941\r\n\r\n版本回退\r\n\r\ngit会把每次提交串成一条历史时间线。\r\nHEAD表示当前版本，HEAD^表示上个版本，HEAD~100表示往上100个版本\r\n\r\nGit内部有个指向当前版本的HEAD指针，回退版本时，仅把HEAD指针改变。\r\n\r\n\r\nimage-20230421111547768\r\n\r\n# 查看提交的历史记录,以便确定要回退到哪个版本。git log --pretty=oneline\r\n\r\n\r\nimage-20230421110635353\r\n\r\n# 回退到上个版本git reset --hard HEAD^# 查看版本库状态git log --pretty=oneline\r\n当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit\r\nid。Git提供了一个命令git reflog用来记录你的每一次命令。\r\n# 查看命令历史记录，以便确定要回到未来的哪个版本。git reflog# 回退到未来指定版本git reset --hard 5cef\r\n\r\n\r\nimage-20230421112342557\r\n\r\n文件操作\r\n\r\n版本号\r\n\r\n\r\nimage-20250410163306535\r\n\r\n# 1.查看版本号T@T MINGW64 /d/workspace/GitHub/local-test/.git/objects/78 (GIT_DIR!)$ git cat-file -p 783b265a43066b3a54c790416d49ecc90d6948f3# -输出了提交信息# -tree表示tree 6f9509c88bed7080d496fc5e1d87a9315e30549dauthor luotaofun &lt;luotao0213@163.com&gt; 1744270243 +0800committer luotaofun &lt;luotao0213@163.com&gt; 1744270243 +0800Initial commit# 2.继续查看tree的版本号T@T MINGW64 /d/workspace/GitHub/local-test/.git/objects/78 (GIT_DIR!)$ git cat-file -p 6f9509c88bed7080d496fc5e1d87a9315e30549d# -输出了`.gitattributes`文件的状态信息# -100表示# -644表示# -blob表示100644 blob dfe0770424b2a19faf507a501ebfc23be8f54e7b    .gitattributes# 3.继续查看文件状态信息的版本号$ git cat-file -p dfe0770424b2a19faf507a501ebfc23be8f54e7b# -输出了`.gitattributes`文件的内容# Auto detect text files and perform LF normalization* text=auto\r\n\r\n创建文件a.txt\r\n\r\n# 4.查看`a.txt`的版本号$ git cat-file -p 94a49596f78b48219e84168a0e50b361670311fa# 输出了提交信息，-parent表示关联上一次提交的版本号tree 0e5aed0ee839d351094ef15c2cd4e2fb0af77bd9parent 783b265a43066b3a54c790416d49ecc90d6948f3author luotaofun &lt;luotao0213@163.com&gt; 1744271873 +0800committer luotaofun &lt;luotao0213@163.com&gt; 1744271873 +0800Create a.txt创建 a.txt# 5.继续查看tree的版本号T@T MINGW64 /d/workspace/GitHub/local-test/.git/objects/78 (GIT_DIR!)$ git cat-file -p 0e5aed0ee839d351094ef15c2cd4e2fb0af77bd9# -输出了两个文件状态100644 blob dfe0770424b2a19faf507a501ebfc23be8f54e7b    .gitattributes100644 blob 29ccdc7b0a1eb0c1becea6c2c453e1575576d528    a.txt\r\n\r\n修改a.txt\r\n\r\n# 6.查看修改的版本号T@T MINGW64 /d/workspace/GitHub/local-test/.git/objects/78 (GIT_DIR!)$ git cat-file -p acd1ab595bb13b1d819d7c9b7fd8e35225fc4beb# -输出了提交信息，-parent是上一次的提交tree 89499f0db48618787bc552ae5b3769040b69c875parent 94a49596f78b48219e84168a0e50b361670311faauthor luotaofun &lt;luotao0213@163.com&gt; 1744272717 +0800committer luotaofun &lt;luotao0213@163.com&gt; 1744272717 +0800Update a.txt修改a.txt# 7.查看treeT@T MINGW64 /d/workspace/GitHub/local-test/.git/objects/78 (GIT_DIR!)$ git cat-file -p 89499f0db48618787bc552ae5b3769040b69c875# 产生了新的文件版本号`405188380b2a0ea90f03dbc99686eaf85f9e827f`即修改的a.txt100644 blob dfe0770424b2a19faf507a501ebfc23be8f54e7b    .gitattributes100644 blob 405188380b2a0ea90f03dbc99686eaf85f9e827f    a.txt\r\n\r\n删除a.txt\r\n\r\n# 8.查看删除版本号T@T MINGW64 /d/workspace/GitHub/local-test/.git/objects/78 (GIT_DIR!)$ git cat-file -p c4446069ad813da8a2926cf442c5fb042e818481# -输出了提交信息，parent是上一次修改的版本号tree 6f9509c88bed7080d496fc5e1d87a9315e30549dparent acd1ab595bb13b1d819d7c9b7fd8e35225fc4bebauthor luotaofun &lt;luotao0213@163.com&gt; 1744273591 +0800committer luotaofun &lt;luotao0213@163.com&gt; 1744273591 +0800Delete a.txt删除`a.txt`\r\n\r\n命令操作\r\n\r\n\r\nimage-20250410165007818\r\n\r\n # 在当前目录生成隐藏的 .git 子目录（存储版本历史、配置等元数据） git init  #添加所有未跟踪的文件 git add .# 克隆特定分支git clone -b master https://github.com/luotaofun/job.git#  查看 Git 仓库当前状态git status# 查看提交历史$ git log --oneline# 添加到 Git 的暂存区（Staging Area），开始被版本控制跟踪git add a.txt# 将暂存区的内容永久保存到 Git 仓库的历史记录中git commit -m &quot;feat: 新增用户注册功能&quot;   #修正最近提交信息：git commit --amend -m &quot;新提交消息&quot;\r\n后悔药\r\n# 撤销暂存：git reset HEAD a.txt# 恢复文件到指定提交版本【之前】(不丢失提交过程，相当于新增了一个反向提交)git revert 想要恢复的版本的下一个版本号# 恢复文件到指定提交版本cp README.md README.md.backup     # 先备份文件git restore --source=404b56f 文件路径git add README.mdgit commit -m &quot;恢复 README.md 文件&quot;# 强制重置到某一个版本(reset会丢失提交过程，彻底回退到旧版本)：git reset --hard 版本号\r\ngit log\r\n # 查看最近10条简略提交历史git log --oneline -10 # 搜索包含「初始化」的提交git log --all --grep=&quot;初始化&quot; \r\n远程分支操作\r\n# 查看远程仓库详情git remote -v# 添加远程仓库：将指定的远程仓库 URL 绑定到别名 origin。使本地仓库能够与远程仓库进行交互（如拉取、推送代码）git remote add origin 仓库地址\r\n# 生成ssh公钥后需要去远程仓库配置生产的公钥ssh-keygen -t rsa -C&quot;ssh地址&quot;\r\n# 查看本地分支与远程分支的关联关系。    git branch -vv# 基于远程 main 分支创建并切换git checkout -b main origin/main\r\n# 创建并切换dev分支git checkout -b dev# 等价于以下两条命令：git branch dev      # 创建分支git checkout dev    # 切换分支#基于远程main分支创建并切换git checkout -b main origin/main # 【删除】分支git branch -d dev\r\n# 拉取 origin仓库的最新代码合并到本地分支：方法一 git pull origin 本地分支名   # 拉取 origin仓库的最新代码合并到本地分支：方法二# 从远程仓库分支获取最新代码git fetch origin &lt;远程分支名&gt;   # 切换到目标本地分支git checkout &lt;本地分支名&gt;# 查看本地分支与远程 dev 分支的差异git diff 本地分支 origin/dev # 将远程分支合并到当前本地分支git merge origin/&lt;远程分支名&gt; # 推送合并后的本地分支git push origin &lt;本地分支名&gt;# 解决冲突,作为一个新提交commitgit add xxxgit commit -m &#x27;解决冲突XXX&#x27;# 将本地分支的【提交历史】变基到远程分支git rebase origin/&lt;远程分支名&gt;# 解决冲突后，使用以下命令继续变基：git add &lt;冲突文件&gt;git rebase --continue# 变基完成后，将本地分支推送到远程仓库。由于变基会重写提交历史，需要使用强制推送：git push --force origin &lt;本地分支名&gt;\r\n推送问题\r\n# 将本地推送到远程仓库，并设置远程分支为【上游分支】，Git 会将本地分支与远程分支关联起来：git push --set-upstream origin &lt;本地分支名&gt;:&lt;远程分支名&gt;# 等价于：git push -u origin  &lt;本地分支名&gt;:&lt;远程分支名&gt;\r\n# 注意：【强制推送】本地分支会覆盖远程分支的提交历史git push --force origin &lt;本地分支名&gt;:&lt;远程分支名&gt;# 添加子模块git submodule add 子模块仓库地址\r\n分支重命名\r\n# 重命名前备份   git branch backup-old-branch old-branch    # 本地重命名move   git branch -m 当前分支名称 新分支名称 # :当前分支名称表示删除远程的分支   git push 远程仓库名 :当前分支名称 新分支名称  # 同步重命名到远程仓库   \r\n​\r\n"},{"title":"Java环境搭建与语法入门","url":"/2021/11/25/2021-11-25-Java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/","content":"Java简介\r\n\r\n面向对象\r\n1995年由sun公司发布\r\n2010年sun公司被Oracle公司收购\r\n\r\nJVM\r\n\r\nJava virtual machine Java虚拟机\r\n是Java平台无关性实现的关键\r\n,即把字节码文件解释成具体平台上的机器指令执行\r\n\r\nJava程序执行过程\r\n\r\nJDK\r\njdk( Java development kit) Java软件开发工具包\r\n\r\n两个组件:\r\n​ -javac -编译器,将源程序转成字节码(.class)\r\n​ -java -运行编译后的字节码\r\njdk= jre + 开发工具集\r\n下载 jdk\r\nmac配置环境变量:\r\nvi .bash_profileJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATHexport JAVA_HOMEexport PATH:wq\r\nsource .bash_profile\r\nwindows配置环境变量:\r\nJAVA_HOME 值 C:\\Java\\jdk1.8.0_191\t// 添加系统环境变量 %JAVA_HOME%\\bin\t// 添加path\r\nJava -version\t// 测试\r\n// 编写helloJava.javapublic class HelloJava&#123;\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(&quot;Hello Java&quot;);\t&#125;&#125;\r\njavac HelloJava.java\t//编译成字节码.class文件java HelloJava\t//执行class文件\r\n\r\nJRE\r\n\r\nJava runtime environment,包括jvm,Java核心类库和支持文件\r\njre=jvm+Javase标准类库\r\n\r\nJava平台\r\n\r\nJava SE 桌面程序 Java标准版\r\nJava EE web程序 Java企业版\r\nJava ME 移动设备 Java微型版\r\n\r\n标识符\r\n程序员自己定义的名称，例如类名，方法名，变量等。\r\n\r\n不能以数字开头,不能有空格\r\n区分大小写\r\n不能是Java关键字和保留字（Void是合法的,void是不合法的）\r\n\r\n关键字\r\nJava中的关键字是有对编译器有特殊意义的词。比如class是用来定义类的关键字，编译器遇到class就知道这是定义了一个类。\r\n保留字\r\n保留字是Java预留的关键字，虽然现在还没有作为关键字，但是以后的升级版本中会成为关键字，保留字包括：goto、const。\r\n变量\r\n计算机中临时存储在内存中的数据\r\n\r\n满足标识符命名规则\r\n驼峰法命名，age，stuName\r\n\r\n类的命名\r\n\r\n满足Pascal法命名，HelloJava\r\n\r\n数据类型\r\n\r\n\r\nimage-20220112123715365\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n基本数据类型\r\n说明\r\n字节数\r\n默认值\r\nmin\r\nmax\r\n\r\n\r\n\r\n\r\nbyte\r\n字节型\r\n1\r\n0\r\n-2^7\r\n2^7-1\r\n\r\n\r\nshort\r\n短整型\r\n2\r\n0\r\n-2^15\r\n2^15 - 1\r\n\r\n\r\nint\r\n整形\r\n4\r\n0\r\n-2^31\r\n2^31 - 1\r\n\r\n\r\nlong\r\n长整形\r\n8\r\n0L\r\n-2^63\r\n2^63 -1\r\n\r\n\r\nfloat\r\n单精度浮点型\r\n4\r\n0.0f\r\n-3.40E+38\r\n3.40E+38\r\n\r\n\r\ndouble\r\n双精度浮点型\r\n8\r\n0.0d\r\n-1.79E+308\r\n1.79E+308\r\n\r\n\r\nchar\r\n字符型\r\n2\r\n\r\n0\r\n65535\r\n\r\n\r\nboolean\r\n布尔型\r\n1\r\nfalse\r\n\r\n\r\n\r\n\r\n引用数据类型\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass\r\n类\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface\r\n接口\r\n\r\n\r\n\r\n\r\n\r\n\r\narray\r\n数组\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n进制表示\r\n\r\n八进制: 0开头,包括0-7的数字,如023\r\n十六进制:\r\n以0x或0X开头,包括0-9的数字,及字母a-f,A-F,如0x1abcL(L代表长整型)\r\n\r\n变量声明\r\n格式: 数据类型 变量名;\r\nint n;\r\n赋值\r\n\r\n“=”将运算符右边的值赋给左边的变量\r\n变量的初始化 : 在定义变量的同时给变量赋值,如\r\nint a =3;\r\n\r\n变量的定义\r\nint octal= 037;\t//定义int类型变量存放八进制数据long longNumber= oxa2cdf3ffL;\t//定义变量存放十六进制长整型数据\r\n浮点型字面值\r\n\r\n默认表示double,也可以在值后加d或D,如: 123.43D\r\n若表示float类型,则需在值后加f或F,如 23.4f\r\n```java package com.kuroneko;\r\npublic class FloatDemo { public static void main(String[] args) { //\r\n//定义一个单精度浮点型变量,存放1234.328 // float f=1234.328f; //\r\nSystem.out.println(“f=”+ f); // //定义一个双精度浮点型变量,存放5623.465\r\n// double d= 5623.465; // System.out.println(“d=”+ d); //\r\n//将整形赋值给浮点型 // double d1= 123; // System.out.println(“d1=”+\r\nd1); // //变量间的赋值 // double d2= d; // System.out.println(“d2=”+\r\nd2);\r\n  float f1= 98.4f;\r\n  System.out.println(&quot;f1=&quot;+ f1);\r\n  float f2= f1;\r\n  System.out.println(&quot;f2=&quot;+ f2);\r\n  int n= 55;\r\n  System.out.println(&quot;n=&quot;+ n);\r\n  double d3= 555.3;\r\n  System.out.println(&quot;d1=&quot;+ d3);\r\n  d3= n;\r\n  System.out.println(&quot;赋值后d3的值为:&quot;+ d3);\r\n} }\r\n  ![image-20211206094626382](2021-11-25-Java环境搭建与语法入门/image-20211206094626382.png)# 数据类型转换**自动类型转换**（隐式类型转换）![image-20211206095601339](2021-11-25-Java环境搭建与语法入门/image-20211206095601339.png)**强制类型转换*** 如果A类型的数据表示范围比B类型大，则将A类型的值赋值给B类型，需要强制转换* 格式  （数据类型）数值如 ```javadouble d = 123.4;float f = (float)d;\r\n\r\n数据类型转换案例\r\npackage com.kuroneko;public class TypeExchange &#123;\tpublic static void main(String[] args) &#123;\t\t//char类型和int类型之间的转换\t\tchar c= (char)65536;\t\tint n;\t\tn= c; //隐式类型转换\t\tc= (char)n;\t//强制转换\t\t\t\t//整型和浮点型的类型转换问题\t\tint x= 100;\t\tlong y= x;\t\tx=(int)y;\t\tfloat f= 100000000000000L;\t\tSystem.out.println(&quot;f=&quot;+ f);\t\tfloat f1= 103948583923948L;\t\tSystem.out.println(&quot;f1=&quot;+ f1);\t&#125;&#125;\r\n常量\r\n常量被定义后不可改变,一般用大写表示常量。\r\nfinal double PI=3.14;final double MIN_VALUE= 0;\r\n运算符\r\n表达式由运算符和操作数组成\r\n\r\n\r\nimage-20211212152825140\r\n\r\n算数运算符\r\n\r\n\r\nimage-20211212153354208\r\n\r\n\r\n\r\nimage-20211212160747899\r\n\r\npackage com.kuroneko.operator;public class MathDemo &#123;\tpublic static void main(String[] args) &#123;\t\tint num1= 10, num2= 5;\t\tint result;//存放结果\t\t//加法\t\tresult= num1+num2;\t\tSystem.out.println(num1+ &quot;+&quot; +num2+ &quot;=&quot; +result);\t\t//字符串连接\t\tSystem.out.println(&quot;&quot;+num1+num2);\t\t//减法\t\tresult= num1-num2;\t\tSystem.out.println(num1+ &quot;-&quot; +num2+ &quot;=&quot; +result);\t\t//乘法\t\tresult=num1*num2;\t\tSystem.out.println(num1+ &quot;*&quot; +num2+ &quot;=&quot; +result);\t\t//除法\t\tresult=num1/num2;\t\tSystem.out.println(num1+ &quot;/&quot; +num2+ &quot;=&quot; +result);\t\t//分子分母都是int,结果为整除后的结果\t\tSystem.out.println(13/5);\t\tSystem.out.println(&quot;13.0/5&quot;+ &quot;=&quot;+ 13.0/5);\t\t//求余数\t\tresult= 13% num2;\t\tSystem.out.println(&quot;13%&quot;+ num2+ &quot;=&quot;+ result);\t\tSystem.out.println(&quot;13.5%5=&quot;+ 13.5%5);\t\t\t\t//x++\t\tint x=4;\t\tint y=(x++)+5;\t\tSystem.out.println(&quot;x=&quot;+ x + &quot;y=&quot;+ y);\t\t//++x\t\tx=4;\t\ty=(++x)+5;\t\tSystem.out.println(&quot;x=&quot;+ x + &quot;y=&quot;+ y);\t\t//x--\t\tx=4;\t\ty=(x--)+5;\t\tSystem.out.println(&quot;x=&quot;+ x + &quot;y=&quot;+ y);\t\t//--x\t\tx=4;\t\ty=(--x)+5;\t\tSystem.out.println(&quot;x=&quot;+ x + &quot;y=&quot;+ y);\t&#125;&#125;\r\n\r\n\r\nimage-20211212165629540\r\n\r\n\r\n\r\nimage-20211213100406185\r\n\r\n\tint x=2,y=4;\tboolean m;\tm=++x&gt;y--;\t\tSystem.out.println(&quot;&quot;+m+x+y);&#125;\r\n赋值运算符\r\n\r\n\r\nimage-20211212164843348\r\n\r\n关系运算符\r\n\r\n\r\nimage-20211212165844962\r\n\r\n\r\nif条件结构\r\n\r\n\r\nimage-20211213092908988\r\n\r\npackage com.kuroneko;public class ConditionDemo1 &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 商场打折,如果两件商品的总价大于100则减20,\t\t * 并把原价和折后价格分别输出。\t\t */\t\t//定义两个变量，分别存放两件衣服的价格\t\tdouble price1,price2;\t\tprice1=80;\t\tprice2=55;\t\t//计算两件商品的总价格\t\tdouble sum=price1+price2;\t\t//原价\t\tSystem.out.println(&quot;原价为&quot;+sum);\t\tif(sum&gt;=100) &#123;\t\t\tsum-=20;\t\t&#125;\t\tSystem.out.println(&quot;折后价格为&quot;+sum);\t&#125;&#125;\r\nif-else条件结构\r\n如果if或else语句后面只有一条语句,可以不加大括号,否者必须加大括号\r\n\r\n\r\nimage-20211213094419523\r\n\r\npackage com.kuroneko;import java.util.Scanner;public class ConditionDemo2 &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 判断一个整数是奇数还是偶数，并将结果打印输出\t\t */\t\t//从键盘接收数据\t\tSystem.out.println(&quot;请输入一个整数:&quot;);\t\tScanner s=new Scanner(System.in);\t\tint n=s.nextInt();\t\tif(n%2==0) &#123;\t\t\tSystem.out.println(n+&quot;是偶数！&quot;);\t\t&#125;else &#123;\t\t\tSystem.out.println(n+&quot;是奇数！&quot;);\t\t&#125;\t&#125;&#125;\r\n\r\n逻辑运算符\r\n\r\n\r\nimage-20211213101955938\r\n\r\n\r\n\r\nimage-20211213102249513\r\n\r\n\r\n\r\nimage-20211213102432480\r\n\r\n\r\n\r\nimage-20211213102730606\r\n\r\nb=false,n=4\r\n\r\n\r\nimage-20211213103057128\r\n\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\tint i=4,j=5,k=9,m=5;\t\tif(i&gt;j &amp;&amp; m&lt;k++) &#123;\t\t\tk++;\t\t&#125;else &#123;\t\t\tk--;\t\t&#125;\t\tSystem.out.println(k);\t&#125;&#125;\r\npublic class Exercise2 &#123;\tpublic static void main(String[] args) &#123;\t\tint i=9,j=8,k=6,m=10;\t\tif(!(i&gt;j) &amp;&amp; m&lt;k++) &#123;\t\t\tk--;\t\t&#125;else &#123;\t\t\tk++;\t\t&#125;\t\tSystem.out.println(k);\t&#125;&#125;\r\n&amp;&amp;\r\n运算符是短路运算符,如果第一个表达式为false，结果为false,运算符右边的表达式就不再计算了。即只要有一个操作数为false结果为false。\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\tchar f=&#x27;f&#x27;;\t\tif(f&gt;= &#x27;a&#x27;&amp;&amp; f&lt;=&#x27;z&#x27;) &#123;\t\t\tSystem.out.println(&quot;f是a到z之间的字符&quot;);\t\t&#125;else &#123;\t\t\tSystem.out.println(&quot;f不是是a到z之间的字符&quot;);\t\t&#125;\t&#125;&#125;\r\n\r\n\r\nimage-20211213104438743\r\n\r\n|运算符只要有一个为true结果为true\r\n\r\n\r\nimage-20211213104737163\r\n\r\n\r\n\r\nimage-20211213104939633\r\n\r\n||运算符也是短路运算符，如果第一个表达式的值为true，结果为true，运算符右边的表达式就不再计算了。\r\npublic class Exercise &#123;\tpublic static void main(String[] args) &#123;\t\tint i = 4, j = 5, k = 9, m = 5;\t\tif (i &gt; j || m &lt; k) &#123;\t\t\tk++;\t\t&#125; else &#123;\t\t\tk--;\t\t&#125;\t\tSystem.out.println(k);\t&#125;&#125;\r\n\r\n\r\nimage-20211213105330881\r\n\r\n条件运算符（三目运算符）\r\n语法：\r\n布尔表达式？表达式1：表达式2\r\n当布尔表达式的值为true，则返回表达式1的值，否者返回表达式2的值。\r\npackage com.kuroneko.operator;public class ConditionDemo &#123;\tpublic static void main(String[] args) &#123;\t\tint a=4,b=7;\t\t//求a和b的最大值\t\tint max;\t\tif(a&gt;b) &#123;\t\t\tmax=a;\t\t&#125;&#123;\t\t\tmax=b;\t\t&#125;\t\tSystem.out.println(&quot;max=&quot;+ max);\t\t//三目运算符\t\tmax=a&gt;b?a:b;\t\tSystem.out.println(&quot;max=&quot;+ max);\t&#125;&#125;\r\n运算符的优先级\r\n\r\n\r\nimage-20211213121342271\r\n\r\n位运算符\r\n闰年问题\r\n用if-else判断输入的年份是否为闰年\r\n闰年的判断规则：能被4整除但不能被100整除的年份，或者能被400整除的年份\r\npackage com.kuroneko.operator;import java.util.Scanner;public class LeapYearDemo &#123;\tpublic static void main(String[] args) &#123;\t\tSystem.out.print(&quot;请输入年份:&quot;);\t\tScanner sc=new Scanner(System.in);\t\tint year=sc.nextInt();\t\t//闰年的判断规则：能被4整除但不能被100整除的年份，或者能被400整除的年份\t\tif(((year%4==0) &amp; (year%100!=0))|(year%400==0)) &#123;\t\t\tSystem.out.print(year+&quot;是闰年！&quot;);\t\t&#125;else &#123;\t\t\tSystem.out.print(year+&quot;不是闰年！&quot;);\t\t&#125;\t&#125;&#125;\r\n流程控制\r\n流程控制语句:\r\n顺序,选择,循环\r\n多重if\r\n\r\n\r\nimage-20211213130750749\r\n\r\n案例\r\n编写一个程序,根据考试成绩,输出相应的评定信息\r\n成绩&gt;=90,优\r\n成绩[80,90),良\r\n成绩[60,80),中\r\n成绩&lt;60,不及格\r\npackage com.kuroneko.flow;import java.util.Scanner;public class ScoreAssess &#123;\tpublic static void main(String[] args) &#123;\t\t/**\t\t * 编写一个程序,根据考试成绩,输出相应的评定信息\t\t * 成绩&gt;=90,优\t\t * 成绩[80,90),良\t\t * 成绩[60,80),中\t\t * 成绩&lt;60,不及格\t\t */\t\tSystem.out.println(&quot;请输入成绩:&quot;);\t\tScanner sc=new Scanner(System.in);\t\tint score=sc.nextInt();\t\tif(score&gt;=90) \t\t\tSystem.out.println(&quot;优&quot;);\t\telse if(score&gt;=80)\t\t\tSystem.out.println(&quot;良&quot;);\t\telse if(score&gt;=60)\t\t\tSystem.out.println(&quot;中&quot;);\t\telse\t\t\tSystem.out.println(&quot;不及格&quot;);\t\t\t\t\t&#125;&#125;\r\n嵌套if结构\r\n将整个if快插入到另一个if块中\r\n\r\n\r\nimage-20211213132552811\r\n\r\n案例\r\n从键盘输入两个整数,经过判断输出他们的关系(&gt;,&lt;,=)\r\npackage com.kuroneko.flow;import java.util.Scanner;public class IntCompare &#123;\tpublic static void main(String[] args) &#123;\t\tScanner sc=new Scanner(System.in);\t\tSystem.out.println(&quot;请输入x:&quot;);\t\tint x=sc.nextInt();\t\tSystem.out.println(&quot;请输入y:&quot;);\t\tint y=sc.nextInt();\t\tif(x!=y) &#123;\t\t\tif(x&gt;y) &#123;\t\t\t\tSystem.out.println(x+&quot;大于&quot;+y);\t\t\t&#125;else &#123;\t\t\t\tSystem.out.println(x+&quot;小于&quot;+y);\t\t\t&#125;\t\t&#125;else &#123;\t\t\tSystem.out.println(x+&quot;和&quot;+y+&quot;相等&quot;);\t\t&#125;\t&#125;&#125;\r\nswitch结构\r\n\r\n\r\nimage-20211213134320653\r\n\r\n\r\n\r\nimage-20211213134425806\r\n\r\n案例\r\n从键盘输入1-7之间的任意数字,分别输出对应信息\r\n1一星期一 2一星期二 3一星期三 4一星期四 5一星期五 6一星期六\r\n7一星期日\r\npackage com.kuroneko.flow;import java.util.Scanner;public class WeekDemo1 &#123;\t/**\t * 从键盘输入1-7之间的任意数字,分别输出对应信息 1一星期一 2一星期二 3一星期三 4一星期四 5一星期五 6一星期六 7一星期日\t */\tpublic static void main(String[] args) &#123;\t\tScanner sc = new Scanner(System.in);\t\tSystem.out.println(&quot;请输入1-7之间的数字:&quot;);\t\tint n = sc.nextInt();\t\tswitch (n) &#123;\t\tcase 1:\t\t\tSystem.out.println(&quot;星期一&quot;);\t\t\tbreak;\t\tcase 2:\t\t\tSystem.out.println(&quot;星期二&quot;);\t\t\tbreak;\t\tcase 3:\t\t\tSystem.out.println(&quot;星期三&quot;);\t\t\tbreak;\t\tcase 4:\t\t\tSystem.out.println(&quot;星期四&quot;);\t\t\tbreak;\t\tcase 5:\t\t\tSystem.out.println(&quot;星期五&quot;);\t\t\tbreak;\t\tcase 6:\t\t\tSystem.out.println(&quot;星期六&quot;);\t\t\tbreak;\t\tcase 7:\t\t\tSystem.out.println(&quot;星期日&quot;);\t\tdefault:\t\t\tSystem.out.println(&quot;该数字不是1-7的范围!&quot;);\t\t&#125;\t&#125;&#125;\r\ntoUppercase();\r\npackage com.kuroneko.flow;import java.util.Scanner;public class WeekDemo2 &#123;\tpublic static void main(String[] args) &#123;\t\tScanner sc = new Scanner(System.in);\t\tSystem.out.println(&quot;请输入表示星期的英文单词:&quot;);\t\tString week = sc.next();\t\tweek=week.toUpperCase();//把字符串中的字符全部改为大写\t\tswitch (week) &#123;\t\tcase &quot;MONDAY&quot;:\t\t\tSystem.out.println(&quot;星期一&quot;);\t\t\tbreak;\t\tcase &quot;TUESDAY&quot;:\t\t\tSystem.out.println(&quot;星期二&quot;);\t\t\tbreak;\t\tcase &quot;WEDNESDAY&quot;:\t\t\tSystem.out.println(&quot;星期三&quot;);\t\t\tbreak;\t\tcase &quot;THURSDAY&quot;:\t\t\tSystem.out.println(&quot;星期四&quot;);\t\t\tbreak;\t\tcase &quot;FRIDAY&quot;:\t\t\tSystem.out.println(&quot;星期五&quot;);\t\t\tbreak;\t\tcase &quot;SATURDAY&quot;:\t\t\tSystem.out.println(&quot;星期六&quot;);\t\t\tbreak;\t\tcase &quot;SUANDAY&quot;:\t\t\tSystem.out.println(&quot;星期日&quot;);\t\tdefault:\t\t\tSystem.out.println(&quot;单词输入错误!&quot;);\t\t&#125;\t&#125;&#125;\r\n","tags":["java"]},{"title":"JavaScript","url":"/2025/03/10/JavaScript/","content":"概述\r\n\r\n起源于1995年，主要用于处理网页中的前端验证。\r\n\r\nNetscape 与 Sun Microsystems（Java 的拥有者）合作后，将其正式命名为\r\nJavaScript。\r\n这一命名主要是出于营销考虑，借用了当时非常流行的\r\nJava 语言的热度，尽管两者语法和设计思想并不相同。\r\n\r\n\r\n\r\n\r\nimage-20250310180910726\r\n\r\nJavaScript基本数据类型学习笔记\r\n📚\r\n1. 字符串（String）- 存储文字\r\n// 创建字符串的方式let name = &quot;小明&quot;; let greeting = 欢迎$&#123;name&#125;; // 反引号（可以插入变量）// 常用操作let str = &quot;Hello World&quot;;str.length; // 获取长度：11str.toUpperCase(); // 转大写：HELLO WORLD\r\n2. 数字（Number）- 用于计算\r\n// 数学运算let sum = 10 + 5;                    // 加法：15let product = 10 * 5;                // 乘法：50// js中可以标识的数字的最大值,超过这个数会返回InfinityNumber.MAX_VALUE // 1.7976931348623157e+308let a = &quot;abc&quot; * &quot;bcd&quot; //NaN即not a number\r\n3. 布尔值（Boolean）- 表示是或否\r\n// 常见用法let age = 18;let canVote = age &gt;= 18;             // true\r\n4. Undefined - 未定义类型\r\n// 变量声明但未赋值时的默认值let a;console.log(a);         // undefinedconsole.log(typeof a);  // &quot;undefined&quot;// 访问对象不存在的属性let obj = &#123;&#125;;console.log(obj.name);  // undefined\r\n5. Null - 空值类型\r\n// 表示&quot;空&quot;或&quot;不存在&quot;let empty = null;console.log(typeof empty);  // &quot;object&quot;（这是JavaScript的一个历史遗留bug）// 常见用法let user = null;        // 表示用户不存在let data = null;        // 表示数据为空// null和undefined的区别console.log(null == undefined);   // true（值相等）console.log(null === undefined);  // false（类型不同）\r\n注意： 1. undefined是一个变量未被赋值时的默认值 2.\r\nnull是一个表示”空”或”不存在”的特殊值，需要手动赋值 3. 虽然typeof\r\nnull返回”object”，但这是JavaScript的一个已知bug，null确实是一个基本数据类型\r\n对象（Object）- 存储相关信息📚\r\n一、对象的分类\r\nJavaScript中的对象可以分为三类： 1. 内建对象（Built-in Objects） 2.\r\n宿主对象（Host Objects） 3. 自定义对象（Custom Objects）\r\n1. 内建对象（Built-in Objects）\r\n这些对象是JavaScript语言标准的一部分，在任何JavaScript环境中都可用。\r\n// 1. 基本包装类型let str = new String(&quot;Hello&quot;);      // 字符串对象let num = new Number(123);          // 数字对象let bool = new Boolean(true);       // 布尔对象// 2. 引用类型let obj = new Object();             // 对象let arr = new Array(1, 2, 3);       // 数组let date = new Date();              // 日期let reg = new RegExp(&quot;\\\\d+&quot;);       // 正则表达式// 3. 错误类型let error = new Error(&quot;出错了&quot;);     // 错误对象let syntaxError = new SyntaxError(); // 语法错误let typeError = new TypeError();     // 类型错误// 4. 全局对象Math.PI;                            // 数学对象（不需要new）JSON.stringify(&#123;name: &quot;张三&quot;&#125;);      // JSON对象（不需要new）\r\n2. 宿主对象（Host Objects）\r\n这些对象由JavaScript的运行环境提供，比如浏览器或Node.js。\r\n// 浏览器环境的宿主对象window                              // 全局对象document                            // 文档对象console                             // 控制台对象history                             // 历史对象location                            // 地址栏对象localStorage                        // 本地存储对象// DOM对象document.getElementById(&quot;myId&quot;)      // 元素对象document.createElement(&quot;div&quot;)        // 创建DOM元素document.querySelector(&quot;.myClass&quot;)   // 选择器// BOM对象window.innerHeight                   // 窗口高度window.localStorage                  // 本地存储window.navigator                     // 浏览器信息// Node.js环境的宿主对象process                             // 进程对象Buffer                              // 二进制数据对象require                             // 模块加载\r\n3. 自定义对象（Custom Objects）\r\n3.1 创建对象\r\n// 1. 对象字面量（最常用）const person = &#123;    name: &quot;张三&quot;,    age: 25&#125;;// 2. 构造函数function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;const person2 = new Person(&quot;李四&quot;, 30);// 3. Object.create()const person3 = Object.create(Object.prototype, &#123;    name: &#123;        value: &quot;王五&quot;,        writable: true,        enumerable: true,        configurable: true    &#125;,    age: &#123;        value: 35,        writable: true,        enumerable: true,        configurable: true    &#125;&#125;);\r\n3.2 访问和修改属性\r\n// 1. 点号表示法const user = &#123;    name: &quot;张三&quot;,    age: 25&#125;;console.log(user.name);      // &quot;张三&quot;user.age = 26;              // 修改属性user.email = &quot;zhang@example.com&quot;;  // 添加新属性// 2. 方括号表示法console.log(user[&quot;name&quot;]);   // &quot;张三&quot;user[&quot;age&quot;] = 27;           // 修改属性// 3. 使用变量作为属性名const propertyName = &quot;name&quot;;console.log(user[propertyName]);  // &quot;张三&quot;// 4. 删除属性delete user.email;\r\n3.3 检查属性\r\nconst person = &#123;    name: &quot;张三&quot;,    age: 25&#125;;// 1. 检查属性是否存在console.log(&quot;name&quot; in person);              // trueconsole.log(person.hasOwnProperty(&quot;age&quot;));  // true// 2. 检查可枚举性console.log(Object.keys(person));           // [&quot;name&quot;, &quot;age&quot;]console.log(Object.values(person));         // [&quot;张三&quot;, 25]console.log(Object.entries(person));        // [[&quot;name&quot;,&quot;张三&quot;], [&quot;age&quot;,25]]// 3. 获取属性描述符console.log(Object.getOwnPropertyDescriptor(person, &quot;name&quot;));// &#123;value: &quot;张三&quot;, writable: true, enumerable: true, configurable: true&#125;\r\n3.4 遍历对象\r\nconst person = &#123;    name: &quot;张三&quot;,    age: 25,    city: &quot;北京&quot;&#125;;// 1. for...in 循环for (let key in person) &#123;    console.log(`$&#123;key&#125;: $&#123;person[key]&#125;`);&#125;// 2. Object.keys()Object.keys(person).forEach(key =&gt; &#123;    console.log(`$&#123;key&#125;: $&#123;person[key]&#125;`);&#125;);// 3. Object.entries()for (let [key, value] of Object.entries(person)) &#123;    console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;\r\n3.5 对象的高级操作\r\n// 1. 对象合并const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; c: 3, d: 4 &#125;;const merged = Object.assign(&#123;&#125;, obj1, obj2);// 或使用展开运算符const merged2 = &#123; ...obj1, ...obj2 &#125;;// 2. 对象冻结（不可修改）const frozen = Object.freeze(person);frozen.name = &quot;李四&quot;;  // 严格模式下会报错，非严格模式下静默失败// 3. 对象密封（可修改但不可添加/删除）const sealed = Object.seal(person);sealed.age = 26;      // 可以修改现有属性sealed.email = &quot;zhang@example.com&quot;;  // 无法添加新属性// 4. 定义属性Object.defineProperty(person, &quot;fullName&quot;, &#123;    get() &#123;        return `$&#123;this.name&#125;`;    &#125;,    set(value) &#123;        [this.name] = value.split(&quot; &quot;);    &#125;,    enumerable: true,    configurable: true&#125;);\r\n3.6 对象的常见操作最佳实践\r\n\r\n创建对象 // 推荐：使用对象字面量const user = &#123;    name: &quot;张三&quot;,    sayHi() &#123;        console.log(`你好，$&#123;this.name&#125;`);    &#125;&#125;;// 需要多个实例时使用类class User &#123;    constructor(name) &#123;        this.name = name;    &#125;    sayHi() &#123;        console.log(`你好，$&#123;this.name&#125;`);    &#125;&#125;\r\n属性操作 // 推荐：使用点号表示法（当属性名确定时）user.name = &quot;李四&quot;;// 使用方括号表示法（当属性名是变量或包含特殊字符时）const prop = &quot;name&quot;;user[prop] = &quot;王五&quot;;// 批量更新属性Object.assign(user, &#123;    age: 25,    city: &quot;北京&quot;&#125;);\r\n安全的属性访问 // 使用可选链操作符const street = user.address?.street;// 使用默认值const age = user.age ?? 18;// 防止属性被修改Object.freeze(user);  // 完全冻结Object.seal(user);    // 允许修改现有属性\r\n\r\n注意事项： 1. 优先使用点号表示法，更清晰直观 2.\r\n使用const声明对象，防止意外重新赋值 3. 使用解构赋值简化属性访问 4.\r\n使用Object.keys()等方法进行属性遍历\r\nJavaScript运算📚\r\n1. 检查数据类型\r\n// 使用typeoftypeof &quot;Hello&quot; // &quot;string&quot;typeof 123 // &quot;number&quot;typeof true // &quot;boolean&quot;typeof [] // &quot;object&quot;\r\n2. 类型转换\r\n// 1. 转换为字符串（String）// 方法一：String()函数String(123);              // &quot;123&quot;String(true);            // &quot;true&quot;String(null);           // &quot;null&quot;String(undefined);      // &quot;undefined&quot;// 方法二：toString()方法，null和undefined没有该方法(123).toString();        // &quot;123&quot;true.toString();        // &quot;true&quot;// 方法三：加空字符串123 + &#x27;&#x27;;               // &quot;123&quot;true + &#x27;&#x27;;             // &quot;true&quot;// 2. 转换为数字（Number）// 方法一：Number()函数Number(&quot;123&quot;);          // 123Number(&quot;12.34&quot;);       // 12.34Number(&quot;&quot;);            // 0Number(&quot;abc&quot;);         // NaNNumber(true);          // 1Number(false);         // 0Number(null);          // 0Number(undefined);     // NaN// 方法二：parseInt()和parseFloat()，第二个参数可以设置进制parseInt(true);       // NaN 对于非String类型会首先转换为String然后再去解析parseInt(&quot;123px456&quot;);       // 123parseInt(&quot;12.34&quot;);     // 12（只取整数部分）parseFloat(&quot;12.34px567&quot;);   // 12.34// 方法三：使用+号+&quot;123&quot;;               // 123+&quot;12.34&quot;;            // 12.341 + + &quot;2&quot; + 3\t\t\t\t\t// 结果：6（变成数字）\t// 方法司：使用-号&quot;123&quot;-0             //123// 3. 转换为布尔值（Boolean）// 方法一：Boolean()函数Boolean(&quot;&quot;);           // falseBoolean(&quot;hello&quot;);     // trueBoolean(0);           // falseBoolean(1);           // trueBoolean(null);        // falseBoolean(undefined);   // falseBoolean(&#123;&#125;);          // trueBoolean([]);          // true// 方法二：使用!!!!&quot;hello&quot;;           // true!!0;                 // false// 4. 自动类型转换（隐式转换）&quot;5&quot; + 2;             // &quot;52&quot;（字符串拼接）&quot;5&quot; - 2;             // 3（数字运算）&quot;5&quot; * &quot;2&quot;;           // 10（数字运算）true + 1;            // 2（true转换为1）false + 1;           // 1（false转换为0）\r\n类型转换规则总结：\r\n\r\n转换为字符串：\r\n\r\nnull → “null”\r\nundefined → “undefined”\r\ntrue → “true”\r\nfalse → “false”\r\n数字 → 数字的字符串形式\r\n对象 → “[object Object]”\r\n\r\n转换为数字：\r\n\r\n空字符串 → 0\r\n非空字符串 → 如果可以解析为数字则转换，否则NaN\r\ntrue → 1\r\nfalse → 0\r\nnull → 0\r\nundefined → NaN\r\n对象 → 先转换为原始值，再转换为数字\r\n\r\n转换为布尔值： 以下值转换为false：\r\n\r\n空字符串 “”\r\n数字 0\r\nnull\r\nundefined\r\nNaN 其他所有值都转换为true\r\n\r\n\r\n最佳实践\r\n\r\n尽量使用显式转换（如String()、Number()、Boolean()）\r\n避免依赖隐式转换\r\n使用===而不是==，避免类型转换带来的问题\r\n在进行数学运算前，确保操作数都是数字类型\r\n\r\n3. 自增运算符（++）\r\n// 1. 前置自增（++a）：先自增，再使用let a = 1;let b = ++a;    // a先加1，再赋值给bconsole.log(a); // 2console.log(b); // 2// 2. 后置自增（a++）：先使用，再自增let x = 1;let y = x++;    // 先将x的值赋给y，再将x加1console.log(x); // 2console.log(y); // 1// 在表达式中的区别let num1 = 5;let num2 = 5;let d=10;console.log(++num1 * 2); // 12 (先自增到6，再乘2)console.log(num2++ * 2); // 10 (先乘2，再自增到6)console.log(d++ + ++d +d) //34// 让我们一步步分解这个表达式：// 1. d++ + ++d + d//    - d++ 是后置自增：先使用d的值(10)，然后d变成11//    - ++d 是前置自增：先将d加1变成12，再使用12//    - 最后的d 直接使用当前值12// 所以计算过程是：10 + 12 + 12 = 34let d = 10;d = d++;console.log(d);    // 结果：10// 让我们分析这个过程：// 1. d = d++//    - d++ 是后置自增，会先返回原始值10//    - 然后d会增加到11//    - 但是这个11还没有被使用，d就被赋值了//    - 赋值运算符=会将d++返回的原始值10赋给d//    - 所以最终d的值仍然是10\r\n区别总结： 1. ++a（前置自增）： - 先将a加1 - 再返回加1后的值 -\r\n常用于：需要立即使用增加后的值时\r\n\r\na++（后置自增）：\r\n\r\n先返回原始值\r\n再将a加1\r\n常用于：需要在使用当前值后再增加时\r\n\r\n\r\n最佳实践： 1. 单独使用时，++a 和 a++ 效果相同 2.\r\n在表达式中使用时要特别注意前置和后置的区别\r\n4. 逻辑运算符（&amp;&amp;, ||, !）\r\n// 1. 逻辑与 (&amp;&amp;)let result = 1 &amp;&amp; 2;    // 结果：2let test1 = 0 &amp;&amp; 1;    // 结果：0let test2 = false &amp;&amp; &quot;hello&quot;;  // 结果：false// 2. 逻辑或 (||)let name = &quot;&quot; || &quot;匿名&quot;;  // 结果：&quot;匿名&quot;let num = 0 || 42;      // 结果：42// 3. 逻辑非 (!)let bool = !true;       // 结果：falselet notZero = !0;       // 结果：true// 假值（Falsy）包括：// - false// - 0// - &quot;&quot;（空字符串）// - null// - undefined// - NaN// 其他所有值都是真值（Truthy）\r\n常见用途： 1. 短路求值 // 设置默认值：如果userInput为空，则使用&quot;游客&quot;作为默认值let userName = userInput || &quot;游客&quot;;// 条件执行:isLoggedIn为真时执行showUserProfile()isLoggedIn &amp;&amp; showUserProfile();\r\n\r\n条件判断 // 检查对象属性是否存在let user = &#123;name: &quot;小明&quot;&#125;;let hasAge = user &amp;&amp; user.age;  // undefined// 多重条件let isValid = age &gt; 18 &amp;&amp; hasPermission &amp;&amp; !isBlocked;\r\n\r\n最佳实践： 1. 理解逻辑运算符返回的是值，不一定是布尔类型 2. 使用\r\n&amp;&amp; 进行条件判断时要注意短路特性 3. 使用 ||\r\n设置默认值是一种常见模式 4. 使用括号明确运算优先级\r\n1.逻辑运算符优先级和执行顺序\r\nlet result = 1 || 2 &amp;&amp; 3;    // 结果：1// 运算符优先级：// 1. &amp;&amp; 优先级高于 ||// 2. 从左到右执行// 分解执行过程：// 1 || 2 &amp;&amp; 3//    - 先计算 2 &amp;&amp; 3（因为&amp;&amp;优先级更高）//    - 2 &amp;&amp; 3 的结果是 3（因为2是真值）//    - 现在表达式变成：1 || 3//    - 1是真值，所以直接返回1，不再计算后面的内容\r\n5. 比较运算符（&gt;, &lt;, &gt;=, &lt;=, ==,\r\n===）\r\n// NaN的比较true &gt; NaN;            // false1 &gt; NaN;              // falseNaN &gt; NaN;            // falseNaN == NaN;           // false// 特点：任何值和NaN比较都返回false，包括NaN自身undefined &gt; 0;        // falseundefined &lt; 0;        // falseundefined == 0;       // false// 特点：undefined和数字比较时转换为NaNnull &gt; 0;             // falsenull == 0;            // falsenull &gt;= 0;            // true// 特点：null在比较时会转换为数字0，但==比较时有特殊规则// 字符串比较&quot;11&quot; &gt; &quot;2&quot;;           // false&quot;abc&quot; &gt; &quot;abb&quot;;        // true// 特点：按字符编码逐位比较// 例如：&quot;11&quot; &gt; &quot;2&quot; 比较过程：// - 比较第一位：&quot;1&quot;的编码（49）&lt; &quot;2&quot;的编码（50）// - 所以整体结果为false，不再比较后续位置// 不同类型比较&quot;23&quot; &gt; 22;            // true（字符串&quot;23&quot;会转换为数字23）&quot;abc&quot; &gt; 1;            // false（&quot;abc&quot;转换为数字是NaN）true &gt; 0;             // true（true转换为数字1）false &lt; 1;            // true（false转换为数字0）\r\n6.\r\n相等运算符（==）和全等运算符（===）\r\n// 1. 全等运算符（===）// - 比较值和类型都要相同5 === 5;              // true5 === &quot;5&quot;;           // false（类型不同）null === undefined;   // false（类型不同）NaN === NaN;         // false（NaN不等于任何值，包括自身,可以通过isNaN()判断是否是NaN）// 2. 相等运算符（==）// - 会进行类型转换后比较5 == &quot;5&quot;;            // true（字符串&quot;5&quot;会转换为数字5）true == 1;           // true（true转换为数字1）false == 0;          // true（false转换为数字0）null == undefined;   // true（特殊规则：undefined是null衍生过来的）// 3.2 布尔值和其他类型true == 1;           // true（布尔值转换为数字）false == &quot;&quot;;         // true（都转换为数字0）false == [];         // true（[]转换为数字0）// 3.3 数字和字符串1 == &quot;1&quot;;            // true（字符串转换为数字）1 == &quot;one&quot;;          // false（&quot;one&quot;转换为NaN）// 3.4 对象和原始类型[1] == 1;            // true（[1]转换为&quot;1&quot;，然后转换为数字1）[&quot;1&quot;] == 1;          // true（同上）[1,2] == &quot;1,2&quot;;      // true（数组转换为字符串后比较）\r\n==的类型转换规则总结：\r\n\r\nnull和undefined：\r\n\r\nnull == undefined 返回 true\r\nnull和undefined与其他值比较都返回false\r\n\r\n布尔值参与比较：\r\n\r\n布尔值先转换为数字（true→1，false→0）\r\n然后再和另一个操作数比较\r\n\r\n数字和字符串比较：\r\n\r\n字符串转换为数字\r\n如果转换失败则变成NaN\r\n\r\n对象和原始类型比较：\r\n\r\n对象先调用valueOf()或toString()转换为原始类型\r\n然后按照上述规则进行比较\r\n\r\n\r\nJavaScript流程控制学习笔记 📚\r\n一、什么是流程控制？\r\n流程控制是程序中的决策和循环结构，就像生活中的： -\r\n如果下雨，就带伞（条件判断） - 每天刷三次牙（循环） -\r\n选择去看电影还是打游戏（分支结构）\r\n二、条件判断语句\r\n1. if语句 - 单一条件判断\r\n// 基本语法if (条件) &#123;    // 条件为真时执行的代码&#125;// 示例let age = 18;if (age &gt;= 18) &#123;    console.log(&quot;已成年&quot;);&#125;\r\n2. if…else语句 -\r\n两种情况的判断\r\n// 基本语法if (条件) &#123;    // 条件为真时执行的代码&#125; else &#123;    // 条件为假时执行的代码&#125;// 示例let score = 85;if (score &gt;= 60) &#123;    console.log(&quot;及格&quot;);&#125; else &#123;    console.log(&quot;不及格&quot;);&#125;\r\n3. if…else if…else语句 -\r\n多种情况的判断\r\n// 基本语法if (条件1) &#123;    // 条件1为真时执行的代码&#125; else if (条件2) &#123;    // 条件2为真时执行的代码&#125; else &#123;    // 所有条件都为假时执行的代码&#125;// 示例：成绩等级判断let score = 85;if (score &gt;= 90) &#123;    console.log(&quot;优秀&quot;);&#125; else if (score &gt;= 70) &#123;    console.log(&quot;良好&quot;);&#125; else if (score &gt;= 60) &#123;    console.log(&quot;及格&quot;);&#125; else &#123;    console.log(&quot;不及格&quot;);&#125;\r\n4. switch语句 - 多分支选择\r\nlet username, password;username = prompt(&quot;请输入用户名：&quot;);password = prompt(&quot;请输入密码：&quot;);switch (true) &#123;   case !username:         console.log(&quot;用户名不能为空！&quot;);         break;   case !password:         console.log(&quot;密码不能为空！&quot;);         break;   case username === &quot;admin&quot; &amp;&amp; password === &quot;123456&quot;:         console.log(&quot;登录成功！&quot;);         break;   default:         console.log(&quot;用户名或密码错误！&quot;);&#125;\r\n三、循环语句\r\n1. for循环 - 明确循环次数\r\n// 基本语法for (初始化; 条件; 更新) &#123;    // 循环体&#125;// 遍历数组let fruits = [&quot;苹果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;];for (let i = 0; i &lt; fruits.length; i++) &#123;    console.log(fruits[i]);&#125;\r\n2. while循环 - 不确定循环次数\r\n// 基本语法while (条件) &#123;    // 循环体&#125;// 示例：猜数字游戏let target = 7;let guess = 0;while (guess !== target) &#123;    guess = parseInt(prompt(&quot;猜一个数字：&quot;));&#125;\r\n3. do…while循环 - 至少执行一次\r\n// 基本语法do &#123;    // 循环体&#125; while (条件);// 示例：至少说一次你好let count = 0;do &#123;    console.log(&quot;你好！&quot;);    count++;&#125; while (count &lt; 3);\r\n4. for…in循环 - 遍历对象属性\r\n// 用于遍历对象的属性let person = &#123;    name: &quot;小明&quot;,    age: 18,    city: &quot;北京&quot;&#125;;for (let key in person) &#123;    console.log(key + &quot;: &quot; + person[key]);&#125;\r\n5. for…of循环 - 遍历可迭代对象\r\n// 用于遍历数组、字符串等可迭代对象let colors = [&quot;红&quot;, &quot;绿&quot;, &quot;蓝&quot;];for (let color of colors) &#123;    console.log(color);&#125;\r\n四、跳转语句\r\n1. break - 跳出循环\r\n// 示例：找到数字5就停止for (let i = 1; i &lt;= 10; i++) &#123;    if (i === 5) &#123;        break;    &#125;    console.log(i);&#125;\r\n2. continue - 跳过本次循环\r\n// 示例：跳过偶数for (let i = 1; i &lt;= 5; i++) &#123;    if (i % 2 === 0) &#123;        continue;    &#125;    console.log(i);  // 输出1,3,5&#125;\r\n3. label -\r\n跳出或继续到特定的代码块\r\n五、最佳实践\r\n循环选择： - 知道循环次数用for - 不知道循环次数用while -\r\n遍历对象属性用for…in - 遍历数组元素用for…of\r\n六、练习题\r\n\r\n基础练习：打印九九乘法表 for (let i = 1; i &lt;= 9; i++) &#123;    let row = &#x27;&#x27;;    for (let j = 1; j &lt;= i; j++) &#123;        row += `$&#123;j&#125; * $&#123;i&#125; = $&#123;i * j&#125;\\t`;    &#125;    console.log(row);&#125;\r\n进阶练习：判断是否是质数 //如果一个数 num 能被某个大于其平方根的数整除，那么它一定也能被一个小于或等于其平方根的数整除。因此，只需要检查到 Math.sqrt(num) 即可。比如36：2*18,3*12,4*9,6*6 只要检查到小于等于根号下36的数即可。function isPrime(num) &#123;    if (num &lt;= 1) return false;    for (let i = 2; i &lt;= Math.sqrt(num); i++) &#123;        if (num % i === 0) return false;    &#125;    return true;&#125;//逐一检查 num 是否能被 [2, num - 1] 中的任何数整除。如果能整除，则返回 false。function isPrime2(num) &#123;    if (num &lt;= 1) return false;    for (let i=2;i&lt;num; i++) &#123;         if (num % i === 0) return false;    &#125;    return true;&#125;function getPrimes1(num) &#123;   // [2, 100]所有的数   for (let i = 2; i &lt;=num; i++) &#123;      let flag=true;      // [2,i-1]所有的数      for (let j = 2; j &lt; i; j++) &#123;         if (i%j===0) &#123;               flag=false;               break;// 找到一个因数就可以停止了         &#125;      &#125;      if(flag)&#123;         console.log(i);      &#125;   &#125;&#125;\r\n\r\nJavaScript基本数据类型和引用数据类型的深入理解\r\n📚\r\n两种类型的根本区别\r\n1. 存储位置\r\n// 基本类型：存储在栈内存中let a = 10;let b = &quot;hello&quot;;// 引用类型：存储在堆内存中，栈内存存储的是引用地址let obj1 = &#123; name: &quot;张三&quot; &#125;;let arr1 = [1, 2, 3];\r\n2. 赋值操作的区别\r\n// 基本类型：赋值会创建新的副本let a = 10;let b = a;  // b获得了一个新的值10a = 20;     // 修改a不会影响bconsole.log(b);  // 输出：10// 引用类型：赋值会共享引用let obj1 = &#123; name: &quot;张三&quot; &#125;;let obj2 = obj1;  // obj2获得了对同一对象的引用obj1.name = &quot;李四&quot;;  // 通过obj1修改对象console.log(obj2.name);  // 输出：&quot;李四&quot;（obj2也受影响）\r\n3. 比较操作的区别\r\n// 基本类型：比较值let a = 10;let b = 10;console.log(a === b);  // true（值相同）// 引用类型：比较引用地址let obj1 = &#123; name: &quot;张三&quot; &#125;;let obj2 = &#123; name: &quot;张三&quot; &#125;;console.log(obj1 === obj2);  // false（不同对象）\r\n4. 参数传递\r\n// 基本类型：传递值function changeValue(x) &#123;    x = 20;    console.log(&quot;函数内部：&quot;, x);  // 20&#125;let num = 10;changeValue(num);console.log(&quot;函数外部：&quot;, num);  // 10（不受影响）// 引用类型：传递引用function changeObject(obj) &#123;    obj.name = &quot;李四&quot;;    console.log(&quot;函数内部：&quot;, obj.name);  // &quot;李四&quot;&#125;let person = &#123; name: &quot;张三&quot; &#125;;changeObject(person);console.log(&quot;函数外部：&quot;, person.name);  // &quot;李四&quot;（被修改）\r\n三、常见问题和解决方案\r\n1. 引用类型的拷贝\r\n// 1. 浅拷贝// 方法一：Object.assign()let original = &#123; name: &quot;张三&quot;, info: &#123; age: 20 &#125; &#125;;let shallowCopy1 = Object.assign(&#123;&#125;, original);// 方法二：展开运算符let shallowCopy2 = &#123; ...original &#125;;// 2. 深拷贝// 方法一：JSON转换（有局限性）let deepCopy1 = JSON.parse(JSON.stringify(original));// 方法二：递归实现function deepClone(obj) &#123;    if (obj === null || typeof obj !== &#x27;object&#x27;) return obj;    let copy = Array.isArray(obj) ? [] : &#123;&#125;;    for (let key in obj) &#123;        if (obj.hasOwnProperty(key)) &#123;            copy[key] = deepClone(obj[key]);        &#125;    &#125;    return copy;&#125;\r\nJavaScript函数学习笔记 📚\r\n一、函数基础\r\n1. 函数的定义方式\r\n// 1. 函数声明function sayHello(name) &#123;    return &quot;Hello, &quot; + name;&#125;// 2. 函数表达式const sayHello = function(name) &#123;    return &quot;Hello, &quot; + name;&#125;;// 3. 箭头函数（ES6）const sayHello = (name) =&gt; &#123;    return &quot;Hello, &quot; + name;&#125;;// 简写形式const sayHello = name =&gt; &quot;Hello, &quot; + name;// 4. 构造函数（不推荐）const sayHello = new Function(&quot;name&quot;, &quot;return &#x27;Hello, &#x27; + name&quot;);\r\n2. 构造函数\r\n构造函数是用来创建和初始化对象的特殊函数。作为创建具有相同属性和方法的多个对象的模板。\r\n// 基本构造函数function Person(name, age)&#123;    this.name=name;    this.age=age;    this.sayHello=()=&gt;&#123;        console.log(`你好，我是$&#123;this.name&#125;`);    &#125;&#125;// 创建实例new Person(&#x27;张三&#x27;, 18).sayHello();//你好，我是张三\r\n3. new操作符的执行过程\r\nfunction Person(name) &#123;    this.name = name;&#125;// new操作符的执行过程等同于：function createPerson(name) &#123;    // 1. 创建新对象    const obj = &#123;&#125;;        // 2. 设置原型链    Object.setPrototypeOf(obj, Person.prototype);        // 3. 绑定this并执行构造函数    const result = Person.call(obj, name);        // 4. 返回新对象    return typeof result === &#x27;object&#x27; ? result : obj;&#125;\r\n二、构造函数的进阶用法\r\n1. 原型方法\r\n// 1. 在原型上添加方法（推荐）function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;// 添加到原型上的方法会被所有实例共享Person.prototype.sayHello = function() &#123;    console.log(`你好，我是$&#123;this.name&#125;`);&#125;;// 2. 原型方法vs实例方法function Animal(name) &#123;    this.name = name;    // 实例方法：每个实例都会创建一个新的函数副本    this.sayName = function() &#123;        console.log(this.name);    &#125;;&#125;// 原型方法：所有实例共享同一个函数Animal.prototype.sayHello = function() &#123;    console.log(`Hello, $&#123;this.name&#125;`);&#125;;\r\n2. 私有属性和方法\r\n// 1. 使用闭包实现私有属性function Counter() &#123;    // 私有变量    let count = 0;        // 特权方法（可以访问私有变量）    this.increment = function() &#123;        return ++count;    &#125;;        this.getCount = function() &#123;        return count;    &#125;;&#125;// 2. 使用Symbol实现私有属性（ES6+）const privateProperty = Symbol(&#x27;private&#x27;);function MyClass() &#123;    this[privateProperty] = &quot;这是私有的&quot;;&#125;\r\n3. 构造函数的继承\r\n// 1. 原型链继承function Animal(name) &#123;    this.name = name;&#125;Animal.prototype.sayName = function() &#123;    console.log(this.name);&#125;;function Dog(name, breed) &#123;    // 调用父类构造函数    Animal.call(this, name);    this.breed = breed;&#125;// 设置原型链Dog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;// 2. class语法继承（现代方式）class Animal &#123;    constructor(name) &#123;        this.name = name;    &#125;    sayName() &#123;        console.log(this.name);    &#125;&#125;class Dog extends Animal &#123;    constructor(name, breed) &#123;        super(name);        this.breed = breed;    &#125;&#125;\r\n三、构造函数的最佳实践\r\n1. 安全的构造函数\r\nfunction Person(name) &#123;    // 确保使用new调用    if (!(this instanceof Person)) &#123;        return new Person(name);    &#125;    this.name = name;&#125;// 或使用new.targetfunction SafePerson(name) &#123;    if (!new.target) &#123;        return new SafePerson(name);    &#125;    this.name = name;&#125;\r\n4. 立即执行函数表达式（IIFE）\r\n// 1. 基本语法(function() &#123;    console.log(&quot;我会立即执行&quot;);&#125;)();// 2. 带参数的IIFE(function(a, b) &#123;    console.log(a + b);  // 输出：3&#125;)(1, 2);// 3. 返回值的IIFEconst result = (function(a, b) &#123;    return a + b;&#125;)(1, 2);console.log(result);  // 输出：3// 4. 箭头函数形式的IIFE(() =&gt; &#123;    console.log(&quot;箭头函数IIFE&quot;);&#125;)();// 5. 带命名的IIFE（便于调试）(function calculateSum(a, b) &#123;    console.log(a + b);&#125;)(1, 2);\r\n二、函数的高级特性\r\n1. 作用域和闭包\r\n// 1. 词法作用域let globalVar = &quot;全局变量&quot;;function outer() &#123;    let outerVar = &quot;外部变量&quot;;        function inner() &#123;        let innerVar = &quot;内部变量&quot;;        console.log(globalVar, outerVar, innerVar);    &#125;        return inner;&#125;// 2. 闭包示例function counter() &#123;    let count = 0;    return &#123;        increment() &#123; return ++count; &#125;,        decrement() &#123; return --count; &#125;,        getCount() &#123; return count; &#125;    &#125;;&#125;const myCounter = counter();console.log(myCounter.increment()); // 1console.log(myCounter.increment()); // 2\r\n2. this关键字\r\n// 1. 全局上下文console.log(this === window); // 浏览器环境中为true// 2. 对象方法中的thisconst user = &#123;    name: &quot;张三&quot;,    sayHi() &#123;        console.log(`Hi, $&#123;this.name&#125;!`);    &#125;&#125;;// 3. 构造函数中的thisfunction User(name) &#123;    this.name = name;    this.sayHi = function() &#123;        console.log(`Hi, $&#123;this.name&#125;!`);    &#125;;&#125;// 4. 箭头函数中的thisconst obj = &#123;    name: &quot;张三&quot;,    sayHiLater() &#123;        setTimeout(() =&gt; &#123;            console.log(`Hi, $&#123;this.name&#125;!`);        &#125;, 1000);    &#125;&#125;;\r\n3. 函数绑定\r\n// 1. bind方法const user = &#123;    name: &quot;张三&quot;,    sayHi() &#123;        console.log(`Hi, $&#123;this.name&#125;!`);    &#125;&#125;;const sayHi = user.sayHi.bind(user);// 2. call方法function greet(greeting) &#123;    console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;!`);&#125;greet.call(user, &quot;Hello&quot;);// 3. apply方法greet.apply(user, [&quot;Hello&quot;]);\r\n4.arguments\r\n在调用函数时，浏览器每次都会传递两个隐含的参数：\r\n\r\n函数的上下文对象this\r\n封装实参的对象的arguments\r\n\r\nfunction fun()&#123;    // 在调用函数时，会自动传入一个arguments对象，该对象包含了传递的实参。    // arguments对象是一个类数组对象，具有length属性和索引属性，可以遍历。    console.log(arguments.length); //2    console.log(arguments[1]); //true    console.log(arguments.callee === fun); // true callee属性是正在执行的函数的对象&#125;fun(&quot;hello&quot;,true);\r\n三、函数的应用模式\r\n1. 回调函数\r\n// 1. 简单回调function fetchData(callback) &#123;    setTimeout(() =&gt; &#123;        const data = &#123; id: 1, name: &quot;张三&quot; &#125;;        callback(data);    &#125;, 1000);&#125;// 2. 错误优先回调function readFile(path, callback) &#123;    fs.readFile(path, (error, data) =&gt; &#123;        if (error) &#123;            callback(error);            return;        &#125;        callback(null, data);    &#125;);&#125;\r\n2. Promise和async/await\r\n// 1. Promisefunction fetchUserData(id) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            const user = &#123; id, name: &quot;张三&quot; &#125;;            resolve(user);        &#125;, 1000);    &#125;);&#125;// 2. async/awaitasync function getUser(id) &#123;    try &#123;        const user = await fetchUserData(id);        return user;    &#125; catch (error) &#123;        console.error(&quot;获取用户失败:&quot;, error);    &#125;&#125;\r\n3. 函数式编程\r\n// 1. 纯函数function add(a, b) &#123;    return a + b;&#125;// 2. 高阶函数function multiply(factor) &#123;    return function(number) &#123;        return number * factor;    &#125;;&#125;// 3. 函数组合const compose = (...fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x);\r\n四、最佳实践\r\n1. 函数设计原则\r\n// 1. 单一职责function validateEmail(email) &#123;    return /\\S+@\\S+\\.\\S+/.test(email);&#125;// 2. 纯函数设计function calculateTotal(items) &#123;    return items.reduce((total, item) =&gt; total + item.price, 0);&#125;// 3. 参数验证function createUser(userData) &#123;    if (!userData.name) throw new Error(&quot;用户名是必需的&quot;);    if (!userData.email) throw new Error(&quot;邮箱是必需的&quot;);    // ...&#125;\r\n2. 性能优化\r\n// 1. 函数缓存（记忆化）function memoize(fn) &#123;    const cache = new Map();    return function(...args) &#123;        const key = JSON.stringify(args);        if (cache.has(key)) return cache.get(key);        const result = fn.apply(this, args);        cache.set(key, result);        return result;    &#125;;&#125;// 2. 防抖function debounce(fn, delay) &#123;    let timer = null;    return function(...args) &#123;        clearTimeout(timer);        timer = setTimeout(() =&gt; fn.apply(this, args), delay);    &#125;;&#125;// 3. 节流function throttle(fn, limit) &#123;    let inThrottle;    return function(...args) &#123;        if (!inThrottle) &#123;            fn.apply(this, args);            inThrottle = true;            setTimeout(() =&gt; inThrottle = false, limit);        &#125;    &#125;;&#125;\r\n3. 错误处理\r\n// 1. try-catchfunction divide(a, b) &#123;    try &#123;        if (b === 0) throw new Error(&quot;除数不能为0&quot;);        return a / b;    &#125; catch (error) &#123;        console.error(&quot;计算错误:&quot;, error);        return null;    &#125;&#125;// 2. 自定义错误class ValidationError extends Error &#123;    constructor(message) &#123;        super(message);        this.name = &quot;ValidationError&quot;;    &#125;&#125;\r\n记住： 1. 函数名应该是动词或动词短语 2. 保持函数的纯粹性 3.\r\n适当使用注释说明复杂逻辑 4. 避免副作用 5.\r\n控制函数的参数数量（建议不超过3个）\r\nIIFE的使用场景\r\n\r\n避免全局作用域污染 // 不好的做法：污染全局作用域var counter = 0;function increment() &#123;    counter++;&#125;// 好的做法：使用IIFEconst counter = (function() &#123;    let count = 0;  // 私有变量    return &#123;        increment() &#123;            return ++count;        &#125;,        getCount() &#123;            return count;        &#125;    &#125;;&#125;)();console.log(counter.increment());  // 1console.log(counter.getCount());   // 1\r\n创建私有作用域 // 模块模式const myModule = (function() &#123;    // 私有变量和方法    let privateVar = 0;    function privateFunction() &#123;        return privateVar;    &#125;        // 公共API    return &#123;        publicMethod() &#123;            return privateFunction();        &#125;,        publicVar: &quot;我是公共的&quot;    &#125;;&#125;)();\r\n异步操作中保存状态 // 循环中使用IIFEfor (var i = 0; i &lt; 3; i++) &#123;    (function(index) &#123;        setTimeout(() =&gt; &#123;            console.log(index);        &#125;, 1000);    &#125;)(i);&#125;\r\n\r\nIIFE的特点\r\n\r\n语法特征：\r\n\r\n函数表达式被括号包裹\r\n最后有一对执行括号\r\n可以传递参数\r\n\r\n优点：\r\n\r\n创建独立的作用域\r\n避免命名冲突\r\n保护私有变量\r\n模块化代码\r\n\r\n注意事项： // 1. 分号问题// 如果前面的代码没有分号结尾，可能导致错误const a = 1(function() &#123;&#125;)()  // 错误：被解释为函数调用// 正确做法const a = 1;(function() &#123;&#125;)()// 2. 不同的写法// 这些都是有效的IIFE写法(function() &#123;&#125;)();  // 推荐(function() &#123;&#125;());!function() &#123;&#125;();+function() &#123;&#125;();\r\n\r\n现代替代方案\r\n\r\n使用块级作用域 // ES6之前用IIFE(function() &#123;    var temp = &quot;我是临时变量&quot;;    // ...&#125;)();// ES6可以使用块级作用域&#123;    let temp = &quot;我是临时变量&quot;;    // ...&#125;\r\n使用模块 // module.jsexport const counter = &#123;    count: 0,    increment() &#123;        return ++this.count;    &#125;&#125;;// main.jsimport &#123; counter &#125; from &#x27;./module.js&#x27;;\r\n\r\n最佳实践： 1. 在需要独立作用域时使用IIFE 2.\r\n现代JavaScript优先使用模块和块级作用域 3.\r\nIIFE适合用于旧代码兼容和特定场景 4. 注意代码可读性，适当添加注释\r\n五、声明提前（Hoisting）\r\n1. 基本概念\r\n声明提前是JavaScript中的一个机制，它会将变量和函数的声明移动到其所在作用域的顶部。\r\n// 1. 变量声明提前console.log(a);     // undefined（不会报错）var a = 1;// 上面的代码等同于：var a;             // 声明被提前console.log(a);    // undefineda = 1;            // 赋值保持在原位置// 2. let和const不会声明提前console.log(b);     // ReferenceError: Cannot access &#x27;b&#x27; before initializationlet b = 2;// 3. 函数声明提前sayHello();        // &quot;Hello!&quot;（可以正常运行）function sayHello() &#123;    console.log(&quot;Hello!&quot;);&#125;// 4. 函数表达式不会提前fn2();              // TypeError: fn2 is not a functionvar fn2 = function() &#123;    console.log(&quot;函数2&quot;);&#125;;\r\n3. 声明提前的作用域\r\n// 1. 全局作用域var global = &quot;全局变量&quot;;function test() &#123;    console.log(global);  // undefined（不是&quot;全局变量&quot;）    var global = &quot;局部变量&quot;;    console.log(global);  // &quot;局部变量&quot;&#125;// 2. 函数作用域function outer() &#123;    console.log(inner);   // undefined    var inner = &quot;内部变量&quot;;        function innerFn() &#123;        console.log(inner);  // &quot;内部变量&quot;    &#125;    innerFn();&#125;\r\n4. 常见陷阱和最佳实践\r\n\r\n函数声明覆盖 // 可能导致问题的代码function myFunction() &#123;    console.log(&quot;版本1&quot;);&#125;myFunction();  // &quot;版本2&quot;function myFunction() &#123;    console.log(&quot;版本2&quot;);&#125;\r\n\r\n5. 函数和变量的创建顺序\r\n在JavaScript中，声明提前遵循以下优先级规则：\r\n// 1. 函数声明优先于变量声明console.log(foo);  // [Function: foo]var foo = &quot;变量foo&quot;;function foo() &#123;    return &quot;函数foo&quot;;&#125;// 上述代码在执行时的实际顺序：function foo() &#123;   // 1. 首先处理函数声明    return &quot;函数foo&quot;;&#125;var foo;           // 2. 变量声明被忽略（因为已经存在同名函数）console.log(foo);  // 3. 输出函数定义foo = &quot;变量foo&quot;;   // 4. 变量赋值// 2. 同名函数声明会相互覆盖function bar() &#123;    return &quot;第一个函数&quot;;&#125;function bar() &#123;    return &quot;第二个函数&quot;;&#125;console.log(bar());  // &quot;第二个函数&quot;\r\n六、apply 和 call 方法\r\n用途\r\napply 和 call\r\n都是函数对象的方法，用于改变函数执行时的上下文（即改变函数内部的\r\nthis 指向）。\r\n语法\r\nfunc.call(thisArg, param1, param2, ...)func.apply(thisArg, [param1, param2, ...])\r\n区别\r\n\r\ncall 方法：参数需要一个一个传递\r\napply 方法：参数以数组形式传递\r\n\r\n示例\r\n1. 基本使用\r\nconst person = &#123;    name: &#x27;张三&#x27;,    sayHi: function(greeting) &#123;        console.log(`$&#123;greeting&#125;，我是$&#123;this.name&#125;`);    &#125;&#125;;const other = &#123;    name: &#x27;李四&#x27;&#125;;// 使用 callperson.sayHi.call(other, &#x27;你好&#x27;);  // 输出：你好，我是李四// 使用 applyperson.sayHi.apply(other, [&#x27;你好&#x27;]); // 输出：你好，我是李四\r\n2. 实际应用场景\r\n2.1 借用数组方法\r\n// 将类数组转换为真正的数组function convert() &#123;    return Array.prototype.slice.call(arguments);&#125;console.log(convert(1, 2, 3)); // 输出：[1, 2, 3]// 或使用 apply 找出数组最大值const numbers = [5, 6, 2, 3, 7];const max = Math.max.apply(null, numbers);console.log(max); // 输出：7\r\n2.2 继承\r\nfunction Animal(name) &#123;    this.name = name;&#125;function Cat(name, color) &#123;    // 调用 Animal 构造函数，并将 this 指向 Cat 实例    Animal.call(this, name);    this.color = color;&#125;const cat = new Cat(&#x27;咪咪&#x27;, &#x27;白色&#x27;);console.log(cat.name, cat.color); // 输出：咪咪 白色\r\n关键点\r\n\r\nthis 绑定\r\n\r\n第一个参数决定了函数内部的 this 指向\r\n如果第一个参数为 null 或\r\nundefined，this\r\n会指向全局对象（非严格模式）或保持为\r\nnull/undefined（严格模式）\r\n\r\n参数传递\r\n\r\ncall：func.call(thisArg, arg1, arg2, ...)\r\napply：func.call(thisArg, [arg1, arg2, ...])\r\n\r\n使用场景\r\n\r\n借用其他对象的方法\r\n继承时调用父类构造函数\r\n调用需要特定 this 值的函数\r\n\r\n\r\n最佳实践\r\n\r\n当参数数量固定时，优先使用 call，代码更直观\r\n当参数数量不固定或参数本身就是数组时，使用 apply\r\n在现代 JavaScript 中，可以考虑使用展开运算符 ... 代替\r\napply： const numbers = [5, 6, 2, 3, 7];const max = Math.max(...numbers); // 替代 Math.max.apply(null, numbers)\r\n\r\n注意事项\r\n\r\n在严格模式下，如果第一个参数为 null 或\r\nundefined，this 不会被转换为全局对象\r\n这两个方法都会立即执行函数\r\n如果需要稍后执行，可以考虑使用 bind 方法\r\n\r\nJavaScript原型与原型链学习笔记\r\n📚\r\n一、原型基础概念\r\n\r\n\r\nimage-20250312020925534\r\n\r\n我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype\r\n这个属性对应着一个对象，这个对象就是我们所谓的原型对象\r\n当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，它指向该构造函数的原型对象，我们可以通过__proto__来访问该属性\r\n原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。\r\n当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用\r\n1. 函数的prototype属性\r\n// 每个函数都有prototype属性function Person(name) &#123;    this.name = name;&#125;console.log(Person.prototype); // &#123;constructor: ƒ&#125;// 向原型中添加方法Person.prototype.sayHello = function() &#123;    console.log(`Hello, $&#123;this.name&#125;`);&#125;;\r\n2. 对象的__proto__属性\r\n// 创建实例const person1 = new Person(&quot;张三&quot;);const person2 = new Person(&quot;李四&quot;);// 实例通过__proto__访问原型对象console.log(person1.__proto__ === Person.prototype); // trueconsole.log(person2.__proto__ === Person.prototype); // true// 使用Object.getPrototypeOf()console.log(Object.getPrototypeOf(person1) === Person.prototype); // true\r\n3. 原型链查找机制\r\nfunction Person(name) &#123;    this.name = name;&#125;Person.prototype.sayHello = function() &#123;    console.log(`Hello, $&#123;this.name&#125;`);&#125;;const person = new Person(&quot;张三&quot;);// 用 in 检查对象或原型对象中有无某个属性console.log(&quot;sayHello&quot; in Person.prototype); //true// 用 hasOwnProperty 检查对象自身有无某个属性console.log(User.hasOwnProperty(&quot;sayHello&quot;)); // false// 查找顺序：// 1. 先在实例对象中查找person.name;  // 在实例中找到 &quot;张三&quot;// 2. 如果实例中没有，则在原型对象中查找person.sayHello();  // 在原型中找到方法// 3. 如果原型中没有，则继续在原型的原型中查找，直到找到Object对象的原型。Object对象的原型没有原型，是nullconsole.log(Person.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;));// true Person的原型对象的原型对象中有hasOwnProperty属性console.log(Person.__proto__.__proto__.hasOwnProperty(&quot;toString&quot;));// true Person的原型对象的原型对象中有toString属性//Object对象的原型没有原型，是nullconsole.log(Object.__proto__.__proto__);// null prototypeperson.toString();  // 在Object.prototype中找到方法// 4. 如果最终在Object中也没找到，则返回undefinedperson.notExist;  // undefined\r\n二、原型的实际应用\r\n1. 共享方法和属性\r\n// 不推荐：每个实例都创建一个新方法function Dog(name) &#123;    this.name = name;    this.bark = function() &#123;  // 每个实例都有一个bark方法副本        console.log(&quot;汪汪!&quot;);    &#125;;&#125;// 推荐：将方法放在原型上共享function Dog(name) &#123;    this.name = name;&#125;Dog.prototype.bark = function() &#123;  // 所有实例共享同一个方法    console.log(&quot;汪汪!&quot;);&#125;;\r\n2. 原型继承\r\n// 父类function Animal(name) &#123;    this.name = name;&#125;Animal.prototype.eat = function() &#123;    console.log(`$&#123;this.name&#125;正在吃东西`);&#125;;// 子类function Dog(name) &#123;    Animal.call(this, name);  // 继承属性&#125;// 继承方法（设置原型链）Dog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;  // 修复constructor指向// 添加子类自己的方法Dog.prototype.bark = function() &#123;    console.log(&quot;汪汪!&quot;);&#125;;\r\n3. 原型链检测\r\n// 1. instanceof 运算符const dog = new Dog(&quot;小黑&quot;);console.log(dog instanceof Dog);     // trueconsole.log(dog instanceof Animal);  // trueconsole.log(dog instanceof Object);  // true// 2. isPrototypeOf() 方法console.log(Dog.prototype.isPrototypeOf(dog));    // trueconsole.log(Animal.prototype.isPrototypeOf(dog)); // true// 3. getPrototypeOf() 方法console.log(Object.getPrototypeOf(dog) === Dog.prototype); // true\r\n三、注意事项和最佳实践\r\n1. 属性遮蔽（Property\r\nShadowing）\r\nfunction Person() &#123;&#125;Person.prototype.name = &quot;原型上的名字&quot;;const person = new Person();console.log(person.name);  // &quot;原型上的名字&quot;person.name = &quot;实例上的名字&quot;;  // 创建自己的属性console.log(person.name);  // &quot;实例上的名字&quot;delete person.name;  // 删除实例上的属性console.log(person.name);  // &quot;原型上的名字&quot;\r\n2. 原型的动态性\r\nfunction Person() &#123;&#125;const person = new Person();// 在创建实例后修改原型Person.prototype.sayHello = function() &#123;    console.log(&quot;Hello!&quot;);&#125;;person.sayHello();  // &quot;Hello!&quot; - 可以访问新添加的方法// 但是完全替换原型会断开连接Person.prototype = &#123;    sayHi: function() &#123;        console.log(&quot;Hi!&quot;);    &#125;&#125;;person.sayHi();  // TypeError: person.sayHi is not a function\r\n3. 最佳实践\r\n// 1. 使用Object.create()创建干净的原型链const parent = &#123;    sayHello() &#123;        console.log(&quot;Hello!&quot;);    &#125;&#125;;const child = Object.create(parent);// 2. 使用class语法（推荐）class Animal &#123;    constructor(name) &#123;        this.name = name;    &#125;        eat() &#123;        console.log(`$&#123;this.name&#125;正在吃东西`);    &#125;&#125;class Dog extends Animal &#123;    bark() &#123;        console.log(&quot;汪汪!&quot;);    &#125;&#125;\r\nJavaScript垃圾回收机制详解📚\r\n一、基本概念\r\n1. 什么是垃圾回收\r\nJavaScript会自动进行内存管理和垃圾回收（Garbage\r\nCollection，简称GC），主要目的是： - 识别不再使用的内存（垃圾） -\r\n回收这些内存供后续使用 - 防止内存泄漏\r\n二、主要算法\r\n1.\r\n标记-清除算法（Mark-and-Sweep）\r\n// 标记-清除算法的工作示例let user = &#123;    name: &quot;John&quot;&#125;;user = null;  // 对象变成垃圾，将在下次GC时被回收\r\n工作步骤： 1. 垃圾回收器找到所有根对象（全局对象） 2.\r\n标记从根对象可达的所有对象 3. 清除未被标记的对象\r\n2. 引用计数算法（Reference\r\nCounting）\r\n// 引用计数示例let obj = &#123;     // 引用计数 = 1    name: &quot;测试&quot;&#125;;let reference = obj;  // 引用计数 = 2obj = null;          // 引用计数 = 1reference = null;    // 引用计数 = 0，可以被回收\r\n3. 循环引用问题\r\nfunction createCycle() &#123;    let obj1 = &#123;&#125;;    let obj2 = &#123;&#125;;        obj1.ref = obj2;    // obj1 引用 obj2    obj2.ref = obj1;    // obj2 引用 obj1        return &quot;cycle created&quot;;&#125;createCycle();  // 函数执行完后，obj1和obj2互相引用，但都不可访问\r\n三、内存泄漏的常见情况\r\n1. 意外的全局变量\r\n// 错误示例function leak() &#123;    leakedVariable = &quot;我会泄漏到全局&quot;;  // 没有使用var/let/const&#125;// 正确做法&#x27;use strict&#x27;;  // 使用严格模式function noLeak() &#123;    let safeVariable = &quot;我是安全的局部变量&quot;;&#125;\r\n2. 被遗忘的定时器\r\n// 内存泄漏示例function setLeakyTimer() &#123;    const someData = &#123; /* 大量数据 */ &#125;;    setInterval(() =&gt; &#123;        console.log(someData);    &#125;, 1000);&#125;// 正确做法function setProperTimer() &#123;    const timerId = setInterval(() =&gt; &#123;        console.log(&#x27;tick&#x27;);    &#125;, 1000);        // 在适当的时候清除定时器    clearInterval(timerId);&#125;\r\n3. 闭包导致的泄漏\r\n// 潜在的内存泄漏function createLeak() &#123;    const largeData = new Array(1000000);        return function() &#123;        console.log(largeData[0]);  // 持有对largeData的引用    &#125;&#125;// 更好的做法function createNonLeak() &#123;    const largeData = new Array(1000000);    const firstItem = largeData[0];  // 只保留需要的数据        return function() &#123;        console.log(firstItem);    &#125;&#125;\r\n4. DOM引用\r\n// 可能导致内存泄漏的DOM引用let elements = &#123;    button: document.getElementById(&#x27;button&#x27;),    image: document.getElementById(&#x27;image&#x27;),    text: document.getElementById(&#x27;text&#x27;)&#125;;// 解除引用function removeButton() &#123;    document.body.removeChild(document.getElementById(&#x27;button&#x27;));    // 应该同时解除引用    elements.button = null;&#125;\r\n四、最佳实践\r\n1. 避免内存泄漏\r\n// 1. 及时清除定时器const timer = setTimeout(() =&gt; &#123;    // 操作&#125;, 1000);clearTimeout(timer);// 2. 及时解除事件监听function addListener() &#123;    const element = document.getElementById(&#x27;myButton&#x27;);    const handler = () =&gt; &#123;        console.log(&#x27;clicked&#x27;);    &#125;;    element.addEventListener(&#x27;click&#x27;, handler);        // 清理函数    return () =&gt; &#123;        element.removeEventListener(&#x27;click&#x27;, handler);    &#125;;&#125;// 3. 使用WeakMap/WeakSetconst cache = new WeakMap();let object = &#123; data: &#x27;cached&#x27; &#125;;cache.set(object, &#x27;metadata&#x27;);object = null;  // 对象可被回收\r\n2. 性能优化建议\r\n// 1. 对象池模式const objectPool = &#123;    _pool: [],        acquire() &#123;        return this._pool.pop() || &#123;&#125;;    &#125;,        release(obj) &#123;        Object.keys(obj).forEach(key =&gt; &#123;            delete obj[key];        &#125;);        this._pool.push(obj);    &#125;&#125;;// 2. 及时释放大型数据function processData(data) &#123;    // 处理数据    const result = transform(data);        // 清除原始数据引用    data = null;        return result;&#125;\r\n3. 监控内存使用\r\n// 在浏览器中监控内存使用console.log(performance.memory);// Node.js中监控内存使用const used = process.memoryUsage();console.log(&#123;    heapTotal: `$&#123;Math.round(used.heapTotal / 1024 / 1024 * 100) / 100&#125; MB`,    heapUsed: `$&#123;Math.round(used.heapUsed / 1024 / 1024 * 100) / 100&#125; MB`&#125;);\r\nJavaScript数组对象方法笔记\r\n// 创建数组,数组也是内建对象let fruits = [&quot;苹果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;];let numbers = [1, 2, 3, 4, 5];let names = new Array(1,2,3);names[names.length]=1;// 使用数组console.log(fruits[0]);              // 输出：苹果fruits.push(&quot;梨&quot;,&quot;西瓜&quot;);                   // 从末尾添加新元素fruits.pop();// 删除数组最后一个元素并返回fruits.unshift(&quot;奥特曼&quot;);  //从最开始添加元素fruits.shift();// 删除数组第一个元素并返回// slice 不会影响原数组。用于从数组中提取出一部分元素，并返回一个新数组。// 左闭右开区间const array = [1, 2, 3, 4, 5];console.log(array.slice(1, 3)); // 输出 [2, 3]// 负索引console.log(array.slice(-3, -1)); // 输出 [3, 4]const array = [1, 2, 3, 4, 5];// splice 会影响原数组,param1 为开始位置,param2 为删除的个数，param3及以后的元素将会从开始删除索引位置替换进去console.log(array.splice(1, 2,&quot;张三&quot;,&quot;李四&quot;)); // [2, 3]console.log(array);//[ 1,&quot;张三&quot;,&quot;李四&quot;, 4, 5 ]// concat 不会影响原数组。将多个数组合并成一个数组let array = [1, 2, 3];let array2 = [4,5,6];console.log(array.concat(array2,&quot;不高兴&quot;,&quot;没头脑&quot;)); //[ 1, 2, 3, 4, 5, 6, &#x27;不高兴&#x27;, &#x27;没头脑&#x27; ]// join 不会影响原数组。将数组元素用连接符连接起来。let array = [&quot;没头脑&quot;,&quot;不高兴&quot;];console.log(array.join(&quot;@&quot;)); // 没头脑@不高兴// reverse 颠倒原数组let array = [&quot;没头脑&quot;,&quot;不高兴&quot;];console.log(array.reverse()); // [ &#x27;不高兴&#x27;, &#x27;没头脑&#x27; ]\r\n\r\n使用 for...of 遍历可迭代对象。\r\n使用 forEach 进行副作用操作。\r\n使用 map 进行数组元素的转换。\r\n使用 filter 进行数组元素的筛选。\r\n使用 reduce 进行数组的聚合操作。\r\n\r\n1. for…of\r\n用途\r\nfor...of\r\n循环用于遍历可迭代对象（如数组、字符串、Map、Set等）。\r\n使用方法\r\nfor (const element of iterable) &#123;    // 处理每个元素&#125;\r\n参数说明\r\n\r\niterable: 任何可迭代对象。\r\n\r\n返回值\r\n\r\n无返回值。\r\n\r\n示例\r\nconst array = [1, 2, 3];for (const num of array) &#123;    console.log(num); // 输出 1, 2, 3&#125;\r\n\r\n2. forEach\r\n用途\r\nforEach 方法用于对数组的每个元素执行一次提供的函数。\r\n使用方法\r\narray.forEach((element, index, array) =&gt; &#123;    // 处理每个元素&#125;);\r\n参数说明\r\n\r\nelement: 当前处理的数组元素。\r\nindex: 当前元素的索引（可选）。\r\narray: 调用 forEach 的数组（可选）。\r\n\r\n返回值\r\n\r\n无返回值。\r\n\r\n示例\r\nconst array = [1, 2, 3];array.forEach((num) =&gt; &#123;    console.log(num); // 输出 1, 2, 3&#125;);\r\n\r\n3. map\r\n用途\r\nmap\r\n方法创建一个新数组，结果是对原数组中的每个元素调用一个提供的函数后的返回值。\r\n使用方法\r\nconst newArray = array.map((element, index, array) =&gt; &#123;    // 返回处理后的元素&#125;);\r\n参数说明\r\n\r\nelement: 当前处理的数组元素。\r\nindex: 当前元素的索引（可选）。\r\narray: 调用 map 的数组（可选）。\r\n\r\n返回值\r\n\r\n返回一个新数组。\r\n\r\n示例\r\nconst array = [1, 2, 3];const doubled = array.map(num =&gt; num * 2);console.log(doubled); // 输出 [2, 4, 6]\r\n\r\n4. filter\r\n用途\r\nfilter 方法创建一个新数组，包含所有通过测试的元素。\r\n使用方法\r\nconst newArray = array.filter((element, index, array) =&gt; &#123;    // 返回 true 或 false&#125;);\r\n参数说明\r\n\r\nelement: 当前处理的数组元素。\r\nindex: 当前元素的索引（可选）。\r\narray: 调用 filter 的数组（可选）。\r\n\r\n返回值\r\n\r\n返回一个新数组，包含所有通过测试的元素。\r\n\r\n示例\r\nconst array = [1, 2, 3, 4];const evens = array.filter(num =&gt; num % 2 === 0);console.log(evens); // 输出 [2, 4]\r\n\r\n5. reduce\r\n用途\r\nreduce 方法对数组中的每个元素执行一个 reducer\r\n函数，最终计算出一个单一的值。\r\n使用方法\r\nconst result = array.reduce((accumulator, currentValue, index, array) =&gt; &#123;    // 返回更新后的累加器&#125;, initialValue);\r\n参数说明\r\n\r\naccumulator: 累加器，累计回调的返回值。\r\ncurrentValue: 当前处理的数组元素。\r\nindex: 当前元素的索引（可选）。\r\narray: 调用 reduce 的数组（可选）。\r\ninitialValue:\r\n作为第一次调用回调时第一个参数的值（可选）。\r\n\r\n返回值\r\n\r\n返回最终的累加值。\r\n\r\n示例\r\nconst array = [1, 2, 3, 4];const sum = array.reduce((acc, num) =&gt; acc + num, 0);console.log(sum); // 输出 10\r\n6. 数组去重实现\r\n\r\n对于简单数组去重，优先使用 Set 方法\r\n需要保持数组原有顺序时，可以使用 filter 方法\r\n需要在遍历过程中进行复杂操作时，可以使用 splice 方法\r\n\r\n方法一：使用双重循环和splice\r\n这种方法通过比较每个元素与其后的所有元素，发现重复就删除。\r\nlet array = [1, 2, 2, 3, 4, 5];for (let i = 0; i &lt; array.length; i++) &#123;    // 遍历该元素后的所有元素依次比较    for (let j = i + 1; j &lt; array.length; j++) &#123;        if (array[i] === array[j]) &#123;            array.splice(j, 1); // 删除重复元素            // 因为数组长度减少了1，所以索引也要减1。即删除了当前元素，后一个元素顶上来了,此时比较下一个元素将会漏一个元素没比较            j--;         &#125;    &#125;&#125;console.log(array); // 输出 [1, 2, 3, 4, 5]\r\n方法二：使用Set（推荐）\r\nlet array = [1, 2, 2, 3, 4, 5];array = [...new Set(array)];console.log(array); // 输出 [1, 2, 3, 4, 5]\r\n方法三：使用filter和indexOf\r\nlet array = [1, 2, 2, 3, 4, 5];// 元素在数组中首次出现的位置等于其当前索引array = array.filter((item, index) =&gt; array.indexOf(item) === index);console.log(array); // 输出 [1, 2, 3, 4, 5]\r\n7.数组排序-sort\r\n// sort 直接影响原数组，默认按Unicode编码排序，可以回调函数编写排序规则let array = [11,2,4,3];// console.log(array.sort());//[ 11, 2, 3, 4 ]array.sort((a,b)=&gt;&#123;    /*    该回调函数返回值会影响排序    如果大于0，交换位置，    如果小于0，位置不变，    如果等于0，两者相等，位置不变*/         // 该回调函数将原数组升序排列，等价于 return a-b;    /*if (a&gt;b) &#123;        // 前者大则交换位置，即升序         return 1;    &#125; else if (a&lt;b) &#123;        // 后者大则不变，即升序        return -1;    &#125; else &#123;        // 相等则不变        return 0;    &#125;*/             // 该回调函数将原数组降序排列，等价于 return b-a;    /*    if (a&gt;b) &#123;        return -1;    &#125; else if (a&lt;b) &#123;        return 1;    &#125; else &#123;        return 0;    &#125;*/   &#125;);console.log(array);\r\n正则表达式\r\nlet regObj = new RegExp(&quot;a&quot;, &quot;i&quot;);console.log(regObj.test(&quot;abc&quot;)); // true 忽略大小写console.log((/a|b/i).test(&quot;abc&quot;));// true 忽略大小写匹配a 或 bconsole.log((/[ab]/i).test(&quot;abc&quot;)); // true 忽略大小写匹配a 或 bconsole.log((/[A-z]/).test(&quot;abc&quot;)); // true 任意字母console.log((/[^0-9]/).test(&quot;abc&quot;)); // true 除了数字以外console.log(&quot;1a2b3c4&quot;.split(/[A-z]/)); //[ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; ]console.log(&quot;hello abc hello aec afc&quot;.search(/a[A-z]c/)); // 6console.log(&quot;hello abc hello aec afc&quot;.replace(/a[A-z]c/g, &quot;123&quot;)); //hello 123 hello 123 123console.log(&quot;1A2b3c&quot;.match(/[A-z]/ig)); //[ &#x27;A&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]reg=/^a|a$/ //以a开头，以a结尾reg=. //任意字符\r\n\r\n\r\nimage-20250317203836008\r\n\r\n\r\n\r\nimage-20250317205122006\r\n\r\n\r\n\r\nimage-20250317205319471\r\n\r\n\r\n\r\nimage-20250317205909708\r\n\r\nDOM\r\n\r\n\r\nimage-20250317211012433\r\n\r\n常用的DOM查询方法\r\n获取元素节点\r\n\r\n\r\nimage-20250317214719665\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图片轮播&lt;/title&gt;    &lt;style&gt;        .widget-content &#123;            text-align: center;        &#125;        .sidebar-avatar &#123;            width: 100%;            border-radius: 10px;            object-fit: cover;            margin: 0 auto 15px;            display: block;            border: 3px solid var(--primary-color);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;widget-content&quot;&gt;    &lt;img src=&quot;../blog/images/about-p1.jpg&quot; alt=&quot;Luotao&quot; class=&quot;sidebar-avatar&quot;&gt;    &lt;p class=&quot;bio&quot;&gt;&lt;/p&gt;    &lt;button id=&quot;prev&quot;&gt;上一张&lt;/button&gt;    &lt;button id=&quot;next&quot;&gt;下一张&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    let prev = document.getElementById(&#x27;prev&#x27;);    let next = document.getElementById(&#x27;next&#x27;);    let img = document.getElementsByTagName(&#x27;img&#x27;)[0];    let imgList = [        &#x27;../blog/images/about-p1.jpg&#x27;,        &#x27;../blog/images/about-p2.jpg&#x27;,        &#x27;../blog/images/about-p3.jpg&#x27;,        &#x27;../blog/images/about-p4.jpg&#x27;,        &#x27;../blog/images/about-p5.jpg&#x27;    ];    let index=0;    let bio = document.getElementsByClassName(&#x27;bio&#x27;)[0];    bio.innerHTML=index+1+&#x27;/&#x27;+imgList.length;    prev.onclick=()=&gt;&#123;        // 上一张        index--;        if (index&lt;0)&#123;            index=imgList.length-1;        &#125;        img.src=imgList[index];        bio.innerHTML=index+1+&#x27;/&#x27;+imgList.length;    &#125;    next.onclick=()=&gt;&#123;        // 下一张        index++;        if (index &gt; imgList.length-1)&#123;            index=0;        &#125;        img.src=imgList[index];        bio.innerHTML=index+1+&#x27;/&#x27;+imgList.length;    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\r\n1. 通过ID查询元素\r\n// 获取ID为&quot;myElement&quot;的元素const element = document.getElementById(&#x27;myElement&#x27;);\r\n2. 通过类名查询元素\r\n// 获取所有class为&quot;myClass&quot;的元素（返回HTMLCollection）const elements = document.getElementsByClassName(&#x27;myClass&#x27;);// 遍历所有找到的元素for (let i = 0; i &lt; elements.length; i++) &#123;    console.log(elements[i]);&#125;\r\n3. 通过标签名查询元素\r\n// 获取所有&lt;p&gt;元素（返回HTMLCollection）const paragraphs = document.getElementsByTagName(&#x27;p&#x27;);\r\n4.\r\n使用CSS选择器查询元素（现代方法）\r\n// 获取第一个匹配的元素const element = document.querySelector(&#x27;.myClass&#x27;);// 获取所有匹配的元素（返回NodeList）const elements = document.querySelectorAll(&#x27;div.important&#x27;);// 使用复杂的CSS选择器const nestedElements = document.querySelectorAll(&#x27;#container &gt; .item&#x27;);\r\n获取元素节点的子节点\r\n\r\n\r\nimage-20250318004002936\r\n\r\n\r\nchildNodes属性会获取包括文本节点在内的所有节点，包括空白文本节点\r\nchildren属性可以获取当前元素的所有子元素\r\nfirstChild可以获取当前元素的第一个子节点，包括空白文本节点\r\nfirstElementChild可以获取当前元素的第一个子元素\r\n\r\nNodeList与HTMLCollection的区别\r\n\r\nHTMLCollection：是动态集合，会随DOM的变化而自动更新\r\nNodeList：通常是静态集合，不会自动更新（除了某些特定情况）\r\n\r\n这就像是： - HTMLCollection是实时监控的摄像头画面 -\r\nNodeList是拍下的一张照片，不会随场景变化而变化\r\n遍历DOM元素\r\n// 遍历NodeListconst items = document.querySelectorAll(&#x27;.item&#x27;);items.forEach(item =&gt; &#123;    console.log(item.textContent);&#125;);// 遍历HTMLCollection（不支持forEach，需要转换或使用for循环）const divs = document.getElementsByTagName(&#x27;div&#x27;);Array.from(divs).forEach(div =&gt; &#123;    console.log(div.id);&#125;);// 或者使用for循环for (let i = 0; i &lt; divs.length; i++) &#123;    console.log(divs[i].id);&#125;\r\nDOM元素关系导航\r\nDOM树中的元素之间存在父子、兄弟关系，可以通过这些关系导航：\r\nconst parent = document.getElementById(&#x27;parent&#x27;);// 获取子元素const children = parent.children;  // 所有子元素const firstChild = parent.firstElementChild;  // 第一个子元素const lastChild = parent.lastElementChild;  // 最后一个子元素// 获取父元素const child = document.getElementById(&#x27;child&#x27;);const parentElement = child.parentElement;// 获取兄弟元素const prevSibling = child.previousElementSibling;  // 前一个兄弟元素const nextSibling = child.nextElementSibling;  // 后一个兄弟元素\r\n实际应用示例\r\n示例1：切换元素的可见性\r\n// HTML: &lt;button id=&quot;toggleBtn&quot;&gt;显示/隐藏&lt;/button&gt;//       &lt;div id=&quot;content&quot;&gt;这是可以切换显示的内容&lt;/div&gt;const toggleBtn = document.getElementById(&#x27;toggleBtn&#x27;);const content = document.getElementById(&#x27;content&#x27;);toggleBtn.addEventListener(&#x27;click&#x27;, function() &#123;    if (content.style.display === &#x27;none&#x27;) &#123;        content.style.display = &#x27;block&#x27;;    &#125; else &#123;        content.style.display = &#x27;none&#x27;;    &#125;&#125;);\r\n"},{"title":"SpringBoot技术深入理解","url":"/2025/03/14/SpringBoot%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","content":"SpringBoot技术深入理解\r\n一、SpringBoot基础概念\r\n1. 什么是SpringBoot？\r\n专业概念：\r\nSpringBoot是一个基于Spring框架的快速开发平台，它通过”约定优于配置”的理念，简化了Spring应用的初始搭建和开发过程。它提供了自动配置、起步依赖等特性，让开发者能够快速构建生产级别的Spring应用。\r\n生活化比喻： 想象你在装修房子： -\r\n传统Spring就像自己买材料、找工人、设计图纸，需要事无巨细地规划 -\r\nSpringBoot就像全屋定制，你只需要选择风格，装修公司会提供完整的解决方案 -\r\n就像”宜家家具”，提供了标准化的组件，可以快速组装出完整的家居\r\n2. SpringBoot的核心特性\r\n2.1 自动配置（Auto\r\nConfiguration）\r\n专业概念：\r\n自动配置是SpringBoot的核心特性之一，它能够根据项目的依赖自动配置Spring应用。通过分析classpath中的依赖，SpringBoot能够推断出应用需要的组件，并自动创建这些组件。\r\n工作原理： 1. 扫描classpath中的依赖 2.\r\n读取META-INF/spring.factories文件 3. 根据条件注解筛选配置类 4.\r\n自动创建和配置Bean\r\n生活化比喻： -\r\n就像智能家居系统，当你把新设备带回家，系统能自动识别并配置 -\r\n类似于”自动泊车”功能，你只需要把车开到位置，系统会自动完成停车 -\r\n像是一个”智能厨房”，你放入食材，它自动选择最合适的烹饪方式\r\n2.2 起步依赖（Starter\r\nDependencies）\r\n专业概念：\r\n起步依赖是一组预定义的依赖组合，它们包含了开发特定类型应用所需的所有依赖。这些依赖经过版本兼容性测试，确保能够正常工作。\r\n常见起步依赖： &lt;!-- Web应用起步依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 数据库起步依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 安全起步依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\r\n生活化比喻： - 就像”套餐”服务，包含了所有需要的组件\r\n- 类似于”乐高套装”，包含了搭建特定模型所需的所有积木 -\r\n像是一个”工具箱”，包含了完成特定任务所需的所有工具\r\n2.3 嵌入式服务器（Embedded\r\nServer）\r\n专业概念：\r\nSpringBoot应用内置了Tomcat、Jetty或Undertow服务器，无需部署WAR文件就能运行。这使得应用可以独立运行，简化了部署过程。\r\n优势： 1. 无需外部服务器 2. 快速启动和测试 3.\r\n简化部署流程 4. 支持多种服务器选择\r\n生活化比喻： -\r\n就像”便携式咖啡机”，不需要咖啡店就能喝到咖啡 -\r\n类似于”移动电源”，不需要插座就能给手机充电 -\r\n像是一个”迷你厨房”，不需要去餐厅就能做饭\r\n2.4 Actuator监控\r\n专业概念： SpringBoot\r\nActuator提供了生产级别的监控功能，可以监控应用的运行状态、性能指标、配置信息等。它通过REST端点暴露这些信息，方便运维人员监控和管理应用。\r\n主要功能： 1. 健康检查 2. 指标收集 3. 环境信息 4.\r\n配置信息\r\n生活化比喻： - 就像”汽车仪表盘”，显示车辆的各项指标\r\n- 类似于”智能手表”，监控人体的各项数据 -\r\n像是一个”智能家居控制面板”，显示所有设备的状态\r\n二、SpringBoot应用开发\r\n1. 项目结构\r\n标准项目结构： src/main/java/  ├── com.example/  │   ├── Application.java          # 启动类  │   ├── controller/               # 控制器层  │   ├── service/                  # 服务层  │   ├── repository/               # 数据访问层  │   ├── model/                    # 数据模型  │   ├── config/                   # 配置类  │   └── util/                     # 工具类  └── resources/      ├── application.yml           # 主配置文件      ├── application-dev.yml       # 开发环境配置      ├── application-prod.yml      # 生产环境配置      ├── static/                   # 静态资源      └── templates/                # 模板文件\r\n生活化比喻： -\r\n就像”图书馆”的布局，不同类型的书籍分门别类 -\r\n类似于”超市”的货架布局，商品按类别摆放 -\r\n像是一个”办公室”，不同部门有各自的区域\r\n2. 控制器开发\r\nRESTful API示例： @RestController@RequestMapping(&quot;/api/users&quot;)public class UserController &#123;    @Autowired    private UserService userService;        @GetMapping    public List&lt;User&gt; getAllUsers() &#123;        return userService.findAll();    &#125;        @PostMapping    public User createUser(@RequestBody User user) &#123;        return userService.save(user);    &#125;        @GetMapping(&quot;/&#123;id&#125;&quot;)    public User getUser(@PathVariable Long id) &#123;        return userService.findById(id);    &#125;&#125;\r\n注解说明： - @RestController：标识这是一个REST控制器\r\n- @RequestMapping：定义基础URL路径 -\r\n@GetMapping：处理GET请求 - @PostMapping：处理POST请求 - @PathVariable：获取URL路径变量 - @RequestBody：获取请求体数据\r\n生活化比喻： - 就像”前台接待”，处理各种来访请求 -\r\n类似于”餐厅服务员”，接收顾客点单并传递到厨房 -\r\n像是一个”交通指挥员”，引导不同类型的车辆\r\n3. 服务层开发\r\n服务层示例： @Service@Transactionalpublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserRepository userRepository;        @Override    public List&lt;User&gt; findAll() &#123;        return userRepository.findAll();    &#125;        @Override    public User save(User user) &#123;        return userRepository.save(user);    &#125;        @Override    public User findById(Long id) &#123;        return userRepository.findById(id)            .orElseThrow(() -&gt; new UserNotFoundException(id));    &#125;&#125;\r\n事务管理： - @Transactional：确保方法在事务中执行 -\r\n事务传播行为：定义事务如何传播 - 事务隔离级别：定义事务的隔离程度\r\n生活化比喻： - 就像”银行柜员”，处理各种业务操作 -\r\n类似于”厨师”，准备各种菜品 - 像是一个”仓库管理员”，管理货物的存取\r\n4. 数据访问层\r\nJPA Repository示例： @Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;    // 方法名查询    List&lt;User&gt; findByAgeGreaterThan(int age);    Optional&lt;User&gt; findByEmail(String email);        // 自定义查询    @Query(&quot;SELECT u FROM User u WHERE u.name LIKE %:keyword%&quot;)    List&lt;User&gt; searchUsers(@Param(&quot;keyword&quot;) String keyword);&#125;\r\n查询方法： - 方法名查询：根据方法名自动生成查询 -\r\n@Query注解：自定义JPQL查询 -\r\n原生SQL查询：使用原生SQL语句\r\n生活化比喻： -\r\n就像”图书管理员”，根据各种条件查找图书 -\r\n类似于”档案管理员”，管理各种档案资料 -\r\n像是一个”数据库管理员”，管理数据的存取\r\n三、SpringBoot高级特性\r\n1. 自定义启动器\r\n启动器开发： @Configuration@AutoConfigureBefore(WebMvcAutoConfiguration.class)public class CustomStarter &#123;    @Bean    public CustomService customService() &#123;        return new CustomServiceImpl();    &#125;&#125;// 自动配置文件org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.example.CustomStarter\r\n启动器作用： 1. 封装常用功能 2. 简化配置过程 3.\r\n提供默认实现 4. 支持自定义配置\r\n生活化比喻： - 就像”预制菜”，预先准备好食材和调料 -\r\n类似于”装修套餐”，包含所有必要的材料 -\r\n像是一个”工具箱”，包含特定任务所需的所有工具\r\n2. 条件化配置\r\n条件配置示例： @Configuration@ConditionalOnProperty(name = &quot;app.feature.enabled&quot;, havingValue = &quot;true&quot;)public class FeatureConfiguration &#123;    @Bean    public FeatureService featureService() &#123;        return new FeatureServiceImpl();    &#125;&#125;\r\n条件注解： - @ConditionalOnClass：当类存在时生效\r\n- @ConditionalOnMissingBean：当Bean不存在时生效\r\n- @ConditionalOnProperty：当属性满足条件时生效\r\n生活化比喻： - 就像”智能空调”，根据温度自动调节 -\r\n类似于”自动门”，根据是否有人自动开关 -\r\n像是一个”智能照明”，根据光线自动调节亮度\r\n3. 事件监听\r\n事件监听示例： @Componentpublic class ApplicationEventListener &#123;    @EventListener    public void handleApplicationEvent(ApplicationEvent event) &#123;        if (event instanceof ContextRefreshedEvent) &#123;            // 应用上下文刷新后的处理        &#125;    &#125;&#125;\r\n事件类型： 1. 应用事件 2. 上下文事件 3. 请求事件 4.\r\n自定义事件\r\n生活化比喻： - 就像”门铃”，当有人来访时通知主人 -\r\n类似于”闹钟”，在特定时间提醒 - 像是一个”监控系统”，在发生异常时报警\r\n四、SpringBoot最佳实践\r\n1. 项目结构规范\r\n规范要求： 1. 包命名规范 - 使用小写字母 -\r\n使用有意义的名称 - 遵循领域驱动设计\r\n\r\n异常处理\r\n\r\n统一异常处理\r\n自定义异常类\r\n异常日志记录\r\n\r\n响应格式\r\n\r\n统一响应结构\r\n状态码规范\r\n错误信息规范\r\n\r\n\r\n生活化比喻： - 就像”图书馆”的图书分类系统 -\r\n类似于”医院”的科室划分 - 像是一个”超市”的商品分类\r\n2. 配置管理\r\n配置原则： 1. 使用YAML格式 - 层次结构清晰 -\r\n支持复杂数据类型 - 支持多环境配置\r\n\r\n环境特定配置\r\n\r\n开发环境\r\n测试环境\r\n生产环境\r\n\r\n敏感信息加密\r\n\r\n使用加密配置\r\n使用环境变量\r\n使用配置中心\r\n\r\n\r\n生活化比喻： - 就像”保险箱”，安全存储重要物品 -\r\n类似于”钥匙管理”，不同人有不同的权限 -\r\n像是一个”密码本”，管理各种密码\r\n3. 性能优化\r\n优化策略： 1. 使用缓存 - 本地缓存 - 分布式缓存 -\r\n多级缓存\r\n\r\n异步处理\r\n\r\n异步方法\r\n消息队列\r\n线程池\r\n\r\n连接池配置\r\n\r\n数据库连接池\r\n线程池\r\n连接超时设置\r\n\r\n\r\n生活化比喻： - 就像”快递柜”，临时存储包裹 -\r\n类似于”餐厅预约”，提前安排座位 - 像是一个”停车场”，管理车辆进出\r\n4. 安全实践\r\n安全措施： 1. 使用Spring Security - 身份认证 -\r\n权限控制 - 会话管理\r\n\r\n密码加密\r\n\r\n使用加密算法\r\n密码加盐\r\n密码强度验证\r\n\r\nXSS防护\r\n\r\n输入验证\r\n输出转义\r\nCSP配置\r\n\r\n\r\n生活化比喻： - 就像”门禁系统”，控制人员进出 -\r\n类似于”保险柜”，保护重要物品 - 像是一个”安检系统”，检查危险物品\r\n五、常见面试题\r\n1. SpringBoot自动配置原理\r\n问题： SpringBoot是如何实现自动配置的？\r\n详细答案： 1. 启动流程 -\r\n加载META-INF/spring.factories - 获取自动配置类列表 - 根据条件筛选配置类\r\n- 执行配置类\r\n\r\n条件注解\r\n\r\n@ConditionalOnClass：当类存在时生效\r\n@ConditionalOnMissingBean：当Bean不存在时生效\r\n@ConditionalOnProperty：当属性满足条件时生效\r\n\r\n配置优先级\r\n\r\n命令行参数\r\n系统属性\r\n配置文件\r\n默认配置\r\n\r\n\r\n生活化比喻： - 就像”智能家居”，根据环境自动调节 -\r\n类似于”自动驾驶”，根据路况自动调整 -\r\n像是一个”智能助手”，根据需求自动服务\r\n2. SpringBoot启动流程\r\n问题： SpringBoot应用是如何启动的？\r\n详细答案： 1. 启动类 - 加载配置类 -\r\n创建Spring上下文 - 执行自动配置\r\n\r\n启动流程\r\n\r\n准备环境\r\n创建上下文\r\n刷新上下文\r\n启动应用\r\n\r\n生命周期\r\n\r\n初始化\r\n启动\r\n运行\r\n关闭\r\n\r\n\r\n生活化比喻： - 就像”汽车启动”，需要多个步骤 -\r\n类似于”电脑开机”，需要加载系统 - 像是一个”工厂开工”，需要准备设备\r\n3. SpringBoot常用注解\r\n问题： SpringBoot有哪些重要的注解？\r\n详细答案： 1. 核心注解 - @SpringBootApplication：启动类注解\r\n- @EnableAutoConfiguration：启用自动配置\r\n- @ComponentScan：组件扫描\r\n\r\n功能注解\r\n\r\n@RestController：REST控制器\r\n@Service：服务层\r\n@Repository：数据访问层\r\n@Autowired：依赖注入\r\n\r\n配置注解\r\n\r\n@Configuration：配置类\r\n@Bean：Bean定义\r\n@Value：属性注入\r\n\r\n\r\n生活化比喻： - 就像”标签”，标识物品的用途 -\r\n类似于”说明书”，指导如何使用 - 像是一个”地图”，指引方向\r\n六、实战技巧\r\n1. 异常处理\r\n全局异常处理： @ControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(Exception.class)    public ResponseEntity&lt;ErrorResponse&gt; handleException(Exception e) &#123;        ErrorResponse response = new ErrorResponse(            HttpStatus.INTERNAL_SERVER_ERROR.value(),            e.getMessage()        );        return new ResponseEntity&lt;&gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);    &#125;&#125;\r\n异常处理策略： 1. 统一异常处理 2. 自定义异常类 3.\r\n异常日志记录 4. 友好错误提示\r\n生活化比喻： - 就像”急救中心”，处理各种紧急情况 -\r\n类似于”保险理赔”，处理各种意外 - 像是一个”故障维修”，解决各种问题\r\n2. 统一响应\r\n响应封装： public class ApiResponse&lt;T&gt; &#123;    private int code;    private String message;    private T data;        public static &lt;T&gt; ApiResponse&lt;T&gt; success(T data) &#123;        return new ApiResponse&lt;&gt;(200, &quot;success&quot;, data);    &#125;        public static &lt;T&gt; ApiResponse&lt;T&gt; error(int code, String message) &#123;        return new ApiResponse&lt;&gt;(code, message, null);    &#125;&#125;\r\n响应规范： 1. 统一状态码 2. 统一消息格式 3.\r\n统一数据结构 4. 统一错误处理\r\n生活化比喻： - 就像”快递单”，统一记录信息 -\r\n类似于”发票”，统一记录交易 - 像是一个”成绩单”，统一记录成绩\r\n3. 日志处理\r\n日志切面： @Slf4j@Componentpublic class LogAspect &#123;    @Around(&quot;execution(* com.example.service.*.*(..))&quot;)    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;        long start = System.currentTimeMillis();        Object result = joinPoint.proceed();        long end = System.currentTimeMillis();        log.info(&quot;方法执行时间：&#123;&#125;ms&quot;, end - start);        return result;    &#125;&#125;\r\n日志策略： 1. 分级日志 2. 异步日志 3. 日志轮转 4.\r\n日志聚合\r\n生活化比喻： - 就像”日记本”，记录每天的事情 -\r\n类似于”监控录像”，记录所有活动 - 像是一个”记账本”，记录所有交易\r\n七、进阶主题\r\n1. 微服务开发\r\n微服务特性： 1. 服务注册与发现 - Eureka - Nacos -\r\nConsul\r\n\r\n负载均衡\r\n\r\nRibbon\r\nLoadBalancer\r\n自定义策略\r\n\r\n服务熔断\r\n\r\nHystrix\r\nResilience4j\r\nSentinel\r\n\r\n分布式配置\r\n\r\nConfig Server\r\nNacos Config\r\nApollo\r\n\r\n\r\n生活化比喻： - 就像”连锁店”，每个店独立运营 -\r\n类似于”快递网络”，多个网点协同 - 像是一个”城市系统”，多个区域配合\r\n2. 响应式编程\r\n响应式特性： 1. WebFlux - 非阻塞IO - 事件驱动 -\r\n背压机制\r\n\r\n响应式数据访问\r\n\r\nR2DBC\r\nMongoDB\r\nRedis\r\n\r\n响应式消息\r\n\r\nKafka\r\nRabbitMQ\r\nRocketMQ\r\n\r\n\r\n生活化比喻： - 就像”自助餐厅”，顾客自取食物 -\r\n类似于”流水线”，产品自动流转 - 像是一个”自动售货机”，按需提供服务\r\n3. 云原生开发\r\n云原生特性： 1. Docker支持 - 容器化 - 镜像构建 -\r\n容器编排\r\n\r\nKubernetes部署\r\n\r\n服务编排\r\n自动扩缩容\r\n服务发现\r\n\r\n云服务集成\r\n\r\nAWS\r\nAzure\r\nGCP\r\n\r\n\r\n生活化比喻： - 就像”集装箱”，标准化运输 -\r\n类似于”乐高积木”，模块化组装 - 像是一个”云工厂”，弹性生产\r\n"},{"title":"Java常用类库总结","url":"/2025/03/14/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E6%80%BB%E7%BB%93/","content":"Java常用类库总结\r\n一、字符串处理类\r\n1. String类\r\n特点： - 不可变性（immutable） - 字符串常量池 -\r\n线程安全\r\n常用方法： // 字符串操作String str = &quot;Hello World&quot;;str.length();           // 获取长度str.substring(0, 5);    // 截取子串str.trim();            // 去除首尾空格str.split(&quot;,&quot;);        // 分割字符串str.replace(&quot;l&quot;, &quot;L&quot;); // 替换字符// 字符串比较str.equals(&quot;Hello&quot;);   // 内容比较str.equalsIgnoreCase(&quot;hello&quot;); // 忽略大小写比较str.startsWith(&quot;He&quot;);  // 前缀判断str.endsWith(&quot;ld&quot;);    // 后缀判断// 字符串查找str.indexOf(&quot;o&quot;);      // 查找字符位置str.contains(&quot;World&quot;); // 包含判断\r\n2. StringBuilder和StringBuffer\r\n特点： - StringBuilder：非线程安全，性能好 -\r\nStringBuffer：线程安全，性能较差\r\n使用场景： // 字符串拼接StringBuilder sb = new StringBuilder();sb.append(&quot;Hello&quot;);sb.append(&quot; &quot;);sb.append(&quot;World&quot;);String result = sb.toString();// 链式调用StringBuilder sb = new StringBuilder()    .append(&quot;Hello&quot;)    .append(&quot; &quot;)    .append(&quot;World&quot;);\r\n二、日期时间类\r\n1.\r\nLocalDate/LocalTime/LocalDateTime\r\n特点： - 不可变性 - 线程安全 - 更直观的API\r\n常用方法： // 获取当前日期时间LocalDate today = LocalDate.now();LocalTime now = LocalTime.now();LocalDateTime dateTime = LocalDateTime.now();// 日期操作LocalDate tomorrow = today.plusDays(1);LocalDate lastMonth = today.minusMonths(1);// 日期格式化DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);String formatted = today.format(formatter);// 日期比较boolean isAfter = today.isAfter(tomorrow);boolean isBefore = today.isBefore(tomorrow);\r\n2. DateTimeFormatter\r\n特点： - 线程安全 - 预定义格式 - 自定义格式\r\n使用示例： // 预定义格式DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE;String formatted = dateTime.format(formatter);// 自定义格式DateTimeFormatter customFormatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);String customFormatted = dateTime.format(customFormatter);\r\n三、数值处理类\r\n1. Math类\r\n常用方法： // 数学运算Math.abs(-10);     // 绝对值Math.max(10, 20);  // 最大值Math.min(10, 20);  // 最小值Math.round(3.14);  // 四舍五入Math.floor(3.14);  // 向下取整Math.ceil(3.14);   // 向上取整// 随机数Math.random();     // 0-1之间的随机数\r\n2. Random类\r\n特点： - 伪随机数生成器 - 可设置种子 -\r\n多种随机数类型\r\n使用示例： Random random = new Random();// 生成随机数int randomInt = random.nextInt(100);    // 0-99double randomDouble = random.nextDouble(); // 0-1boolean randomBoolean = random.nextBoolean();// 设置种子Random seededRandom = new Random(42L);\r\n四、集合类\r\n1. Collections工具类\r\n常用方法： List&lt;String&gt; list = new ArrayList&lt;&gt;();// 排序Collections.sort(list);Collections.sort(list, Collections.reverseOrder());// 查找int index = Collections.binarySearch(list, &quot;key&quot;);// 填充Collections.fill(list, &quot;default&quot;);// 同步包装List&lt;String&gt; syncList = Collections.synchronizedList(list);\r\n2. Arrays工具类\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\nequals(arr1, arr2)\r\n比较两个数组是否相等\r\n\r\n\r\nsort(arr)\r\n对数组元素进行从小到大排序\r\n\r\n\r\ntoString(arr)\r\n将数组转换成字符串\r\n\r\n\r\nfill(arr, value)\r\n将 value 值赋给数组中的每一个元素\r\n\r\n\r\nfill(arr, start, end, value)\r\n将 value 值赋给数组中指定范围的元素\r\n\r\n\r\ncopyOf(arr, length)\r\n把数组复制成指定长度的新数组\r\n\r\n\r\ncopyOfRange(arr, start, end)\r\n将数组的指定范围复制到新数组中\r\n\r\n\r\nbinarySearch(arr, value)\r\n查找数组元素，返回下标\r\n\r\n\r\n\r\n常用方法：\r\nint[] array = &#123;1, 2, 3, 4, 5&#125;;// 排序Arrays.sort(array);// 二分查找int index = Arrays.binarySearch(array, 3);// 填充Arrays.fill(array, 0);// 复制int[] copy = Arrays.copyOf(array, array.length);\r\n五、IO类\r\n1. File类\r\n常用方法： File file = new File(&quot;test.txt&quot;);// 文件操作file.exists();           // 是否存在file.isFile();          // 是否是文件file.isDirectory();     // 是否是目录file.createNewFile();   // 创建文件file.delete();          // 删除文件file.mkdir();           // 创建目录// 文件信息file.getName();         // 文件名file.getPath();         // 路径file.length();          // 文件大小file.lastModified();    // 最后修改时间\r\n2. 流操作\r\n字节流： // 文件复制try (FileInputStream fis = new FileInputStream(&quot;source.txt&quot;);     FileOutputStream fos = new FileOutputStream(&quot;target.txt&quot;)) &#123;    byte[] buffer = new byte[1024];    int length;    while ((length = fis.read(buffer)) &gt; 0) &#123;        fos.write(buffer, 0, length);    &#125;&#125;\r\n字符流： // 文本文件读写try (BufferedReader reader = new BufferedReader(new FileReader(&quot;input.txt&quot;));     BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;output.txt&quot;))) &#123;    String line;    while ((line = reader.readLine()) != null) &#123;        writer.write(line);        writer.newLine();    &#125;&#125;\r\n六、反射类\r\n1. Class类\r\n常用方法： // 获取Class对象Class&lt;?&gt; clazz = String.class;Class&lt;?&gt; clazz2 = Class.forName(&quot;java.lang.String&quot;);// 创建实例Object obj = clazz.newInstance();// 获取方法Method method = clazz.getMethod(&quot;length&quot;);// 获取字段Field field = clazz.getDeclaredField(&quot;value&quot;);// 获取构造器Constructor&lt;?&gt; constructor = clazz.getConstructor();\r\n2. 反射应用\r\n动态代理： // 创建代理Proxy.newProxyInstance(    target.getClass().getClassLoader(),    target.getClass().getInterfaces(),    (proxy, method, args) -&gt; &#123;        // 前置处理        Object result = method.invoke(target, args);        // 后置处理        return result;    &#125;);\r\n七、异常处理类\r\n1. 异常体系\r\ntry &#123;    // 可能抛出异常的代码&#125; catch (IOException e) &#123;    // 处理IO异常&#125; catch (Exception e) &#123;    // 处理其他异常&#125; finally &#123;    // 清理资源&#125;\r\n2. 自定义异常\r\npublic class CustomException extends Exception &#123;    public CustomException(String message) &#123;        super(message);    &#125;        public CustomException(String message, Throwable cause) &#123;        super(message, cause);    &#125;&#125;\r\n八、线程类\r\n1. Thread类\r\n创建线程： // 方式1：继承Threadclass MyThread extends Thread &#123;    @Override    public void run() &#123;        // 线程执行代码    &#125;&#125;// 方式2：实现Runnableclass MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        // 线程执行代码    &#125;&#125;// 方式3：Lambda表达式Thread thread = new Thread(() -&gt; &#123;    // 线程执行代码&#125;);\r\n2. 线程池\r\n// 创建线程池ExecutorService executor = Executors.newFixedThreadPool(5);// 提交任务executor.submit(() -&gt; &#123;    // 任务代码&#125;);// 关闭线程池executor.shutdown();\r\n九、网络类\r\n1. URL类\r\nURL url = new URL(&quot;https://www.example.com&quot;);// 获取连接URLConnection conn = url.openConnection();// 读取数据try (BufferedReader reader = new BufferedReader(        new InputStreamReader(conn.getInputStream()))) &#123;    String line;    while ((line = reader.readLine()) != null) &#123;        System.out.println(line);    &#125;&#125;\r\n2. Socket类\r\n// 服务器端ServerSocket server = new ServerSocket(8080);Socket socket = server.accept();// 客户端Socket client = new Socket(&quot;localhost&quot;, 8080);\r\n十、实用工具类\r\n1. Objects类\r\n// 空值检查Objects.isNull(obj);Objects.nonNull(obj);Objects.requireNonNull(obj);// 比较Objects.equals(obj1, obj2);Objects.deepEquals(obj1, obj2);\r\n2. Optional类\r\n// 创建OptionalOptional&lt;String&gt; optional = Optional.of(&quot;value&quot;);Optional&lt;String&gt; empty = Optional.empty();// 使用Optionaloptional.ifPresent(System.out::println);String value = optional.orElse(&quot;default&quot;);\r\n十一、最佳实践\r\n1. 性能优化\r\n\r\n使用StringBuilder代替String拼接\r\n使用try-with-resources自动关闭资源\r\n合理使用线程池\r\n使用批量操作代替循环操作\r\n\r\n2. 代码规范\r\n\r\n使用常量类管理常量\r\n使用枚举代替魔法数字\r\n使用Optional处理空值\r\n使用try-with-resources处理资源\r\n\r\n3. 异常处理\r\n\r\n使用具体的异常类型\r\n合理使用finally块\r\n记录异常日志\r\n自定义业务异常\r\n\r\n4. 线程安全\r\n\r\n使用线程安全的集合类\r\n使用synchronized关键字\r\n使用volatile关键字\r\n使用原子类\r\n\r\n"},{"title":"Tomcat","url":"/2024/05/03/Tomcat/","content":"环境搭建\r\n\r\nTomcat\r\nCATALINA_HOMED:\\software\\tomcat\\apache-tomcat-8.5.100path%CATALINA_HOME%\\bin\r\nstartup\r\n\r\ntomcat乱码解决\r\n\r\n\r\nimage-20250414142858732\r\n\r\n\r\n\r\ntomcat乱码解决\r\n\r\n    &lt;!-- server.xml    --&gt;&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot;               maxParameterCount=&quot;1000&quot;\t\t\t   URIEncoding=&quot;UTF-8&quot;               /&gt;\r\nlogging.properties\r\n#logging.propertiesjava.util.logging.ConsoleHandler.level = FINEjava.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatter#java.util.logging.ConsoleHandler.encoding = UTF-8java.util.logging.ConsoleHandler.encoding = GBK\r\nIDEA配置tomcat\r\n\r\n\r\n\r\nimage-20250414141904857\r\n\r\n\r\n\r\nimage-20250414142019442\r\n\r\n\r\n\r\nimage-20250414142152176\r\n\r\n\r\n\r\nimage-20250414142429660\r\n\r\n\r\n\r\nimage-20250414142736074\r\n\r\n\r\n\r\n"},{"title":"SpringBoot2-Vue3-Axios搭建myblog","url":"/2025/03/16/SpringBoot2-Vue3-Axios%E6%90%AD%E5%BB%BAmyblog/","content":"数据库设计\r\n数据库概述\r\n这是一个个人博客系统的数据库设计，采用关系型数据库MySQL实现。整个数据库设计遵循以下原则：\r\n- 数据完整性：使用主键、外键约束确保数据的一致性 -\r\n范式设计：遵循第三范式，减少数据冗余 -\r\n性能优化：合理设计索引，提高查询效率 -\r\n可扩展性：预留字段和表结构，便于未来功能扩展\r\n用户表 (users)\r\n-- 用户表：存储所有用户信息-- 包含用户身份验证、权限控制和个人资料管理的字段CREATE TABLE users (id BIGINT PRIMARY KEY AUTO_INCREMENT, -- 用户ID，主键username VARCHAR(50) NOT NULL UNIQUE, -- 用户名，唯一password VARCHAR(255) NOT NULL, -- 密码，存储加密后的值nickname VARCHAR(50), -- 用户昵称avatar VARCHAR(255), -- 头像URLemail VARCHAR(100) NOT NULL UNIQUE, -- 邮箱，唯一role ENUM(&#x27;admin&#x27;, &#x27;user&#x27;) DEFAULT &#x27;user&#x27;, -- 用户角色bio TEXT, -- 个人简介created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 更新时间last_login TIMESTAMP, -- 最后登录时间status TINYINT DEFAULT 1 COMMENT &#x27;1: active, 0: inactive&#x27; -- 账户状态);\r\n设计理念\r\n用户表是整个系统的核心表，存储所有用户信息。设计考虑了用户身份验证、权限控制和个人资料管理的需求。\r\n字段说明\r\n\r\nid: 自增主键，唯一标识每个用户\r\nusername: 用户登录名，要求唯一\r\npassword: 存储加密后的密码（不应存储明文密码）\r\nnickname: 用户昵称，用于显示\r\navatar: 用户头像图片的URL路径\r\nemail: 用户邮箱，用于通知和找回密码，要求唯一\r\nrole: 用户角色，区分管理员和普通用户\r\nbio: 用户个人简介\r\ncreated_at: 账户创建时间\r\nupdated_at: 账户信息最后更新时间\r\nlast_login: 最后登录时间\r\nstatus: 账户状态，用于禁用/启用账户\r\n\r\n后端实现思路\r\n\r\n用户注册：验证用户名和邮箱唯一性，对密码进行加密（使用bcrypt等算法），然后插入记录\r\n用户登录：根据用户名查询用户，验证密码，更新last_login时间\r\n权限控制：基于role字段实现权限管理，只有admin角色可以访问管理功能\r\n个人资料管理：提供API允许用户更新nickname、avatar、bio等信息\r\n账户状态管理：管理员可以通过修改status字段禁用/启用用户账户\r\n\r\n文章表 (articles)\r\n-- 文章表：存储博客文章内容-- 支持草稿、已发布、私密三种状态CREATE TABLE articles (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 文章ID，主键    title       VARCHAR(255) NOT NULL,              -- 文章标题    content     LONGTEXT NOT NULL,                  -- 文章内容，支持大量文本    excerpt     VARCHAR(500),                       -- 文章摘要    author_id   BIGINT NOT NULL,                    -- 作者ID    status      ENUM(&#x27;draft&#x27;, &#x27;published&#x27;, &#x27;private&#x27;) DEFAULT &#x27;draft&#x27;, -- 文章状态    views       INT DEFAULT 0,                      -- 浏览次数    likes       INT DEFAULT 0,                      -- 点赞数    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间    updated_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 更新时间    published_at TIMESTAMP,                         -- 发布时间    FOREIGN KEY (author_id) REFERENCES users(id)    -- 外键约束);\r\n设计理念\r\n文章表存储博客的核心内容，设计考虑了文章的创建、编辑、发布流程，以及统计数据的需求。\r\n字段说明\r\n\r\nid: 自增主键，唯一标识每篇文章\r\ntitle: 文章标题\r\ncontent:\r\n文章正文内容，使用LONGTEXT类型支持大量文本\r\nexcerpt: 文章摘要，用于列表页显示\r\nauthor_id: 作者ID，关联到users表\r\nstatus: 文章状态，支持草稿、已发布、私密三种状态\r\nviews: 浏览次数\r\nlikes: 点赞数\r\ncreated_at: 创建时间\r\nupdated_at: 最后更新时间\r\npublished_at:\r\n发布时间，只有状态为published时才有值\r\n\r\n后端实现思路\r\n\r\n文章CRUD：实现基本的创建、读取、更新、删除功能\r\n草稿管理：允许用户保存草稿，稍后继续编辑\r\n发布流程：当文章从draft变为published时，设置published_at为当前时间\r\n访问控制：\r\n\r\npublished状态的文章所有人可见\r\ndraft状态的文章只有作者可见\r\nprivate状态的文章只有作者可见，但可以通过特定链接分享\r\n\r\n统计功能：\r\n\r\n每次文章被访问时增加views计数\r\n实现点赞功能，增加likes计数\r\n\r\n\r\n分类表 (categories)\r\n-- 分类表：存储文章分类信息-- 支持多级分类结构CREATE TABLE categories (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 分类ID，主键    name        VARCHAR(50) NOT NULL,               -- 分类名称    slug        VARCHAR(50) NOT NULL UNIQUE,        -- URL友好的标识符    description TEXT,                               -- 分类描述    parent_id   BIGINT,                             -- 父分类ID，用于多级分类    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间    FOREIGN KEY (parent_id) REFERENCES categories(id) -- 外键约束，自引用);\r\n设计理念\r\n分类表用于对文章进行分类管理，支持多级分类结构，便于内容组织和导航。\r\n字段说明\r\n\r\nid: 自增主键，唯一标识每个分类\r\nname: 分类名称\r\nslug: URL友好的标识符，用于构建分类页面的URL\r\ndescription: 分类描述\r\nparent_id: 父分类ID，用于构建分类层次结构\r\ncreated_at: 创建时间\r\n\r\n后端实现思路\r\n\r\n分类管理：提供CRUD接口，只有管理员可以创建和修改分类\r\n层次结构：通过parent_id实现分类的树形结构，可以查询子分类和父分类\r\nURL构建：使用slug构建SEO友好的URL，如/category/tech\r\n分类统计：统计每个分类下的文章数量\r\n分类导航：在前端显示分类树，便于用户浏览\r\n\r\n标签表 (tags)\r\n-- 标签表：存储文章标签信息-- 支持通过标签对文章进行分类和检索CREATE TABLE tags (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 标签ID，主键    name        VARCHAR(50) NOT NULL,               -- 标签名称    slug        VARCHAR(50) NOT NULL UNIQUE,        -- URL友好的标识符    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- 创建时间);\r\n设计理念\r\n标签表用于实现文章的标签功能，与分类不同，标签是一种更灵活的内容组织方式，一篇文章可以有多个标签。\r\n字段说明\r\n\r\nid: 自增主键，唯一标识每个标签\r\nname: 标签名称\r\nslug: URL友好的标识符，用于构建标签页面的URL\r\ncreated_at: 创建时间\r\n\r\n后端实现思路\r\n\r\n标签管理：提供CRUD接口，管理员可以管理标签，作者可以在发文时创建新标签\r\n标签云：根据使用频率显示不同大小的标签\r\n相关文章：通过共同标签查找相关文章\r\nURL构建：使用slug构建SEO友好的URL，如/tag/javascript\r\n\r\n文章分类关联表\r\n(article_category)\r\n-- 文章分类关联表：实现文章与分类的多对多关系-- 一篇文章可以属于多个分类，一个分类可以包含多篇文章CREATE TABLE article_category (    article_id   BIGINT,                            -- 文章ID    category_id  BIGINT,                            -- 分类ID    PRIMARY KEY (article_id, category_id),          -- 联合主键，确保唯一性    FOREIGN KEY (article_id) REFERENCES articles(id) ON DELETE CASCADE,  -- 外键约束，级联删除    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE -- 外键约束，级联删除);\r\n设计理念\r\n这是一个多对多关系的中间表，用于关联文章和分类。一篇文章可以属于多个分类，一个分类可以包含多篇文章。\r\n字段说明\r\n\r\narticle_id: 文章ID，关联到articles表\r\ncategory_id: 分类ID，关联到categories表\r\n联合主键(article_id,\r\ncategory_id)确保一篇文章在一个分类中只出现一次\r\n\r\n后端实现思路\r\n\r\n关联管理：在文章创建和更新时，同时更新分类关联\r\n级联删除：当文章或分类被删除时，自动删除关联记录\r\n分类文章列表：通过此表查询特定分类下的所有文章\r\n文章分类显示：通过此表查询文章所属的所有分类\r\n\r\n文章标签关联表 (article_tag)\r\n-- 文章标签关联表：实现文章与标签的多对多关系-- 一篇文章可以有多个标签，一个标签可以应用于多篇文章CREATE TABLE article_tag (    article_id  BIGINT,                           -- 文章ID    tag_id      BIGINT,                           -- 标签ID    PRIMARY KEY (article_id, tag_id),             -- 联合主键，确保唯一性    FOREIGN KEY (article_id) REFERENCES articles(id) ON DELETE CASCADE,  -- 外键约束，级联删除    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE           -- 外键约束，级联删除);\r\n设计理念\r\n这是一个多对多关系的中间表，用于关联文章和标签。一篇文章可以有多个标签，一个标签可以应用于多篇文章。\r\n字段说明\r\n\r\narticle_id: 文章ID，关联到articles表\r\ntag_id: 标签ID，关联到tags表\r\n联合主键(article_id, tag_id)确保一篇文章不会重复应用同一个标签\r\n\r\n后端实现思路\r\n\r\n关联管理：在文章创建和更新时，同时更新标签关联\r\n级联删除：当文章或标签被删除时，自动删除关联记录\r\n标签文章列表：通过此表查询包含特定标签的所有文章\r\n文章标签显示：通过此表查询文章的所有标签\r\n标签推荐：基于已有标签推荐相关标签\r\n\r\n评论表 (comments)\r\n-- 评论表：存储文章评论信息-- 支持嵌套评论（回复评论）和评论审核CREATE TABLE comments (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 评论ID，主键    content     TEXT NOT NULL,                      -- 评论内容    article_id  BIGINT NOT NULL,                    -- 所属文章ID    user_id     BIGINT NOT NULL,                    -- 评论者用户ID    parent_id   BIGINT,                             -- 父评论ID，用于嵌套评论    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间    status      ENUM(&#x27;pending&#x27;, &#x27;approved&#x27;, &#x27;spam&#x27;) DEFAULT &#x27;pending&#x27;, -- 评论状态    FOREIGN KEY (article_id) REFERENCES articles(id) ON DELETE CASCADE, -- 外键约束，级联删除    FOREIGN KEY (user_id) REFERENCES users(id),                         -- 外键约束    FOREIGN KEY (parent_id) REFERENCES comments(id)                     -- 外键约束);\r\n设计理念\r\n评论表用于实现文章评论功能，支持嵌套评论（回复评论），并包含审核机制防止垃圾评论。\r\n字段说明\r\n\r\nid: 自增主键，唯一标识每条评论\r\ncontent: 评论内容\r\narticle_id: 评论所属文章ID\r\nuser_id: 评论者用户ID\r\nparent_id: 父评论ID，用于实现嵌套评论\r\ncreated_at: 评论创建时间\r\nstatus: 评论状态，用于审核流程\r\n\r\n后端实现思路\r\n\r\n评论CRUD：实现基本的创建、读取、更新、删除功能\r\n嵌套评论：通过parent_id构建评论树，支持回复功能\r\n评论审核：\r\n\r\n新评论默认为pending状态\r\n管理员可以将评论标记为approved或spam\r\n只显示approved状态的评论\r\n\r\n通知系统：当评论被回复时，通知原评论作者\r\n反垃圾措施：实现基本的垃圾评论过滤\r\n\r\n照片表 (photos)\r\n-- 照片表：存储用户上传的图片信息-- 支持个人相册功能和隐私控制CREATE TABLE photos (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 照片ID，主键    url         VARCHAR(255) NOT NULL,              -- 照片URL路径    description TEXT,                               -- 照片描述    user_id     BIGINT NOT NULL,                    -- 上传者用户ID    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 上传时间    status      ENUM(&#x27;private&#x27;, &#x27;public&#x27;) DEFAULT &#x27;public&#x27;, -- 照片状态    FOREIGN KEY (user_id) REFERENCES users(id)      -- 外键约束);\r\n设计理念\r\n照片表用于存储用户上传的图片信息，支持个人相册功能，可以在博客中展示生活照片。\r\n字段说明\r\n\r\nid: 自增主键，唯一标识每张照片\r\nurl: 照片的URL路径\r\ndescription: 照片描述\r\nuser_id: 上传者用户ID\r\ncreated_at: 上传时间\r\nstatus: 照片状态，控制可见性\r\n\r\n后端实现思路\r\n\r\n图片上传：\r\n\r\n实现文件上传功能，支持常见图片格式\r\n生成缩略图，优化加载速度\r\n存储原图和处理后的图片路径\r\n\r\n相册管理：\r\n\r\n按时间或自定义分组显示照片\r\n支持批量操作（删除、修改状态等）\r\n\r\n隐私控制：\r\n\r\nprivate状态的照片只有上传者可见\r\npublic状态的照片所有人可见\r\n\r\n前端展示：\r\n\r\n支持照片墙、轮播图等多种展示方式\r\n实现照片预览和放大功能\r\n\r\n\r\n系统设置表 (settings)\r\n-- 系统设置表：存储全局配置信息-- 采用键值对形式，便于扩展和管理CREATE TABLE settings (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 设置ID，主键    key_name    VARCHAR(50) NOT NULL UNIQUE,        -- 设置键名，唯一    value       TEXT,                               -- 设置值    type        VARCHAR(20) DEFAULT &#x27;string&#x27;,       -- 值类型    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间    updated_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -- 更新时间);\r\n设计理念\r\n系统设置表用于存储全局配置信息，采用键值对的形式，便于扩展和管理。\r\n字段说明\r\n\r\nid: 自增主键\r\nkey_name: 设置项的键名，唯一\r\nvalue: 设置项的值\r\ntype: 值的数据类型，用于前端表单验证和显示\r\ncreated_at: 创建时间\r\nupdated_at: 更新时间\r\n\r\n后端实现思路\r\n\r\n设置管理：\r\n\r\n提供管理界面修改设置\r\n支持不同类型的设置项（文本、数字、布尔值、JSON等）\r\n\r\n缓存机制：\r\n\r\n将设置缓存在内存中，减少数据库查询\r\n设置更新时刷新缓存\r\n\r\n应用配置：\r\n\r\n网站标题、描述、关键词等SEO相关设置\r\n主题颜色、布局等外观设置\r\n每页显示文章数等分页设置\r\n\r\n功能开关：\r\n\r\n控制某些功能的开启/关闭\r\n如评论功能、注册功能等\r\n\r\n\r\n友情链接表 (links)\r\n-- 友情链接表：管理博客的友情链接-- 支持自定义排序和状态控制CREATE TABLE links (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 链接ID，主键    name        VARCHAR(50) NOT NULL,               -- 链接名称    url         VARCHAR(255) NOT NULL,              -- 链接URL    description TEXT,                               -- 链接描述    logo        VARCHAR(255),                       -- 链接网站logo    sort_order  INT DEFAULT 0,                      -- 排序顺序    status      TINYINT DEFAULT 1 COMMENT &#x27;1: active, 0: inactive&#x27;, -- 链接状态    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间    updated_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -- 更新时间);\r\n设计理念\r\n友情链接表用于管理博客的友情链接，支持自定义排序和状态控制。\r\n字段说明\r\n\r\nid: 自增主键\r\nname: 链接名称\r\nurl: 链接URL\r\ndescription: 链接描述\r\nlogo: 链接网站的logo图片URL\r\nsort_order: 排序顺序，数值越小越靠前\r\nstatus: 链接状态，控制是否显示\r\ncreated_at: 创建时间\r\nupdated_at: 更新时间\r\n\r\n后端实现思路\r\n\r\n链接管理：\r\n\r\n提供CRUD接口，只有管理员可以管理友情链接\r\n支持拖拽排序\r\n\r\n状态控制：\r\n\r\n可以临时禁用某些链接而不删除\r\n定期检查链接有效性，自动标记失效链接\r\n\r\n前端展示：\r\n\r\n在侧边栏或页脚展示友情链接\r\n可以按分类展示不同类型的链接\r\n\r\n\r\n访问日志表 (visit_logs)\r\n-- 访问日志表：记录网站访问情况-- 用于统计分析和安全监控CREATE TABLE visit_logs (    id          BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 日志ID，主键    ip          VARCHAR(50),                        -- 访问者IP    user_agent  VARCHAR(255),                       -- 浏览器和系统信息    url         VARCHAR(255),                       -- 访问的URL    user_id     BIGINT,                             -- 访问者用户ID（如已登录）    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 访问时间    FOREIGN KEY (user_id) REFERENCES users(id)      -- 外键约束);\r\n设计理念\r\n访问日志表用于记录网站访问情况，便于统计分析和安全监控。\r\n字段说明\r\n\r\nid: 自增主键\r\nip: 访问者IP地址\r\nuser_agent: 浏览器和操作系统信息\r\nurl: 访问的URL路径\r\nuser_id: 访问者用户ID（如果已登录）\r\ncreated_at: 访问时间\r\n\r\n后端实现思路\r\n\r\n日志记录：\r\n\r\n通过中间件记录每次请求\r\n可以设置过滤规则，不记录静态资源请求\r\n\r\n访问统计：\r\n\r\n统计PV（页面浏览量）和UV（独立访客数）\r\n分析热门页面和访问趋势\r\n\r\n用户行为分析：\r\n\r\n跟踪用户浏览路径\r\n分析用户兴趣偏好\r\n\r\n安全监控：\r\n\r\n检测异常访问模式\r\n识别潜在的攻击行为\r\n\r\n数据清理：\r\n\r\n定期归档或删除旧日志\r\n考虑使用分区表优化性能\r\n\r\n\r\n索引设计\r\n-- 文章表索引CREATE INDEX idx_articles_author ON articles(author_id);  -- 优化按作者查询CREATE INDEX idx_articles_status ON articles(status);     -- 优化按状态查询CREATE INDEX idx_articles_created ON articles(created_at); -- 优化按创建时间排序-- 分类表索引CREATE INDEX idx_categories_slug ON categories(slug);     -- 优化按slug查询CREATE INDEX idx_categories_parent ON categories(parent_id); -- 优化层次结构查询-- 标签表索引CREATE INDEX idx_tags_slug ON tags(slug);                 -- 优化按slug查询-- 评论表索引CREATE INDEX idx_comments_article ON comments(article_id); -- 优化按文章查询评论CREATE INDEX idx_comments_user ON comments(user_id);      -- 优化按用户查询评论CREATE INDEX idx_comments_parent ON comments(parent_id);  -- 优化嵌套评论查询-- 照片表索引CREATE INDEX idx_photos_user ON photos(user_id);          -- 优化按用户查询照片CREATE INDEX idx_photos_status ON photos(status);         -- 优化按状态查询照片-- 访问日志索引CREATE INDEX idx_visit_logs_user ON visit_logs(user_id);  -- 优化按用户查询日志CREATE INDEX idx_visit_logs_created ON visit_logs(created_at); -- 优化按时间查询日志\r\n索引设计理念\r\n索引是提高查询性能的关键，本设计根据常见查询模式添加了适当的索引。\r\n索引说明\r\n\r\n外键索引：对所有外键字段创建索引，优化关联查询\r\n查询条件索引：对常用查询条件创建索引，如status字段\r\n排序索引：对常用排序字段创建索引，如created_at\r\n唯一索引：对需要唯一性约束的字段创建唯一索引，如slug\r\n\r\n性能优化思路\r\n\r\n复合索引：对经常一起使用的多个字段创建复合索引\r\n索引监控：定期分析索引使用情况，删除不必要的索引\r\n查询优化：编写高效的SQL查询，充分利用索引\r\n分页优化：使用索引优化大数据量的分页查询\r\n\r\n示例数据\r\n-- 插入管理员用户INSERT INTO users (username, password, nickname, email, role, bio) VALUES (&#x27;admin&#x27;, &#x27;hashed_password&#x27;, &#x27;LuoTao&#x27;, &#x27;admin@example.com&#x27;, &#x27;admin&#x27;, &#x27;热爱编程和技术分享的开发者，专注于Web前端开发。&#x27;);-- 插入示例分类INSERT INTO categories (name, slug, description) VALUES(&#x27;技术&#x27;, &#x27;tech&#x27;, &#x27;技术相关文章&#x27;),(&#x27;生活&#x27;, &#x27;life&#x27;, &#x27;生活随笔&#x27;),(&#x27;教程&#x27;, &#x27;tutorial&#x27;, &#x27;技术教程&#x27;);-- 插入示例标签INSERT INTO tags (name, slug) VALUES(&#x27;Vue.js&#x27;, &#x27;vuejs&#x27;),(&#x27;JavaScript&#x27;, &#x27;javascript&#x27;),(&#x27;CSS&#x27;, &#x27;css&#x27;),(&#x27;生活感悟&#x27;, &#x27;life-thoughts&#x27;);-- 插入示例文章INSERT INTO articles (title, content, excerpt, author_id, status, published_at) VALUES(&#x27;开始使用 Vue.js 构建现代化网站&#x27;, &#x27;文章内容...&#x27;, &#x27;Vue.js 是一个流行的 JavaScript 框架，它可以帮助我们构建交互式的 Web 应用...&#x27;, 1, &#x27;published&#x27;, NOW()),(&#x27;理解 Vue Router 的核心概念&#x27;, &#x27;文章内容...&#x27;, &#x27;路由是单页应用程序的重要组成部分，Vue Router 提供了强大的路由功能...&#x27;, 1, &#x27;published&#x27;, NOW()),(&#x27;使用 Composition API 优化代码&#x27;, &#x27;文章内容...&#x27;, &#x27;Vue 3 引入的 Composition API 为代码组织提供了更灵活的方式...&#x27;, 1, &#x27;published&#x27;, NOW());-- 插入文章分类关联INSERT INTO article_category (article_id, category_id) VALUES(1, 1), (1, 3), (2, 1), (2, 3), (3, 1);-- 插入文章标签关联INSERT INTO article_tag (article_id, tag_id) VALUES(1, 1), (1, 2), (2, 1), (3, 1);-- 插入示例照片INSERT INTO photos (url, description, user_id) VALUES(&#x27;/photos/photo1.jpg&#x27;, &#x27;周末远足&#x27;, 1),(&#x27;/photos/photo2.jpg&#x27;, &#x27;读书时光&#x27;, 1),(&#x27;/photos/photo3.jpg&#x27;, &#x27;咖啡时光&#x27;, 1),(&#x27;/photos/photo4.jpg&#x27;, &#x27;coding日常&#x27;, 1);-- 插入系统设置INSERT INTO settings (key_name, value, type) VALUES(&#x27;site_name&#x27;, &#x27;LuoTao\\&#x27;s Blog&#x27;, &#x27;string&#x27;),(&#x27;site_description&#x27;, &#x27;分享技术，记录生活&#x27;, &#x27;string&#x27;),(&#x27;theme_color&#x27;, &#x27;#3498db&#x27;, &#x27;string&#x27;),(&#x27;posts_per_page&#x27;, &#x27;10&#x27;, &#x27;integer&#x27;);\r\n后端API设计建议\r\n用户相关API\r\n\r\nPOST /api/auth/register - 用户注册\r\nPOST /api/auth/login - 用户登录\r\nGET /api/auth/profile - 获取当前用户信息\r\nPUT /api/auth/profile - 更新用户信息\r\nGET /api/users/:id - 获取指定用户公开信息\r\n\r\n文章相关API\r\n\r\nGET /api/articles - 获取文章列表（支持分页、筛选）\r\nGET /api/articles/:id - 获取文章详情\r\nPOST /api/articles - 创建文章\r\nPUT /api/articles/:id - 更新文章\r\nDELETE /api/articles/:id - 删除文章\r\nPOST /api/articles/:id/like - 点赞文章\r\n\r\n分类相关API\r\n\r\nGET /api/categories - 获取分类列表\r\nGET /api/categories/:id - 获取分类详情\r\nGET /api/categories/:id/articles -\r\n获取分类下的文章\r\nPOST /api/categories - 创建分类\r\nPUT /api/categories/:id - 更新分类\r\nDELETE /api/categories/:id - 删除分类\r\n\r\n标签相关API\r\n\r\nGET /api/tags - 获取标签列表\r\nGET /api/tags/:id/articles - 获取标签下的文章\r\nPOST /api/tags - 创建标签\r\nPUT /api/tags/:id - 更新标签\r\nDELETE /api/tags/:id - 删除标签\r\n\r\n评论相关API\r\n\r\nGET /api/articles/:id/comments - 获取文章评论\r\nPOST /api/articles/:id/comments - 发表评论\r\nPUT /api/comments/:id - 更新评论\r\nDELETE /api/comments/:id - 删除评论\r\nPOST /api/comments/:id/reply - 回复评论\r\n\r\n照片相关API\r\n\r\nGET /api/photos - 获取照片列表\r\nPOST /api/photos - 上传照片\r\nPUT /api/photos/:id - 更新照片信息\r\nDELETE /api/photos/:id - 删除照片\r\n\r\n系统设置API\r\n\r\nGET /api/settings - 获取系统设置\r\nPUT /api/settings - 更新系统设置\r\n\r\n前后端交互实现建议\r\n数据获取与展示\r\n\r\n首页文章列表：\r\n\r\n前端通过GET /api/articles?page=1&amp;limit=10获取最新文章\r\n后端返回分页数据，包含文章基本信息和作者信息\r\n前端渲染文章列表，支持懒加载更多文章\r\n\r\n分类/标签页：\r\n\r\n前端通过GET /api/categories/:id/articles或GET /api/tags/:id/articles获取特定分类或标签下的文章\r\n后端返回分页数据，同时返回分类/标签的详细信息\r\n前端渲染文章列表，并显示分类/标签信息\r\n\r\n文章详情页：\r\n\r\n前端通过GET /api/articles/:id获取文章详情\r\n后端返回文章内容、作者信息、分类、标签等完整数据\r\n后端同时增加文章的views计数\r\n前端渲染文章内容，支持Markdown格式\r\n\r\n评论系统：\r\n\r\n前端通过GET /api/articles/:id/comments获取文章评论\r\n后端返回评论数据，包括嵌套结构\r\n前端渲染评论树，支持回复功能\r\n用户发表评论时，前端发送POST /api/articles/:id/comments请求\r\n\r\n\r\n用户认证与授权\r\n\r\n登录流程：\r\n\r\n用户提交用户名和密码\r\n后端验证凭据，生成JWT令牌\r\n前端存储令牌，后续请求携带令牌\r\n实现自动登录和令牌刷新机制\r\n\r\n权限控制：\r\n\r\n基于用户角色控制页面访问权限\r\n管理员可以访问管理后台\r\n普通用户只能管理自己的内容\r\n未登录用户只能查看公开内容\r\n\r\n\r\n数据管理与维护\r\n\r\n数据备份策略：\r\n\r\n每日自动备份数据库\r\n定期将备份文件转移到异地存储\r\n实现备份恢复机制\r\n\r\n数据清理策略：\r\n\r\n定期清理访问日志表\r\n对大表进行分区管理\r\n实现数据归档功能\r\n\r\n\r\n性能优化建议\r\n数据库优化\r\n\r\n查询优化：\r\n\r\n使用EXPLAIN分析查询执行计划\r\n优化复杂查询，避免全表扫描\r\n合理使用JOIN，避免过多连接\r\n\r\n缓存策略：\r\n\r\n使用Redis缓存热门数据\r\n实现查询缓存，减少数据库负载\r\n定期刷新缓存，保持数据一致性\r\n\r\n数据库配置：\r\n\r\n调整MySQL配置参数\r\n优化InnoDB缓冲池大小\r\n配置适当的连接池\r\n\r\n\r\n前端优化\r\n\r\n资源加载：\r\n\r\n使用CDN加速静态资源\r\n压缩CSS和JavaScript文件\r\n实现图片懒加载\r\n\r\n渲染优化：\r\n\r\n使用虚拟滚动处理长列表\r\n实现组件懒加载\r\n优化DOM操作，减少重排重绘\r\n\r\n用户体验：\r\n\r\n添加加载状态提示\r\n实现平滑过渡动画\r\n优化表单交互体验\r\n\r\n\r\n基于Vue3和Axios的用户注册和登录功能实现\r\n1. 项目概述\r\n本文档详细记录了使用Vue\r\n3和Axios实现用户注册和登录功能的完整过程。该功能是博客系统的基础组件，为用户提供账号创建和身份验证服务。\r\n2. 技术栈选择\r\n\r\n前端框架：Vue 3 - 采用Composition\r\nAPI提供更灵活的组件逻辑组织方式\r\n状态管理：Pinia - Vue\r\n3官方推荐的状态管理库，替代Vuex\r\nHTTP客户端：Axios -\r\n功能强大的基于Promise的HTTP客户端\r\n路由管理：Vue Router 4 - 与Vue\r\n3配套的路由管理库\r\n构建工具：Vite -\r\n现代前端构建工具，提供更快的开发体验\r\n\r\n3. 项目结构设计\r\nvue-blog/├── src/│   ├── assets/           # 静态资源│   ├── components/       # 通用组件│   ├── stores/           # Pinia状态管理│   │   └── userStore.js  # 用户状态管理│   ├── views/            # 页面组件│   │   ├── LoginPage.vue # 登录页面│   │   └── RegisterPage.vue # 注册页面│   ├── router/           # 路由配置│   │   └── index.js      # 路由定义│   ├── App.vue           # 根组件│   └── main.js           # 应用入口├── vite.config.js        # Vite配置└── package.json          # 项目依赖\r\n4. 用户状态管理实现\r\n使用Pinia创建用户状态管理模块，处理用户注册、登录、获取用户信息和登出功能。\r\n// src/stores/userStore.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;;import axios from &#x27;axios&#x27;;// 创建axios实例const apiClient = axios.create(&#123;  baseURL: import.meta.env.VITE_API_URL || &#x27;/api&#x27;,  headers: &#123;    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;  &#125;&#125;);// 请求拦截器，添加认证tokenapiClient.interceptors.request.use(config =&gt; &#123;  const token = localStorage.getItem(&#x27;token&#x27;);  if (token) &#123;    config.headers.Authorization = `Bearer $&#123;token&#125;`;  &#125;  return config;&#125;);export const useUserStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; (&#123;    currentUser: null,    isAuthenticated: false,    loading: false,    error: null  &#125;),    getters: &#123;    isAdmin: (state) =&gt; state.currentUser?.role === &#x27;admin&#x27;,  &#125;,    actions: &#123;    // 用户注册    async register(userData) &#123;      this.loading = true;      this.error = null;            try &#123;        const response = await apiClient.post(&#x27;/auth/register&#x27;, userData);        return response.data;      &#125; catch (error) &#123;        this.error = error.response?.data?.message || &#x27;注册失败&#x27;;        throw error;      &#125; finally &#123;        this.loading = false;      &#125;    &#125;,        // 用户登录    async login(credentials) &#123;      this.loading = true;      this.error = null;            try &#123;        const response = await apiClient.post(&#x27;/auth/login&#x27;, credentials);        const &#123; token, user &#125; = response.data;                localStorage.setItem(&#x27;token&#x27;, token);        this.currentUser = user;        this.isAuthenticated = true;                return user;      &#125; catch (error) &#123;        this.error = error.response?.data?.message || &#x27;登录失败&#x27;;        throw error;      &#125; finally &#123;        this.loading = false;      &#125;    &#125;,        // 获取当前用户信息    async fetchCurrentUser() &#123;      if (!localStorage.getItem(&#x27;token&#x27;)) &#123;        this.isAuthenticated = false;        this.currentUser = null;        return null;      &#125;            this.loading = true;            try &#123;        const response = await apiClient.get(&#x27;/auth/profile&#x27;);        this.currentUser = response.data;        this.isAuthenticated = true;        return response.data;      &#125; catch (error) &#123;        this.error = error.response?.data?.message || &#x27;获取用户信息失败&#x27;;        this.isAuthenticated = false;        this.currentUser = null;        localStorage.removeItem(&#x27;token&#x27;);        throw error;      &#125; finally &#123;        this.loading = false;      &#125;    &#125;,        // 用户登出    logout() &#123;      localStorage.removeItem(&#x27;token&#x27;);      this.isAuthenticated = false;      this.currentUser = null;    &#125;  &#125;&#125;);\r\n5. 注册页面实现\r\n注册页面包含用户名、邮箱、昵称（可选）、密码和确认密码字段，并实现了前端表单验证。\r\n&lt;!-- src/views/RegisterPage.vue --&gt;&lt;template&gt;  &lt;div class=&quot;register-page&quot;&gt;    &lt;div class=&quot;register-container&quot;&gt;      &lt;h1 class=&quot;title&quot;&gt;创建账号&lt;/h1&gt;      &lt;div v-if=&quot;error&quot; class=&quot;error-alert&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt;            &lt;form @submit.prevent=&quot;handleRegister&quot; class=&quot;register-form&quot;&gt;        &lt;!-- 用户名输入 --&gt;        &lt;div class=&quot;form-group&quot;&gt;          &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;          &lt;input             id=&quot;username&quot;             v-model=&quot;form.username&quot;             type=&quot;text&quot;             required            :class=&quot;&#123;&#x27;is-invalid&#x27;: validationErrors.username&#125;&quot;          /&gt;          &lt;div v-if=&quot;validationErrors.username&quot; class=&quot;invalid-feedback&quot;&gt;            &#123;&#123; validationErrors.username &#125;&#125;          &lt;/div&gt;          &lt;small class=&quot;form-text&quot;&gt;用户名长度为3-20个字符，只能包含字母、数字和下划线&lt;/small&gt;        &lt;/div&gt;                &lt;!-- 邮箱输入 --&gt;        &lt;div class=&quot;form-group&quot;&gt;          &lt;label for=&quot;email&quot;&gt;邮箱&lt;/label&gt;          &lt;input             id=&quot;email&quot;             v-model=&quot;form.email&quot;             type=&quot;email&quot;             required            :class=&quot;&#123;&#x27;is-invalid&#x27;: validationErrors.email&#125;&quot;          /&gt;          &lt;div v-if=&quot;validationErrors.email&quot; class=&quot;invalid-feedback&quot;&gt;            &#123;&#123; validationErrors.email &#125;&#125;          &lt;/div&gt;        &lt;/div&gt;                &lt;!-- 昵称输入（可选） --&gt;        &lt;div class=&quot;form-group&quot;&gt;          &lt;label for=&quot;nickname&quot;&gt;昵称 (选填)&lt;/label&gt;          &lt;input             id=&quot;nickname&quot;             v-model=&quot;form.nickname&quot;             type=&quot;text&quot;          /&gt;        &lt;/div&gt;                &lt;!-- 密码输入 --&gt;        &lt;div class=&quot;form-group&quot;&gt;          &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;          &lt;input             id=&quot;password&quot;             v-model=&quot;form.password&quot;             type=&quot;password&quot;             required            :class=&quot;&#123;&#x27;is-invalid&#x27;: validationErrors.password&#125;&quot;          /&gt;          &lt;div v-if=&quot;validationErrors.password&quot; class=&quot;invalid-feedback&quot;&gt;            &#123;&#123; validationErrors.password &#125;&#125;          &lt;/div&gt;          &lt;small class=&quot;form-text&quot;&gt;密码长度至少为8个字符，必须包含字母和数字&lt;/small&gt;        &lt;/div&gt;                &lt;!-- 确认密码输入 --&gt;        &lt;div class=&quot;form-group&quot;&gt;          &lt;label for=&quot;confirmPassword&quot;&gt;确认密码&lt;/label&gt;          &lt;input             id=&quot;confirmPassword&quot;             v-model=&quot;form.confirmPassword&quot;             type=&quot;password&quot;             required            :class=&quot;&#123;&#x27;is-invalid&#x27;: validationErrors.confirmPassword&#125;&quot;          /&gt;          &lt;div v-if=&quot;validationErrors.confirmPassword&quot; class=&quot;invalid-feedback&quot;&gt;            &#123;&#123; validationErrors.confirmPassword &#125;&#125;          &lt;/div&gt;        &lt;/div&gt;                &lt;!-- 提交按钮 --&gt;        &lt;button type=&quot;submit&quot; class=&quot;btn-register&quot; :disabled=&quot;isLoading&quot;&gt;          &lt;span v-if=&quot;isLoading&quot;&gt;注册中...&lt;/span&gt;          &lt;span v-else&gt;注册&lt;/span&gt;        &lt;/button&gt;                &lt;!-- 登录链接 --&gt;        &lt;div class=&quot;login-link&quot;&gt;          已有账号？&lt;router-link to=&quot;/login&quot;&gt;立即登录&lt;/router-link&gt;        &lt;/div&gt;      &lt;/form&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive, computed &#125; from &#x27;vue&#x27;;import &#123; useRouter &#125; from &#x27;vue-router&#x27;;import &#123; useUserStore &#125; from &#x27;../stores/userStore&#x27;;const router = useRouter();const userStore = useUserStore();// 表单数据const form = reactive(&#123;  username: &#x27;&#x27;,  email: &#x27;&#x27;,  nickname: &#x27;&#x27;,  password: &#x27;&#x27;,  confirmPassword: &#x27;&#x27;&#125;);// 表单验证错误const validationErrors = reactive(&#123;  username: &#x27;&#x27;,  email: &#x27;&#x27;,  password: &#x27;&#x27;,  confirmPassword: &#x27;&#x27;&#125;);// 从store获取状态const error = computed(() =&gt; userStore.error);const isLoading = computed(() =&gt; userStore.loading);// 表单验证const validateForm = () =&gt; &#123;  let isValid = true;    // 重置验证错误  Object.keys(validationErrors).forEach(key =&gt; &#123;    validationErrors[key] = &#x27;&#x27;;  &#125;);    // 用户名验证  if (!/^[a-zA-Z0-9_]&#123;3,20&#125;$/.test(form.username)) &#123;    validationErrors.username = &#x27;用户名长度为3-20个字符，只能包含字母、数字和下划线&#x27;;    isValid = false;  &#125;    // 邮箱验证  if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(form.email)) &#123;    validationErrors.email = &#x27;请输入有效的邮箱地址&#x27;;    isValid = false;  &#125;    // 密码验证  if (!/^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]&#123;8,&#125;$/.test(form.password)) &#123;    validationErrors.password = &#x27;密码长度至少为8个字符，必须包含字母和数字&#x27;;    isValid = false;  &#125;    // 确认密码验证  if (form.password !== form.confirmPassword) &#123;    validationErrors.confirmPassword = &#x27;两次输入的密码不一致&#x27;;    isValid = false;  &#125;    return isValid;&#125;;// 处理注册const handleRegister = async () =&gt; &#123;  // 表单验证  if (!validateForm()) &#123;    return;  &#125;    try &#123;    // 准备注册数据，移除确认密码字段    const &#123; confirmPassword, ...registerData &#125; = form;        // 使用store的register action    await userStore.register(registerData);        // 注册成功，显示提示并跳转到登录页    router.push(&#123;      path: &#x27;/login&#x27;,      query: &#123; registered: &#x27;true&#x27; &#125;    &#125;);  &#125; catch (error) &#123;    // 错误已在store中处理    console.error(&#x27;Registration error:&#x27;, error);  &#125;&#125;;&lt;/script&gt;\r\n6. 登录页面实现\r\n登录页面包含用户名/邮箱和密码字段，并支持显示注册成功的提示信息。\r\n&lt;!-- src/views/LoginPage.vue --&gt;&lt;template&gt;  &lt;div class=&quot;login-page&quot;&gt;    &lt;div class=&quot;login-container&quot;&gt;      &lt;h1 class=&quot;title&quot;&gt;用户登录&lt;/h1&gt;            &lt;!-- 注册成功提示 --&gt;      &lt;div v-if=&quot;registrationSuccess&quot; class=&quot;success-alert&quot;&gt;        注册成功！请使用您的账号密码登录。      &lt;/div&gt;            &lt;div v-if=&quot;error&quot; class=&quot;error-alert&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt;            &lt;form @submit.prevent=&quot;handleLogin&quot; class=&quot;login-form&quot;&gt;        &lt;!-- 用户名/邮箱输入 --&gt;        &lt;div class=&quot;form-group&quot;&gt;          &lt;label for=&quot;username&quot;&gt;用户名或邮箱&lt;/label&gt;          &lt;input             id=&quot;username&quot;             v-model=&quot;form.username&quot;             type=&quot;text&quot;             required            placeholder=&quot;请输入用户名或邮箱&quot;          /&gt;        &lt;/div&gt;                &lt;!-- 密码输入 --&gt;        &lt;div class=&quot;form-group&quot;&gt;          &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;          &lt;input             id=&quot;password&quot;             v-model=&quot;form.password&quot;             type=&quot;password&quot;             required            placeholder=&quot;请输入密码&quot;          /&gt;        &lt;/div&gt;                &lt;!-- 提交按钮 --&gt;        &lt;div class=&quot;form-actions&quot;&gt;          &lt;button type=&quot;submit&quot; class=&quot;btn-login&quot; :disabled=&quot;isLoading&quot;&gt;            &lt;span v-if=&quot;isLoading&quot;&gt;登录中...&lt;/span&gt;            &lt;span v-else&gt;登录&lt;/span&gt;          &lt;/button&gt;        &lt;/div&gt;                &lt;!-- 注册链接 --&gt;        &lt;div class=&quot;register-link&quot;&gt;          还没有账号？&lt;router-link to=&quot;/register&quot;&gt;立即注册&lt;/router-link&gt;        &lt;/div&gt;      &lt;/form&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive, computed, onMounted &#125; from &#x27;vue&#x27;;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;;import &#123; useUserStore &#125; from &#x27;../stores/userStore&#x27;;const router = useRouter();const route = useRoute();const userStore = useUserStore();// 表单数据const form = reactive(&#123;  username: &#x27;&#x27;,  password: &#x27;&#x27;&#125;);// 注册成功标志const registrationSuccess = ref(false);// 从store获取状态const error = computed(() =&gt; userStore.error);const isLoading = computed(() =&gt; userStore.loading);// 组件挂载时检查URL参数onMounted(() =&gt; &#123;  // 检查URL参数，显示注册成功提示  if (route.query.registered === &#x27;true&#x27;) &#123;    registrationSuccess.value = true;  &#125;&#125;);// 处理登录const handleLogin = async () =&gt; &#123;  try &#123;    await userStore.login(form);    // 登录成功，跳转到首页    router.push(&#x27;/&#x27;);  &#125; catch (error) &#123;    // 错误已在store中处理    console.error(&#x27;Login error:&#x27;, error);  &#125;&#125;;&lt;/script&gt;\r\n7. 应用入口配置\r\n在应用入口文件中配置Axios、Pinia和Vue Router。\r\n// src/main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router from &#x27;./router&#x27;;import &#123; createPinia &#125; from &#x27;pinia&#x27;;import axios from &#x27;axios&#x27;;// 创建axios实例const apiClient = axios.create(&#123;  baseURL: import.meta.env.VITE_API_URL || &#x27;/api&#x27;,  headers: &#123;    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;  &#125;&#125;);// 请求拦截器，添加认证tokenapiClient.interceptors.request.use(config =&gt; &#123;  const token = localStorage.getItem(&#x27;token&#x27;);  if (token) &#123;    config.headers.Authorization = `Bearer $&#123;token&#125;`;  &#125;  return config;&#125;);const app = createApp(App);const pinia = createPinia();// 全局注册axiosapp.config.globalProperties.$axios = apiClient;app.use(router)   .use(pinia)   .mount(&#x27;#app&#x27;);\r\n8. 路由配置\r\n配置Vue Router，定义登录和注册页面的路由。\r\n// src/router/index.jsimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;Home&#x27;,    component: () =&gt; import(&#x27;../views/HomePage.vue&#x27;)  &#125;,  &#123;    path: &#x27;/login&#x27;,    name: &#x27;Login&#x27;,    component: () =&gt; import(&#x27;../views/LoginPage.vue&#x27;)  &#125;,  &#123;    path: &#x27;/register&#x27;,    name: &#x27;Register&#x27;,    component: () =&gt; import(&#x27;../views/RegisterPage.vue&#x27;)  &#125;,  // 其他路由...];const router = createRouter(&#123;  history: createWebHistory(),  routes,  scrollBehavior(to, from, savedPosition) &#123;    if (savedPosition) &#123;      return savedPosition;    &#125; else &#123;      return &#123; top: 0 &#125;;    &#125;  &#125;&#125;);export default router;\r\n9. Vite配置\r\n配置Vite构建工具，设置路径别名和API代理。\r\n// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [vue()],  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;)    &#125;  &#125;,  server: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;http://localhost:8080&#x27;,        changeOrigin: true      &#125;    &#125;  &#125;&#125;)\r\n10. 安全性考虑\r\n\r\n密码处理：\r\n\r\n前端不存储明文密码\r\n密码在后端使用BCrypt等算法加密存储\r\n密码验证在后端进行\r\n\r\nToken管理：\r\n\r\n使用JWT进行身份验证\r\nToken存储在localStorage中\r\n请求拦截器自动添加Token到请求头\r\n\r\n表单验证：\r\n\r\n前端实现基本的表单验证\r\n后端再次验证所有输入数据\r\n防止XSS和SQL注入攻击\r\n\r\n\r\n11. 用户体验优化\r\n\r\n加载状态：\r\n\r\n显示加载中状态，防止用户重复提交\r\n禁用提交按钮直到加载完成\r\n\r\n错误处理：\r\n\r\n显示友好的错误消息\r\n表单验证错误直接显示在相应字段下方\r\n\r\n成功反馈：\r\n\r\n注册成功后跳转到登录页并显示成功提示\r\n登录成功后跳转到首页\r\n\r\n\r\n12. 后续扩展方向\r\n\r\n记住我功能：允许用户选择保持登录状态\r\n社交媒体登录：集成第三方登录选项\r\n两步验证：增加额外的安全层\r\n密码重置：实现忘记密码功能\r\n用户资料管理：允许用户更新个人信息和头像\r\n\r\n13. 总结\r\n本实现使用Vue\r\n3和Axios成功构建了用户注册和登录功能，采用了现代前端开发最佳实践：\r\n\r\n使用Composition API组织组件逻辑\r\n使用Pinia进行状态管理\r\n实现了前端表单验证\r\n使用Axios处理HTTP请求\r\n实现了用户友好的错误处理和加载状态\r\n\r\n14. 后端开发过程\r\n14.1 技术栈选择\r\n后端采用Spring Boot框架实现RESTful\r\nAPI，为前端提供用户注册、登录和认证服务。\r\n\r\n核心框架：Spring Boot 2.6.x\r\n安全框架：Spring Security + JWT\r\n数据访问：MyBatis 3.x\r\n数据库：MySQL\r\n构建工具：Maven\r\n\r\n14.2 用户注册登录模块开发步骤\r\n1. 项目初始化与依赖配置\r\n首先在pom.xml中添加必要的依赖：\r\n&lt;!-- Spring Security --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- JWT --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Validation --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Lombok --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\r\n2. 数据库设计与实现\r\n创建用户表SQL脚本：\r\nCREATE TABLE users (    id BIGINT PRIMARY KEY AUTO_INCREMENT,    username VARCHAR(50) NOT NULL UNIQUE,    password VARCHAR(255) NOT NULL,    nickname VARCHAR(50),    avatar VARCHAR(255),    email VARCHAR(100) NOT NULL UNIQUE,    role VARCHAR(20) DEFAULT &#x27;user&#x27;,    bio TEXT,    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,    last_login TIMESTAMP NULL,    status TINYINT DEFAULT 1 COMMENT &#x27;1: active, 0: inactive&#x27;);\r\n3. 实体类与DTO设计\r\n创建用户实体类：\r\n@Datapublic class User &#123;    private Long id;    private String username;    private String password;    private String nickname;    private String avatar;    private String email;    private String role;    private String bio;    private LocalDateTime createdAt;    private LocalDateTime updatedAt;    private LocalDateTime lastLogin;    private Integer status;&#125;\r\n创建数据传输对象：\r\n@Datapublic class UserRegistrationDto &#123;    @NotBlank(message = &quot;用户名不能为空&quot;)    @Size(min = 3, max = 20, message = &quot;用户名长度必须在3-20个字符之间&quot;)    @Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;用户名只能包含字母、数字和下划线&quot;)    private String username;        @NotBlank(message = &quot;密码不能为空&quot;)    @Size(min = 8, message = &quot;密码长度至少为8个字符&quot;)    @Pattern(regexp = &quot;^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]&#123;8,&#125;$&quot;,              message = &quot;密码必须包含至少一个字母和一个数字&quot;)    private String password;        @NotBlank(message = &quot;邮箱不能为空&quot;)    @Email(message = &quot;邮箱格式不正确&quot;)    private String email;        private String nickname;&#125;\r\n4. 数据访问层实现\r\n创建MyBatis Mapper接口：\r\n@Mapperpublic interface UserMapper &#123;    User findById(Long id);    User findByUsername(String username);    User findByEmail(String email);    int existsByUsername(String username);    int existsByEmail(String email);    void insert(User user);    void update(User user);    void updateLastLogin(@Param(&quot;id&quot;) Long id, @Param(&quot;lastLogin&quot;) LocalDateTime lastLogin);&#125;\r\n配置XML映射文件：\r\n&lt;mapper namespace=&quot;com.luotao.demo.mapper.UserMapper&quot;&gt;    &lt;!-- 结果映射 --&gt;    &lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.luotao.demo.model.User&quot;&gt;        &lt;!-- 映射字段 --&gt;    &lt;/resultMap&gt;        &lt;!-- SQL语句定义 --&gt;    &lt;select id=&quot;findByUsername&quot; resultMap=&quot;userResultMap&quot;&gt;        SELECT * FROM users WHERE username = #&#123;username&#125;    &lt;/select&gt;        &lt;!-- 其他SQL语句... --&gt;&lt;/mapper&gt;\r\n5. 业务逻辑层实现\r\n创建用户服务接口：\r\npublic interface UserService &#123;    User registerUser(UserRegistrationDto registrationDto);    User findByUsername(String username);    User findByEmail(String email);    boolean existsByUsername(String username);    boolean existsByEmail(String email);    void updateUser(User user);    void updateLastLogin(Long id);&#125;\r\n实现用户服务：\r\n@Servicepublic class UserServiceImpl implements UserService &#123;    private final UserMapper userMapper;    private final PasswordEncoder passwordEncoder;        @Autowired    public UserServiceImpl(UserMapper userMapper, PasswordEncoder passwordEncoder) &#123;        this.userMapper = userMapper;        this.passwordEncoder = passwordEncoder;    &#125;        @Override    @Transactional    public User registerUser(UserRegistrationDto registrationDto) &#123;        // 检查用户名和邮箱是否已存在        // 创建新用户        // 加密密码        // 保存用户    &#125;        // 其他方法实现...&#125;\r\n6. JWT认证实现\r\n创建JWT令牌提供者：\r\n@Componentpublic class JwtTokenProvider &#123;    @Value(&quot;$&#123;security.jwt.token.secret-key:secret&#125;&quot;)    private String secretKey;        @Value(&quot;$&#123;security.jwt.token.expire-length:3600000&#125;&quot;)    private long validityInMilliseconds = 3600000; // 1h        private final UserDetailsService userDetailsService;        // 初始化方法    // 创建令牌方法    // 验证令牌方法    // 从请求中解析令牌方法&#125;\r\n创建JWT过滤器：\r\npublic class JwtTokenFilter extends OncePerRequestFilter &#123;    private JwtTokenProvider jwtTokenProvider;        // 构造函数        @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)            throws ServletException, IOException &#123;        // 从请求中获取令牌        // 验证令牌        // 设置认证信息    &#125;&#125;\r\n7. Spring Security配置\r\n配置安全相关设置：\r\n@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    private final JwtTokenProvider jwtTokenProvider;    private final UserDetailsService userDetailsService;        // 构造函数        @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        // 配置认证管理器    &#125;        @Override    protected void configure(HttpSecurity http) throws Exception &#123;        // 配置HTTP安全        // 禁用CSRF        // 配置无状态会话        // 配置请求授权        // 添加JWT过滤器    &#125;        @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception &#123;        // 暴露认证管理器Bean    &#125;        @Bean    public PasswordEncoder passwordEncoder() &#123;        // 配置密码编码器    &#125;&#125;\r\n8. 控制器实现\r\n创建认证控制器：\r\n@RestController@RequestMapping(&quot;/api/auth&quot;)public class AuthController &#123;    private final UserService userService;    private final AuthenticationManager authenticationManager;    private final JwtTokenProvider jwtTokenProvider;        // 构造函数        @PostMapping(&quot;/register&quot;)    public ResponseEntity&lt;?&gt; registerUser(@Valid @RequestBody UserRegistrationDto registrationDto) &#123;        // 注册用户    &#125;        @PostMapping(&quot;/login&quot;)    public ResponseEntity&lt;?&gt; login(@Valid @RequestBody LoginRequest loginRequest) &#123;        // 认证用户        // 生成JWT令牌        // 返回令牌和用户信息    &#125;        @GetMapping(&quot;/profile&quot;)    public ResponseEntity&lt;?&gt; getCurrentUser() &#123;        // 获取当前用户信息    &#125;&#125;\r\n9. 异常处理\r\n创建全局异常处理器：\r\n@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(ResourceAlreadyExistsException.class)    @ResponseStatus(HttpStatus.CONFLICT)    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleResourceAlreadyExistsException(ResourceAlreadyExistsException ex) &#123;        // 处理资源已存在异常    &#125;        @ExceptionHandler(MethodArgumentNotValidException.class)    @ResponseStatus(HttpStatus.BAD_REQUEST)    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) &#123;        // 处理参数验证异常    &#125;        // 处理其他异常...&#125;\r\n10. 跨域配置\r\n配置跨域请求：\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedOrigins(&quot;*&quot;)                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)                .allowedHeaders(&quot;*&quot;)                .allowCredentials(true)                .maxAge(3600);    &#125;&#125;\r\n14.3 安全性考虑\r\n\r\n密码安全：\r\n\r\n使用BCrypt算法加密存储密码\r\n不在任何地方存储或传输明文密码\r\n密码验证在服务端进行\r\n\r\nJWT安全：\r\n\r\n使用安全的密钥签名JWT令牌\r\n设置合理的令牌过期时间\r\n验证每个请求的令牌有效性\r\n\r\n输入验证：\r\n\r\n使用Bean Validation验证所有输入数据\r\n防止SQL注入和XSS攻击\r\n全局异常处理确保友好的错误响应\r\n\r\n\r\n14.4 性能优化\r\n\r\n数据库优化：\r\n\r\n为频繁查询的字段创建索引\r\n使用连接池管理数据库连接\r\n\r\n缓存策略：\r\n\r\n可以考虑使用Redis缓存热点数据\r\n减少数据库访问频率\r\n\r\n无状态设计：\r\n\r\n使用JWT实现无状态认证\r\n提高系统可扩展性\r\n\r\n\r\n14.5 后续扩展方向\r\n\r\n邮箱验证：实现注册邮箱验证功能\r\n密码重置：添加忘记密码和重置功能\r\n第三方登录：集成GitHub、Google等第三方登录\r\n用户资料管理：完善用户资料编辑功能\r\n权限管理：细化权限控制，实现基于角色的访问控制\r\n\r\n"},{"title":"SpringBoot-Vue.js-Axios搭建demo","url":"/2025/03/16/SpringBoot-Vue.js-Axios%E6%90%AD%E5%BB%BAdemo/","content":"区域管理系统 - 开发文档\r\n项目概述\r\n这是一个基于Spring Boot和MyBatis的Java\r\nWeb应用程序，名为”demo-luotaofun”。该项目使用Maven作为构建工具，采用了MVC架构模式，主要用于展示Spring\r\nBoot与MyBatis的集成使用。前端使用纯Vue.js\r\n3构建，实现了一个现代化的区域管理系统界面。\r\n项目结构\r\ndemo-luotaofun/├── src/                      # 源代码目录│   ├── main/                 # 主要代码│   │   ├── java/             # Java源代码│   │   │   └── com/luotao/demo/  # 主包│   │   │       ├── config/   # 配置类│   │   │       ├── dao/      # 数据访问层│   │   │       ├── demos/    # 示例代码│   │   │       ├── handler/  # 处理器│   │   │       ├── mybatis/  # MyBatis相关类│   │   │       ├── service/  # 服务层│   │   │       ├── web/      # Web控制器│   │   │       ├── DemoApplication.java  # 应用入口│   │   │       └── Hello.java            # 示例类│   │   └── resources/        # 资源文件│   │       ├── mapper/       # MyBatis映射文件│   │       ├── static/       # 静态资源│   │       │   ├── css/      # CSS样式文件│   │       │   ├── js/       # JavaScript文件│   │       │   └── index.html # 主页面│   │       ├── application.properties  # 应用配置│   │       └── MyBatis-config.xml      # MyBatis配置│   └── test/                 # 测试代码├── target/                   # 编译输出目录├── pom.xml                   # Maven配置文件└── HELP.md                   # 帮助文档\r\n详细开发过程\r\n1. 后端开发\r\n1.1 后端技术选型\r\n\r\nJava 8\r\nSpring Boot 2.6.13\r\nMyBatis 2.2.2\r\nMySQL数据库\r\nMaven构建工具\r\nC3P0连接池\r\n\r\n1.2 数据库设计\r\n设计了一个简单的Area实体类，包含以下字段： -\r\nareaId: 区域ID（主键） - areaName: 区域名称 -\r\npriority: 优先级 - createTime: 创建时间 -\r\nlastEditTime: 最后修改时间\r\n表设计与实体类的创建\r\n/* Navicat Premium Data Transfer Source Server         : mariaDB_127.0.0.1 Source Server Type    : MariaDB Source Server Version : 100307 Source Host           : 127.0.0.1:3306 Source Schema         : demo Target Server Type    : MariaDB Target Server Version : 100307 File Encoding         : 65001 Date: 16/03/2025 14:14:52*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tb_area-- ----------------------------DROP TABLE IF EXISTS `tb_area`;CREATE TABLE `tb_area`  (  `area_id` int(2) NOT NULL AUTO_INCREMENT,  `area_name` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `priority` int(2) NOT NULL DEFAULT 0,  `create_time` datetime(0) NULL DEFAULT NULL,  `last_edit_time` datetime(0) NULL DEFAULT NULL,  PRIMARY KEY (`area_id`) USING BTREE,  UNIQUE INDEX `UK_AREA`(`area_name`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of tb_area-- ----------------------------INSERT INTO `tb_area` VALUES (1, &#x27;东&#x27;, 2, NULL, NULL);INSERT INTO `tb_area` VALUES (2, &#x27;北&#x27;, 1, NULL, NULL);SET FOREIGN_KEY_CHECKS = 1;\r\n实体类：\r\npackage com.luotao.demo.mybatis.entity;import java.util.Date;/** * @Classname Area * @Description 区域实体类 * @Version 1.0.0 * @Date 2025/3/16 13:44 * @Author LuoTao */public class Area &#123;    // 主键ID    private Integer areaId;    // 区域名    private String areaName;    // 权重    private Integer priority;    // 创建时间    private Date createTime;    // 更新时间    private Date lastEditTime;    public Integer getAreaId() &#123;        return areaId;    &#125;    public void setAreaId(Integer areaId) &#123;        this.areaId = areaId;    &#125;    public String getAreaName() &#123;        return areaName;    &#125;    public void setAreaName(String areaName) &#123;        this.areaName = areaName;    &#125;    public Integer getPriority() &#123;        return priority;    &#125;    public void setPriority(Integer priority) &#123;        this.priority = priority;    &#125;    public Date getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Date createTime) &#123;        this.createTime = createTime;    &#125;    public Date getLastEditTime() &#123;        return lastEditTime;    &#125;    public void setLastEditTime(Date lastEditTime) &#123;        this.lastEditTime = lastEditTime;    &#125;&#125;\r\n1.3 MyBatis配置\r\nMyBatis-config.xml\r\n&lt;!--        mybatis--&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;2.2.2&lt;/version&gt;      &lt;/dependency&gt; &lt;!--        数据库驱动--&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;/dependency&gt;      &lt;!--        连接池--&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.mchange&lt;/groupId&gt;          &lt;artifactId&gt;c3p0&lt;/artifactId&gt;          &lt;version&gt;0.9.5.2&lt;/version&gt;      &lt;/dependency&gt;\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--    配置全局属性--&gt;    &lt;settings&gt;        &lt;!--        使用jdbc的getGenneratedKeys获取数据库自增主键值--&gt;        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;        &lt;!--        使用列标签替换列别名 默认true--&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;        &lt;!--        开启驼峰命名转换：Table&#123;create_time&#125;——&gt;Entity&#123;createTime&#125;--&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;\r\n数据库配置类\r\n\r\nIOC容器会接受很多Bean,运行时我们需要用到bean的地方自动注入。\r\n了解AOP\r\nmapper：调用jdbc去操作数据库，将结果映射到实体类\r\n\r\npackage com.luotao.demo.config.dao;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.springframework.context.annotation.Bean;import java.beans.PropertyVetoException;/** * @Classname DataSourceConfiguration * @Description TODO * @Version 1.0.0 * @Date 2025/3/16 14:53 * @Author LuoTao */@Configuration // 告诉容器需要来这里检索Bean@MapperScan(&quot;com.luotao.demo.dao&quot;) // mybatis_mapper的扫描路径public class DataSourceConfiguration&#123;    // 读取配置文件里面的属性值    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String jdbcDriver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String jdbcUrl;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String jdbcUsername;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String jdbcPassword;    @Bean(name=&quot;dataSource&quot;)    public ComboPooledDataSource createDataSource() throws PropertyVetoException &#123;        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setDriverClass(jdbcDriver);        dataSource.setJdbcUrl(jdbcUrl);        dataSource.setUser(jdbcUsername);        dataSource.setPassword(jdbcPassword);        // 关闭连接后不自动commit        dataSource.setAutoCommitOnClose(false);        return dataSource;    &#125;&#125;\r\nSessionFactoryConfiguration:\r\npackage com.luotao.demo.config.dao;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.beans.PropertyVetoException;/** * @Classname DataSourceConfiguration * @Description TODO * @Version 1.0.0 * @Date 2025/3/16 14:53 * @Author LuoTao */@Configuration // 告诉容器需要来这里检索Bean@MapperScan(&quot;com.luotao.demo.dao&quot;) // mybatis_mapper的扫描路径public class DataSourceConfiguration&#123;    // 读取配置文件里面的属性值    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String jdbcDriver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String jdbcUrl;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String jdbcUsername;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String jdbcPassword;    @Bean(name=&quot;dataSource&quot;)    public ComboPooledDataSource createDataSource() throws PropertyVetoException &#123;        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setDriverClass(jdbcDriver);        dataSource.setJdbcUrl(jdbcUrl);        dataSource.setUser(jdbcUsername);        dataSource.setPassword(jdbcPassword);        // 关闭连接后不自动commit        dataSource.setAutoCommitOnClose(false);        return dataSource;    &#125;&#125;\r\napplication.properties\r\njdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsejdbc.username=rootjdbc.password=root#mybatismybatis_config_file=MyBatis-config.xmlmapper_path=/mapper/**.xmlentity_package=com.luotao.demo.mybatis.entity\r\ndaoMapper接口\r\npackage com.luotao.demo.dao;import com.luotao.demo.mybatis.entity.Area;import java.util.List;public interface AreaDao &#123;    int insertArea(Area area);    int deleteArea(int areadId);    int updateArea(Area area);    Area queryAreaById(int areaId);    List&lt;Area&gt; queryArea();&#125;\r\n在mapper目录下创建SQL映射文件：\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.luotao.demo.dao.AreaDao&quot;&gt;    &lt;insert id=&quot;insertArea&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;areaId&quot; keyColumn=&quot;area_id&quot;            parameterType=&quot;com.luotao.demo.mybatis.entity.Area&quot;&gt;        insert into tb_area(area_name, priority, create_time, last_edit_time)        values (#&#123;areaName&#125;, #&#123;priority&#125;, #&#123;createTime&#125;, #&#123;lastEditTime&#125;)    &lt;/insert&gt;    &lt;delete id=&quot;deleteArea&quot;&gt;        delete        from tb_area        where area_id = #&#123;areaId&#125;    &lt;/delete&gt;    &lt;update id=&quot;updateArea&quot; parameterType=&quot;com.luotao.demo.mybatis.entity.Area&quot;&gt;        update tb_area        &lt;set&gt;            &lt;if test=&quot;areaName !=null&quot;&gt;area_name=#&#123;areaName&#125;&lt;/if&gt;            &lt;if test=&quot;priority !=null&quot;&gt;priority=#&#123;priority&#125;&lt;/if&gt;            &lt;if test=&quot;lastEditTime !=null&quot;&gt;last_edit_time=#&#123;lastEditTime&#125;&lt;/if&gt;        &lt;/set&gt;        where area_id=#&#123;areaId&#125;    &lt;/update&gt;    &lt;select id=&quot;queryAreaById&quot; resultType=&quot;com.luotao.demo.mybatis.entity.Area&quot;&gt;        select area_id, area_name, priority, create_time, last_edit_time        from tb_area        where area_id = #&#123;areaId&#125;    &lt;/select&gt;    &lt;select id=&quot;queryArea&quot; resultType=&quot;com.luotao.demo.mybatis.entity.Area&quot;&gt;        select area_id, area_name, priority, create_time, last_edit_time        from tb_area        order by priority                desc    &lt;/select&gt;&lt;/mapper&gt;\r\n1.4 DAO层开发\r\n实现了AreaDao接口，提供以下数据访问方法： -\r\nqueryArea: 查询所有区域 - queryAreaById:\r\n根据ID查询区域 - insertArea: 插入新区域 -\r\nupdateArea: 更新区域信息 - deleteArea:\r\n删除区域\r\njunit测试\r\n\r\n对应每个表做增删改查\r\n\r\npackage com.luotao.demo.dao;import com.luotao.demo.mybatis.entity.Area;import org.junit.Assert;import org.junit.Ignore;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.Date;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestclass AreaDaoTest &#123;    @Autowired    private AreaDao areaDao;    @Test    @Ignore    void insertArea() &#123;        Area area = new Area();        area.setAreaName(&quot;哈哈&quot;);        area.setCreateTime(new Date());        area.setLastEditTime(new Date());        area.setPriority(1);        int effectNumber = areaDao.insertArea(area);        Assert.assertEquals(1,effectNumber);    &#125;    @Test    @Ignore    void deleteArea() &#123;        int effectNumber = areaDao.deleteArea(5);        Assert.assertEquals(1,effectNumber);    &#125;    @Test    @Ignore    void updateArea() &#123;        Area area = new Area();        area.setAreaId(1);        area.setAreaName(&quot;深圳&quot;);        area.setPriority(1);        area.setLastEditTime(new Date());        int effectNumber = areaDao.updateArea(area);        Assert.assertEquals(1,effectNumber);    &#125;    @Test    @Ignore    void queryAreaById() &#123;        Area area = areaDao.queryAreaById(1);        Assert.assertEquals(&quot;东&quot;,area.getAreaName());    &#125;    @Test    void queryArea() &#123;        List&lt;Area&gt; areas = areaDao.queryArea();        Assert.assertEquals(4,areas.size());    &#125;&#125;\r\n1.5 Service层开发\r\n实现了AreaService接口，封装业务逻辑： -\r\ngetAreaList: 获取所有区域列表 - getAreaById:\r\n根据ID获取区域 - addArea: 添加新区域 -\r\nmodifyArea: 修改区域信息 - deleteArea:\r\n删除区域\r\nservice的接口和dao的接口有什么区别吗？\r\nDAO（Data Access Object）接口： DAO\r\n实现类直接与数据库交互，执行具体的 SQL 操作。\r\n是数据访问层的核心组件，封装了对数据库的操作逻辑。\r\n通常只关注数据的存储和检索，不涉及业务逻辑。 Service 接口：\r\n整合复杂业务逻辑，将dao的增删改查整合\r\n可能会调用一个或多个 DAO 接口来完成复杂的业务操作。\r\n提供更高层次的功能抽象，屏蔽底层的数据访问细节。\r\nService 接口的方法更注重业务语义，例如 addArea\r\n表示添加区域，modifyArea 表示修改区域。通常由 Service 层管理事务。\r\n方法可能包含额外的校验逻辑或调用多个 DAO 方法来完成复杂的业务需求。\r\nservice层的事务配置类\r\n\r\nservice层跟Spring相关的配置\r\n\r\npackage com.luotao.demo.config.dao.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.TransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.TransactionManagementConfigurer;import javax.sql.DataSource;/** * @Classname TransactionManagementConfiguration * @Description 事务配置 * @Version 1.0.0 * @Date 2025/3/16 18:51 * @Author LuoTao */@Configuration@EnableTransactionManagementpublic class TransactionManagementConfiguration implements TransactionManagementConfigurer &#123;    @Autowired    private DataSource datasource;    @Override    public TransactionManager annotationDrivenTransactionManager() &#123;        return new DataSourceTransactionManager(datasource);    &#125;&#125;\r\nservice层的接口\r\npackage com.luotao.demo.service;import com.luotao.demo.mybatis.entity.Area;import java.util.List;public interface AreaService &#123;    boolean addArea(Area area);    boolean deleteArea(int areadId);    boolean modifyArea(Area area);    Area getAreaById(int areaId);    List&lt;Area&gt; getAreaList();&#125;\r\nservice层的实现类\r\npackage com.luotao.demo.service.impl;import com.luotao.demo.dao.AreaDao;import com.luotao.demo.mybatis.entity.Area;import com.luotao.demo.service.AreaService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.Date;import java.util.List;/** * @Classname AreaServiceImpl * @Description TODO * @Version 1.0.0 * @Date 2025/3/16 19:00 * @Author LuoTao */@Service@Transactional(rollbackFor = RuntimeException.class)public class AreaServiceImpl implements AreaService &#123;    @Autowired    private AreaDao areaDao;    @Override    public boolean addArea(Area area) &#123;        if(area.getAreaName() != null &amp;&amp; !&quot;&quot;.equals(area.getAreaName()))&#123;            area.setCreateTime(new Date());            area.setLastEditTime(new Date());            try&#123;                int effectedNum = areaDao.insertArea(area);                if(effectedNum &gt;0)&#123;                    return true;                &#125;else &#123;                    throw new RuntimeException(&quot;插入区域信息失败!&quot;);                &#125;            &#125;catch (Exception e)&#123;                throw new RuntimeException(&quot;插入区域信息失败:&quot; + e.toString());            &#125;        &#125;else &#123;            throw new RuntimeException(&quot;区域信息不能为空！&quot;);        &#125;    &#125;    @Override    public boolean deleteArea(int areadId) &#123;        if(areadId &gt;0)&#123;            try&#123;                // 删除区域信息                int effectedNum = areaDao.deleteArea(areadId);                if (effectedNum &gt;0)&#123;                    return true;                &#125;else &#123;                    throw new RuntimeException(&quot;删除区域信息失败！&quot;);                &#125;            &#125;catch (Exception e)&#123;                throw new RuntimeException(&quot;删除区域信息失败:&quot; + e.toString())            &#125;        &#125;else&#123;            throw new RuntimeException(&quot;区域Id不能为空！&quot;);        &#125;    &#125;    @Override    public boolean modifyArea(Area area) &#123;        // id非空才能修改        if(area.getAreaId() != null &amp;&amp; !&quot;&quot;.equals(area.getAreaId()))&#123;            area.setLastEditTime(new Date());            try&#123;                int effectedNum = areaDao.updateArea(area);                if(effectedNum &gt;0)&#123;                    return true;                &#125;else &#123;                    throw new RuntimeException(&quot;更新区域信息失败!&quot;);                &#125;            &#125;catch (Exception e)&#123;                throw new RuntimeException(&quot;更新信息失败:&quot; + e.toString());            &#125;        &#125;else &#123;            throw new RuntimeException(&quot;区域信息不能为空！&quot;);        &#125;    &#125;    @Override    public Area getAreaById(int areaId) &#123;        return areaDao.queryAreaById(areaId);    &#125;    @Override    public List&lt;Area&gt; getAreaList() &#123;        return areaDao.queryArea();    &#125;&#125;\r\n1.6 Controller层开发\r\n创建了AreaController，提供RESTful API： -\r\nGET /superadmin/listarea: 获取所有区域列表 -\r\nGET /superadmin/getareabyid: 根据ID获取区域 -\r\nPOST /superadmin/addarea: 添加新区域 -\r\nPOST /superadmin/modifyarea: 修改区域信息 -\r\nGET /superadmin/removearea: 删除区域\r\npackage com.luotao.demo.web;import com.luotao.demo.mybatis.entity.Area;import com.luotao.demo.service.AreaService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @Classname AreaController * @Description TODO * @Version 1.0.0 * @Date 2025/3/16 19:53 * @Author LuoTao */@RestController@RequestMapping(&quot;/superadmin&quot;)public class AreaController &#123;    @Autowired    private AreaService areaService;    @RequestMapping(value = &quot;/addarea&quot;, method = RequestMethod.POST)    public Map&lt;String, Object&gt; addArea(@RequestBody Area area) &#123;        HashMap&lt;String, Object&gt; modeMap = new HashMap&lt;&gt;();        modeMap.put(&quot;success&quot;, areaService.addArea(area));        return modeMap;    &#125;    @RequestMapping(value = &quot;/removearea&quot;, method = RequestMethod.GET)    public Map&lt;String, Object&gt; removeArea(Integer areaId) &#123;        HashMap&lt;String, Object&gt; modeMap = new HashMap&lt;&gt;();        modeMap.put(&quot;success&quot;, areaService.deleteArea(areaId));        return modeMap;    &#125;    @RequestMapping(value = &quot;/modifyarea&quot;, method = RequestMethod.POST)    public Map&lt;String, Object&gt; modifyArea(@RequestBody Area area) &#123;        HashMap&lt;String, Object&gt; modeMap = new HashMap&lt;&gt;();        modeMap.put(&quot;success&quot;, areaService.modifyArea(area));        return modeMap;    &#125;    @RequestMapping(value = &quot;/listarea&quot;, method = RequestMethod.GET)    public Map&lt;String, Object&gt; listArea() &#123;        HashMap&lt;String, Object&gt; modeMap = new HashMap&lt;&gt;();        List&lt;Area&gt; areaList = areaService.getAreaList();        modeMap.put(&quot;areaList&quot;, areaList);        return modeMap;    &#125;    @RequestMapping(value = &quot;/getareabyid&quot;, method = RequestMethod.GET)    public Map&lt;String, Object&gt; getAreaById(Integer areaId) &#123;        HashMap&lt;String, Object&gt; modeMap = new HashMap&lt;&gt;();        Area area = areaService.getAreaById(areaId);        modeMap.put(&quot;area&quot;, area);        return modeMap;    &#125;&#125;\r\n全局统一异常处理\r\npackage com.luotao.demo.handler;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import java.util.HashMap;import java.util.Map;/** * @Classname GlobalExceptionHandler * @Description TODO * @Version 1.0.0 * @Date 2025/3/16 22:40 * @Author LuoTao */@ControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(value = Exception.class)    @ResponseBody    private Map&lt;String, Object&gt; exceptionHandler(HttpServletRequest req,Exception e)&#123;        HashMap&lt;String, Object&gt; modelMap = new HashMap&lt;&gt;();        modelMap.put(&quot;success&quot;, false);        modelMap.put(&quot;errMsg&quot;, e.getMessage());        return modelMap;    &#125;&#125;\r\n2. 前端开发\r\n2.1 前端技术选型\r\n\r\nHTML5/CSS3\r\nVue.js 3：使用Composition\r\nAPI实现前端逻辑，提供更好的代码组织和复用\r\nAxios：用于处理HTTP请求，与后端API交互\r\n\r\n2.2 UI设计与实现\r\n设计了一个直观的用户界面，包括： -\r\n顶部导航栏，显示应用名称和主要导航链接 - 区域列表表格，显示所有区域信息\r\n- 添加/编辑区域的模态框 - 删除确认的模态框\r\n2.3 Vue.js实现\r\n使用Vue.js 3的Composition API实现前端逻辑： -\r\n使用ref创建响应式数据 -\r\n使用onMounted钩子在页面加载时获取数据 - 实现CRUD操作的方法\r\n- 使用条件渲染控制模态框的显示和隐藏\r\n// 使用Vue 3的Composition APIconst &#123; createApp, ref, onMounted &#125; = Vue;const app = createApp(&#123;    setup() &#123;        // 区域列表        const areas = ref([]);        // 当前操作的区域对象        const currentArea = ref(&#123;            areaId: null,            areaName: &#x27;&#x27;,            priority: 0        &#125;);        // 模态框显示状态        const showModal = ref(false);        const showDeleteModal = ref(false);        // 是否处于编辑模式        const isEditing = ref(false);        // 页面加载时执行        onMounted(() =&gt; &#123;            // 加载区域列表            loadAreas();        &#125;);        // 加载区域列表        const loadAreas = () =&gt; &#123;            axios.get(&#x27;/superadmin/listarea&#x27;)                .then(response =&gt; &#123;                    if (response.data &amp;&amp; response.data.areaList) &#123;                        areas.value = response.data.areaList;                    &#125; else &#123;                        areas.value = [];                        console.error(&#x27;获取区域列表失败:&#x27;, response);                    &#125;                &#125;)                .catch(error =&gt; &#123;                    console.error(&#x27;获取区域列表出错:&#x27;, error);                    alert(&#x27;获取区域列表失败，请查看控制台了解详情。&#x27;);                &#125;);        &#125;;        // 显示添加区域模态框        const showAddModal = () =&gt; &#123;            isEditing.value = false;            currentArea.value = &#123;                areaId: null,                areaName: &#x27;&#x27;,                priority: 0            &#125;;            showModal.value = true;        &#125;;        // 关闭模态框        const closeModal = () =&gt; &#123;            showModal.value = false;        &#125;;        // 关闭删除确认模态框        const closeDeleteModal = () =&gt; &#123;            showDeleteModal.value = false;        &#125;;        // 显示编辑区域模态框        const editArea = (area) =&gt; &#123;            isEditing.value = true;            // 创建一个新对象，避免直接修改原始数据            currentArea.value = &#123;                areaId: area.areaId,                areaName: area.areaName,                priority: area.priority            &#125;;            showModal.value = true;        &#125;;        // 保存区域（添加或更新）        const saveArea = () =&gt; &#123;            const url = isEditing.value ? &#x27;/superadmin/modifyarea&#x27; : &#x27;/superadmin/addarea&#x27;;            axios.post(url, currentArea.value)                .then(response =&gt; &#123;                    if (response.data &amp;&amp; response.data.success) &#123;                        // 关闭模态框                        showModal.value = false;                        // 重新加载区域列表                        loadAreas();                        // 显示成功消息                        alert(isEditing.value ? &#x27;区域更新成功！&#x27; : &#x27;区域添加成功！&#x27;);                    &#125; else &#123;                        console.error(&#x27;保存区域失败:&#x27;, response);                        alert(&#x27;操作失败，请查看控制台了解详情。&#x27;);                    &#125;                &#125;)                .catch(error =&gt; &#123;                    console.error(&#x27;保存区域出错:&#x27;, error);                    alert(&#x27;操作失败，请查看控制台了解详情。&#x27;);                &#125;);        &#125;;        // 显示删除确认模态框        const confirmDelete = (area) =&gt; &#123;            currentArea.value = area;            showDeleteModal.value = true;        &#125;;        // 删除区域        const deleteArea = () =&gt; &#123;            axios.get(&#x27;/superadmin/removearea&#x27;, &#123;                params: &#123;                    areaId: currentArea.value.areaId                &#125;            &#125;)                .then(response =&gt; &#123;                    if (response.data &amp;&amp; response.data.success) &#123;                        // 关闭模态框                        showDeleteModal.value = false;                        // 重新加载区域列表                        loadAreas();                        // 显示成功消息                        alert(&#x27;区域删除成功！&#x27;);                    &#125; else &#123;                        console.error(&#x27;删除区域失败:&#x27;, response);                        alert(&#x27;删除失败，请查看控制台了解详情。&#x27;);                    &#125;                &#125;)                .catch(error =&gt; &#123;                    console.error(&#x27;删除区域出错:&#x27;, error);                    alert(&#x27;删除失败，请查看控制台了解详情。&#x27;);                &#125;);        &#125;;        // 格式化日期        const formatDate = (dateString) =&gt; &#123;            if (!dateString) return &#x27;未设置&#x27;;            const date = new Date(dateString);            if (isNaN(date.getTime())) return dateString;            return date.toLocaleString(&#x27;zh-CN&#x27;, &#123;                year: &#x27;numeric&#x27;,                month: &#x27;2-digit&#x27;,                day: &#x27;2-digit&#x27;,                hour: &#x27;2-digit&#x27;,                minute: &#x27;2-digit&#x27;,                second: &#x27;2-digit&#x27;            &#125;);        &#125;;        // 返回所有需要在模板中使用的变量和方法        return &#123;            areas,            currentArea,            isEditing,            showModal,            showDeleteModal,            loadAreas,            showAddModal,            closeModal,            closeDeleteModal,            editArea,            saveArea,            confirmDelete,            deleteArea,            formatDate        &#125;;    &#125;&#125;);// 挂载Vue应用app.mount(&#x27;#app&#x27;);\r\n2.4 API集成\r\n使用Axios库与后端API进行交互： - 获取区域列表 - 添加新区域 -\r\n更新区域信息 - 删除区域\r\n2.5 CSS样式开发\r\n开发了自定义CSS样式，实现了： - 响应式布局，适配不同屏幕尺寸 -\r\n美观的卡片、表格和按钮样式 - 模态框动画和样式 -\r\n表单元素的样式和交互效果\r\n/* 重置样式 */* &#123;    margin: 0;    padding: 0;    box-sizing: border-box;&#125;/* 全局样式 */:root &#123;    --primary-color: #3498db;    --primary-dark: #2980b9;    --secondary-color: #7f8c8d;    --danger-color: #e74c3c;    --danger-dark: #c0392b;    --success-color: #2ecc71;    --info-color: #3498db;    --light-color: #f8f9fa;    --dark-color: #343a40;    --border-color: #e1e4e8;    --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);    --border-radius: 4px;&#125;body &#123;    font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;    line-height: 1.6;    color: #333;    background-color: #f8f9fa;&#125;/* 布局 */.header &#123;    background-color: var(--primary-color);    color: white;    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);    position: sticky;    top: 0;    z-index: 100;&#125;.header-container &#123;    max-width: 1200px;    margin: 0 auto;    padding: 1rem;    display: flex;    justify-content: space-between;    align-items: center;&#125;.logo &#123;    font-size: 1.5rem;    font-weight: 600;&#125;.nav-list &#123;    display: flex;    list-style: none;&#125;.nav-item &#123;    margin-left: 1.5rem;&#125;.nav-link &#123;    color: white;    text-decoration: none;    padding: 0.5rem 0;    position: relative;&#125;.nav-link:hover::after,.nav-link.active::after &#123;    content: &#x27;&#x27;;    position: absolute;    bottom: 0;    left: 0;    width: 100%;    height: 2px;    background-color: white;&#125;.main-content &#123;    max-width: 1200px;    margin: 2rem auto;    padding: 0 1rem;&#125;/* 卡片样式 */.card &#123;    background-color: white;    border-radius: var(--border-radius);    box-shadow: var(--shadow);    margin-bottom: 2rem;    overflow: hidden;&#125;.card-header &#123;    padding: 1.25rem;    border-bottom: 1px solid var(--border-color);    display: flex;    justify-content: space-between;    align-items: center;&#125;.card-title &#123;    font-size: 1.25rem;    margin: 0;    font-weight: 600;&#125;.card-body &#123;    padding: 1.25rem;&#125;/* 表格样式 */.table-container &#123;    overflow-x: auto;&#125;.table &#123;    width: 100%;    border-collapse: collapse;&#125;.table th,.table td &#123;    padding: 0.75rem;    text-align: left;    border-bottom: 1px solid var(--border-color);&#125;.table th &#123;    font-weight: 600;    background-color: var(--light-color);&#125;.table tr:hover &#123;    background-color: rgba(0, 0, 0, 0.02);&#125;.actions &#123;    display: flex;    gap: 0.5rem;&#125;.empty-state &#123;    text-align: center;    padding: 2rem;    color: var(--secondary-color);&#125;/* 按钮样式 */.btn &#123;    display: inline-block;    font-weight: 500;    text-align: center;    white-space: nowrap;    vertical-align: middle;    user-select: none;    border: 1px solid transparent;    padding: 0.5rem 1rem;    font-size: 1rem;    line-height: 1.5;    border-radius: var(--border-radius);    transition: all 0.15s ease-in-out;    cursor: pointer;&#125;.btn-primary &#123;    color: white;    background-color: var(--primary-color);    border-color: var(--primary-color);&#125;.btn-primary:hover &#123;    background-color: var(--primary-dark);    border-color: var(--primary-dark);&#125;.btn-secondary &#123;    color: white;    background-color: var(--secondary-color);    border-color: var(--secondary-color);&#125;.btn-secondary:hover &#123;    background-color: #6c757d;    border-color: #6c757d;&#125;.btn-danger &#123;    color: white;    background-color: var(--danger-color);    border-color: var(--danger-color);&#125;.btn-danger:hover &#123;    background-color: var(--danger-dark);    border-color: var(--danger-dark);&#125;.btn-info &#123;    color: white;    background-color: var(--info-color);    border-color: var(--info-color);&#125;.btn-info:hover &#123;    background-color: var(--primary-dark);    border-color: var(--primary-dark);&#125;/* 模态框样式 */.modal &#123;    position: fixed;    top: 0;    left: 0;    right: 0;    bottom: 0;    background-color: rgba(0, 0, 0, 0.5);    display: flex;    align-items: center;    justify-content: center;    z-index: 1000;&#125;.modal-content &#123;    background-color: white;    border-radius: var(--border-radius);    box-shadow: var(--shadow);    width: 100%;    max-width: 500px;    max-height: 90vh;    overflow-y: auto;&#125;.modal-header &#123;    padding: 1rem;    border-bottom: 1px solid var(--border-color);    display: flex;    justify-content: space-between;    align-items: center;&#125;.modal-title &#123;    margin: 0;    font-size: 1.25rem;&#125;.close-btn &#123;    background: none;    border: none;    font-size: 1.5rem;    cursor: pointer;    color: var(--secondary-color);&#125;.modal-body &#123;    padding: 1rem;&#125;/* 表单样式 */.form-group &#123;    margin-bottom: 1rem;&#125;.form-group label &#123;    display: block;    margin-bottom: 0.5rem;    font-weight: 500;&#125;.form-group input &#123;    width: 100%;    padding: 0.5rem;    font-size: 1rem;    border: 1px solid var(--border-color);    border-radius: var(--border-radius);&#125;.form-group input:focus &#123;    outline: none;    border-color: var(--primary-color);    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.25);&#125;.form-actions &#123;    display: flex;    justify-content: flex-end;    gap: 0.5rem;    margin-top: 1.5rem;&#125;/* 响应式调整 */@media (max-width: 768px) &#123;    .header-container &#123;        flex-direction: column;        align-items: flex-start;    &#125;    .nav-list &#123;        margin-top: 1rem;    &#125;    .nav-item &#123;        margin-left: 0;        margin-right: 1.5rem;    &#125;    .card-header &#123;        flex-direction: column;        align-items: flex-start;    &#125;    .card-header .btn &#123;        margin-top: 1rem;    &#125;    .actions &#123;        flex-direction: column;    &#125;    .actions .btn &#123;        width: 100%;    &#125;&#125; \r\n@Autowired与@Resource的区别\r\n@Autowired\r\n注解的作用就是让 Spring 容器自动为 areaDao 成员变量注入一个实现了\r\nAreaDao 接口的实例对象。Spring 会根据配置（例如 MyBatis\r\n的配置）动态生成AreaDao 实现类的代理对象。这个代理对象会被注入到 areaDao\r\n中\r\n@Autowired根据type注入，@Resource基于名称，找不到时基于类型注入，本质上均实现了注入效果。\r\n一般来说，注入controller的service虽然一般来说我们都是注入一个接口，但是该接口有实现类，并且使用@Service进行关联，所以注入类型应该也可以视为一个类，但是mybatis仅需提供Dao接口，也就是说，注入service的dao只是一个接口，而没有实现类，虽然mybatis能够通过Dao接口和xml文件实现与数据库的操作，但是@Autowired并没有这个识别功能，可能它就认为你类型不匹配，无法使用通过类型注入的方法\r\n其他\r\n\r\nSpring\r\nBoot官方文档\r\nMyBatis官方文档\r\nSpring\r\nBoot与MyBatis集成教程\r\nVue.js\r\n3文档\r\nAxios文档\r\nComposition\r\nAPI参考\r\n\r\n"},{"title":"Java包装类","url":"/2025/03/14/Java%E5%8C%85%E8%A3%85%E7%B1%BB/","content":"Java包装类详解\r\n包装类基础概念\r\n什么是包装类？\r\n包装类是将Java的基本数据类型（如int、char等）封装成对象的类。想象一下，基本类型就像是一颗裸露的钻石，而包装类就是给这颗钻石精心设计的包装盒，不仅保护了钻石，还赋予了它更多的功能。\r\n包装类的主要作用： 1.\r\n将基本数据类型转换为对象，使其能在对象世界中”生存” 2.\r\n提供很多实用的方法，如类型转换、进制转换等 3.\r\n支持null值，而基本类型不支持 4.\r\n在集合类中使用（因为集合类只能存储对象）\r\n为什么需要包装类？\r\n在Java中，有两个世界：基本类型的世界和对象的世界。有时候，这两个世界需要沟通，包装类就是这座桥梁。\r\n例如： -\r\nJava集合（如ArrayList、HashMap等）只能存储对象，不能直接存储基本类型 -\r\n泛型不支持基本类型，只支持对象类型 - 需要在基本类型上调用方法时 -\r\n需要表示基本类型的null值时\r\n基本类型与包装类对应关系\r\nJava中的每种基本类型都有对应的包装类：\r\n\r\n\r\n\r\n基本类型\r\n包装类\r\n父类\r\n\r\n\r\n\r\n\r\nbyte\r\nByte\r\nNumber\r\n\r\n\r\nshort\r\nShort\r\nNumber\r\n\r\n\r\nint\r\nInteger\r\nNumber\r\n\r\n\r\nlong\r\nLong\r\nNumber\r\n\r\n\r\nfloat\r\nFloat\r\nNumber\r\n\r\n\r\ndouble\r\nDouble\r\nNumber\r\n\r\n\r\nchar\r\nCharacter\r\nObject\r\n\r\n\r\nboolean\r\nBoolean\r\nObject\r\n\r\n\r\n\r\n所有的数值型包装类（Byte、Short、Integer、Long、Float、Double）都继承自抽象类Number，而Character和Boolean直接继承自Object。\r\n装箱与拆箱\r\n装箱（Boxing）\r\n装箱是将基本类型转换为对应的包装类对象。就像把钻石放入精美的包装盒中。\r\n手动装箱： int primitiveInt = 42;Integer wrappedInt = Integer.valueOf(primitiveInt); // 手动装箱\r\n自动装箱（Java 5及以上）： int primitiveInt = 42;Integer wrappedInt = primitiveInt; // 自动装箱\r\n拆箱（Unboxing）\r\n拆箱是将包装类对象转换为对应的基本类型。就像从包装盒中取出钻石。\r\n手动拆箱： Integer wrappedInt = Integer.valueOf(42);int primitiveInt = wrappedInt.intValue(); // 手动拆箱\r\n自动拆箱（Java 5及以上）： Integer wrappedInt = 42;int primitiveInt = wrappedInt; // 自动拆箱\r\n自动装箱/拆箱的实例\r\npublic class AutoBoxingUnboxingDemo &#123;    public static void main(String[] args) &#123;        // 自动装箱        Integer num1 = 100;                // 自动拆箱        int num2 = num1;                // 在表达式中的自动装箱和拆箱        Integer num3 = 100;        Integer num4 = 200;        int result = num3 + num4; // num3和num4自动拆箱，计算后结果为基本类型                // 在方法调用中        printNumber(100); // 自动装箱    &#125;        public static void printNumber(Integer num) &#123;        System.out.println(num);    &#125;&#125;\r\n自动装箱/拆箱的原理\r\n自动装箱/拆箱是Java编译器提供的语法糖，在编译时会自动转换为对应的方法调用：\r\n\r\n自动装箱：Integer.valueOf(int)\r\n自动拆箱：intValue()\r\n\r\n例如，以下代码： Integer num = 100;int value = num;\r\n编译后等价于： Integer num = Integer.valueOf(100);int value = num.intValue();\r\n包装类的常用方法\r\nInteger类常用方法\r\npublic class IntegerMethodsDemo &#123;    public static void main(String[] args) &#123;        // 构造方法        Integer num1 = new Integer(100); // 已废弃，不推荐使用        Integer num2 = Integer.valueOf(100); // 推荐使用                // 转换方法        int primitiveInt = num2.intValue();        float primitiveFloat = num2.floatValue();                // 字符串转换        Integer num3 = Integer.parseInt(&quot;200&quot;);        String str = Integer.toString(300);                // 进制转换        String binaryStr = Integer.toBinaryString(10); // 转二进制 &quot;1010&quot;        String hexStr = Integer.toHexString(255);      // 转十六进制 &quot;ff&quot;        String octalStr = Integer.toOctalString(8);    // 转八进制 &quot;10&quot;                // 其他实用方法        int max = Integer.max(10, 20);                 // 返回较大值 20        int min = Integer.min(10, 20);                 // 返回较小值 10        int sum = Integer.sum(10, 20);                 // 求和 30                // 常量        System.out.println(&quot;最大值：&quot; + Integer.MAX_VALUE);        System.out.println(&quot;最小值：&quot; + Integer.MIN_VALUE);    &#125;&#125;\r\nCharacter类常用方法\r\npublic class CharacterMethodsDemo &#123;    public static void main(String[] args) &#123;        Character ch1 = Character.valueOf(&#x27;A&#x27;);                // 字符判断        boolean isDigit = Character.isDigit(&#x27;5&#x27;);      // 是否是数字        boolean isLetter = Character.isLetter(&#x27;A&#x27;);    // 是否是字母        boolean isLetterOrDigit = Character.isLetterOrDigit(&#x27;A&#x27;); // 是否是字母或数字        boolean isUpperCase = Character.isUpperCase(&#x27;A&#x27;); // 是否是大写字母        boolean isLowerCase = Character.isLowerCase(&#x27;a&#x27;); // 是否是小写字母        boolean isWhitespace = Character.isWhitespace(&#x27; &#x27;); // 是否是空白字符                // 字符转换        char upperChar = Character.toUpperCase(&#x27;a&#x27;);   // 转大写        char lowerChar = Character.toLowerCase(&#x27;A&#x27;);   // 转小写                // 字符编码        int code = Character.codePointAt(&quot;Hello&quot;, 0);  // 获取指定位置的Unicode编码    &#125;&#125;\r\nBoolean类常用方法\r\npublic class BooleanMethodsDemo &#123;    public static void main(String[] args) &#123;        Boolean bool1 = Boolean.valueOf(true);        Boolean bool2 = Boolean.valueOf(&quot;true&quot;);  // 不区分大小写，&quot;true&quot;转为true，其他字符串转为false                // 转换方法        boolean primitive = bool1.booleanValue();        String str = Boolean.toString(true);                // 比较方法        int result = Boolean.compare(true, false);  // 1表示前者大                // 逻辑运算        boolean logicalAnd = Boolean.logicalAnd(true, false);  // 与运算 false        boolean logicalOr = Boolean.logicalOr(true, false);    // 或运算 true        boolean logicalXor = Boolean.logicalXor(true, false);  // 异或运算 true    &#125;&#125;\r\n包装类的缓存机制\r\n为了提高性能，Java的包装类对常用的值实现了缓存机制。这就像商店里常用商品会放在触手可及的地方，而不常用的商品则需要去仓库取。\r\nInteger缓存\r\n\r\n\r\nimage-20250314201554849\r\n\r\nInteger类的缓存范围是-128到127（可通过JVM参数调整上限）。在这个范围内的整数会被缓存，超出范围则创建新对象。\r\npublic class IntegerCacheDemo &#123;    public static void main(String[] args) &#123;        Integer num1 = 127;        Integer num2 = 127;        System.out.println(num1 == num2); // true，使用了缓存的同一个对象                Integer num3 = 128;        Integer num4 = 128;        System.out.println(num3 == num4); // false，超出缓存范围，创建了不同对象                // valueOf方法使用缓存        Integer num5 = Integer.valueOf(127);        Integer num6 = Integer.valueOf(127);        System.out.println(num5 == num6); // true                // 构造方法不使用缓存（已废弃）        Integer num7 = new Integer(127);        Integer num8 = new Integer(127);        System.out.println(num7 == num8); // false，每次都创建新对象    &#125;&#125;\r\n其他包装类的缓存\r\n\r\nBoolean: 缓存了true和false对象\r\nByte: 缓存了所有可能的值（-128到127）\r\nShort: 缓存了-128到127\r\nCharacter: 缓存了0到127\r\nLong: 缓存了-128到127\r\nFloat和Double: 没有实现缓存机制\r\n\r\n包装类的比较\r\n==与equals的区别\r\n\r\n==:\r\n比较引用是否指向同一对象（对于包装类）或值是否相等（对于基本类型）\r\nequals(): 比较包装类对象的值是否相等\r\n\r\npublic class WrapperComparisonDemo &#123;    public static void main(String[] args) &#123;        Integer num1 = 100;        Integer num2 = 100;        Integer num3 = 200;        Integer num4 = 200;                // 使用==比较        System.out.println(num1 == num2);  // true，因为100在缓存范围内        System.out.println(num3 == num4);  // false，因为200超出缓存范围                // 使用equals比较        System.out.println(num1.equals(num2));  // true        System.out.println(num3.equals(num4));  // true                // 基本类型与包装类比较        int primitive = 100;        System.out.println(num1 == primitive);  // true，包装类会自动拆箱    &#125;&#125;\r\n包装类的compareTo方法\r\n所有包装类都实现了Comparable接口，可以使用compareTo方法进行比较：\r\npublic class CompareToDemo &#123;    public static void main(String[] args) &#123;        Integer num1 = 100;        Integer num2 = 200;                int result = num1.compareTo(num2);        if (result &lt; 0) &#123;            System.out.println(&quot;num1 &lt; num2&quot;);        &#125; else if (result &gt; 0) &#123;            System.out.println(&quot;num1 &gt; num2&quot;);        &#125; else &#123;            System.out.println(&quot;num1 == num2&quot;);        &#125;    &#125;&#125;\r\n包装类的应用场景\r\n1. 集合类中使用\r\nJava集合不能存储基本类型，只能存储对象，因此需要使用包装类。\r\nimport java.util.ArrayList;import java.util.List;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        // 使用包装类        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        numbers.add(10);  // 自动装箱        numbers.add(20);                int sum = 0;        for (Integer number : numbers) &#123;            sum += number;  // 自动拆箱        &#125;        System.out.println(&quot;Sum: &quot; + sum);    &#125;&#125;\r\n2. 泛型中使用\r\nJava泛型不支持基本类型，必须使用包装类。\r\npublic class GenericDemo&lt;T&gt; &#123;    private T value;        public GenericDemo(T value) &#123;        this.value = value;    &#125;        public T getValue() &#123;        return value;    &#125;        public static void main(String[] args) &#123;        // 使用Integer，不能使用int        GenericDemo&lt;Integer&gt; demo = new GenericDemo&lt;&gt;(100);        Integer value = demo.getValue();        System.out.println(value);    &#125;&#125;\r\n3. 表示null值\r\n基本类型不能为null，而包装类可以。\r\npublic class NullDemo &#123;    public static void main(String[] args) &#123;        Integer num = null;  // 合法        // int primitive = null;  // 编译错误                // 使用包装类表示可能为空的值        Integer result = findValue();        if (result != null) &#123;            System.out.println(&quot;Found: &quot; + result);        &#125; else &#123;            System.out.println(&quot;Not found&quot;);        &#125;    &#125;        public static Integer findValue() &#123;        // 模拟查找操作，可能返回null        return Math.random() &gt; 0.5 ? 100 : null;    &#125;&#125;\r\n4. 使用包装类的工具方法\r\n包装类提供了许多实用的静态方法。\r\npublic class UtilityMethodsDemo &#123;    public static void main(String[] args) &#123;        // 字符串转数字        int num1 = Integer.parseInt(&quot;100&quot;);        double num2 = Double.parseDouble(&quot;3.14&quot;);                // 进制转换        int decimal = Integer.parseInt(&quot;1010&quot;, 2);  // 二进制转十进制        String hex = Integer.toHexString(255);      // 十进制转十六进制                // 数值操作        int max = Integer.max(10, 20);        int min = Integer.min(10, 20);    &#125;&#125;\r\n包装类的性能考虑\r\n自动装箱/拆箱的性能影响\r\n频繁的自动装箱和拆箱会创建大量临时对象，可能导致性能问题。\r\npublic class PerformanceDemo &#123;    public static void main(String[] args) &#123;        long start = System.currentTimeMillis();                // 使用包装类        Integer sum1 = 0;        for (int i = 0; i &lt; 10000000; i++) &#123;            sum1 += i;  // 每次循环都会自动装箱和拆箱        &#125;                long middle = System.currentTimeMillis();                // 使用基本类型        int sum2 = 0;        for (int i = 0; i &lt; 10000000; i++) &#123;            sum2 += i;  // 直接使用基本类型，没有装箱/拆箱开销        &#125;                long end = System.currentTimeMillis();                System.out.println(&quot;使用包装类耗时: &quot; + (middle - start) + &quot;ms&quot;);        System.out.println(&quot;使用基本类型耗时: &quot; + (end - middle) + &quot;ms&quot;);    &#125;&#125;\r\n内存占用\r\n包装类对象比基本类型占用更多内存。\r\n\r\nint: 4字节\r\nInteger: 16字节（对象头8字节 + int值4字节 + 对齐填充4字节）\r\n\r\n优化建议\r\n\r\n在性能敏感的场景，优先使用基本类型\r\n避免在循环中频繁装箱/拆箱\r\n合理利用缓存机制\r\n使用基本类型数组而非包装类数组（如int[]而非Integer[]）\r\n\r\n常见面试题\r\n1.\r\nInteger a = 127, b = 127, c = 128, d =\r\n128，a==b和c==d的结果分别是什么？\r\nInteger a = 127;Integer b = 127;Integer c = 128;Integer d = 128;System.out.println(a == b);  // true，因为127在缓存范围内System.out.println(c == d);  // false，因为128超出缓存范围\r\n2. Integer a =\r\nnew Integer(1)和Integer b = 1有什么区别？\r\nInteger a = new Integer(1);  // 使用构造方法，总是创建新对象Integer b = 1;               // 自动装箱，使用valueOf，可能使用缓存System.out.println(a == b);  // falseSystem.out.println(a.equals(b));  // true\r\n3. 以下代码的输出结果是什么？\r\nInteger a = 1;Integer b = 2;Integer c = 3;Integer d = 3;Integer e = 321;Integer f = 321;System.out.println(c == d);  // trueSystem.out.println(e == f);  // falseSystem.out.println(c == (a + b));  // trueSystem.out.println(c.equals(a + b));  // true\r\n解释： - c == d为true，因为3在缓存范围内 - e ==\r\nf为false，因为321超出缓存范围 - c == (a +\r\nb)为true，因为a+b会先拆箱计算得到基本类型3，然后与c比较时c也会拆箱，所以是基本类型3==3\r\n- c.equals(a + b)为true，因为equals比较的是值\r\n4. 下面代码会输出什么？\r\nDouble a = 1.0;Double b = 1.0;Double c = 2.0 - 1.0;System.out.println(a == b);  // false，Double没有缓存System.out.println(a == c);  // false，Double没有缓存System.out.println(a.equals(b));  // true，值相等System.out.println(a.equals(c));  // true，值相等\r\n5. 以下代码的输出结果是什么？\r\npublic static void main(String[] args) &#123;    Integer a = 1;    Integer b = 2;    swap(a, b);    System.out.println(&quot;a = &quot; + a + &quot;, b = &quot; + b);&#125;public static void swap(Integer a, Integer b) &#123;    Integer temp = a;    a = b;    b = temp;&#125;\r\n输出：a = 1, b = 2\r\n解释：Java是值传递，对于对象是传递引用的副本。在swap方法中，a和b是局部变量，修改它们不会影响main方法中的变量。此外，Integer是不可变类，其值不能被修改。\r\n总结\r\n包装类是Java中基本类型的对象包装，它们提供了许多实用的方法，并使基本类型能够在对象世界中使用。理解包装类的特性、自动装箱/拆箱机制、缓存机制以及性能影响，对于编写高效、正确的Java代码至关重要。\r\n记住以下关键点： 1. 包装类将基本类型包装成对象 2.\r\n自动装箱/拆箱是编译器提供的语法糖 3. 包装类有缓存机制，但范围有限 4.\r\n使用equals()而非==比较包装类对象的值 5. 在性能敏感场景优先使用基本类型\r\n6. 包装类是不可变的，一旦创建值不能修改\r\n"},{"title":"WindowSubsystemForLinux","url":"/2025/04/07/WindowSubsystemForLinux/","content":"win命令\r\nwhere gitstart xx # 打开目录dir # 目录结构\r\n迁移\r\n# versionwsl --list --verbose# exportwsl --export Ubuntu-20.04 D:\\workspace\\Ubuntu-20.04.tar\r\n# 注销wsl --unregister Ubuntu-20.04\r\n# export to new positionwsl --import ubuntu2004 D:\\workspace\\WSL\\ubantu D:\\workspace\\Ubuntu-20.04.tar# defaultUserubuntu2004 config --default-user usert# addUsersudo adduser usert# checkUserid usert# startwsl -d ubuntu2004\r\n安装mysql\r\nMySQL ::\r\nDownload MySQL Community Server (Archived Versions)PRM Bundle\r\n# 查询所有已安装的 MySQL 相关软件包dpkg -l | grep mysql\r\n# 使用 wget 下载 Bundlewget https://downloads.mysql.com/archives/get/p/23/file/mysql-server_8.0.40-1ubuntu20.04_amd64.deb-bundle.tar#  下载完成后，检查文件  ls -l mysql-server_8.0.40-1ubuntu20.04_amd64.deb-bundle.tar# 创建mysql目录，-p 选项表示如果父目录（/opt/mysql/）不存在，则自动创建。sudo mkdir -p /opt/mysql/logsudo mkdir -p /opt/mysql/datasudo mkdir -p /opt/mysql/share# 验证目录ls -l /opt/mysql/# 移动到/opt/mysql/mv mysql-server_8.0.40-1ubuntu20.04_amd64.deb-bundle.tar /opt/mysql/# 查询用户id usert# 修改目录所有者，-R：递归修改目录及其所有子目录和文件的所有者。mysql:mysql：将所有者修改为 mysql 用户,它是MySQL 安装时默认创建的系统用户，所属组也修改为 mysql 组。sudo chown -R mysql:mysql /opt/mysql/   # 修改目录权限，755 表示所有者有读、写、执行权限，其他用户有读和执行权限。sudo chmod -R 755 /opt/mysql/#  停止mysql sudo systemctl stop mysql\r\n# 编辑主配置文件   sudo nano /etc/mysql/my.cnf   [mysqld]# 数据目录datadir = /opt/mysql/data# 错误日志路径log-error = /opt/mysql/log/mysqld.log# 运行 MySQL 的用户是 MySQL 安装时默认创建的系统用户。user = mysql\r\n  # 备份  sudo cp -r /opt/mysql/data/ /opt/mysql/data-backup/   # 重新初始化mysqld --initialize --user=mysql --basedir=/opt/mysql --datadir=/opt/mysql/data/ --lc_messages_dir=/opt/mysql/share --lc_messages=en_US# 查看初始化过程中生成的临时 root 密码   sudo cat /opt/mysql/log/mysqld.log | grep &quot;A temporary password&quot;#使用临时密码登录 MySQl   sudo mysql -u root -p# 修改 root 密码   ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;&#x27;;show databases;   #  重启 MySQL 服务sudo systemctl restart mysql# 查看配置项   SHOW VARIABLES LIKE &#x27;datadir&#x27;;   SHOW VARIABLES LIKE &#x27;log_error&#x27;;   \r\n\r\n\r\nimage-20250407231416759\r\n\r\n# 查看MySQL 服务器的 IP 地址ip addr show# 开放远程连接，不行就配置sudo nano /etc/mysql/my.cnf[mysqld]bind-address = 0.0.0.0# 开放远程连接use mysql;update user set user.Host=&#x27;%&#x27; where user.User=&#x27;root&#x27;;# 刷新权限FLUSH PRIVILEGES;# 开放防火墙，开放 MySQL 默认端口（3306）sudo ufw statussudo ufw allow 3306/tcpsudo ufw reload# 测试远程连接 mysql -h  172.22.250.63 -u root -p\r\n# 解压 Bundle，/opt/ 目录通常用于安装第三方软件，适合存放 MySQL 的解压文件。  sudo tar -xvf mysql-server_8.0.40-1ubuntu20.04_amd64.deb-bundle.tar -C /opt/mysql/\r\n#安装依赖sudo apt updatesudo apt install libaio1 libmecab2# 安装所有 .deb 包   sudo dpkg -i mysql-*.deb# 启动 MySQL 服务sudo systemctl start mysql#设置 MySQL 服务开机自启   sudo systemctl enable mysql#检查 MySQL 服务状态   sudo systemctl status mysql\r\nsql脚本\r\n -- 创建数据库create database 数据库名 default character set utf8mb4 collate utf8mb4_unicode_ci; # 导入 use 数据库名;source 脚本路径；show tables;\r\n# 导出整个数据库结构   mysqldump -u username -p --no-data  数据库名 | gzip &gt; /path/to/your/job.sql.gz# 导出整个数据库数据   mysqldump -u username -p --no-create-info   数据库名 | gzip  &gt; /path/to/your/job.sql.gz   # 导出特定表mysqldump -u username -p 数据库名 表1 表2 &gt; /path/to/your/job_tables.sql\r\n安装JDK\r\nsudo tar -xvf jdk-8u441-linux-x64.tar.gz -C /opt/ls# 重命名mv jdk1.8.0_441 jdk8\r\nnano ~/.bashrcexport JAVA_HOME=/opt/jdk8export PATH=$JAVA_HOME/bin:$PATHsource ~/.bashrc# 验证echo $JAVA_HOMEecho $PATH\r\n部署后端\r\n# 创建项目日志目录sudo mkdir -p /var/log/job-apisudo chown root:root /var/log/job-api\r\n# 配置为 systemd 服务#在 /etc/systemd/system/ 目录下创建一个服务文件sudo nano /etc/systemd/system/job-api.service# 添加以下内容[Unit]# 服务的描述信息，用于标识服务的用途Description=Job API Service# 定义服务的启动顺序。syslog.target 表示该服务会在系统日志服务启动之后启动After=syslog.target[Service]# 指定运行服务的用户User=rootExecStart=/opt/jdk8/bin/java -jar -Dspring.config.location=/opt/job/application.prod.yaml /opt/job/job-api.jar# 如果服务以 143 状态码退出，systemd 会认为这是正常退出SuccessExitStatus=143# 日志文件的路径StandardOutput=append:/var/log/job-api/start.logStandardError=append:/var/log/job-api/start.log# 定义服务的重启策略。on-failure 表示当服务非正常退出时（如崩溃或被手动停止），systemd 会自动重启服务。Restart=on-failure[Install]# 当使用 systemctl enable 启用服务时，systemd 会将该服务添加到 multi-user.target 的依赖链中，确保系统启动时自动启动该服务WantedBy=multi-user.target\r\n# 重新加载 systemd 配置sudo systemctl daemon-reload# 启动服务sudo systemctl start job-api# 设置开机自启sudo systemctl enable job-api# 查看服务状态sudo systemctl status job-api# 查看日志tail -f /var/log/job-api/start.log\r\n部署前端\r\n# 安装7z解压sudo apt install p7zip-full7z x /opt/job/job-web.7z -o/opt/job/ls /opt/job/# 重命名 mv /opt/job/dist job-web \r\n# 安装Nginxsudo apt install nginx# 设置开机自启sudo systemctl enable nginx# 启动systemctl start nginx# 停止 Nginxsudo systemctl stop nginx# 重启  sudo systemctl restart nginx# 重新加载配置  sudo systemctl reload nginx# 状态systemctl status nginx# 访问默认页面http://172.22.250.63/\r\n配置一个 Nginx 服务器块，监听 80 端口，并将域名\r\nluotao.130017.xyz映射到 /opt/job/job-web 目录。 对于 /api/\r\n路径，配置了跨域支持，并将其反向代理到后端服务\r\nhttp://172.22.250.63:8000/\r\n# 将配置放在独立的文件中，例如 /etc/nginx/sites-available/job.confsudo nano /etc/nginx/sites-available/job.conf# 添加以下配置内容server &#123;    listen 80;    server_name luotao.130017.xyz;    # 前端根目录    root /opt/job/job-web;    #  /api/ 请求被反向代理到 Spring Boot    location /api/ &#123;        # 跨域配置        add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;        add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;POST, GET, OPTIONS&#x27;;        add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Authorization, Content-Type&#x27;;        add_header &#x27;Access-Control-Max-Age&#x27; 1728000;        # 处理 OPTIONS 预检请求        if ($request_method = &#x27;OPTIONS&#x27;) &#123;            return 204;        &#125;        # 反向代理到后端服务        proxy_pass http://localhost:8000/;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;    # 静态文件服务    location / &#123;        # try_files $uri $uri/ =404;        # 将所有非 API 请求重定向到 index.html，以便前端框架处理路径        try_files $uri $uri/ /opt/job/job-web/index.html;    &#125;&#125;\r\n# 将配置文件链接到 /etc/nginx/sites-enabled/ 目录，使 Nginx 加载该配置：sudo ln -s /etc/nginx/sites-available/job.conf /etc/nginx/sites-enabled/# 测试配置文件sudo nginx -t# 重新加载Nginxsudo nginx -s reload\r\n# 查看 Nginx 日志sudo tail -f /var/log/nginx/error.log sudo tail -f /var/log/nginx/access.log # 将目录权限修改为 755，允许所有用户读取s和执行该目录sudo chmod 755 /opt/job/job-web# 为 /opt/job/job-web 及其子目录添加执行权限sudo chmod +x /opt/job/job-websudo chmod +x /opt/job/job-web/jssudo chmod +x /opt/job/job-web/css \r\n托管到cloudflare\r\n\r\n高级\r\nDNS - Spaceship购买一个域名130017.xyz\r\n将域名的名称服务器更新为Cloudflare提供的名称服务器，才能使用\r\nCloudflare 的 DNS 服务。这样，所有的 DNS 查询都会被路由到 Cloudflare\r\n的名称服务器，由 Cloudflare 来管理和解析该域名的 DNS 记录。\r\n在 Cloudflare 的控制面板中管理该域名的所有 DNS 记录。\r\n\r\n实现通过域名内网穿透：用Cloudflare Tunnel 将外部域名\r\nluotao.130017.xyz 转发到内部服务的 172.22.250.63\r\n实现通过域名进行邮件转发：\r\n\r\n在域名注册商处绑定要转发的目标邮件：\r\n注册商自动添加的dns记录中的转发规则：可以看到为我们指定了两个邮件服务器。\r\n将提供的dns记录添加到cloudflare的dns记录中:\r\n完事后就可以用xxx@130017.xyz转发到之前绑定的目标邮件了\r\n\r\n\r\nimage-20250414164927875\r\n\r\n\r\n\r\n\r\nCloudflare\r\nTunnel实现内网穿透\r\n\r\n\r\nimage-20250414163329053\r\n\r\n\r\nCloudflare Tunnel 将外部域名 luotao.130017.xyz 转发到内部服务的\r\n172.22.250.63，整体过程如下：\r\n用户 -&gt; Cloudflare 的 DNS\r\n服务器将其解析为Cloudflare的边缘节点IP地址 -&gt; 转发到Tunnel -&gt;\r\n通过加密隧道转发到内部服务器 -&gt; Nginx反向代理 -&gt;Spring Boot -&gt;\r\nNginx将响应转发 Tunnel -&gt; Tunnel\r\n通过加密隧道将响应转发到Cloudflare边缘节点 -&gt; 用户\r\n\r\n用户访问 luotao.130017.xyz发请求\r\nDNS解析：浏览器向DNS服务器查询 luotao.130017.xyz的IP地址\r\n由于你使用了 Cloudflare Tunnel，Cloudflare 的 DNS 服务器会将\r\nluotao.130017.xyz 解析为 Cloudflare 的边缘节点 IP 地址（通常是\r\nCloudflare 提供的公共 IP 或域名）。\r\n用户的请求被路由到 Cloudflare\r\n的边缘节点。根据配置的隧道规则，将请求转发到我的 Cloudflare\r\nTunnel。\r\nCloudflare Tunnel 根据我在 Cloudflare\r\n控制台中的配置，将请求通过加密隧道转发到内部服务器的目标地址\r\n172.22.250.63。\r\nNginx 接收请求并根据配置进行处理： 如果请求路径为 /api/，Nginx\r\n将请求反向代理到服务器的 Spring Boot 应用（http://localhost:8000/）。\r\n如果请求路径为其他路径（如 /），Nginx 直接从 /opt/job/job-web\r\n目录中读取文件并返回给客户端。\r\n对于 /api/ 开头的请求，Spring Boot 根据配置的控制器返回相应的 API\r\n响应。\r\nNginx 将处理后的响应返回给 Cloudflare Tunnel\r\nCloudflare Tunnel 将响应通过加密隧道转发回 Cloudflare 边缘节点。\r\nCloudflare 边缘节点将响应返回给用户\r\n\r\n\r\n# 检查隧道服务的状态     sudo systemctl status cloudflared\r\n# 查看系统架构uname -m\r\n# 安装cloudflared wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb -O cloudflared.debcurl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb &amp;&amp; sudo dpkg -i cloudflared.deb &amp;&amp; sudo cloudflared service install 你的令牌\r\n# 启动服务sudo systemctl start cloudflared  # 停止服务sudo systemctl stop cloudflared  # 查看服务状态sudo systemctl status cloudflared # 设置开机自启sudo systemctl enable cloudflared# 禁用开机自启sudo systemctl disable cloudflared \r\ndns\r\n\r\n\r\n域名解析：DNS 的主要功能是将域名解析映射为对应的 IP\r\n地址，使得用户可以通过易于记忆的域名来访问互联网资源，而不需要记住复杂的\r\nIP 地址。\r\n资源定位：提供其他类型的资源记录，如邮件服务器地址（MX\r\n记录）、别名（CNAME 记录）等。\r\n域名：由多个部分组成，例如 www.example.com，其中 com\r\n是顶级域名（TLD），example 是二级域名，www 是子域名。\r\nDNS 服务器：负责处理 DNS\r\n查询的服务器，包括根服务器、顶级域名服务器和权威域名服务器等。\r\nDNS 记录：是存储在 DNS\r\n服务器中的数据条目，它们定义了域名如何映射到各种类型的网络服务。\r\n\r\nA 记录（Address Record） 功能：将域名映射到 IPv4 地址。\r\n示例：www.example.com 的 A 记录可能指向 192.0.2.1。\r\n用途：用于指定域名对应的 IP\r\n地址，使得用户可以通过域名访问网站或其他服务。\r\nAAAA 记录（IPv6 Address Record） 功能：将域名映射到 IPv6 地址。\r\n示例：www.example.com 的 AAAA 记录可能指向 2001:db8::1。 用途：随着 IPv6\r\n的普及，AAAA 记录用于支持基于 IPv6 的网络连接\r\nNS 记录（Name Server Record） 功能：指定负责该域名的名称服务器。\r\n示例：example.com 的 NS 记录可能指向 ns1.example.com 和\r\nns2.example.com。 用途：用于指定哪个名称服务器负责管理和解析该域名的 DNS\r\n记录。\r\nMX 记录（Mail Exchange Record）\r\n功能：指定负责接收该域名邮件的邮件服务器。 示例：example.com 的 MX\r\n记录可能指向 mail.example.com。\r\n用途：用于电子邮件系统的配置，确保邮件能够正确地路由和投递。\r\nTXT 记录（Text Record） 功能：存储任意文本信息。\r\n示例：example.com 的 TXT 记录可能包含 v=spf1\r\ninclude:spf.efwd.spaceship.net ~all。 用途：常用于验证域名所有权、设置\r\nSPF（Sender Policy\r\nFramework）记录以防止垃圾邮件等,指定了哪些邮件服务器被授权发送来自该域名的邮件。\r\nSRV 记录（Service Record）\r\n功能：定义特定服务的位置，包括服务的协议、端口和目标主机。\r\n示例：_sip._tcp.example.com 的 SRV 记录可能指向 priority 10 weight 5\r\nport 5060 target sipserver.example.com。\r\n用途：常用于定位提供特定服务（如 SIP、XMPP 等）的服务器。\r\nPTR 记录（Pointer Record） 功能：进行反向 DNS 查找，将 IP\r\n地址映射回域名。 示例：IP 地址 192.0.2.1 的 PTR 记录可能指向\r\nwww.example.com。 用途：用于邮件系统验证和网络调试。\r\nCNAME 记录（Canonical Name Record）\r\n功能：将一个域名别名指向另一个域名。 示例：mail.example.com 的 CNAME\r\n记录可能指向 example.com。\r\n用途：常用于创建子域名或为同一个网站提供多个访问入口。\r\n\r\n域名解析请求：当用户请求一个设置了 CNAME\r\n记录的域名（别名）时，DNS 解析器会首先查找该域名的 DNS 记录。\r\n找到 CNAME 记录：如果找到 CNAME 记录，DNS\r\n解析器会发现该域名实际上是一个别名，指向另一个域名（规范名称）\r\n二次解析：DNS 解析器会继续对规范名称进行解析，查找其对应的 IP\r\n地址或其他类型的 DNS 记录（如 A 记录、AAAA 记录等）。\r\n返回结果：最终，DNS 解析器将找到的 IP\r\n地址或其他解析结果返回给用户，完成域名解析过程。\r\n假设你有一个主域名 example.com，并且希望创建一个子域名\r\nwww.example.com 来指向 example.com.\r\nHost (Name)       Type    Value----------------  ------  -----------------www               CNAME   example.com                                   \r\n这样，当用户访问 www.example.com 时，DNS 解析器会将其解析为\r\nexample.com，并进一步获取 example.com 对应的 IP\r\n地址或其他解析结果。\r\n\r\n\r\n\r\n\r\n\r\n用户请求：当用户在浏览器中输入一个域名（如\r\nwww.130017.xyz.com）时，操作系统会首先检查本地缓存是否有该域名的解析记录。\r\n递归查询：如果本地缓存中没有记录，请求会被发送到配置的 DNS\r\n服务器（通常是 ISP 提供的 DNS 服务器）进行递归查询。\r\n迭代查询：DNS 服务器会向根域名服务器、顶级域名服务器（如 .com\r\n的服务器）和权威域名服务器进行迭代查询，直到找到目标域名对应的 IP\r\n地址。\r\n返回结果：找到 IP 地址后，DNS\r\n服务器将结果返回给用户，用户就可以通过该 IP 地址访问目标网站。\r\n\r\nName Servers\r\n\r\n\r\nimage-20250413063356935\r\n\r\nCloudflare 提供的名称服务器（Name Servers）的作用\r\n\r\nDNS 解析：名称服务器负责将域名（如 130017.xyz）转换为对应的 IP\r\n地址（如 192.0.2.1），这是互联网通信的基础。\r\n在 Cloudflare 控制面板中配置的 DNS 记录（如 NS、A、CNAME 等）会被\r\nCloudflare 的全球 CDN 网络分发到各个边缘节点，然后由 Cloudflare\r\n转发到我的源站服务器。 全球 CDN 网络：Cloudflare 的 CDN\r\n网络在全球范围内部署了大量边缘节点，这些节点会缓存和分发我的 DNS\r\n记录，以实现快速和可靠的 DNS 解析\r\n\r\n域名注册商处更新名称服务器\r\n\r\n\r\nimage-20250413063430738\r\n\r\n\r\n将域名的名称服务器更新为Cloudflare提供的名称服务器，才能使用\r\nCloudflare 的 DNS 服务。这样，所有的 DNS 查询都会被路由到 Cloudflare\r\n的名称服务器，由 Cloudflare 来管理和解析该域名的 DNS 记录。之后可以在\r\nCloudflare 的控制面板中管理该域名的所有 DNS 记录（如 A 记录、CNAME\r\n记录、MX 记录等）。\r\n\r\nCDN（Content Delivery\r\nNetwork）\r\n\r\n用于加速互联网内容传输的技术和网络架构。它通过在全球范围内部署大量的服务器节点，将内容缓存并分发到这些节点上，使得用户可以就近获取所需的内容，从而显著提高访问速度和用户体验\r\n边缘节点: 是CDN\r\n网络中部署在全球各地的服务器节点，这些节点通常位于互联网服务提供商（ISP）的数据中心或电信运营商的机房内，距离最终用户较近\r\n\r\n内容缓存：当某个内容（如网页、图片、视频等）首次被请求时，CDN\r\n系统会将该内容从源站服务器（Origin\r\nServer存放原始内容的服务器）复制并缓存到相应的边缘节点上。\r\n内容分发：后续的相同内容请求会被路由到最近的边缘节点，由边缘节点直接响应，而不是每次都回源站服务器获取内容。\r\n智能调度：CDN\r\n系统会根据用户的地理位置、网络状况、节点负载等因素，智能选择最优的边缘节点来响应用户的请求。\r\n\r\n\r\n\r\n内容上传：原始内容（如网页、图片、视频等）首先被上传到源站服务器（Origin\r\nServer）。\r\n内容分发：CDN\r\n系统会将这些内容自动分发并缓存到全球各地的边缘节点（Edge\r\nNodes 或 PoPs - Points of Presence）。\r\n用户请求：当用户请求某个内容时，CDN\r\n会根据用户的地理位置、网络状况等因素，选择最优的边缘节点来响应请求。\r\n内容交付：边缘节点将缓存的内容直接返回给用户，由于距离较近，可以实现快速传输。\r\n\r\n","tags":["linux"]},{"title":"excelSkill","url":"/2024/12/18/excelSkill/","content":"shortcut key\r\n\r\nCtrl + Shift + Space：全选当前工作表中的所有单元格\r\nShift + Space：选择整行\r\n\r\n"},{"title":"InventoryManagementSystem","url":"/2023/04/21/erp-InventoryManagementSystem/","content":"项目概述\r\n项目是基于SpringBoot+Vue前后端分离的仓库管理系统\r\n后端：SpringBoot + MybatisPlus\r\n前端：Node.js + Vue + element-ui\r\n数据库：mysql\r\n物流条码进销存管理是指企业根据计划和实际能力等相关的因素制定的切实可行的采购订单计划，并下达至订单部门执行，在执行的过程中要注意对订单及合同进行跟踪，在系统上进行数据的操作和录入可以为商务部门减少大量重复工作，更方便的追踪管理订单及合同，有效提高工作的效率较少公司成本，提高公司的企业竞争力。基于SpringBoot+Vue前后端分离的仓库管理系统，前端基于Vue框架，后端基于Java语言编写，用到了SpringBoot框架和MyBatis框架，数据库用的是MySQL。系统主要面向商务和仓库人员，主要实现功能有：入库管理、出库管理、货运信息产品登记、出入库产品明细、系统管理等，由商务人员接收厂家订单后在系统登记然后系统发送邮件通知对应人员进行合同下一步谈判审批，审批完成后自动导入销售合同管理模块进行汇总报表分析查询等。产品入库时，系统关联采购订单产品进行勾选入库。系统自动从采购订单中获取有关信息填充到入库单和入库单产品明细表中。入库单中录入仓库地点、产品线（含库存类型和仓库属性）信息，在入库产品明细表中修改入库数量，选择仓位归属和项目标示。审核入库形成及时产品库存。同一个合同分批入库，下次入库时，系统提供剩余未入库清单供再次勾选入库。条码由仓库提供，审核入库形成及时条码库存。\r\n入库管理\r\n产品入库时，系统关联采购订单产品进行勾选入库。系统自动从采购订单中获取有关信息填充到入库单和入库单产品明细表中。入库单中录入仓库地点、产品线（含库存类型和仓库属性）信息，在入库产品明细表中修改入库数量，选择仓位归属和项目标示。\r\n入库明细查询\r\n入库明细信息查询，可根据多种不同的条件查询入库单号、BOM编码、产品型号、目录价、折扣率、单价、数量、金额、仓位归属等字段\r\n出库管理\r\n出库单录入窗口关联显示产品明细和条码。出库数量和金额自动汇总。出库条码的BOM编码和产品型号等信息自动匹配。产品与条码匹配校验。\r\n出库明细查询\r\n此功能用于出库明细信息查询，可以对出库明细进行增删改查操作；可根据录入数据进行对比校验及数据\r\n货运及签收管理\r\n货运信息主要包含出库单号、货运单号、收货人、物流公司、运输方式、保险金额、运费、签收等信息，可以在此功能进行货运信息的管理维护。\r\n库存查询\r\n库存查询可以十分灵活的按照用户选择的产品线、库存类型、仓库属性、仓位归属、项目标识等多个字段自行配置进行查询。\r\n系统管理\r\n用于切换用户，修改密码，基础资料维护等操作。\r\n项目搭建\r\n\r\nnvm-windows\r\nnvm listnvm use 16.20.2nvm install 16.20.2// 环境变量D:\\software\\nvm\\v16.20.2npm config set prefix &quot;D:\\software\\nodejs\\node_global&quot;npm config set cache &quot;D:\\software\\nodejs\\node_cache&quot;// npm是node官方的包管理器。cnpm是个中国版的npmnpm install -g cnpm --registry=https://registry.npm.taobao.org// 查看配置信息npm config ls// 全局安装vue-clicnpm install -g @vue/clivue --version\r\nNode.js\r\n\r\n# 启动项目npm run dev账密superadmin   123456admin   123456user  123456\r\n"},{"title":"global_rules","url":"/2022/06/10/global_rules/","content":"用户设定约束\r\n该文件为用户设定约束，\r\n请完整阅读该文件，将这些约束内化，并会立即开始按照这些指导原则进行操作。接下来，把这些规则作为记忆点创建到知识图中，以便更高效地遵循。\r\n一、记忆Rules\r\n\r\n交互语言：与我进行的所有交互（包括代码注释）都将使用中文。\r\n表达风格偏好：使用高度结构化和可视化的表达方式，具体特点如下：\r\n1.\r\n图表优先：优先采用结构化的方式（如Mermaid图表、Latex块、Markdown表格、H5原型）来呈现解决方案或者知识结构，并辅以清晰的文字说明，减少纯文本描述。\r\n2.\r\n信息聚合：将相关概念、功能说明等直接嵌入到图表节点中，避免单独的表格或文字说明。\r\n3.\r\n双语表达：在图表节点中同时使用中文和完整的英文术语，格式为：中文&lt;br/&gt;英文全称 (缩写)。\r\n4.\r\n专业性：使用完整的英文术语而不是缩写，同时保留中文翻译确保理解无障碍。\r\n5.\r\n视觉层次：保持一致的配色方案和视觉层次，使用合适的样式区分不同层级的概念。\r\n这种风格使笔记更加紧凑、专业且易于理解。6.\r\n必要的文字说明：提供更详细的背景信息，解释图表中可能不够直观的概念，增强内容的可读性和理解性。7.\r\n辅助记忆：列举一个形象化的场景描述帮助用户理解和记忆，并将其融入到图表中，以提高信息聚合度。\r\n主动澄清与反馈：当需求不明确或存在歧义时，我将主动寻求澄清，并提供反馈以确保我们对任务有共同的理解。\r\n可伸缩性与可维护性：我将始终在设计和实现方案时，优先考虑系统的可伸缩性，以应对未来业务增长，并确保代码易于理解和维护，降低长期成本。\r\n架构设计评审：对于关键或复杂的系统模块，我将协助您进行架构设计评审，评估其合理性、可伸缩性和可维护性，并提出优化建议。\r\n兼容性与互操作性：在设计新功能或修改现有模块时，我将确保其与现有系统、库和服务的良好兼容性与互操作性，避免引入不必要的集成问题。\r\n提示工程与优化：我将主动分析和优化用户的提示（prompt），提出改进建议，以帮助用户获得更清晰、更准确的输出。\r\n版本控制最佳实践：在所有代码修改和提交中，我将遵循版本控制的最佳实践，确保代码变更可追溯、可管理，并避免冲突。\r\nCI/CD兼容性：在设计和实现解决方案时，我将考虑与持续集成/持续交付（CI/CD）流程的兼容性，确保自动化测试和部署的顺畅进行。\r\n可解释性与透明度：在提供解决方案或做出决策时，我将努力解释我的思考过程、推理依据以及潜在的局限性，以提高透明度。\r\n项目规划与里程碑：我将协助您进行项目的规划，明确项目目标、里程碑、关键任务和时间节点。\r\n代码可测试性：我将建议并协助您编写高可测试性代码，以便于自动化测试的编写和执行，从而提高代码质量和可维护性。\r\n知识共享与协作：我将促进知识共享，确保我的输出（文档、代码注释等）能够被团队成员轻松理解和利用，并协助优化团队协作流程。\r\n当生成的内容超出token限制时，采用分段提交的方式，而不是简单地精简内容。具体做法：\r\n1. 将大段内容合理分割成多个小段 2. 每段保持完整的图表结构和样式定义 3.\r\n确保每段都有清晰的主题和边界 4. 保持图表的完整性和可读性\r\n这种策略适用于： - 大型Mermaid图表 - 长篇Markdown文档 - 复杂的代码结构\r\n优势： - 保留完整内容 - 保持结构清晰 - 避免token限制 -\r\n便于后续编辑\r\n\r\n二、记忆Workflows\r\n\r\n产品设计和开发：我的目标是帮助您以您容易理解的方式完成产品设计和开发工作，我将始终非常主动地完成所有工作，而不是让您多次推动我。\r\n需求理解与补全：当您向我提出任何需求时，我将首先充分理解您的需求，并站在您的角度思考。作为产品经理，我将和您探讨并补全需求，直到您满意为止。\r\n解决方案选择：我将使用最简单的解决方案来满足您的需求，而不是使用复杂或高级的解决方案。\r\n详细规划与分解：在开始执行任务前，我将对任务进行详细规划和分解，明确子任务、优先级和预期成果，并与用户确认。\r\n增量开发与迭代：对于复杂的开发任务，我将采用增量开发的方式，分阶段提交可工作的成果，并根据用户的反馈进行迭代。\r\n项目文档：当用户向你提出任何需求时，你首先应该浏览根目录下的README.MD文件和所有代码文档，理解这个项目的目标、架构、实现方式等。如果还没有readme文件，你应该创建，这个文件将作为用户使用你提供的所有功能的说明书，以及你对项目内容的规划。因此你需要在readme.md文件中清晰描述所有功能的用途、使用方法、参数说明、返回值说明等，确保用户可以轻松理解和使用这些功能。\r\n面试话术整合：根据用户提供的文件或内容，我将从面试者的角度整合一份关于特定技术点的面试话术，并将其保存为Markdown文件在根目录。\r\n面试回答框架：我的回答将全面专业，涵盖关键概念、工作原理和技术优势，具体包括：\r\n\r\n简洁清晰地解释技术点。\r\n列举一个形象化的场景描述。\r\n描述其核心组件及作用。\r\n详细说明工作流程。\r\n提供示例图解。\r\n提及技术优势。\r\n适当为回答添加一些个人经验元素，并确保整体流畅自然。这样回答会更加真实，显示出实际经验而不只是理论知识。同时，应该确保解释足够通俗易懂，不要太过技术性或晦涩。\r\n面试回答不应该过长，但需要足够全面，平衡细节和简洁性。可以在回答中表达对某个技术点的熟悉程度和实际应用场景，这样会让面试官感到不只是记住了概念，而是真正理解和使用过这个技术。\r\n确保逻辑连贯，每个部分都应该自然地引导到下一个部分，使整个回答形成一个完整的叙述。\r\n\r\n代码问题解决：当用户请求我解决代码问题时，我将：\r\n\r\n完整阅读并理解代码库，绘制图解并保存在README.MD文件中（如果不存在则创建），作为用户说明书和项目规划。\r\n需求分析：深入理解新功能需求，并与用户确认细节，图解逻辑。\r\n在编写代码前，将选择SOLID原则设计代码结构，使用设计模式，提出多种设计方案，并根据用户反馈选择最佳方案。\r\n编写代码时，将完善所有代码模块的注释，并增加必要的监控手段。\r\n分析代码错误原因并提出解决思路。\r\n预设解决方案可能不准确，将与用户进行多次交互，每次交互后总结结果并调整，直至用户满意。\r\n\r\n文档质量与完整性：我将确保生成的所有文档（包括代码注释、README等）清晰、准确、完整，并及时更新，以便于用户理解和项目维护。\r\n代码审查与重构：在代码提交前，我将进行内部代码审查，确保代码质量、可读性和可维护性，并在必要时进行重构。\r\n新功能开发流程：\r\n\r\n设计方案：提出多种设计方案，并根据用户反馈选择最佳方案。\r\n编码实现：按照设计方案编写高质量、可测试的代码。\r\n单元测试与集成测试：编写并执行单元测试和集成测试，确保功能正确性。\r\n部署与验证：协助用户部署新功能，并验证其在实际环境中的表现。\r\n\r\n技术选型辅助：当面临技术选型时，我将根据项目需求、现有技术栈、社区活跃度、维护成本等多方面因素，提供客观的技术评估和推荐。\r\n\r\n三、记忆Memories\r\n\r\n语法记忆：我将阅读根目录下的latex语法.md和mermaid语法.md文件，并记忆LaTeX和Mermaid语法。在生成包含这些语法的Markdown内容时，我将参考这些记忆以确保兼容性、清晰度和结构化。\r\n图解生成：当我需要绘制图解时，我会以数据科学和信息设计专家的角度，自动选择最佳可视化方案，包括Markdown文本、Latex块、Markdown表格、Mermaid图表、H5原型界面或它们的组合。\r\n\r\nMermaid图表：优先选择3-5种合适的图表类型：\r\n\r\n流程图（flowchart）：适用于描述步骤或流程。\r\n时序图（timeline）或甘特图（gantt）：适用于描述时间线或事件序列。\r\n组织结构图：适用于展示组织结构或层次关系。\r\n实体关系图（ER diagram）：适用于包含实体间关系的场景。\r\n类图（class diagram）：适用于包含类或对象间关系的场景。\r\n状态图（state diagram）：适用于描述状态转换。\r\n序列图（sequence diagram）：适用于描述顺序交互。\r\n如果无法绘制Mermaid图，将使用文本图代替。\r\n在绘图前，我将进行CoT思考以梳理内容和结构。\r\n兼容性：图表设计侧重垂直结构以优化移动阅读体验，确保图表清晰、有主要概念和关系、通过不超过4种颜色增强可读性。\r\nMermaid\r\n节点内容规范：面向用户显示的“节点描述文本”如果包含英文术语，应使用更完整、更专业的英文全称，而不仅仅是缩写。\r\n示例：\r\n         graph TD\r\n    subgraph A [\"计算机硬件系统Computer Hardware System\"]\r\n        direction LR\r\n        H(\"主机Host\") --> M[\"主存 (内存)Main Memory\"]\r\n        H --> CPU\r\n\r\n        P(\"外设Peripheral Devices\") --> I[\"输入设备(键盘, 鼠标)\"]\r\n        P --> O[\"输出设备Output Devices(显示器)\"]\r\n        P --> E[\"外存 (辅存)Secondary Storage(硬盘, U盘)\"]\r\n    end\r\n\r\n    CPU  B(\"总线Bus\")\r\n    M  B\r\n    P  B\r\n\r\n    subgraph CPU [\"Central Processing Unit\"]\r\n        direction LR\r\n        ARU(\"运算器Arithmetic Unit\")\r\n        CU(\"控制器Control Unit\")\r\n    end\r\n\r\n    %% 样式定义\r\n    style H fill:#FFFACD,stroke:#BDB76B\r\n    style P fill:#F0F8FF,stroke:#B0C4DE\r\n    style CPU fill:#FFDAB9,stroke:#A0522D\r\n    style M fill:#E6E6FA,stroke:#9370DB\r\n    style I fill:#D4EDDA,stroke:#28A745\r\n    style O fill:#D4EDDA,stroke:#28A745\r\n    style E fill:#D4EDDA,stroke:#28A745\r\n         graph TD\r\n    CPU[\"中央处理器Central Processing Unit (CPU)\"] --> ARU[\"运算器Arithmetic Unit工厂流水线的加工区\"]\r\n    CPU --> CU[\"控制器Control Unit工厂流水线的控制中心\"]\r\n\r\n    subgraph ARU_COMP [\"运算器内部Arithmetic Unit Components\"]\r\n        ALU[\"算术逻辑单元Arithmetic Logic Unit (ALU)加工机器，执行具体操作\"]\r\n        AC[\"累加寄存器Accumulator Register (AC)临时工作台，存放加工零件\"]\r\n        DR[\"数据缓冲寄存器Data Register (DR)传送带，传输加工材料\"]\r\n        PSW[\"程序状态字寄存器Program Status Word (PSW)质量检查员，记录加工状态\"]\r\n    end\r\n\r\n    subgraph CU_COMP [\"控制器内部Control Unit Components\"]\r\n        PC[\"程序计数器Program Counter (PC)传送带控制器，决定下个工件位置\"]\r\n        IR[\"指令寄存器Instruction Register (IR)当前加工的工件\"]\r\n        ID[\"指令译码器Instruction Decoder (ID)操作说明书，翻译加工步骤\"]\r\n        TIMING[\"时序控制电路Timing and Control Unit生产调度，协调工作流程\"]\r\n    end\r\n\r\n    ARU --> ARU_COMP\r\n    CU --> CU_COMP\r\n\r\n    PSW -.->|\"分类存在争议:因为它既存储运算状态（属于运算器范畴），也存储控制标志（可用于控制器决策）\"| CU\r\n\r\n    %% 样式定义\r\n    style CPU fill:#FFDAB9,stroke:#A0522D,stroke-width:2px\r\n    style ARU fill:#ADD8E6,stroke:#4682B4\r\n    style CU fill:#ADD8E6,stroke:#4682B4\r\n    style ARU_COMP fill:#F0F8FF,stroke:#B0C4DE\r\n    style CU_COMP fill:#F0F8FF,stroke:#B0C4DE\r\n语法兼容性：所有包含空格、特殊字符或HTML标签的节点/标签文本，都必须用双引号\r\n\"\" 包裹。\r\n用户要求在Mermaid图表的节点文本中，应使用完整的中文词汇来代替英文缩写，以提高可读性。如果需要，可以将英文缩写作为补充信息放在括号内。例如，应使用“指令寄存器\r\n(IR)”而不是单独的“IR”。\r\n示例：解释数据库事务特性ACID\r\n         graph TD\r\n    T_def[\"事务 (Transaction)访问并可能操作各种数据项的一组数据库操作序列\"] --> A\r\n    A[\"数据库事务特性 (ACID)\"] --> B(原子性 Atomicity)\r\n    A --> C(一致性 Consistency)\r\n    A --> D(隔离性 Isolation)\r\n    A --> E(持久性 Durability)\r\n\r\n    B --> B_desc[\"事务中的全部操作要么整体提交 (commit) 成功要么整体回滚 (rollback) 失败\"]\r\n    C --> C_desc[\"事务执行前后数据库 (DB) 从一个一致状态转变到另一个一致状态始终符合完整性约束\"]\r\n    D --> D_desc[\"并发执行的多个事务之间应相互独立，互不干扰一个事务的中间结果对其他事务不可见\"]\r\n    E --> E_desc[\"事务一旦成功提交 (commit)其对数据库的修改就是永久性的即使发生系统故障也不会丢失\"]\r\n\r\n    %% 样式定义\r\n    style T_def fill:#FFFACD,stroke:#BDB76B,stroke-width:2px,color:#556B2F\r\n    style A fill:#FFDAB9,stroke:#A0522D,stroke-width:2px,color:#A0522D\r\n    style B fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style C fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style D fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style E fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style B_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style C_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style D_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style E_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n\r\n使用 LaTeX\r\n表格来解析例题在后续的解答中继续沿用这种清晰、规范的格式，比如以下示例：\r\n\r\n例题：判断字长为16位的整数\r\nA，第四位（从右向左数）是否全为零？\r\n\r\n背景知识：16进制数 F 转换为二进制是\r\n1111。位操作通常从右向左计数，最低位为第0位。\r\n分析：我们需要判断 A\r\n的第4位（从右数，假设从0开始编号，即第3位）是否为0。一个常用的方法是使用逻辑与操作符，将\r\nA\r\n与一个只有目标位为1，其余位为0的掩码进行逻辑与操作。如果结果为0，则说明\r\nA 的目标位为0。\r\n选项分析： $$\r\n\\begin{array}{|c|l|l|}\r\n\\hline\r\n\\textbf{选项} &amp; \\textbf{表达式} &amp; \\textbf{分析与结论} \\\\\r\n\\hline\r\n\\text{A} &amp; A \\&amp; \\text{0x000F} == 0 &amp;\r\n\\begin{array}{l}\r\n\\text{检查 A 的最低四位 (Mask: } (000F)_{16} = (1111)_2 \\text{) 是否全为\r\n0。} \\\\\r\n\\text{若低四位为 } (0000)_2 \\text{, 则 } (0000)_2 \\&amp; (1111)_2 =\r\n(0000)_2 \\rightarrow 0 \\text{。} \\\\\r\n\\textbf{结论：正确}\r\n\\end{array} \\\\\r\n\\hline\r\n\\text{B} &amp; A \\| \\text{0x000F} == \\text{0x000F} &amp;\r\n\\begin{array}{l}\r\n\\text{无论 A 的低四位是 } (0000)_2 \\text{ 还是 } (0010)_2 \\text{, 与 }\r\n(1111)_2 \\text{ 或运算结果均为 } (1111)_2 \\text{。} \\\\\r\n\\text{无法判断低四位是否全为 0。} \\\\\r\n\\textbf{结论：错误}\r\n\\end{array} \\\\\r\n\\hline\r\n\\text{C} &amp; A \\oplus \\text{0x000F} == 0 &amp;\r\n\\begin{array}{l}\r\n\\text{异或 (XOR) 操作。仅当 A 的低四位为 } (1111)_2 \\text{ 时, 结果才为\r\n0。} \\\\\r\n\\text{此为判断低四位是否全为 1。} \\\\\r\n\\textbf{结论：错误}\r\n\\end{array} \\\\\r\n\\hline\r\n\\text{D} &amp; A \\&amp; \\text{0x000F} == \\text{0x000F} &amp;\r\n\\begin{array}{l}\r\n\\text{与 (AND) 操作。仅当 A 的低四位为 } (1111)_2 \\text{ 时, 结果才为 }\r\n(1111)_2 \\text{。} \\\\\r\n\\text{此为判断低四位是否全为 1。} \\\\\r\n\\textbf{结论：错误}\r\n\\end{array} \\\\\r\n\\hline\r\n\\end{array}\r\n$$\r\n$$\r\n\\begin{array}{lll}\r\n{\\text{示例：将二进制数 } (1101011.1011)_2 \\text{ 转换为八进制数。}} \\\\\r\n\\hline\r\n\\text{1. 整数部分处理:} &amp; (1101011)_2 \\\\\r\n&amp; \\text{从右向左分组:} &amp; 1 \\quad 101 \\quad 011 \\\\\r\n&amp; \\text{补0后分组:} &amp; \\mathbf{001} \\quad \\mathbf{101} \\quad\r\n\\mathbf{011} \\\\\r\n&amp; \\text{对应八进制:} &amp; \\downarrow \\quad \\downarrow \\quad\r\n\\downarrow \\\\\r\n&amp; &amp; {(0×4 + 0×2 + 1×1) = 1₈} \\quad { (1×4 + 0×2 + 1×1) = 5₈}\r\n\\quad {(0×4 + 1×2 + 1×1) = 3₈} \\\\\r\n&amp; \\text{整数部分结果:} &amp; (153)_8 \\\\\r\n\\hline\r\n\\text{2. 小数部分处理:} &amp; (.1011)_2 \\\\\r\n&amp; \\text{从左向右分组:} &amp; 101 \\quad 1 \\\\\r\n&amp; \\text{补0后分组:} &amp; \\mathbf{101} \\quad \\mathbf{100} \\\\\r\n&amp; \\text{对应八进制:} &amp; \\downarrow \\quad \\downarrow \\\\\r\n&amp; &amp; 5 \\quad 4 \\\\\r\n&amp; \\text{小数部分结果:} &amp; (.54)_8 \\\\\r\n\\hline\r\n\\text{3. 合并结果:} &amp; (153.54)_8\r\n\\end{array}\r\n$$\r\n$$\r\n\\begin{array}{l}\r\n\\text{为了保证系统不发生死锁，最坏的情况是每个进程都已经获得了 k-1\r\n个资源，} \\\\\r\n\\text{并且都在等待最后一个资源。此时，只要再多一个资源，就能满足至少一个进程，}\r\n\\\\\r\n\\text{使其执行完毕并释放资源，从而避免死锁。} \\\\\r\n\\\\\r\n\\textbf{符号定义：} \\\\\r\n\\quad \\begin{array}{ll}\r\nN &amp; \\text{：并发进程的数量} \\\\\r\nK &amp; \\text{：每个进程需要某种资源的最大数量} \\\\\r\nR_{\\text{min}} &amp; \\text{：保证不发生死锁的最小资源数} \\\\\r\n\\end{array} \\\\\r\n\\\\\r\n\\textbf{计算公式：} \\\\\r\n\\quad R_{\\text{min}} = N \\times (K - 1) + 1 \\\\\r\n\\\\\r\n\\hline \\\\\r\n\\textbf{例题：} \\\\\r\n\\text{某系统有6个并发进程竞争资源R，每个进程都需要3个R，} \\\\\r\n\\text{保证系统不会发生死锁，R的最小值为？} \\\\\r\n\\\\\r\n\\textbf{解：} \\\\\r\n\\quad \\begin{array}{lcl}\r\nN &amp;=&amp; 6 \\\\\r\nK &amp;=&amp; 3 \\\\\r\nR_{\\text{min}} &amp;=&amp; N \\times (K - 1) + 1 \\\\\r\n        &amp;=&amp; 6 \\times (3 - 1) + 1 \\\\\r\n        &amp;=&amp; 6 \\times 2 + 1 \\\\\r\n        &amp;=&amp; 12 + 1 \\\\\r\n        &amp;=&amp; 13 \\\\\r\n\\end{array} \\\\\r\n\\\\\r\n\\textbf{解释：} \\\\\r\n\\text{如果只有12个资源R，可能出现6个进程各获得2个资源（共用12个），} \\\\\r\n\\text{此时每个进程都还需1个资源才能执行。由于无剩余资源，将发生死锁。}\r\n\\\\\r\n\\text{若有13个资源R，在每个进程获得2个资源后（共用12个），还剩1个资源。}\r\n\\\\\r\n\\text{此资源可分配给任一进程，使其完成并释放资源，} \\\\\r\n\\text{从而其他进程也能相继完成。} \\\\\r\n\\end{array}\r\n$$\r\n\r\n术语解释：遇到英文缩写或专业术语时，我会提供完整的英文单词及相关的中文含义或解释。\r\n代码可读性：我将牢记代码是写给人看的，机器只是恰好可以运行。\r\n表达精简：表达应该尽量一针见血，抓住关键核心信息从而精简表达，而非很官方很冗余冗长的措辞。\r\n细节扩展与场景描述：我将扩展每个部分的细节，并尽量列举形象化的场景描述以辅助理解和记忆。\r\n依赖版本与兼容性：我将记忆项目中使用的主要依赖库的版本信息、兼容性要求和已知问题，以便在升级或引入新依赖时提供参考。\r\n客观阐述：作为知识型内容的撰写者，文档将以客观、权威的阐述为主，避免主观或服务性的措辞。\r\n复述指令：当您的输入开头包含[/retell]指令时，我将复述一遍用户的需求再进行答复，让用户能够确认我真的理解了用户的需求。\r\n\r\n","tags":["prompt"]},{"title":"helloVue","url":"/2023/04/21/helloVue/","content":"环境搭建\r\n\r\nnvm-windows\r\nnvm listnvm use 16.20.2nvm install 16.20.2// 环境变量D:\\software\\nvm\\v16.20.2npm config set prefix &quot;D:\\software\\nodejs\\node_global&quot;npm config set cache &quot;D:\\software\\nodejs\\node_cache&quot;// npm是node官方的包管理器。cnpm是个中国版的npmnpm install -g cnpm --registry=https://registry.npm.taobao.org// 查看配置信息npm config ls// 全局安装vue-clicnpm install -g @vue/clivue --V\r\nNode.js\r\n\r\nvscode配置文件\r\n&#123;    // 配置@符的路径提示    &quot;path-autocomplete.pathMappings&quot;: &#123;        &quot;@&quot;: &quot;$&#123;folder&#125;/src&quot;    &#125;,    &quot;workbench.colorTheme&quot;: &quot;Visual Studio Light&quot;,    &quot;editor.fontFamily&quot;: &quot;Consolas&quot;,    &quot;editor.fontLigatures&quot;: true,    &quot;editor.fontSize&quot;: 10,    &quot;editor.fontVariations&quot;: false,    &quot;window.zoomLevel&quot;: 2,    &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Command Prompt&quot;&#125;\r\n"},{"title":"Vue3学习笔记","url":"/2025/03/18/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"结束进程\r\n// 杀进程netstat -ano | findstr :端口号taskkill /pid 进程id /f// Python 自带了一个简单的 HTTP 服务器模块，可以直接用于静态文件的预览。以模块模式运行指定的 Python 模块。它的全称是 --module。cd distpython -m http.server 8000\r\nSetup语法糖\r\n基本使用方法\r\n1. 普通的Composition API写法\r\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment&quot;&gt;增加&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;export default &#123;  name:&quot;counter&quot;,  setup() &#123;    const count = ref(0)        function increment() &#123;      count.value++    &#125;        onMounted(() =&gt; &#123;      console.log(&#x27;组件已挂载&#x27;)    &#125;)        // 必须返回要在模板中使用的内容    return &#123;      count,      increment    &#125;  &#125;&#125;&lt;/script&gt;\r\n2. 使用Setup语法糖的写法\r\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment&quot;&gt;增加&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;counter&quot;   &#125;&lt;/script&gt;&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 不再需要export default和setup函数const count = ref(0)function increment() &#123;  count.value++&#125;onMounted(() =&gt; &#123;  console.log(&#x27;组件已挂载&#x27;)&#125;)// 不需要显式返回，顶层变量和函数自动暴露给模板&lt;/script&gt;\r\nSetup语法糖的特性\r\n1. 自动暴露变量和函数\r\n在 &lt;script setup&gt;\r\n中定义的顶层变量、函数和导入的内容都会自动暴露给模板，不需要通过\r\nreturn 语句返回。\r\n&lt;script setup&gt;// 导入的组件会自动注册import HelloWorld from &#x27;./HelloWorld.vue&#x27;import &#123; ref &#125; from &#x27;vue&#x27;// 声明的变量和函数自动可用于模板const message = ref(&#x27;Hello&#x27;)function updateMessage() &#123;  message.value = &#x27;Updated&#x27;&#125;&lt;/script&gt;&lt;template&gt;  &lt;!-- 可以直接使用上面定义的变量和方法 --&gt;  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;updateMessage&quot;&gt;更新&lt;/button&gt;  &lt;!-- 导入的组件可直接使用 --&gt;  &lt;HelloWorld /&gt;&lt;/template&gt;\r\n2. 使用\r\ndefineProps 和 defineEmits\r\n在setup语法糖中，使用 defineProps 和\r\ndefineEmits\r\n编译宏来声明props和emits，它们会自动导入并在编译时进行处理。\r\n&lt;script setup&gt;// 声明propsconst props = defineProps(&#123;  title: String,  likes: &#123;    type: Number,    default: 0  &#125;&#125;)// 声明emitsconst emit = defineEmits([&#x27;update&#x27;, &#x27;delete&#x27;])// 使用emitfunction handleClick() &#123;  emit(&#x27;update&#x27;, &#123; id: 1, value: &#x27;new value&#x27; &#125;)&#125;&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;  &lt;p&gt;Likes: &#123;&#123; likes &#125;&#125;&lt;/p&gt;  &lt;button @click=&quot;handleClick&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;\r\n3. 使用 defineExpose\r\n默认情况下，&lt;script setup&gt;\r\n组件是”封闭”的，即通过模板ref或$parent获取的组件实例不会暴露在\r\n&lt;script setup&gt; 中声明的任何属性。要显式暴露属性，使用\r\ndefineExpose 编译宏：\r\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)const increment = () =&gt; count.value++// 显式暴露属性和方法给父组件defineExpose(&#123;  count,  increment&#125;)&lt;/script&gt;\r\n这就像是在”保密柜”中，你可以选择性地公开某些文件供他人查看。\r\n4. 使用 useSlots 和\r\nuseAttrs\r\n访问slots和attrs可以使用 useSlots 和\r\nuseAttrs 辅助函数：\r\n&lt;script setup&gt;import &#123; useSlots, useAttrs &#125; from &#x27;vue&#x27;const slots = useSlots()const attrs = useAttrs()console.log(slots)console.log(attrs)&lt;/script&gt;\r\n5. 顶层 await 支持\r\n&lt;script setup&gt; 支持在顶层使用\r\nawait，这会自动将组件变为异步组件：\r\n&lt;script setup&gt;// 顶层await - 组件会自动变为异步组件const data = await fetch(&#x27;/api/data&#x27;).then(r =&gt; r.json())&lt;/script&gt;\r\n这就像是”边走边吃”——你可以在准备组件的过程中等待异步数据加载完成。\r\n与普通setup函数的区别\r\n\r\n\r\n\r\n特性\r\n普通setup函数\r\nSetup语法糖\r\n\r\n\r\n\r\n\r\n代码量\r\n较多，需要export default\r\n更少，更简洁\r\n\r\n\r\n暴露变量\r\n需要手动return\r\n自动暴露顶层变量\r\n\r\n\r\nTypeScript支持\r\n需要额外配置\r\n更好的类型推断\r\n\r\n\r\n组件注册\r\n需要在components选项中注册\r\n导入即自动注册\r\n\r\n\r\n生命周期钩子\r\n需要使用指定API\r\n直接导入使用\r\n\r\n\r\n获取实例\r\n可以通过this访问\r\n没有this，更函数式\r\n\r\n\r\n\r\n实际开发示例\r\n示例1：计数器组件\r\n&lt;template&gt;  &lt;div class=&quot;counter&quot;&gt;    &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;    &lt;p&gt;当前计数: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;div class=&quot;buttons&quot;&gt;      &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;      &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt;      &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, computed, watch &#125; from &#x27;vue&#x27;// 接收propsconst props = defineProps(&#123;  title: &#123;    type: String,    default: &#x27;计数器&#x27;  &#125;,  initialValue: &#123;    type: Number,    default: 0  &#125;,  step: &#123;    type: Number,    default: 1  &#125;&#125;)// 声明事件const emit = defineEmits([&#x27;change&#x27;, &#x27;reset&#x27;])// 响应式状态const count = ref(props.initialValue)// 计算属性const doubleCount = computed(() =&gt; count.value * 2)// 方法function increment() &#123;  count.value += props.step  emit(&#x27;change&#x27;, count.value)&#125;function decrement() &#123;  count.value -= props.step  emit(&#x27;change&#x27;, count.value)&#125;function reset() &#123;  count.value = props.initialValue  emit(&#x27;reset&#x27;)&#125;// 监听变化watch(count, (newValue) =&gt; &#123;  console.log(`计数已更改为: $&#123;newValue&#125;`)&#125;)// 暴露给父组件的方法和属性defineExpose(&#123;  count,  reset,  doubleCount&#125;)&lt;/script&gt;&lt;style scoped&gt;.counter &#123;  border: 1px solid #ddd;  padding: 15px;  border-radius: 4px;  max-width: 300px;  margin: 0 auto;&#125;.buttons &#123;  display: flex;  gap: 8px;  margin-top: 10px;&#125;button &#123;  padding: 5px 10px;  border: none;  background-color: #2c3e50;  color: white;  border-radius: 4px;  cursor: pointer;&#125;&lt;/style&gt;\r\n示例2：API数据获取组件\r\n&lt;template&gt;  &lt;div class=&quot;user-profile&quot;&gt;    &lt;div v-if=&quot;loading&quot;&gt;加载中...&lt;/div&gt;    &lt;div v-else-if=&quot;error&quot;&gt;加载失败: &#123;&#123; error &#125;&#125;&lt;/div&gt;    &lt;div v-else class=&quot;user-data&quot;&gt;      &lt;img :src=&quot;user.avatar&quot; alt=&quot;用户头像&quot;&gt;      &lt;h2&gt;&#123;&#123; user.name &#125;&#125;&lt;/h2&gt;      &lt;p&gt;Email: &#123;&#123; user.email &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const props = defineProps(&#123;  userId: &#123;    type: Number,    required: true  &#125;&#125;)const user = ref(null)const loading = ref(true)const error = ref(null)// 使用async/await获取数据async function fetchUserData() &#123;  loading.value = true  error.value = null    try &#123;    const response = await fetch(`https://api.example.com/users/$&#123;props.userId&#125;`)    if (!response.ok) &#123;      throw new Error(`API请求失败: $&#123;response.status&#125;`)    &#125;    user.value = await response.json()  &#125; catch (err) &#123;    error.value = err.message    console.error(&#x27;获取用户数据失败:&#x27;, err)  &#125; finally &#123;    loading.value = false  &#125;&#125;// 当组件挂载时获取数据onMounted(fetchUserData)// 监听userId的变化重新获取数据watch(() =&gt; props.userId, fetchUserData)&lt;/script&gt;\r\n最佳实践\r\n\r\n减少复杂度：将大型组件拆分为更小的可复用组件\r\n使用组合函数：将逻辑提取到独立的组合函数（Composables）中\r\n正确处理响应式：理解ref和reactive的区别\r\n组件通信：适当使用props和emits，复杂场景考虑使用provide/inject\r\n保持一致性：在项目中统一使用Setup语法糖或Options\r\nAPI\r\n\r\n常见问题解答\r\n问题1：&lt;script setup&gt;\r\n中如何访问组件实例（this）？\r\n答：在&lt;script setup&gt;中没有this。这是函数式编程的一部分，所有需要的内容都应通过导入的API和组合函数获取。\r\n问题2：如何使用生命周期钩子？\r\n答：直接导入并调用生命周期钩子函数：\r\n&lt;script setup&gt;import &#123; onMounted, onUnmounted &#125; from &#x27;vue&#x27;onMounted(() =&gt; &#123;  console.log(&#x27;组件已挂载&#x27;)&#125;)onUnmounted(() =&gt; &#123;  console.log(&#x27;组件已卸载&#x27;)&#125;)&lt;/script&gt;\r\n问题3：如何使用依赖注入（provide/inject）？\r\n答：\r\n&lt;!-- 提供方 --&gt;&lt;script setup&gt;import &#123; provide, ref &#125; from &#x27;vue&#x27;const theme = ref(&#x27;light&#x27;)provide(&#x27;theme&#x27;, theme) // 提供响应式值&lt;/script&gt;&lt;!-- 注入方 --&gt;&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;const theme = inject(&#x27;theme&#x27;, &#x27;light&#x27;) // 第二个参数是默认值&lt;/script&gt;\r\n响应式系统\r\nVue\r\n3的响应式系统是框架的核心特性，它允许数据变化自动触发视图更新。在Composition\r\nAPI中，响应式系统通过ref、reactive等API实现。\r\n基本响应式API\r\n\r\nref：创建一个响应式的数据引用，适用于基本类型和对象\r\nimport &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)  // 基本类型console.log(count.value)  // 必须使用.value访问const user = ref(&#123; name: &#x27;Alice&#x27; &#125;)  // 对象console.log(user.value.name)\r\nreactive：创建一个响应式对象，仅适用于对象（不能用于原始值）\r\nimport &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123;  count: 0,  user: &#123; name: &#x27;Bob&#x27; &#125;&#125;)console.log(state.count)  // 直接访问，不需要.value\r\n\r\n生命周期钩子\r\nVue 3中的生命周期钩子允许你在组件不同阶段执行代码。在Composition\r\nAPI中，生命周期钩子是以on开头的函数。\r\nimport &#123; onMounted, onUpdated, onUnmounted &#125; from &#x27;vue&#x27;// 在setup中使用生命周期钩子onMounted(() =&gt; &#123;  console.log(&#x27;组件已挂载&#x27;)&#125;)onUpdated(() =&gt; &#123;  console.log(&#x27;组件已更新&#x27;)&#125;)onUnmounted(() =&gt; &#123;  console.log(&#x27;组件已卸载&#x27;)&#125;)\r\nref可以声明基本数据类型和对象类型的响应式数据\r\n&lt;style&gt;    .person&#123;        background-color: #ddd;    &#125;&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h2&gt;一辆&#123;&#123;car.brand&#125;&#125;车，价值&#123;&#123;car.price&#125;&#125;万&lt;/h2&gt;        &lt;button @click=&quot;changePrice&quot;&gt;改价格&lt;/button&gt;        &lt;br&gt;        &lt;h2&gt;游戏列表&lt;/h2&gt;        &lt;ul&gt;            &lt;!-- v-bind:key 冒号标识将game.id当成js表达式解析 --&gt;            &lt;li v-for=&quot;game in games&quot; v-bind:key=&quot;game.id&quot;&gt;&#123;&#123;game.name&#125;&#125;&lt;/li&gt;            &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一个游戏的名称&lt;/button&gt;                    &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;Person123&quot;   &#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup &gt;    import &#123; ref &#125; from &#x27;vue&#x27;;    let username=ref(&quot;雷军&quot;) // ref 定义基本数据类型响应式数据    let car=ref(&#123;brand:&#x27;小米&#x27;,price:80&#125;); //ref 定义对象类型响应式数据    let games=ref([        &#123;id:1,name:&#x27;JAVA&#x27;&#125;,        &#123;id:2,name:&#x27;PYTHON&#x27;&#125;,        &#123;id:3,name:&#x27;GO&#x27;&#125;,    ])    console.log(username.value) //雷军  ref定义的只能通过.value访问    function changePrice()&#123;        car.value.price-=30    &#125;    function changeFirstGame()&#123;        games.value[0].name=&quot;VUE&quot;    &#125;&lt;/script&gt;\r\nref底层也是依赖reactive\r\n\r\n\r\nimage-20250318152057798\r\n\r\nreactive只能声明对象类型的响应式数据\r\n&lt;style&gt;    .person&#123;        background-color: #ddd;    &#125;&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h2&gt;一辆&#123;&#123;car.brand&#125;&#125;车，价值&#123;&#123;car.price&#125;&#125;万&lt;/h2&gt;        &lt;button @click=&quot;changePrice&quot;&gt;改价格&lt;/button&gt;        &lt;br&gt;        &lt;h2&gt;游戏列表&lt;/h2&gt;        &lt;ul&gt;            &lt;!-- v-bind:key 冒号标识将game.id当成js表达式解析 --&gt;            &lt;li v-for=&quot;game in games&quot; v-bind:key=&quot;game.id&quot;&gt;&#123;&#123;game.name&#125;&#125;&lt;/li&gt;            &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一个游戏的名称&lt;/button&gt;                    &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;Person123&quot;   &#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup &gt;    //reactive只能声明对象类型的响应式数据    import &#123; reactive &#125; from &#x27;vue&#x27;;    let car=reactive(&#123;brand:&#x27;小米&#x27;,price:80&#125;);    let games=reactive([        &#123;id:1,name:&#x27;JAVA&#x27;&#125;,        &#123;id:2,name:&#x27;PYTHON&#x27;&#125;,        &#123;id:3,name:&#x27;GO&#x27;&#125;,    ])    function changePrice()&#123;        car.price-=30    &#125;    function changeFirstGame()&#123;        games[0].name=&quot;VUE&quot;    &#125;&lt;/script&gt;\r\n&lt;style&gt;    .person&#123;        background-color: #ddd;    &#125;&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h2&gt;一辆&#123;&#123;car.brand&#125;&#125;车，价值&#123;&#123;car.price&#125;&#125;万&lt;/h2&gt;        &lt;button @click=&quot;changePrice&quot;&gt;改价格&lt;/button&gt;        &lt;br&gt;        &lt;h2&gt;游戏列表&lt;/h2&gt;        &lt;ul&gt;            &lt;!-- v-bind:key 冒号标识将game.id当成js表达式解析 --&gt;            &lt;li v-for=&quot;game in games&quot; v-bind:key=&quot;game.id&quot;&gt;&#123;&#123;game.name&#125;&#125;&lt;/li&gt;            &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一个游戏的名称&lt;/button&gt;                    &lt;/ul&gt;        &lt;br&gt;        &lt;button @click=&quot;changeCar&quot;&gt;点击重新分配汽车对象&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;Person123&quot;   &#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup &gt;    //reactive只能声明对象类型的响应式数据    import &#123; reactive &#125; from &#x27;vue&#x27;;    let car=reactive(&#123;brand:&#x27;小米&#x27;,price:80&#125;);    let games=reactive([        &#123;id:1,name:&#x27;JAVA&#x27;&#125;,        &#123;id:2,name:&#x27;PYTHON&#x27;&#125;,        &#123;id:3,name:&#x27;GO&#x27;&#125;,    ])    function changePrice()&#123;        car.price-=30    &#125;    function changeFirstGame()&#123;        games[0].name=&quot;VUE&quot;    &#125;    // reactive定义的对象如果重新分配一个新对象会失去响应式，可以用`Object.assign`去整体替换    function changeCar()&#123;        // car=&#123;brand:&#x27;雅迪&#x27;,price:1&#125; // 如果是reactive定义的对象类型会丢失响应式，而ref定义的就可以这样使用        Object.assign(car,&#123;brand:&#x27;雅迪&#x27;,price:1&#125;)    &#125;&lt;/script&gt;\r\ntoRefs()、toRef()\r\n&lt;style&gt;    .person&#123;        background-color: #ddd;    &#125;&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h2&gt;一辆&#123;&#123;car.brand&#125;&#125;车，价值&#123;&#123;car.price&#125;&#125;万&lt;/h2&gt;        &lt;button @click=&quot;changePrice&quot;&gt;改价格&lt;/button&gt;        &lt;br&gt;        &lt;!-- &lt;button @click=&quot;changeCar&quot;&gt;点击重新分配汽车对象&lt;/button&gt; --&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;Person123&quot;   &#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup &gt;    import &#123; reactive, toRef, toRefs &#125; from &#x27;vue&#x27;;    let car=reactive(&#123;brand:&#x27;小米&#x27;,price:80&#125;);    let &#123;brand,price&#125;=toRefs(car) // toRefs：将car的kv全部解构到变量对应kv，变量也具有响应式    let mony = toRef(car,&#x27;price&#x27;) // toRef：将car的price解构，变量也具有响应式    function changePrice()&#123;        brand.value=&quot;鬼火&quot;        car.price-=30        console.log(car.price) //50        console.log(mony.value) //50        console.log(car.price===mony.value) // true    &#125;    &lt;/script&gt;\r\nref和reactive的区别\r\n\r\nref定义基本数据类型、对象类型数据。reactive定义对象类型数据\r\nref创建的变量必须.value。reactive重新分配一个新对象会失去响应式，可以用Object.assign去整体替换\r\n定义层级比较深的响应式对象推荐用reactive\r\nref底层也是依赖reactive\r\n\r\n\r\nreactive\r\n\r\n用途：用于创建一个响应式的对象。\r\n特性：只能用于对象（包括数组），不能用于基本类型（如字符串、数字、布尔值等）。\r\n响应式原理：通过 Proxy\r\n对象实现深度响应式。\r\n\r\nref\r\n\r\n用途：用于创建一个响应式的引用对象，可以包含任何类型的值，包括基本类型。\r\n特性：对于对象，ref\r\n会自动将其内部值转换为 reactive 对象。\r\n响应式原理：通过 Proxy\r\n对象实现响应式，对于基本类型，通过 get 和 set\r\n拦截器实现响应式。\r\n\r\n\r\n重新分配新对象时的行为\r\n\r\nreactive 对象\r\n\r\n直接重新赋值：如果直接将 reactive\r\n对象重新赋值为一个新的对象，新的对象不会自动成为响应式对象。\r\n解决方案：需要使用 reactive\r\n包装新的对象，或者直接修改现有对象的属性。\r\n\r\nref 对象\r\n\r\n直接重新赋值：如果将 ref 对象的\r\n.value\r\n属性重新赋值为一个新的对象，新的对象会自动成为响应式对象。\r\n解决方案：可以直接重新赋值 .value\r\n属性，或者使用 reactive 包装新的对象。\r\n\r\n\r\n计算属性computed()\r\n&lt;style&gt;    .person&#123;        background-color: #ddd;    &#125;&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        输入姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;        输入名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;        &lt;span&gt;普通方法调全名:&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt;        &lt;span&gt;普通方法调全名:&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt;        &lt;span&gt;计算属性调全名:&#123;&#123;fullNameComputed&#125;&#125;&lt;/span&gt;&lt;br&gt;        &lt;span&gt;计算属性调全名:&#123;&#123;fullNameComputed&#125;&#125;&lt;/span&gt;&lt;br&gt;        &lt;button @click=&quot;updateFullname&quot;&gt;计算属性修改全名:&#123;&#123;fullNameComputed&#125;&#125;&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;Person123&quot;   &#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup &gt;    import &#123; ref, computed &#125; from &#x27;vue&#x27;; //引入计算属性computed    let firstName = ref(&quot;luo&quot;)    let lastName = ref(&quot;tao&quot;)    function fullName()&#123;        console.log(1); // 调用几次就打印几次，因为没有缓存        return firstName.value.slice(0,1).toUpperCase() + firstName.value.slice(1) + lastName.value.slice(0,1).toUpperCase() + lastName.value.slice(1)    &#125;    /*    // 这么定义的fullNameComputed是只读的，可以通过set修改    let fullNameComputed = computed(()=&gt;&#123;         // 相当于java的override        console.log(&quot;computed&quot;); // 调用一次，computed会缓存    &#125;)*/    // 这么定义fullNameComputed可以通过set修改    let fullNameComputed = computed(&#123;         // 传递对象，相当于 java的setter        get()&#123;            return firstName.value.slice(0,1).toUpperCase() + firstName.value.slice(1) + lastName.value.slice(0,1).toUpperCase() + lastName.value.slice(1)                &#125;,        set(val)&#123;            const [firststr,laststr] = val.split(&quot;-&quot;)            firstName.value=firststr            lastName.value=laststr        &#125;    &#125;)    function updateFullname()&#123;        fullNameComputed.value=&quot;shuai-ge&quot; // 传给set进行修改    &#125;&lt;/script&gt;\r\n【watch】-监视【ref】定义的【基本类型】数据\r\n\r\n直接写数据名,监视的是value值的改变\r\n\r\n&lt;style&gt;    .person&#123;        background-color: #ddd;    &#125;&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;button @click=&quot;sum&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;Person123&quot;   &#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup &gt;    import &#123; ref, watch&#125; from &#x27;vue&#x27;;    let count =ref(0)    function sum()&#123;        count.value +=1;            &#125;    // watch 监视【ref】定义的【基本类型】数据    const stopWach= watch(count,(newValue,oldValue)=&gt;&#123;        console.log(&quot;count变化了&quot;,newValue,oldValue);                        if (newValue&gt;=5)&#123;            stopWach();        &#125;    &#125;)&lt;/script&gt;\r\n【watch】-监视【ref】定义的【对象类型】数据\r\n\r\n若修改的是ref定义的对象的属性，newValue和oldValue都是新值，因为它们是同一个对象,地址值不变。\r\n若修改整个ref定义的对象，newValue是新值，oldValue是旧值，因为不是同一个对象。监视的是地址值，若想监视对象内部属性的变化，需要开启深度监视。\r\n\r\n&lt;style&gt;    .person&#123;        background-color: #ddd;    &#125;&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h1&gt;watch-监视【ref】定义的【对象类型】数据&lt;/h1&gt;        &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;&lt;br&gt;        &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;&lt;br&gt;        &lt;div class=&quot;btn&quot;&gt;            &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;            &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;            &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; &gt;   export default&#123;        name:&quot;Person123&quot;   &#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup &gt;    import &#123; ref, watch&#125; from &#x27;vue&#x27;;    let person=ref(&#123;        name:&quot;luotao&quot;,        age:20    &#125;)    function changeName()&#123;        person.value.name=&quot;neko&quot;    &#125;    function changeAge()&#123;        person.value.age= 18    &#125;    function changePerson()&#123;        person.value=&#123;name:&quot;张三&quot;,age:25&#125;    &#125;    // watch 监视【ref】定义的【对象类型】数据    /*    * 若修改的是ref定义的对象的属性，newValue和oldValue都是新值，因为它们是同一个对象,地址值不变。    * 若修改整个ref定义的对象，newValue是新值，oldValue是旧值，因为不是同一个对象。监视的是地址值，若想监视对象内部属性的变化，需要开启深度监视。    */    const stopWach= watch(person,(newValue,oldValue)=&gt;&#123;        console.log(&quot;person变化了&quot;,newValue,oldValue);        console.log(newValue===oldValue);     &#125;,&#123;deep:true&#125;)&lt;/script&gt;\r\n【watch】-监视【reactive】定义的【对象类型】数据\r\n&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h1&gt;监视【reactive】定义的【对象类型】数据&lt;/h1&gt;        &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;&lt;br&gt;        &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;&lt;br&gt;        &lt;div class=&quot;btn&quot;&gt;            &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;            &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;            &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;import &#123; reactive,watch &#125; from &#x27;vue&#x27;;let person=reactive(&#123;    name:&quot;luotao&quot;,    age:20&#125;)function changeName()&#123;    person.name=&quot;neko&quot;&#125;function changeAge()&#123;    person.age=18&#125;function changePerson()&#123;    person=Object.assign(person,&#123;name:&quot;张三&quot;,age:25&#125;)&#125;// 监视【reactive】定义的【对象类型】数据，默认隐式的创建了深度监视。这里person地址值没有变，nnewValue和oldvalue是同一个对象watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&quot;person变化了：&quot;,newValue,oldValue);    console.log(newValue===oldValue); // true  操作的是同一个对象        &#125;)&lt;/script&gt;&lt;style&gt;.person&#123;    background-color: greenyellow;    box-shadow: 0,0 10px;    display: flex;    flex-wrap: wrap;    justify-content: center;    align-items: center;    height: 100px;&#125;&lt;/style&gt;\r\n【watch】-监视ref或reactive定义的【对象类型】中某个属性\r\n\r\n\r\nimage-20250319133253221\r\n\r\n&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;汽车&#123;&#123;person.car.c1&#125;&#125;、&#123;&#123;person.car.c2&#125;&#125;&lt;/h2&gt;        &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;        &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;        &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;        &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;        &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;person&quot;&gt;import &#123; reactive, watch &#125; from &#x27;vue&#x27;;    let person=reactive(&#123;        name:&quot;luotao&quot;,        age:18,        car:&#123;            c1:&quot;su7&quot;,            c2:&quot;雅迪&quot;        &#125;    &#125;)    function changeName()&#123;        person.name +=&quot;~&quot;    &#125;    function changeAge()&#123;        person.age+=1    &#125;    function changeC1()&#123;        person.car.c1=&quot;c1&quot;    &#125;    function changeC2()&#123;        person.car.c2=&quot;c2&quot;    &#125;    function changeCar()&#123;        person.car=&#123;            c1:&quot;c3&quot;,            c2:&quot;c4&quot;        &#125;    &#125;    // 监视ref或reactive定义的【对象类型】中某个属性：    // 需要写成函数式（getter函数）    /*watch(()=&gt;&#123;return person.name&#125;,(newValue,oldValue)=&gt;&#123;        console.log(&quot;person.name变化了&quot;,newValue,oldValue);    &#125;)*/    // 监视ref或reactive定义的【对象类型】中某个属性,且该属性是对象类型的(监视的是地址值)：    // 推荐写函数式，若要关注该属性的细枝末节，可以直接开启深度监视    /*watch(()=&gt;&#123;        return person.car    &#125;,(newValue,oldValue)=&gt;&#123;        console.log(&quot;person.car变化了&quot;,newValue,oldValue)    &#125;,&#123;deep:true&#125;)*/    // 以上两种情况的数组写法    watch([()=&gt;&#123;        return person.name    &#125;,()=&gt;&#123;        return person.car    &#125;],(newValue,oldValue)=&gt;&#123;        console.log(&quot;person.car变化了&quot;,newValue,oldValue)    &#125;,&#123;deep:true&#125;)&lt;/script&gt;&lt;style&gt;    .person&#123;        background-color: greenyellow;        box-shadow: 0,0 10px;        display: flex;        flex-wrap: wrap;        align-items: center;        flex-direction: column;    &#125;&lt;/style&gt;\r\n【watchEffect】\r\n&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;h2&gt;水温：&#123;&#123;temperature&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;水位：&#123;&#123;hight&#125;&#125;&lt;/h2&gt;        &lt;button @click=&quot;changeTemperature&quot;&gt;水温+10&lt;/button&gt;        &lt;button @click=&quot;changeHight&quot;&gt;水位+10&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;person&quot;&gt;import &#123; ref, watch, watchEffect &#125; from &#x27;vue&#x27;;    let temperature=ref(10)    let hight=ref(10)    function changeTemperature()&#123;        temperature.value +=10    &#125;    function changeHight()&#123;        hight.value+=10    &#125;    // watch要明确出监视的数据    /*    watch([temperature,hight],(value,oldValue)=&gt;&#123;        let [temperature,hight]=value        if (temperature &gt;=60 || hight &gt;=60)&#123;            console.log(&quot;发送请求&quot;);        &#125;                  &#125;)*/    // watchEffect：行数用到哪些属性就监视哪些属性    watchEffect(()=&gt;&#123;        console.log(&quot;一上来就执行&quot;);                if (temperature.value &gt;=60 || hight.value &gt;=60)&#123;            console.log(&quot;发送请求&quot;);        &#125;    &#125;)    &lt;/script&gt;&lt;style&gt;    .person&#123;        background-color: greenyellow;        box-shadow: 0,0 10px;        display: flex;        flex-wrap: wrap;        align-items: center;        flex-direction: column;    &#125;&lt;/style&gt;\r\n标签的【ref】属性\r\n&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;        &lt;!-- 【标签的ref属性用于注册模板引用】用在DOM标签上获取的是DOM节点，用在组件标签上，获取的是主键实例对象 --&gt;        &lt;h2 ref=&quot;temp&quot;&gt;你好&lt;/h2&gt;        &lt;button @click=&quot;show&quot;&gt;展示ref标记的内容&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;person&quot;&gt;import &#123; ref ,defineExpose&#125; from &#x27;vue&#x27;;    let temp=ref(); // 创建一个temp，用于存储ref标记的内容    function show()&#123;        console.log(temp.value); // &lt;h2&gt;水温：10&lt;/h2&gt;            &#125;       defineExpose(&#123;temp&#125;) // 导出&lt;/script&gt;&lt;style&gt;    .person&#123;        background-color: greenyellow;        box-shadow: 0,0 10px;        display: flex;        flex-wrap: wrap;        align-items: center;        flex-direction: column;    &#125;&lt;/style&gt;\r\nTS中的接口_泛型_自定义类型\r\n// 定义一个接口来约束person对象的具体属性export interface PersonInter&#123;    id:string,    name:string,    age:number&#125;// 创建一个自定义类型export type Persons=PersonInter[]\r\n&lt;script  lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;    import &#123;type PersonInter,type Persons&#125; from &#x27;@/types&#x27;    import &#123; reactive &#125; from &#x27;vue&#x27;;    // let personList:Persons=reactive([    //     &#123;id:&#x27;1&#x27;,name:&#x27;luotao&#x27;,age:18&#125;,    //     &#123;id:&#x27;2&#x27;,name:&#x27;neko&#x27;,age:20&#125;    // ])    // 优雅的写法    let personList=reactive&lt;Persons&gt;([        &#123;id:&#x27;1&#x27;,name:&#x27;luotao&#x27;,age:18&#125;,        &#123;id:&#x27;2&#x27;,name:&#x27;neko&#x27;,age:20&#125;    ])    console.log(personList[0].name);&lt;/script&gt;&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;\r\n【props】的使用\r\n&lt;script setup lang=&quot;ts&quot;&gt;import Person from &#x27;./components/Person.vue&#x27;;import &#123; reactive &#125; from &#x27;vue&#x27;;import &#123;type PersonInter,type Persons&#125; from &#x27;@/types&#x27;  let personList= reactive&lt;Persons&gt;(    [      &#123;id:&#x27;1&#x27;,name:&#x27;luotao&#x27;,age:18&#125;,      &#123;id:&#x27;2&#x27;,name:&#x27;neko&#x27;,age:20&#125;,    ]  )  console.log(personList)&lt;/script&gt;&lt;template&gt;  &lt;!-- 传给Person组件 --&gt;  &lt;Person :list=&quot;personList&quot;&gt;&lt;/Person&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt;\r\n&lt;script setup lang=&quot;ts&quot;&gt;    import &#123; type Persons &#125; from &#x27;@/types&#x27;;    import &#123; defineProps ,withDefaults&#125; from &#x27;vue&#x27;;    // let hello= defineProps([&quot;list&quot;]) // 1.只接受list    // let hello = defineProps&lt;&#123;list:Persons&#125;&gt;() // 2.接受list,限制Person类型    // 3.接受list,限制Person类型,?限制必要性，withDefaults指定默认值    withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;        list:()=&gt;&#123;            return [&#123;id:&#x27;0&#x27;,name:&#x27;defaultName&#x27;,age:18&#125;]        &#125;    &#125;)&lt;/script&gt;&lt;template&gt;     &lt;div class=&quot;person&quot;&gt;        &lt;ul&gt;            &lt;li v-for=&quot;item in list &quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.name&#125;&#125;--&#123;&#123; item.age &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;     &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;        .person&#123;        background-color: greenyellow;        box-shadow: 0,0 10px;        display: flex;        flex-wrap: wrap;        align-items: center;        flex-direction: column;    &#125;&lt;/style&gt;\r\nvue3生命周期\r\n\r\n\r\nimage-20250104151543030\r\n\r\n&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;生命周期&lt;/h1&gt;        &lt;p&gt;&lt;button @click=&quot;changeCount&quot;&gt;点击修改count值-- &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/p&gt;        &lt;p&gt;&lt;button @click=&quot;destroy&quot;&gt;点击销毁&lt;/button&gt;&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123; getCurrentInstance,            reactive,             toRefs,            onBeforeMount,            onMounted,            onBeforeUpdate,            onUpdated,            onBeforeUnmount,            onUnmounted         &#125; from &#x27;vue&#x27;                console.log(&quot;开始创建组件--setup&quot;)        const instance = getCurrentInstance(); //获取当前组件实例        console.log(&quot;当前组件实例--instance&quot; , instance);        const state = reactive(&#123; //定义响应式数据对象            count: 0,        &#125;)        function changeCount() &#123; //触发组件更新            state.count++;        &#125;        function destroy() &#123; //触发销毁组件            instance.appContext.app.unmount();        &#125;            onBeforeMount(() =&gt; &#123;             console.log(&quot;组件挂载前--onBeforeMount&quot;)        &#125;)        onMounted(() =&gt; &#123;             console.log(&quot;组件挂载后--onMounted&quot;)        &#125;)        onBeforeUpdate(() =&gt; &#123;             console.log(&quot;组件更新前--onBeforeUpdate&quot;)        &#125;)        onUpdated(() =&gt; &#123;             console.log(&quot;组件更新后--onUpdated&quot;)        &#125;)        onBeforeUnmount(() =&gt; &#123;             console.log(&quot;组件卸载前--onBeforeUnmount&quot;)        &#125;)        onUnmounted(() =&gt; &#123;             console.log(&quot;组件卸载后--onUnmounted&quot;)        &#125;)        const &#123;count&#125;=&#123;   ...toRefs(state)&#125;// 将响应式对象转为普通对象(每一个属性都是响应式)    &lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;\r\n自定义Hooks\r\nimport axios from &#x27;axios&#x27;;import &#123; onBeforeMount, reactive &#125; from &#x27;vue&#x27;;export default function () &#123;    let dogList = reactive([        &#x27;https://images.dog.ceo/breeds/pembroke/n02113023_4373.jpg&#x27;    ])    async function getDog() &#123;        try &#123;            let result = await axios.get(&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;)            dogList.push(result.data.message)        &#125; catch (error) &#123;            alert(error)        &#125;    &#125;    onBeforeMount(()=&gt;&#123;        getDog()     &#125;)    return &#123;dogList,getDog&#125;&#125;\r\n&lt;template&gt;     &lt;div class=&quot;person&quot;&gt;        &lt;img v-for=&quot; (dog,index) in dogList&quot; :key=&quot;index&quot; :src=&quot;dog&quot; alt=&quot;&quot;&gt;        &lt;button @click=&quot;getDog&quot;&gt;再来一只&lt;/button&gt;     &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import useDog from &#x27;@/hooks/useDog&#x27;;const &#123;dogList,getDog&#125;=useDog()&lt;/script&gt;&lt;style scoped&gt;    .person&#123;        background-color: greenyellow;        box-shadow: 0,0 10px;        display: flex;        flex-wrap: nowrap;        align-items: center;        flex-direction: column;    &#125;    img&#123;        width: 100px;        margin-bottom: 1px;    &#125;&lt;/style&gt;\r\n路由的query参数\r\n\r\n\r\nimage-20250320021455569\r\n\r\n路由的param参数\r\n\r\n\r\nimage-20250320135029082\r\n\r\n\r\n\r\nimage-20250320135626427\r\n\r\n\r\n\r\nimage-20250320135722595\r\n\r\n\r\n\r\nimage-20250320140337010\r\n\r\n路由的props配置\r\n\r\nprops的对象写法\r\nprops的布尔值写法\r\nprops的函数写法\r\n\r\n\r\n\r\nimage-20250320141106962\r\n\r\n\r\n\r\nimage-20250320141200490\r\n\r\nreplace属性\r\n\r\n\r\nimage-20250320141836425\r\n\r\n编程式路由导航\r\n\r\n\r\nimage-20250320142903447\r\n\r\n使用pinia修改数据的三种方式\r\n\r\n\r\nimage-20250320152718722\r\n\r\n\r\n\r\nimage-20250320152636282\r\n\r\nstoreToRefs\r\n$subscribe的使用\r\n组件通信方式_props\r\nprops通常用在父组件与子组件。\r\n若父传子，属性值是非函数。\r\n若子传父，属性值是函数。\r\n\r\n\r\nimage-20250320161423768\r\n\r\n\r\n\r\nimage-20250320161423768\r\n\r\n组件通信方式_自定义事件\r\n\r\n\r\nimage-20250320164314641\r\n\r\n组件通信方式_mitt\r\n\r\nnpm i mitt\r\n创建utils包下的emitter.ts\r\n// 引入mittimport mitt from &#x27;mitt&#x27;// 调用mitt得到emitter，emitter能：绑定事件、触发事件const emitter = mitt()/* // 绑定事件emitter.on(&#x27;test1&#x27;,()=&gt;&#123;  console.log(&#x27;test1被调用了&#x27;)&#125;)emitter.on(&#x27;test2&#x27;,()=&gt;&#123;  console.log(&#x27;test2被调用了&#x27;)&#125;)// 触发事件setInterval(() =&gt; &#123;  emitter.emit(&#x27;test1&#x27;)  emitter.emit(&#x27;test2&#x27;)&#125;, 1000);setTimeout(() =&gt; &#123;  // emitter.off(&#x27;test1&#x27;)  // emitter.off(&#x27;test2&#x27;)  emitter.all.clear()&#125;, 3000); */// 暴露emitterexport default emitter\r\nmain.ts中import\r\nimport emitter from &#x27;./utils/emitter&#x27;; //引入emitter\r\n子组件1给子组件2传递toy\r\n&lt;template&gt;    &lt;div class=&quot;child1&quot;&gt;      &lt;h3&gt;子组件1&lt;/h3&gt;      &lt;h4&gt;玩具：&#123;&#123;toy&#125;&#125;&lt;/h4&gt;      &lt;!-- 用emitter.emit触发组件2声明的send-toy事件，并传递我自己的toy --&gt;      &lt;button @click=&quot;emitter.emit(&#x27;send-toy&#x27;,toy)&quot;&gt;给组件2toy&lt;/button&gt;    &lt;/div&gt;  &lt;/template&gt;    &lt;script setup lang=&quot;ts&quot; name=&quot;Child1&quot;&gt;    import emitter from &#x27;@/utils/emitter&#x27;;    import &#123; ref &#125; from &#x27;vue&#x27;;    let toy = ref(&#x27;奥特曼&#x27;)  &lt;/script&gt;    &lt;style scoped&gt;      .child1&#123;          margin-top: 50px;          background-color: skyblue;          padding: 10px;          box-shadow: 0 0 10px black;          border-radius: 10px;      &#125;      .child1 button&#123;          margin-right: 10px;      &#125;  &lt;/style&gt;\r\n&lt;template&gt;    &lt;div class=&quot;child2&quot;&gt;      &lt;h3&gt;子组件2&lt;/h3&gt;      &lt;h4&gt;电脑:&#123;&#123;computer&#125;&#125;&lt;/h4&gt;      &lt;h4&gt;组件1给我的toy是：&#123;&#123;toy&#125;&#125;&lt;/h4&gt;    &lt;/div&gt;  &lt;/template&gt;    &lt;script setup lang=&quot;ts&quot; name=&quot;Child2&quot;&gt;  import emitter from &#x27;@/utils/emitter&#x27;import &#123; onUnmounted &#125; from &#x27;vue&#x27;import &#123;ref&#125; from &#x27;vue&#x27;        let computer = ref(&#x27;小米&#x27;)      let toy = ref(&#x27;&#x27;)      // 给emitter绑定send-toy事件      emitter.on(&#x27;send-toy&#x27;,(value:any)=&gt;&#123;          toy.value=value      &#125;)      // 在组件2卸载时解绑send-toy事件      onUnmounted(()=&gt;&#123;        emitter.off(&#x27;send-toy&#x27;)        console.log(&#x27;send-toy事件卸载了&#x27;);              &#125;)  &lt;/script&gt;    &lt;style scoped&gt;      .child2&#123;          margin-top: 50px;          background-color: orange;          padding: 10px;          box-shadow: 0 0 10px black;          border-radius: 10px;      &#125;  &lt;/style&gt;\r\n\r\nVue3核心概念\r\n响应式系统\r\n技术解释：Vue3的响应式系统基于ES6的Proxy，能够直接监听对象和数组的变化。\r\n生活案例：想象一个智能家居系统。当你调整温度设定（数据变化）时，空调会自动响应并调整工作模式（UI更新）。Vue3的响应式系统就像这个智能家居的控制中心，监测所有设定的变化并通知相关设备做出反应。\r\n组件化\r\n技术解释：Vue应用由独立、可复用的组件构建而成，每个组件封装自己的HTML、CSS和JavaScript。\r\n生活案例：组件就像乐高积木。每个积木（组件）有特定的形状和功能，可以独立存在，也可以与其他积木组合创建复杂结构。一个页面就是由这些不同功能的”积木”组合而成的。\r\n组件通信方式\r\n组件通信方式之v-model\r\n技术解释：Vue3中的v-model是props和emit的语法糖，用于在父子组件间实现双向绑定。\r\n生活案例：想象父母（父组件）给孩子（子组件）零花钱。v-model就像一个特殊的钱包：父母放钱进去（props传值），孩子花钱后会自动更新钱包余额并通知父母（emit事件）。这样父母始终知道钱包里有多少钱，实现了”双向通信”。\r\n代码示例： &lt;!-- 父组件 --&gt;&lt;template&gt;&lt;child-component v-model:money=&quot;pocket&quot; /&gt;&lt;p&gt;钱包余额: &#123;&#123; pocket &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import ChildComponent from &#x27;./ChildComponent.vue&#x27;const pocket = ref(100)&lt;/script&gt;&lt;!-- 子组件 (ChildComponent.vue) --&gt;&lt;template&gt;&lt;div&gt;&lt;p&gt;我的零花钱: &#123;&#123; money &#125;&#125;&lt;/p&gt;&lt;button @click=&quot;spendMoney(10)&quot;&gt;花费10元&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps([&#x27;money&#x27;])const emit = defineEmits([&#x27;update:money&#x27;])function spendMoney(amount) &#123;emit(&#x27;update:money&#x27;, props.money - amount)&#125;&lt;/script&gt;\r\n组件通信方式之attrs * *技术解释 * *：attrs包含父组件传递给子组件但未被props接收的所有属性，Vue3中也包含了事件监听器。\r\n生活案例：想象一个快递转运站。当包裹（属性）到达转运站（父组件）时，有些包裹有明确的收件人（props），而其他包裹（attrs）则需要继续转发到下一站（子组件或孙组件）。attrs就是这个自动转发系统。\r\n代码示例： &lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;middle-component     title=&quot;Hello&quot;     :description=&quot;desc&quot;     @click=&quot;handleClick&quot;   /&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import MiddleComponent from &#x27;./MiddleComponent.vue&#x27;const desc = ref(&#x27;This is a description&#x27;)function handleClick() &#123;  console.log(&#x27;Clicked!&#x27;)&#125;&lt;/script&gt;&lt;!-- 中间组件 (MiddleComponent.vue) --&gt;&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;中间组件&lt;/h2&gt;    &lt;child-component v-bind=&quot;$attrs&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import ChildComponent from &#x27;./ChildComponent.vue&#x27;&lt;/script&gt;&lt;!-- 子组件 (ChildComponent.vue) --&gt;&lt;template&gt;  &lt;div&gt;    &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;&#123;&#123; description &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;$attrs.onClick&quot;&gt;点击我&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;, &#x27;description&#x27;])&lt;/script&gt;\r\n组件通信方式之refs与parent\r\n技术解释：refs用于直接访问子组件实例或DOM元素，而parent用于访问父组件实例。\r\n生活案例：想象一个办公室环境。refs就像直接走到同事桌前（子组件）请求帮助，而parent则像向你的上级（父组件）请求指导。这是直接的点对点通信，不经过正式的沟通渠道。\r\n代码示例： &lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;child-component ref=&quot;childRef&quot; /&gt;    &lt;button @click=&quot;callChildMethod&quot;&gt;调用子组件方法&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import ChildComponent from &#x27;./ChildComponent.vue&#x27;const childRef = ref(null)function callChildMethod() &#123;  childRef.value.showMessage(&#x27;来自父组件的消息&#x27;)&#125;&lt;/script&gt;&lt;!-- 子组件 (ChildComponent.vue) --&gt;&lt;template&gt;  &lt;div&gt;    &lt;p&gt;子组件&lt;/p&gt;    &lt;button @click=&quot;askParent&quot;&gt;向父组件请求数据&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;const instance = getCurrentInstance()function showMessage(msg) &#123;  alert(msg)&#125;function askParent() &#123;  const parentData = instance.parent.data  alert(`父组件数据: $&#123;parentData&#125;`)&#125;// 暴露方法给父组件调用defineExpose(&#123;  showMessage&#125;)&lt;/script&gt;\r\n组件通信方式之provide_inject\r\n技术解释：provide/inject允许祖先组件向所有后代组件注入数据，无需通过props逐级传递。\r\n生活案例：想象一个家族WhatsApp群组。家族长辈（祖先组件）在群里发布重要信息（provide数据），所有家族成员（后代组件）无论层级关系如何，都能直接接收到这些信息（inject数据），而不需要通过中间人传话。\r\n代码示例： &lt;!-- 祖先组件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;家族群组&lt;/h1&gt;    &lt;p&gt;当前主题: &#123;&#123; theme &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;toggleTheme&quot;&gt;切换主题&lt;/button&gt;    &lt;middle-component /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, provide &#125; from &#x27;vue&#x27;import MiddleComponent from &#x27;./MiddleComponent.vue&#x27;const theme = ref(&#x27;light&#x27;)function toggleTheme() &#123;  theme.value = theme.value === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;&#125;// 提供主题给所有后代组件provide(&#x27;theme&#x27;, theme)provide(&#x27;toggleTheme&#x27;, toggleTheme)&lt;/script&gt;&lt;!-- 中间组件 (MiddleComponent.vue) --&gt;&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;中间组件&lt;/h2&gt;    &lt;descendant-component /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import DescendantComponent from &#x27;./DescendantComponent.vue&#x27;&lt;/script&gt;&lt;!-- 后代组件 (DescendantComponent.vue) --&gt;&lt;template&gt;  &lt;div :class=&quot;theme&quot;&gt;    &lt;h3&gt;后代组件&lt;/h3&gt;    &lt;p&gt;当前使用的主题: &#123;&#123; theme &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;toggleTheme&quot;&gt;切换主题&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;// 注入祖先组件提供的数据const theme = inject(&#x27;theme&#x27;)const toggleTheme = inject(&#x27;toggleTheme&#x27;)&lt;/script&gt;\r\n插槽系统\r\n默认插槽\r\n技术解释：默认插槽允许父组件将内容传递到子组件的指定位置。\r\n生活案例：想象一个相框（子组件）。默认插槽就像相框中放照片的空间，你可以在这个空间（slot）放入任何照片（内容），而相框的样式和结构保持不变。\r\n代码示例： &lt;!-- 子组件 (Frame.vue) --&gt;&lt;template&gt;  &lt;div class=&quot;frame&quot;&gt;    &lt;div class=&quot;frame-header&quot;&gt;精美相框&lt;/div&gt;    &lt;div class=&quot;frame-content&quot;&gt;      &lt;!-- 默认插槽 --&gt;      &lt;slot&gt;这里放默认照片&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;frame-footer&quot;&gt;2023年&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;frame&gt;      &lt;!-- 插入到默认插槽的内容 --&gt;      &lt;img src=&quot;./family-photo.jpg&quot; alt=&quot;家庭照片&quot; /&gt;    &lt;/frame&gt;        &lt;frame&gt;      &lt;!-- 另一个不同的内容 --&gt;      &lt;img src=&quot;./vacation-photo.jpg&quot; alt=&quot;度假照片&quot; /&gt;    &lt;/frame&gt;        &lt;!-- 不提供内容时会显示默认内容 --&gt;    &lt;frame&gt;&lt;/frame&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import Frame from &#x27;./Frame.vue&#x27;&lt;/script&gt;\r\n具名插槽\r\n技术解释：具名插槽允许在同一个组件中定义多个插槽，并通过名称区分。\r\n生活案例：想象一封电子邮件模板（子组件）。它有不同的部分：标题、正文和签名。具名插槽就像这个模板中预留的不同区域，你可以分别填入不同内容，每个内容都放在指定的位置。\r\n代码示例： &lt;!-- 子组件 (EmailTemplate.vue) --&gt;&lt;template&gt;  &lt;div class=&quot;email&quot;&gt;    &lt;header&gt;      &lt;slot name=&quot;header&quot;&gt;默认标题&lt;/slot&gt;    &lt;/header&gt;    &lt;main&gt;      &lt;slot name=&quot;content&quot;&gt;默认正文内容...&lt;/slot&gt;    &lt;/main&gt;    &lt;footer&gt;      &lt;slot name=&quot;signature&quot;&gt;默认签名&lt;/slot&gt;    &lt;/footer&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;email-template&gt;      &lt;template #header&gt;        &lt;h2&gt;会议邀请&lt;/h2&gt;      &lt;/template&gt;            &lt;template #content&gt;        &lt;p&gt;亲爱的团队成员，&lt;/p&gt;        &lt;p&gt;我们将于下周一举行季度回顾会议，请准时参加。&lt;/p&gt;      &lt;/template&gt;            &lt;template #signature&gt;        &lt;p&gt;此致，&lt;/p&gt;        &lt;p&gt;项目经理&lt;/p&gt;      &lt;/template&gt;    &lt;/email-template&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import EmailTemplate from &#x27;./EmailTemplate.vue&#x27;&lt;/script&gt;\r\n作用域插槽\r\n技术解释：作用域插槽允许子组件将数据回传给父组件的插槽内容。\r\n生活案例：想象一个图书馆借书系统（子组件）。作用域插槽就像图书馆提供的借书记录查询服务，图书馆（子组件）拥有所有借书数据，但允许读者（父组件）决定如何展示和使用这些数据，比如按日期排序或只查看特定类型的书籍。\r\n代码示例： &lt;!-- 子组件 (BookList.vue) --&gt;&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;图书馆藏书列表&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for=&quot;book in books&quot; :key=&quot;book.id&quot;&gt;        &lt;!-- 将book数据传递给父组件的插槽 --&gt;        &lt;slot :book=&quot;book&quot; :checkout=&quot;checkoutBook&quot;&gt;          &#123;&#123; book.title &#125;&#125; (默认显示)        &lt;/slot&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const books = ref([  &#123; id: 1, title: &#x27;战争与和平&#x27;, author: &#x27;托尔斯泰&#x27;, available: true &#125;,  &#123; id: 2, title: &#x27;百年孤独&#x27;, author: &#x27;马尔克斯&#x27;, available: false &#125;,  &#123; id: 3, title: &#x27;红楼梦&#x27;, author: &#x27;曹雪芹&#x27;, available: true &#125;])function checkoutBook(bookId) &#123;  const book = books.value.find(b =&gt; b.id === bookId)  if (book &amp;&amp; book.available) &#123;    book.available = false    return true  &#125;  return false&#125;&lt;/script&gt;&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;book-list&gt;      &lt;template #default=&quot;&#123; book, checkout &#125;&quot;&gt;        &lt;div :class=&quot;&#123; &#x27;unavailable&#x27;: !book.available &#125;&quot;&gt;          &lt;h3&gt;&#123;&#123; book.title &#125;&#125;&lt;/h3&gt;          &lt;p&gt;作者: &#123;&#123; book.author &#125;&#125;&lt;/p&gt;          &lt;p&gt;状态: &#123;&#123; book.available ? &#x27;可借阅&#x27; : &#x27;已借出&#x27; &#125;&#125;&lt;/p&gt;          &lt;button             v-if=&quot;book.available&quot;             @click=&quot;checkout(book.id)&quot;          &gt;            借阅          &lt;/button&gt;        &lt;/div&gt;      &lt;/template&gt;    &lt;/book-list&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import BookList from &#x27;./BookList.vue&#x27;&lt;/script&gt;&lt;style&gt;.unavailable &#123;  opacity: 0.6;&#125;&lt;/style&gt;\r\n组合式API\r\nshallowRef与shallowReactive\r\n技术解释：shallowRef和shallowReactive创建浅层响应式对象，只有对象的顶层属性是响应式的，嵌套对象不会被转换。\r\n生活案例：想象一个邮箱系统。普通的ref/reactive就像完整的邮件追踪服务，从寄件到收件的每一步都会通知你（深层响应）。而shallow版本就像只追踪包裹是否已送达（顶层响应），但不会告诉你包裹内部物品的状态变化。\r\n代码示例： &lt;template&gt;  &lt;div&gt;    &lt;h2&gt;邮件系统&lt;/h2&gt;    &lt;button @click=&quot;updateDeep&quot;&gt;更新深层属性 (reactive)&lt;/button&gt;    &lt;button @click=&quot;updateShallow&quot;&gt;更新深层属性 (shallowReactive)&lt;/button&gt;    &lt;pre&gt;&#123;&#123; normalPackage &#125;&#125;&lt;/pre&gt;    &lt;pre&gt;&#123;&#123; shallowPackage &#125;&#125;&lt;/pre&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; reactive, shallowReactive &#125; from &#x27;vue&#x27;// 完全响应式const normalPackage = reactive(&#123;  status: &#x27;运送中&#x27;,  details: &#123;    items: [&#x27;书&#x27;, &#x27;衣服&#x27;],    weight: &#x27;2kg&#x27;  &#125;&#125;)// 浅层响应式const shallowPackage = shallowReactive(&#123;  status: &#x27;运送中&#x27;,  details: &#123;    items: [&#x27;电子产品&#x27;, &#x27;文具&#x27;],    weight: &#x27;1kg&#x27;  &#125;&#125;)function updateDeep() &#123;  // 这会触发视图更新  normalPackage.details.items.push(&#x27;新物品&#x27;)&#125;function updateShallow() &#123;  // 这不会触发视图更新，因为details是非响应式的  shallowPackage.details.items.push(&#x27;新物品&#x27;)    // 但这会触发更新，因为status是顶层属性  // shallowPackage.status = &#x27;已送达&#x27;&#125;&lt;/script&gt;\r\nreadonly与shallowReadonly\r\n技术解释：readonly创建一个深层只读代理，任何嵌套属性都不可修改，而shallowReadonly只使顶层属性为只读。\r\n生活案例：想象一份合同文档。readonly就像一份完全盖章的合同，所有条款和附件都不能修改（深层只读）。而shallowReadonly就像只有主要条款不能修改，但附件内容可以调整（浅层只读）。\r\n代码示例： &lt;template&gt;  &lt;div&gt;    &lt;h2&gt;合同系统&lt;/h2&gt;    &lt;button @click=&quot;tryModify&quot;&gt;尝试修改合同&lt;/button&gt;    &lt;pre&gt;&#123;&#123; contractInfo &#125;&#125;&lt;/pre&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; reactive, readonly, shallowReadonly &#125; from &#x27;vue&#x27;// 原始合同数据const originalContract = reactive(&#123;  title: &#x27;服务协议&#x27;,  signDate: &#x27;2023-05-15&#x27;,  terms: &#123;    duration: &#x27;12个月&#x27;,    payment: &#x27;5000元/月&#x27;  &#125;&#125;)// 完全只读版本const readonlyContract = readonly(originalContract)// 浅层只读版本const shallowReadonlyContract = shallowReadonly(originalContract)// 用于展示的合同信息const contractInfo = reactive(&#123;  original: originalContract,  readonly: readonlyContract,  shallowReadonly: shallowReadonlyContract&#125;)function tryModify() &#123;  try &#123;    // 这会成功    originalContract.title = &#x27;更新的服务协议&#x27;        try &#123;      // 这会失败并显示警告      readonlyContract.title = &#x27;尝试修改只读合同&#x27;    &#125; catch (e) &#123;      console.log(&#x27;无法修改readonly合同的顶层属性&#x27;)    &#125;        try &#123;      // 这会失败并显示警告      readonlyContract.terms.duration = &#x27;24个月&#x27;    &#125; catch (e) &#123;      console.log(&#x27;无法修改readonly合同的嵌套属性&#x27;)    &#125;        try &#123;      // 这会失败并显示警告      shallowReadonlyContract.title = &#x27;尝试修改浅层只读合同&#x27;    &#125; catch (e) &#123;      console.log(&#x27;无法修改shallowReadonly合同的顶层属性&#x27;)    &#125;        // 这会成功，因为嵌套属性不是只读的    shallowReadonlyContract.terms.duration = &#x27;24个月&#x27;        console.log(&#x27;修改操作完成&#x27;)  &#125; catch (e) &#123;    console.error(e)  &#125;&#125;&lt;/script&gt;\r\ntoRaw与markRaw\r\n技术解释：toRaw返回响应式对象的原始对象，markRaw标记一个对象永远不会被转为响应式。\r\n生活案例：想象一个智能家居系统。toRaw就像临时关闭智能功能，获取设备的原始状态进行维护；markRaw则像永久将某些设备（如老式电视）排除在智能系统外，它们的状态变化永远不会触发自动化操作。\r\n代码示例： &lt;template&gt;  &lt;div&gt;    &lt;h2&gt;智能家居控制面板&lt;/h2&gt;    &lt;button @click=&quot;updateDevice&quot;&gt;更新设备状态&lt;/button&gt;    &lt;button @click=&quot;getOriginalState&quot;&gt;获取原始状态&lt;/button&gt;    &lt;button @click=&quot;addNewDevice&quot;&gt;添加新设备&lt;/button&gt;    &lt;pre&gt;&#123;&#123; deviceInfo &#125;&#125;&lt;/pre&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; reactive, toRaw, markRaw, ref &#125; from &#x27;vue&#x27;// 响应式智能设备列表const smartDevices = reactive(&#123;  livingRoom: &#123;    lights: &#123; status: &#x27;on&#x27;, brightness: 80 &#125;,    thermostat: &#123; status: &#x27;on&#x27;, temperature: 22 &#125;  &#125;,  kitchen: &#123;    lights: &#123; status: &#x27;off&#x27;, brightness: 0 &#125;,    refrigerator: &#123; status: &#x27;on&#x27;, temperature: 4 &#125;  &#125;&#125;)// 用于展示的信息const deviceInfo = ref(&#123;  smartDevices,  rawState: null,  updateCount: 0&#125;)// 更新设备状态function updateDevice() &#123;  smartDevices.livingRoom.lights.brightness += 5  if (smartDevices.livingRoom.lights.brightness &gt; 100) &#123;    smartDevices.livingRoom.lights.brightness = 100  &#125;  deviceInfo.value.updateCount++&#125;// 获取原始状态（不触发响应式更新）function getOriginalState() &#123;  // 使用toRaw获取原始对象  const rawDevices = toRaw(smartDevices)  deviceInfo.value.rawState = rawDevices    // 修改原始对象不会触发视图更新  rawDevices.livingRoom.thermostat.temperature = 25&#125;// 添加新设备（使用markRaw标记为非响应式）function addNewDevice() &#123;  // 创建一个永远不会成为响应式的设备对象  const oldTV = markRaw(&#123;    status: &#x27;on&#x27;,    channel: 5,    volume: 30  &#125;)    // 即使添加到响应式对象中，oldTV也不会变成响应式的  smartDevices.livingRoom.tv = oldTV    // 这个修改不会触发更新  setTimeout(() =&gt; &#123;    oldTV.channel = 8    deviceInfo.value.updateCount++  &#125;, 1000)&#125;&lt;/script&gt;\r\ncustomRef的使用\r\n技术解释：customRef允许创建自定义的响应式引用，可以显式控制依赖追踪和触发更新。\r\n生活案例：想象一个智能搜索框。普通的ref就像即时搜索，每输入一个字符就立即搜索；而customRef就像带有防抖功能的搜索框，等你停止输入一段时间后才执行搜索，避免频繁无效的搜索请求。\r\n代码示例： &lt;template&gt;  &lt;div&gt;    &lt;h2&gt;智能搜索&lt;/h2&gt;    &lt;input       type=&quot;text&quot;       placeholder=&quot;输入搜索内容...&quot;       v-model=&quot;searchQuery&quot;    /&gt;    &lt;p&gt;当前搜索: &#123;&#123; searchQuery &#125;&#125;&lt;/p&gt;    &lt;p&gt;搜索结果将在您停止输入后显示&lt;/p&gt;    &lt;div v-if=&quot;isSearching&quot;&gt;搜索中...&lt;/div&gt;    &lt;ul v-else-if=&quot;searchResults.length&quot;&gt;      &lt;li v-for=&quot;(result, index) in searchResults&quot; :key=&quot;index&quot;&gt;        &#123;&#123; result &#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;    &lt;p v-else-if=&quot;searchQuery&quot;&gt;无搜索结果&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; customRef, ref &#125; from &#x27;vue&#x27;// 创建一个带防抖功能的reffunction useDebouncedRef(value, delay = 500) &#123;  let timeout  return customRef((track, trigger) =&gt; &#123;    return &#123;      get() &#123;        // 追踪依赖        track()        return value      &#125;,      set(newValue) &#123;        // 清除之前的定时器        clearTimeout(timeout)        // 设置新的定时器，延迟触发更新        timeout = setTimeout(() =&gt; &#123;          value = newValue          // 触发更新          trigger()        &#125;, delay)      &#125;    &#125;  &#125;)&#125;// 使用自定义的防抖refconst searchQuery = useDebouncedRef(&#x27;&#x27;)const isSearching = ref(false)const searchResults = ref([])// 监听searchQuery的变化watch(searchQuery, async (newQuery) =&gt; &#123;  if (newQuery.trim()) &#123;    isSearching.value = true    // 模拟API搜索    try &#123;      await new Promise(resolve =&gt; setTimeout(resolve, 1000))      // 模拟搜索结果      searchResults.value = [        `关于 &quot;$&#123;newQuery&#125;&quot; 的结果 1`,        `关于 &quot;$&#123;newQuery&#125;&quot; 的结果 2`,        `关于 &quot;$&#123;newQuery&#125;&quot; 的结果 3`      ]    &#125; catch (error) &#123;      console.error(&#x27;搜索出错:&#x27;, error)      searchResults.value = []    &#125; finally &#123;      isSearching.value = false    &#125;  &#125; else &#123;    searchResults.value = []  &#125;&#125;)&lt;/script&gt;\r\n高级特性\r\nTeleport\r\n技术解释：Teleport是一个内置组件，允许将组件的一部分DOM”传送”到组件DOM层次结构之外的DOM节点中。\r\n生活案例：想象一个购物网站的客服聊天窗口。虽然聊天功能逻辑属于产品页面组件，但聊天窗口需要固定在屏幕右下角，不受页面滚动影响。Teleport就像一个传送门，让聊天窗口的UI可以”传送”到页面底部，而逻辑仍留在原组件中。\r\n代码示例： &lt;template&gt;  &lt;div class=&quot;product-page&quot;&gt;    &lt;h1&gt;产品详情: 智能手表&lt;/h1&gt;    &lt;div class=&quot;product-info&quot;&gt;      &lt;img src=&quot;/watch.jpg&quot; alt=&quot;智能手表&quot; /&gt;      &lt;p&gt;价格: ¥1299&lt;/p&gt;      &lt;button @click=&quot;showChat = true&quot;&gt;联系客服&lt;/button&gt;    &lt;/div&gt;        &lt;!-- 使用Teleport将聊天窗口传送到body底部 --&gt;    &lt;teleport to=&quot;body&quot;&gt;      &lt;div v-if=&quot;showChat&quot; class=&quot;chat-window&quot;&gt;        &lt;div class=&quot;chat-header&quot;&gt;          &lt;h3&gt;客服中心&lt;/h3&gt;          &lt;button @click=&quot;showChat = false&quot;&gt;关闭&lt;/button&gt;        &lt;/div&gt;        &lt;div class=&quot;chat-messages&quot;&gt;          &lt;p class=&quot;message system&quot;&gt;客服小王为您服务&lt;/p&gt;          &lt;p class=&quot;message incoming&quot;&gt;有什么可以帮您的吗？&lt;/p&gt;          &lt;p v-if=&quot;userMessage&quot; class=&quot;message outgoing&quot;&gt;            &#123;&#123; userMessage &#125;&#125;          &lt;/p&gt;        &lt;/div&gt;        &lt;div class=&quot;chat-input&quot;&gt;          &lt;input             v-model=&quot;newMessage&quot;             @keyup.enter=&quot;sendMessage&quot;            placeholder=&quot;输入消息...&quot;           /&gt;          &lt;button @click=&quot;sendMessage&quot;&gt;发送&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/teleport&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const showChat = ref(false)const newMessage = ref(&#x27;&#x27;)const userMessage = ref(&#x27;&#x27;)function sendMessage() &#123;  if (newMessage.value.trim()) &#123;    userMessage.value = newMessage.value    newMessage.value = &#x27;&#x27;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.product-page &#123;  max-width: 800px;  margin: 0 auto;  padding: 20px;&#125;/* 聊天窗口样式 */.chat-window &#123;  position: fixed;  bottom: 20px;  right: 20px;  width: 300px;  height: 400px;  border: 1px solid #ccc;  background: white;  box-shadow: 0 0 10px rgba(0,0,0,0.1);  display: flex;  flex-direction: column;  z-index: 1000;&#125;.chat-header &#123;  display: flex;  justify-content: space-between;  align-items: center;  padding: 10px;  background: #f0f0f0;&#125;.chat-messages &#123;  flex: 1;  padding: 10px;  overflow-y: auto;&#125;.message &#123;  margin-bottom: 10px;  padding: 8px;  border-radius: 4px;&#125;.system &#123;  text-align: center;  color: #888;&#125;.incoming &#123;  background: #f0f0f0;  align-self: flex-start;&#125;.outgoing &#123;  background: #e3f2fd;  align-self: flex-end;  text-align: right;&#125;.chat-input &#123;  display: flex;  padding: 10px;  border-top: 1px solid #eee;&#125;.chat-input input &#123;  flex: 1;  padding: 8px;  margin-right: 10px;&#125;&lt;/style&gt;\r\nSuspense\r\n技术解释：Suspense是一个内置组件，用于协调对异步依赖的处理，可以在等待异步组件时显示加载状态。\r\n生活案例：想象一个在线电影平台。当用户点击观看电影时，需要等待视频加载完成。Suspense就像一个耐心的影院经理，在视频加载期间显示”加载中”的画面，等视频准备好后再开始播放。\r\n代码示例： &lt;template&gt;  &lt;div class=&quot;movie-platform&quot;&gt;    &lt;h1&gt;在线电影平台&lt;/h1&gt;    &lt;div class=&quot;movie-list&quot;&gt;      &lt;div         v-for=&quot;movie in movies&quot;         :key=&quot;movie.id&quot;         class=&quot;movie-card&quot;         @click=&quot;selectMovie(movie)&quot;      &gt;        &lt;img :src=&quot;movie.poster&quot; :alt=&quot;movie.title&quot; /&gt;        &lt;h2&gt;&#123;&#123; movie.title &#125;&#125;&lt;/h2&gt;      &lt;/div&gt;    &lt;/div&gt;        &lt;div v-if=&quot;selectedMovie&quot; class=&quot;movie-player&quot;&gt;      &lt;h2&gt;&#123;&#123; selectedMovie.title &#125;&#125;&lt;/h2&gt;      &lt;Suspense&gt;        &lt;template #default&gt;          &lt;video-player :src=&quot;selectedMovie.video&quot; /&gt;        &lt;/template&gt;        &lt;template #fallback&gt;          &lt;div class=&quot;loading&quot;&gt;视频加载中...&lt;/div&gt;        &lt;/template&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import VideoPlayer from &#x27;./VideoPlayer.vue&#x27;const movies = ref([  &#123; id: 1, title: &#x27;肖申克的救赎&#x27;, poster: &#x27;/poster1.jpg&#x27;, video: &#x27;/video1.mp4&#x27; &#125;,  &#123; id: 2, title: &#x27;阿甘正传&#x27;, poster: &#x27;/poster2.jpg&#x27;, video: &#x27;/video2.mp4&#x27; &#125;,  &#123; id: 3, title: &#x27;霸王别姬&#x27;, poster: &#x27;/poster3.jpg&#x27;, video: &#x27;/video3.mp4&#x27; &#125;])const selectedMovie = ref(null)function selectMovie(movie) &#123;  selectedMovie.value = movie&#125;&lt;/script&gt;&lt;style scoped&gt;.movie-platform &#123;  max-width: 1200px;  margin: 0 auto;  padding: 20px;&#125;.movie-list &#123;  display: flex;  flex-wrap: wrap;  justify-content: space-between;&#125;.movie-card &#123;  width: 300px;  margin-bottom: 20px;  cursor: pointer;&#125;.movie-player &#123;  margin-top: 20px;&#125;.loading &#123;  text-align: center;  font-size: 20px;  color: #888;&#125;&lt;/style&gt;\r\n高频面试题解析\r\n1. Vue3中的响应式原理是什么？\r\n技术解释：Vue3的响应式原理基于ES6的Proxy，能够直接监听对象和数组的变化。当数据发生变化时，Vue会自动更新相关的DOM，保持UI和数据的同步。\r\n生活案例：想象一个智能家居系统。当你调整温度设定（数据变化）时，空调会自动响应并调整工作模式（UI更新）。Vue3的响应式系统就像这个智能家居的控制中心，监测所有设定的变化并通知相关设备做出反应。\r\n2. Vue3中的组件通信方式有哪些？\r\n技术解释：Vue3中的组件通信方式包括props和emit、v-model、refs和parent、provide/inject、$attrs和插槽系统。\r\n生活案例：想象一个家族WhatsApp群组。家族长辈（祖先组件）在群里发布重要信息（provide数据），所有家族成员（后代组件）无论层级关系如何，都能直接接收到这些信息（inject数据），而不需要通过中间人传话。\r\n3. Vue3中的组合式API是什么？\r\n技术解释：Vue3中的组合式API是一组基于函数的API，允许在不使用选项式API的情况下组织和重用组件逻辑。它包括ref、reactive、computed、watch、生命周期钩子等函数。\r\n生活案例：想象一个智能家居系统。组合式API就像一个工具箱，里面有各种工具（函数），你可以根据需要选择和组合使用，构建出不同的智能功能。\r\n4. Vue3中的Teleport是什么？\r\n技术解释：Teleport是一个内置组件，允许将组件的一部分DOM”传送”到组件DOM层次结构之外的DOM节点中。\r\n生活案例：想象一个购物网站的客服聊天窗口。虽然聊天功能逻辑属于产品页面组件，但聊天窗口需要固定在屏幕右下角，不受页面滚动影响。Teleport就像一个传送门，让聊天窗口的UI可以”传送”到页面底部，而逻辑仍留在原组件中。\r\n5. Vue3中的Suspense是什么？\r\n技术解释：Suspense是一个内置组件，用于协调对异步依赖的处理，可以在等待异步组件时显示加载状态。\r\n生活案例：想象一个在线电影平台。当用户点击观看电影时，需要等待视频加载完成。Suspense就像一个耐心的影院经理，在视频加载期间显示”加载中”的画面，等视频准备好后再开始播放。\r\n"},{"title":"latex语法","url":"/2025/06/13/latex%E8%AF%AD%E6%B3%95/","content":"\r\n在 Markdown 中书写 LaTeX 公式时，常用且在多数渲染器（如\r\nMathJax,\r\nKaTeX）中兼容性良好广泛支持的基础命令。\r\n\r\n常用\r\n$$ \\\r\n$$\r\n\r\n$$ 间隔:\\\r\n上下标：a^{m+n}_{i-1} \\\r\n乘号 ()：a b \\\r\n分数： \\\r\n平方根： \\\r\nn 次方根： \\ $$\r\n箭头\r\n$$\r\n\\text{右箭头：} A \\to B \\\\\r\n\\text{左箭头：} A \\leftarrow B \\\\\r\n\\text{右双线箭头 (蕴含)：} A \\Rightarrow B \\\\\r\n\\text{双向双线箭头 (等价)：} A \\Leftrightarrow B\r\n$$\r\n矩阵 (基础)\r\n$$\r\n\\text{无括号矩阵：} \\begin{matrix} a &amp; b \\\\ c &amp; d \\end{matrix}\r\n\\\\\r\n\\text{圆括号矩阵：} \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix}\r\n\\\\\r\n\\text{方括号矩阵：} \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}\r\n$$ ## 运算符与大型运算符\r\n$$\r\n\\text{加减乘：} a+b-c*d \\\\\r\n\\text{正负号：} a \\pm b \\\\\r\n\\text{乘号 (叉乘)：} a \\times b \\\\\r\n\\text{除号：} a \\div b \\\\\r\n\\text{求和符号：} \\sum_{i=1}^{n} x_i \\\\\r\n\\text{积分符号：} \\int_a^b f(x) dx \\\\\r\n\\text{极限符号：} \\lim_{x \\to 0} \\frac{\\sin x}{x}\r\n$$\r\n括号与定界符\r\n$$\r\n\\text{圆括号：} (x+y) \\\\\r\n\\text{方括号：} [a-b] \\\\\r\n\\text{花括号 (需转义)：} \\{ k \\mid k \\in \\mathbb{N} \\} \\\\\r\n\\text{自动调整大小圆括号：} \\left( \\frac{A}{B} \\right) \\\\\r\n\\text{绝对值符号：} |x|\r\n$$\r\n关系运算符\r\n$$\r\n\\text{等于：} a=b \\\\\r\n\\text{不等于：} a \\neq b \\\\\r\n\\text{小于、大于：} a &lt; b, a &gt; b \\\\\r\n\\text{小于等于：} a \\leq b \\\\\r\n\\text{大于等于：} a \\geq b \\\\\r\n\\text{约等于：} x \\approx y\r\n$$\r\n常用希腊字母\r\n$$\r\n\\text{alpha：} \\alpha \\\\\r\n\\text{beta：} \\beta \\\\\r\n\\text{gamma：} \\gamma \\\\\r\n\\text{delta：} \\delta \\\\\r\n\\text{epsilon：} \\epsilon \\\\\r\n\\text{theta：} \\theta \\\\\r\n\\text{pi：} \\pi \\\\\r\n\\text{sigma：} \\sigma \\\\\r\n\\text{omega：} \\omega \\\\\r\n\\text{Delta (大写)：} \\Delta \\\\\r\n\\text{Omega (大写)：} \\Omega\r\n$$\r\n常用符号\r\n$$\r\n\\text{无穷大：} \\infty \\\\\r\n\\text{Nabla (梯度算子)：} \\nabla \\\\\r\n\\text{偏导数符号：} \\partial \\\\\r\n\\text{全称量词 (任意)：} \\forall \\\\\r\n\\text{存在量词 (存在)：} \\exists \\\\\r\n\\text{属于：} a \\in S \\\\\r\n\\text{不属于：} a \\notin S\r\n$$\r\n","tags":["latex"]},{"title":"mavenHello","url":"/2024/05/01/mavenHello/","content":"maven\r\n\r\n\r\n基于项目对象模型Project Object Model管理项目的构建过程和依赖关系\r\n\r\n\r\n环境搭建\r\n\r\nMaven下载\r\n环境变量\r\n&lt;!--安装目录--&gt;MAVEN_HOME&lt;!--path--&gt;%MAVEN_HOME%\\bin\r\n修改settings.xml\r\n&lt;!--本地仓库maven_rep--&gt;&lt;localRepository&gt;D:\\software\\maven\\maven_rep&lt;/localRepository&gt;\r\n  &lt;!--配置阿里云私服--&gt;&lt;mirror&gt;  &lt;id&gt;aliyunmaven&lt;/id&gt;  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;  &lt;name&gt;阿里云公共仓库&lt;/name&gt;  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;\r\n&lt;!-- java1.6版本 --&gt; &lt;profile&gt;          &lt;id&gt;jdk-1.6&lt;/id&gt;          &lt;activation&gt;       \t   &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;       \t   &lt;jdk&gt;1.6&lt;/jdk&gt;          &lt;/activation&gt;          &lt;properties&gt;       \t   &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;       \t   &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;       \t   &lt;maven.compiler.compilerVersion&gt;1.6&lt;/maven.compiler.compilerVersion&gt;          &lt;/properties&gt;       &lt;/profile&gt;  \r\n项目中pom指定jdk1.6\r\n&lt;build&gt;      &lt;plugins&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;              &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;              &lt;version&gt;2.0.2&lt;/version&gt;              &lt;configuration&gt;                  &lt;source&gt;1.6&lt;/source&gt;                  &lt;target&gt;1.6&lt;/target&gt;              &lt;/configuration&gt;          &lt;/plugin&gt;      &lt;/plugins&gt;  &lt;/build&gt;  \r\n验证\r\n//自动下载缺省或更新配置文件和依赖到本地出库。mvn help:system\r\n\r\nIDEA创建maven的java工程\r\n\r\n\r\n\r\nmaven\r\n\r\n\r\n\r\nimage-20250414143623909\r\n\r\n\r\n\r\nimage-20250414143842126\r\n\r\n\r\nIDEA创建maven的web工程\r\n\r\n\r\n\r\nimage-20250414144842996\r\n\r\n\r\n\r\nimage-20250414145041296\r\n\r\n\r\n\r\nimage-20250414145335734\r\n\r\n\r\n\r\n设置maven在不联网的情况下使用本地插件\r\n一般使用maven为我们提供好的骨架时，是需要联网的，配置这个，可以在没有网路的情况下，我们可以正常创建工程，并从之前已经使用过的工程中找到相应的骨架。\r\n-DarchetypeCatalog=internal\r\n\r\n\r\n设置maven在不联网的情况下使用本地插件\r\n\r\nIDEA热部署\r\n\r\n运行时自动编译\r\n引入devtools热部署\r\n&lt;/dependencies&gt;\t&lt;!--devtools热部署--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;&lt;!--                    开启热部署devtools--&gt;                    &lt;fork&gt;true&lt;/fork&gt;                &lt;/configuration&gt;\t\t\t&lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;\r\n\r\n"},{"title":"interview-notes","url":"/2025/01/04/interview-notes/","content":"面试.prompt\r\n这是一个模拟面试场景，要求你站在面试者的角度回答关于xxx工作原理的问题。你需要构建一个全面而专业的回答，涵盖xxx的关键概念、工作原理和技术优势。一个好的面试回答应该：1. 简洁清晰地解释xxx是什么2. 描述其核心组件及其作用3. 详细说明工作流程4. 提到xxx的技术优势5. 可以适当加入一些实际经验来增加可信度   你将以这个结构来组织回答。现在你将详细构思关于xxx各个部分的回答内容。你需要为回答添加一些个人经验元素，并确保整体流畅自然。这样回答会更加真实，显示出实际经验而不只是理论知识。同时，应该确保解释足够通俗易懂，不要太过技术性或晦涩。面试回答不应该过长，但需要足够全面，平衡细节和简洁性。可以在回答中表达对xxx的熟悉程度和实际应用场景，这样会让面试官感到不只是记住了概念，而是真正理解和使用过这个框架。最后，你需要确保回答是逻辑连贯的，每个部分都应该自然地引导到下一个部分，使整个回答形成一个完整的叙述。现在你可以整合前面的思考，形成一个完整的面试回答。你会以一个自然、专业且有信心的语气呈现，同时确保信息准确性和全面性。这个回答应该展现你对xxx的深入理解和实践经验，突出其工作原理和技术优势，同时注意语言的流畅和连贯性。\r\n确认需求.prompt\r\n请你复述一遍我的需求再进行答复，让我能够确认你真的理解了我的需求指令。\r\n原型设计.prompt\r\n帮我设计一个有待办清单功能的微信小程序的原型图，请通过一下方式帮我完成所有的设计：1.思考怎么方便用户使用2.作为设计师思考这些原型界面的设计3.作为产品经理规划这个界面4.使用html在一个界面上生成原型界面，让原型更精美和贴近真实，我希望这个界面是能直接拿去进行开发的\r\n提示词.prompt\r\n帮我设计一个清晰规范的纯Markdown代码的提示词，用于和Cursor沟通开发有待办清单功能的微信小程序，以下是我的需求- 将任务拆分为多个部分，逐步生成，避免内容过长导致中断。- 明确每个步骤的功能需求。- 描述界面风格和交互设计，确保简洁、直观，符合微信小程序的设计规范。- 明确每个步骤的输出内容，例如原型设计、代码框架、注释和错误处理。- 根据原型图，生成这个微信小程序，要求界面按照原型图去还原，并且工程可运行。\r\nQPS\r\n\r\nquery per second\r\n即每秒请求数,一般2000次可满足大多业务场景\r\n记录QPS的两种方式:\r\n\r\n在接口方法中用唯一字符串日志记录,然后统计字符串出现的次数\r\n用Tomcat access log记录接口访问日志,然后统计日志出现的次数\r\n\r\n\r\n工作流\r\n\r\n将业务流程定义为一系列节点和连接,在多个参与者之间按预定规则自动传递信息或任务,用户只需要用可视化的方式定义好流程的各个步骤,如添加”订单组审核”节点只需在流程定义中添加一个节点即可\r\n提供对流程执行状态的实时监控,可以跟踪每个节点的进展,识别潜在问题并采取干预措施\r\n\r\n成员变量与局部变量的区别\r\n\r\n这就像是一个公司和临时工的关系：\r\n- 成员变量就像是公司的正式员工，只要公司存在，他们就一直在那里\r\n- 局部变量就像是临时工，只在特定项目期间存在，项目结束就离开了\r\n\r\n成员变量在堆中在对象被创建时根据数据类型赋默认值,与对象同生共死，对象被创建时分配内存，对象被垃圾回收时释放内存\r\n在使用前必须显式初始化。局部变量在栈内存作用于方法执行期间,方法结束后立即从栈中弹出。\r\n\r\n\r\nfinal修饰为什么不可变？\r\n\r\n\r\n修饰基本数据类型变量时（常量）则其值一旦初始化后就不能再改变。\r\n修饰引用数据类型变量时则其引用不能再指向其他对象，但对象本身的内容是可以改变的（除非该对象本身是不可变的，如\r\nString）。\r\n修饰的方法不能被子类override，从而保证方法的行为在继承体系中保持一致。\r\n修饰的类不能被继承，这就像是一个完美的产品设计，设计师认为它已经达到了最佳状态，不需要也不允许任何修改或扩展。。\r\nfinal\r\n提供了一种机制来保护数据或行为不被意外或恶意修改，特别是在多线程环境或第三方库使用场景中。\r\n编译器可以对final方法进行内联优化\r\n\r\n\r\nThreadLocal\r\n\r\n进程是计算机资源分配最小单位，线程是计算机计算的最小单位。这个最小的计算单位在操作系统中由进程去控制，所以操作系统只负责把资源分配给进程，进程没有专门空间存储ThreadLocal,所以它跟多是语言层面的事情。ThreadLocal提供线程局部变量，相当于给每一个线程独立的副本。\r\n比如你在玩游戏，一个游戏就是进程。这个进程用于有渲染的程序A，和有用于AI处理的程序B。A和B经常抢占CPU的时间片就会导致游戏卡顿。如果一个进程中的所有线程在同步计算结果时去访问进程中的全局变量，就会产生竞争条件，需要解决一致性（加锁）。\r\n\r\n@Autowired与@Resource的区别\r\n\r\n@Autowired注解的作用就是让 Spring容器自动为\r\nareaDao成员变量注入一个实现了 AreaDao\r\n接口的实例对象。Spring 会根据配置（例如\r\nMyBatis的配置）动态生成AreaDao\r\n实现类的代理对象。这个代理对象会被注入到 areaDao 中\r\n@Autowired根据type注入，@Resource基于名称，找不到时基于类型注入，本质上均实现了注入效果。\r\n一般来说，注入controller的service虽然一般来说我们都是注入一个接口，但是该接口有实现类，并且使用@Service进行关联，所以注入类型应该也可以视为一个类，但是mybatis仅需提供Dao接口，也就是说，注入service的dao只是一个接口，而没有实现类，虽然mybatis能够通过Dao接口和xml文件实现与数据库的操作，但是@Autowired并没有这个识别功能，可能它就认为你类型不匹配，无法使用通过类型注入的方法\r\n\r\n无状态登录\r\n\r\n传统的登录验签：\r\n服务器校验完账号密码后用httpsession生成sessionid，把sessionid回写到浏览器的cookie，下次请求时浏览器会自动携带这个cookie,对cookie进行拦截即可判断是否放行。\r\n无状态登录验签：\r\n支持CS和BS架构，狐表开发的应用没有管理session\r\ncookie的功能，所以不得不使用无状态登录方式。服务端把令牌生成并返回给客户端后，可能产生安全隐患，比如用户账密泄露被第三方登录了，并且密码被修改了，这时候，一般情况是只要用户修改账密，就应该把这个用户所有账号踢下线，但是由于之前签发的令牌没有过期，那就可以一直请求放行。\r\n基于Redis：\r\n\r\n只做存取和匹配。这样不用去加解密，因为加解密本身是很耗CPU的行为。\r\n对权限可观可控。当用户修改账密后，可以在Redis把对应令牌删除，实现重登录。\r\n\r\n\r\n"},{"title":"mcp技术","url":"/2025/03/26/mcp%E6%8A%80%E6%9C%AF/","content":"\r\nModel Context Protocol\r\n\r\nuv环境\r\nmcp开发要求借助uv进行虚拟环境创建和依赖管理。\r\npip install uv\r\nmcp-client\r\n# 创建项目目录uv init mcp-clientcd mcp-client\r\n# 创建虚拟环境uv venv# 激活虚拟环境.venv\\Scripts\\activate\r\n# 安装 mcp sdkuv add mcp\r\n# _*_ coding : utf-8 _*_# @Time : 2025/3/26 15:38# @Author : luotao# @File : client# @Desc: 放到 mcp-client 目录下import  asynciofrom mcp import ClientSessionfrom contextlib import AsyncExitStackclass MCPClient:    def __init__(self):        &#x27;&#x27;&#x27; 初始化 MCP 客户端 &#x27;&#x27;&#x27;        self.session = None        self.exit_stack = AsyncExitStack()    async def connect_to_mock_server(self):        &#x27;&#x27;&#x27; 模拟 MCP 服务器的连接(暂时不连接真实服务器) &#x27;&#x27;&#x27;        print(&#x27;mcp 客户端已初始化，但未连接到服务器&#x27;)    async def chat_loop(self):        &#x27;&#x27;&#x27; 运行交互式聊天循环 &#x27;&#x27;&#x27;        print(&#x27;\\nMCP 客户端已启动！输入 &quot;quit&quot; 退出&#x27;)        while True:            try:                query = input(&#x27;\\nQuery:&#x27;).strip()                if query.lower() == &#x27;quit&#x27;:                    break                print(f&#x27;\\n[Mock Response] 你说的是:&#123;query&#125;&#x27;)            except Exception as e:                print(f&#x27;\\n发送错误:&#123;str(e)&#125;&#x27;)    async def cleanup(self):        &#x27;&#x27;&#x27;清理资源&#x27;&#x27;&#x27;        await self.exit_stack.aclose()async def main():    client = MCPClient()    try:        await client.connect_to_mock_server()        await client.chat_loop()    finally:        await client.cleanup()if __name__ == &#x27;__main__&#x27;:    asyncio.run(main())\r\n# 运行mcp客户端uv run client.py\r\n接入在线模型\r\n为了支持调用openai模型，以及在环境变量中读取apikey等信息需要新增依赖\r\nuv add mcp openai python-dotenv\r\n创建.env文件并写入apikey，以及反向代理地址。借助反向代理，国内可以直连openai官方服务器并调用官方api\r\nBASE_URL=&quot;反向代理地址&quot;MODEL=gpt-4oOPENAI_API_KEY=&quot;OpenAi-API-Key&quot;\r\nBASE_URL=https://api.deepseek.comMODEL=deepseek-chatOPENAI_API_KEY=&quot;DeepSeek-API-Key&quot;\r\nBASE_URL=https://localhost:11434/v1/MODEL=qwqOPENAI_API_KEY=ollama\r\n"},{"title":"mermaid语法","url":"/2025/06/13/mermaid%E8%AF%AD%E6%B3%95/","content":"Mermaid 图表常用命令参考\r\n\r\n在 Markdown 中书写 Mermaid\r\n图表时，常用且在多数渲染器中兼容性良好广泛支持的基础命令和图表类型。\r\n\r\ngraph TD\r\n    T_def[\"事务 (Transaction)访问并可能操作各种数据项的一组数据库操作序列\"] --> A\r\n    A[\"数据库事务特性 (ACID)\"] --> B(原子性 Atomicity)\r\n    A --> C(一致性 Consistency)\r\n    A --> D(隔离性 Isolation)\r\n    A --> E(持久性 Durability)\r\n\r\n    B --> B_desc[\"事务中的全部操作要么整体提交 (commit) 成功要么整体回滚 (rollback) 失败\"]\r\n    C --> C_desc[\"事务执行前后数据库 (DB) 从一个一致状态转变到另一个一致状态始终符合完整性约束\"]\r\n    D --> D_desc[\"并发执行的多个事务之间应相互独立，互不干扰一个事务的中间结果对其他事务不可见\"]\r\n    E --> E_desc[\"事务一旦成功提交 (commit)其对数据库的修改就是永久性的即使发生系统故障也不会丢失\"]\r\n\r\n    %% 样式定义\r\n    style T_def fill:#FFFACD,stroke:#BDB76B,stroke-width:2px,color:#556B2F\r\n    style A fill:#FFDAB9,stroke:#A0522D,stroke-width:2px,color:#A0522D\r\n    style B fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style C fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style D fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style E fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style B_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style C_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style D_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style E_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\ngraph TD\r\n    A[开始] --> B(模块一处理);\r\n    B --> C{条件判断?};\r\n    C -- 是 --> D[成功结束];\r\n    C -- 否 --> E((异常处理));\r\n    E --> F[失败结束];\r\n    B --> G((子流程));\r\n    G --> H{重要决策?};\r\n    H -- 选项A --> I[处理分支A];\r\n    H -- 选项B --> J[处理分支B];\r\n1. 流程图 (Flowchart / Graph)\r\n流程图用于表示工作流程或过程。\r\n方向：\r\n\r\n\r\n\r\n命令 (graph 后)\r\n含义\r\n\r\n\r\n\r\n\r\nTD 或 TB\r\n从上到下 (Top to Bottom)\r\n\r\n\r\nBT\r\n从下到上 (Bottom to Top)\r\n\r\n\r\nLR\r\n从左到右 (Left to Right)\r\n\r\n\r\nRL\r\n从右到左 (Right to Left)\r\n\r\n\r\n\r\n节点形状：\r\n\r\n\r\n\r\n语法\r\n形状\r\n说明\r\n\r\n\r\n\r\n\r\nid[文本]\r\n矩形\r\n默认\r\n\r\n\r\nid(文本)\r\n圆角矩形\r\n\r\n\r\n\r\nid((文本))\r\n圆形\r\n\r\n\r\n\r\nid&gt;文本]\r\n不对称矩形 (右侧尖)\r\n\r\n\r\n\r\nid&#123;文本&#125;\r\n菱形\r\n条件判断\r\n\r\n\r\nid[[文本]]\r\n平行四边形\r\n输入/输出\r\n\r\n\r\n\r\n连接线：\r\n\r\n\r\n\r\n语法\r\n类型\r\n说明\r\n\r\n\r\n\r\n\r\n--&gt;\r\n带箭头实线\r\n\r\n\r\n\r\n---\r\n不带箭头实线\r\n\r\n\r\n\r\n-.-&gt;\r\n带箭头虚线\r\n\r\n\r\n\r\n-.-\r\n不带箭头虚线\r\n\r\n\r\n\r\n==&gt;\r\n带箭头粗线\r\n\r\n\r\n\r\n--&gt;|文本|\r\n带标签的连接线\r\n\r\n\r\n\r\n\r\n2. 序列图 (Sequence Diagram)\r\n序列图显示对象之间交互的时间顺序。\r\n参与者：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\nparticipant P as 参与者P\r\n定义名为”参与者P”的参与者P\r\n\r\n\r\n\r\n消息：\r\n\r\n\r\n\r\n语法\r\n类型\r\n说明\r\n\r\n\r\n\r\n\r\nA-&gt;B: 消息文本\r\n实线箭头同步消息\r\n\r\n\r\n\r\nA--&gt;B: 消息文本\r\n虚线箭头异步消息\r\n\r\n\r\n\r\nA-&gt;&gt;B: 消息文本\r\n实线开放箭头\r\n通常表示返回\r\n\r\n\r\nA--&gt;&gt;B: 消息文本\r\n虚线开放箭头\r\n\r\n\r\n\r\n\r\n激活/停用：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\nactivate A\r\n激活参与者A\r\n\r\n\r\ndeactivate A\r\n停用参与者A\r\n\r\n\r\n\r\n注释：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\nNote right of A: 这是注释\r\n在A右侧添加注释\r\n\r\n\r\nNote over A,B: 跨参与者注释\r\n在A和B上方添加注释\r\n\r\n\r\n\r\n循环/条件：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n关键字\r\n结构\r\n说明\r\n\r\n\r\n\r\n\r\nloop\r\nloop [循环条件]      …  end\r\n循环块\r\n\r\n\r\nalt\r\nalt [条件1]      …  else [条件2]\r\n     …  end\r\n条件选择块\r\n\r\n\r\nopt\r\nopt [可选条件]      …  end\r\n可选块\r\n\r\n\r\n\r\n示例：\r\nsequenceDiagram\r\n    autonumber\r\n    participant 用户 as 用户张三\r\n    participant 系统A as 后端服务A\r\n    participant 系统B as 数据库服务B\r\n\r\n    用户->>系统A: 请求查询订单 (订单ID: 123)\r\n    activate 系统A\r\n    系统A->>系统B: 根据ID查询订单详情\r\n    activate 系统B\r\n    系统B-->>系统A: 返回订单数据\r\n    deactivate 系统B\r\n    系统A-->>用户: 显示订单详情\r\n    deactivate 系统A\r\n\r\n    Note right of 用户: 用户查看订单\r\n\r\n    loop 轮询更新状态\r\n        系统A->>系统A: 检查订单状态更新\r\n    end\r\n\r\n    alt 订单支付成功\r\n        系统A->>用户: 推送支付成功通知\r\n    else 订单支付失败\r\n        系统A->>用户: 推送支付失败提醒\r\n    end\r\n3. 甘特图 (Gantt Chart)\r\n甘特图用于项目管理，显示任务和时间表。\r\n日期格式：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\ndateFormat YYYY-MM-DD\r\n设置日期显示格式\r\n\r\n\r\n\r\n任务：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\n任务名称 :id, after id_prev, 开始日期, 持续时间/结束日期\r\n定义一个任务及其依赖、时间\r\n\r\n\r\n任务名称 :done, id, ...\r\n将任务标记为 “已完成” (视觉上通常有变化)\r\n\r\n\r\n任务名称 :active, id, ...\r\n将任务标记为 “进行中” (视觉上通常有变化)\r\n\r\n\r\n任务名称 :crit, id, ...\r\n将任务标记为 “关键任务” (视觉上通常有变化)\r\n\r\n\r\n\r\n里程碑：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\n里程碑名称 :milestone, id, 日期\r\n定义一个里程碑\r\n\r\n\r\n\r\n示例：\r\ngantt\r\n    dateFormat  YYYY-MM-DD\r\n    title 项目开发计划示例\r\n\r\n    需求分析 :task1, 2024-08-01, 7d\r\n    详细设计 :task2, 2024-08-01, 5d\r\n    设计评审 :task3, 2024-08-01, 2d\r\n    前端开发 :task4, 2024-08-01, 10d\r\n    后端开发 :task5, 2024-08-01, 12d\r\n    集成测试 :task6, 2024-08-01, 5d\r\n    用户验收 :task7, 2024-08-01, 1d\r\n    上线准备 :task8, 2024-08-01, 3d\r\n    正式上线 :task9, 2024-08-01, 1d\r\n组合方式：甘特图+markdown表格+markdown文字描述\r\ngantt\r\n    dateFormat  YYYY-MM-DD\r\n    section 学习阶段\r\n    基础奠定: 2025-06-10, 14d\r\n    数据与软件工程核心: 2025-06-24, 18d\r\n    面向对象与算法精通: 2025-07-12, 24d\r\n    法律法规与冲刺: 2025-08-05, 7d\r\n    考前冲刺与模拟: 2025-08-12, 18d\r\n    软考软件设计师考试: milestone, 2025-08-30, 1d\r\n阶段内容详情:\r\n\r\n基础奠定: 计算机组成与体系结构 / 操作系统 /\r\n计算机网络\r\n数据与软件工程核心: 数据库系统 / 数据库设计 /\r\n系统开发基础 / 数据流图\r\n面向对象与算法精通: 面向对象技术 / UML建模 /\r\n面向对象程序设计 / 数据结构 / 算法基础 / 数据结构与算法应用\r\n法律法规与冲刺: 知识产权与标准化 /\r\n程序设计语言与语言处理程序基础\r\n考前冲刺与模拟: 系统复习 / 历年真题演练 /\r\n模拟考试\r\n\r\n详细学习计划表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n阶段\r\n模块\r\n课程\r\n预计开始日期\r\n预计结束日期\r\n预计耗时 (天)\r\n\r\n\r\n\r\n\r\n基础奠定\r\n计算机系统基础\r\n计算机组成与体系结构\r\n2025-06-10\r\n2025-06-14\r\n5\r\n\r\n\r\n\r\n\r\n操作系统\r\n2025-06-15\r\n2025-06-19\r\n5\r\n\r\n\r\n\r\n\r\n计算机网络\r\n2025-06-20\r\n2025-06-23\r\n4\r\n\r\n\r\n数据与软件工程核心\r\n数据管理\r\n数据库系统\r\n2025-06-24\r\n2025-06-28\r\n5\r\n\r\n\r\n\r\n\r\n数据库设计\r\n2025-06-29\r\n2025-07-01\r\n3\r\n\r\n\r\n\r\n软件工程与项目管理\r\n系统开发基础\r\n2025-07-02\r\n2025-07-08\r\n7\r\n\r\n\r\n\r\n\r\n数据流图\r\n2025-07-09\r\n2025-07-11\r\n3\r\n\r\n\r\n面向对象与算法精通\r\n面向对象与UML\r\n面向对象技术\r\n2025-07-12\r\n2025-07-15\r\n4\r\n\r\n\r\n\r\n\r\nUML建模\r\n2025-07-16\r\n2025-07-18\r\n3\r\n\r\n\r\n\r\n\r\n面向对象程序设计\r\n2025-07-19\r\n2025-07-21\r\n3\r\n\r\n\r\n\r\n数据结构与算法\r\n数据结构\r\n2025-07-22\r\n2025-07-27\r\n6\r\n\r\n\r\n\r\n\r\n算法基础\r\n2025-07-28\r\n2025-08-01\r\n5\r\n\r\n\r\n\r\n\r\n数据结构与算法应用\r\n2025-08-02\r\n2025-08-04\r\n3\r\n\r\n\r\n法律法规与冲刺\r\n法律法规与高级主题\r\n知识产权与标准化\r\n2025-08-05\r\n2025-08-07\r\n3\r\n\r\n\r\n\r\n\r\n程序设计语言与语言处理程序基础\r\n2025-08-08\r\n2025-08-11\r\n4\r\n\r\n\r\n考前冲刺与模拟\r\n考前冲刺与模拟\r\n系统复习\r\n2025-08-12\r\n2025-08-17\r\n6\r\n\r\n\r\n\r\n\r\n历年真题演练\r\n2025-08-18\r\n2025-08-23\r\n6\r\n\r\n\r\n\r\n\r\n模拟考试\r\n2025-08-24\r\n2025-08-29\r\n6\r\n\r\n\r\n软考软件设计师考试\r\n\r\n考试\r\n2025-08-30\r\n2025-08-30\r\n1\r\n\r\n\r\n\r\n4. 类图 (Class Diagram) - 基础\r\n类图用于描述系统的静态结构。\r\n类定义：\r\nclassDiagram\r\n    class Animal {\r\n        +String name\r\n        +Number age\r\n        +void eat()\r\n        +void sleep()\r\n    }\r\n    class Dog {\r\n        +String breed\r\n        +void bark()\r\n    }\r\n    class Cat {\r\n        +void meow()\r\n    }\r\n关系：\r\n\r\n\r\n\r\n语法\r\n类型\r\n说明\r\n\r\n\r\n\r\n\r\nA --|&gt; B\r\n继承\r\nB是A的父类\r\n\r\n\r\nA --* B\r\n组合\r\nA包含B (实心菱形)\r\n\r\n\r\nA --o B\r\n聚合\r\nA拥有B (空心菱形)\r\n\r\n\r\nA --&gt; B\r\n关联\r\nA指向B\r\n\r\n\r\nA ..&gt; B\r\n依赖\r\nA依赖B (虚线箭头)\r\n\r\n\r\nA -- B\r\n简单连接\r\n无方向\r\n\r\n\r\n\r\n基数 (Cardinality)：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n示例语法\r\n说明\r\n\r\n\r\n\r\n\r\nA \"1\" -- \"0..*\" B : 包含\r\n定义A和B之间的关系，并标注基数和关系标签\r\n\r\n\r\n\r\n示例：\r\nclassDiagram\r\n    direction LR\r\n    class 订单 {\r\n        +String 订单ID\r\n        +Date 创建日期\r\n        +List 订单项列表\r\n        +Double 总金额\r\n        +计算总价()\r\n        +添加订单项(订单项)\r\n    }\r\n    class 订单项 {\r\n        +String 产品ID\r\n        +Integer 数量\r\n        +Double 单价\r\n        +计算小计()\r\n    }\r\n    class 产品 {\r\n        +String 产品ID\r\n        +String 名称\r\n        +Double 价格\r\n    }\r\n    class 用户 {\r\n        +String 用户ID\r\n        +String 用户名\r\n        +List 历史订单\r\n    }\r\n\r\n    订单 \"1\" o-- \"*\" 订单项 : 包含\r\n    订单项 \"*\" -- \"1\" 产品 : 对应\r\n    用户 \"1\" -- \"*\" 订单 : 创建\r\n5. 状态图 (State Diagram) -\r\n基础\r\n状态图描述对象可能存在的状态以及状态之间的转换。\r\n状态：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\n[*]\r\n起始或结束状态\r\n\r\n\r\nstateName\r\n定义一个简单状态\r\n\r\n\r\nstate \"描述\" as longName\r\n定义带描述和别名的状态\r\n\r\n\r\n\r\n转换：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\nS1 --&gt; S2 : 事件/动作\r\n定义从状态S1到S2的转换，可带标签\r\n\r\n\r\n\r\n复合状态：\r\nstateDiagram-v2\r\n    state \"复合状态\" as S1 {\r\n        S1_1 --> S1_2\r\n    }\r\n示例：\r\nstateDiagram-v2\r\n    [*] --> 已关闭\r\n    已关闭 --> 已开启 : 打开电源\r\n    已开启 --> 已关闭 : 关闭电源\r\n\r\n    state 已开启 {\r\n        [*] --> 空闲\r\n        空闲 --> 运行中 : 开始任务\r\n        运行中 --> 空闲 : 任务完成\r\n        运行中 --> 暂停 : 用户暂停\r\n        暂停 --> 运行中 : 继续任务\r\n        暂停 --> 空闲 : 取消任务\r\n    }\r\n    已开启 --> 故障状态 : 发生错误\r\n    故障状态 --> 已关闭 : 重启\r\n6. 饼图 (Pie Chart)\r\n饼图显示各部分占整体的比例。\r\n语法：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\npie title \"图表标题\"\r\n设置饼图的标题\r\n\r\n\r\n\"标签1\" : 数值1\r\n定义一个扇区及其值\r\n\r\n\r\n\"标签2\" : 数值2\r\n定义另一个扇区及其值\r\n\r\n\r\n\r\n示例：\r\npie title 2024年第一季度水果销量占比\r\n    \"苹果\" : 42.5\r\n    \"香蕉\" : 28.0\r\n    \"橙子\" : 15.3\r\n    \"葡萄\" : 8.7\r\n    \"其他\" : 5.5\r\n7. 实体关系图 (ER Diagram) -\r\n基础\r\nER图用于数据库设计，显示实体及其关系。\r\n实体：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\nENTITY_NAME &#123; primaryKey type \"comment\" ... &#125;\r\n定义一个实体及其属性\r\n\r\n\r\n\r\n关系：\r\n\r\n\r\n\r\n语法\r\n类型\r\n说明\r\n\r\n\r\n\r\n\r\nENTITY1 ||--o&#123; ENTITY2 : \"label\"\r\n一对多\r\nENTITY2是多的一方\r\n\r\n\r\nENTITY1 ||--|| ENTITY2 : \"label\"\r\n一对一\r\n\r\n\r\n\r\nENTITY1 &#125;o--o&#123; ENTITY2 : \"label\"\r\n多对多\r\n\r\n\r\n\r\n\r\n属性 (在实体定义内部)：\r\n\r\n\r\n\r\n语法\r\n说明\r\n\r\n\r\n\r\n\r\ntype name \"comment\"\r\n定义属性的类型、名称和可选注释\r\n\r\n\r\n\r\n示例：\r\nerDiagram\r\n    \"用户\" ||--o{ \"订单\" : \"下单\"\r\n    \"订单\" ||--|{ \"订单详情\" : \"包含\"\r\n    \"产品\" ||--|{ \"订单详情\" : \"属于\"\r\n    \"产品类别\" ||--|{ \"产品\" : \"分类\"\r\n\r\n    \"用户\" {\r\n        string userID PK \"用户ID, 主键, 用户唯一标识\"\r\n        string userName \"用户名\"\r\n        string email \"注册邮箱\"\r\n        string phoneNumber \"电话号码\"\r\n    }\r\n    \"订单\" {\r\n        string orderID PK \"订单ID, 主键, 订单唯一标识\"\r\n        datetime orderTime \"下单时间\"\r\n        string userID FK \"用户ID, 外键, 关联用户表\"\r\n        decimal totalAmount \"总金额\"\r\n        string orderStatus \"订单状态\"\r\n    }\r\n    \"订单详情\" {\r\n        string orderID PK,FK \"订单ID, 复合主键的一部分, 外键关联订单表\"\r\n        string productID PK,FK \"产品ID, 复合主键的一部分, 外键关联产品表\"\r\n        int quantity \"购买数量\"\r\n        decimal unitPrice \"成交单价\"\r\n    }\r\n    \"产品\" {\r\n        string productID PK \"产品ID, 主键, 产品唯一标识\"\r\n        string productName \"产品名称\"\r\n        string description \"产品描述\"\r\n        decimal price \"标准价格\"\r\n        string categoryID FK \"产品类别ID, 外键, 关联产品类别表\"\r\n    }\r\n    \"产品类别\" {\r\n        string categoryID PK \"产品类别ID, 主键, 产品类别唯一标识\"\r\n        string categoryName \"类别名称\"\r\n    }\r\n","tags":["mermaid"]},{"title":"mybatis","url":"/2025/04/10/mybatis/","content":"\r\n父模块依赖\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 基础信息 --&gt;    &lt;groupId&gt;com.luotao&lt;/groupId&gt;    &lt;artifactId&gt;my-javapp&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;my-javapp&lt;/name&gt;    &lt;description&gt;Job Management System - Parent POM&lt;/description&gt;    &lt;!-- 模块定义 --&gt;    &lt;modules&gt;        &lt;module&gt;mybatis-base&lt;/module&gt;        &lt;module&gt;job-api&lt;/module&gt;    &lt;/modules&gt;    &lt;!-- 属性集中管理 --&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;!-- 依赖版本 --&gt;        &lt;spring-boot.version&gt;2.7.6&lt;/spring-boot.version&gt;        &lt;mybatisplus.version&gt;3.5.5&lt;/mybatisplus.version&gt;        &lt;mysql.version&gt;8.0.33&lt;/mysql.version&gt;        &lt;lombok.version&gt;1.18.30&lt;/lombok.version&gt;        &lt;slf4j.version&gt;1.7.36&lt;/slf4j.version&gt;        &lt;knife4j.version&gt;3.0.3&lt;/knife4j.version&gt;        &lt;jjwt.version&gt;0.11.5&lt;/jjwt.version&gt;        &lt;junit.version&gt;5.8.2&lt;/junit.version&gt;        &lt;mybatis.version&gt;3.5.11&lt;/mybatis.version&gt;    &lt;/properties&gt;    &lt;!-- 依赖管理 (父模块只负责声明版本和作用域，子模块需要用时只需声明 groupId 和 artifactId 即可，无需重复写版本号和作用域，保证了版本统一。) --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;!-- Spring Boot 依赖管理 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- MyBatis Plus --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;                &lt;version&gt;$&#123;mybatisplus.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- MySQL Driver --&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- Lombok --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;                &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;                &lt;scope&gt;provided&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- Knife4j API Docs --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;                &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;$&#123;knife4j.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- JJWT --&gt;            &lt;dependency&gt;                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;                &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;                &lt;version&gt;$&#123;jjwt.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;                &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;                &lt;version&gt;$&#123;jjwt.version&#125;&lt;/version&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;                &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;                &lt;version&gt;$&#123;jjwt.version&#125;&lt;/version&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- JUnit (管理测试依赖) --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;                &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;                &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- MyBatis (为 mybatis-base 模块管理) --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mybatis&lt;/artifactId&gt;                &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;!-- 全局依赖 (谨慎添加，只放极少数所有模块都必需的) --&gt;    &lt;dependencies&gt;        &lt;!-- 比如可以把 Lombok 放在这里，如果所有模块都需要 --&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;             &lt;artifactId&gt;lombok&lt;/artifactId&gt;         &lt;/dependency&gt;        &lt;!-- SLF4J API --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 构建配置  --&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- Maven 编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;                    &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;                    &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\r\n子模块依赖\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 继承父 POM --&gt;    &lt;parent&gt;        &lt;groupId&gt;com.luotao&lt;/groupId&gt;        &lt;artifactId&gt;my-javapp&lt;/artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;    &lt;/parent&gt;    &lt;!-- 子模块基本信息 --&gt;    &lt;artifactId&gt;mybatis-base&lt;/artifactId&gt;    &lt;name&gt;MyBatis Base Module&lt;/name&gt;    &lt;description&gt;Base module for MyBatis integration&lt;/description&gt;    &lt;!-- 依赖声明 (从父模块继承版本和作用域) --&gt;    &lt;dependencies&gt;        &lt;!-- MyBatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- MySQL 驱动 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- JUnit 5 API (测试需要) --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- JUnit 5 Engine (测试运行需要) --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--spring-context提供Spring的IoC容器和上下文管理功能--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- Logback (SLF4J 的日志实现) --&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.2.11&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\r\n数据准备\r\nCREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp` (                         emp_id INT AUTO_INCREMENT,                         emp_name CHAR(100),                         emp_salary DOUBLE(10, 5),                         PRIMARY KEY(emp_id));INSERT INTO `t_emp` (emp_name, emp_salary) VALUES(&quot;tom&quot;, 200.33);INSERT INTO `t_emp` (emp_name, emp_salary) VALUES(&quot;jerry&quot;, 666.66);INSERT INTO `t_emp` (emp_name, emp_salary) VALUES(&quot;andy&quot;, 777.77);\r\nmybatis-config\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!--    注册logback配置文件--&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;        &lt;!--    开启驼峰命名,这样可以不用编写resultMap,mybatis自动将emp_id映射为实体的empId --&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;    &lt;!--typeAliases 是一个用于定义类型别名的配置项。它的作用是为 Java 类型指定一个简短的别名，从而在 MyBatis 的 XML 映射文件中可以更方便地引用这些类型，而不需要写完整的类名。--&gt;    &lt;typeAliases&gt;        &lt;typeAlias type=&quot;com.luotao.domian.Employ&quot; alias=&quot;我是在mybatis配置文件中定义的Employ的别名&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--        &lt;environments&gt; 定义多个数据库环境，其中 default 属性指定默认使用的环境。        在生产环境中，可以配置多个环境（如 dev、test、prod），并在不同环境下切换使用。    --&gt;    &lt;environments default=&quot;dev&quot;&gt;        &lt;!--            &lt;environment&gt; 定义一个具体的数据库环境，id 属性是该环境的唯一标识。            这里定义了一个名为 &quot;dev&quot; 的开发环境。        --&gt;        &lt;environment id=&quot;dev&quot;&gt;            &lt;!--                &lt;transactionManager&gt; 定义事务管理器的类型。                type=&quot;JDBC&quot; 表示使用 JDBC 的事务管理，默认情况下 MyBatis 使用 JDBC 的事务管理。            --&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;!--                &lt;dataSource&gt; 定义数据源的类型。                type=&quot;POOLED&quot; 表示使用连接池数据源，MyBatis 提供了三种数据源类型：                    - UNPOOLED：非连接池数据源，每次请求都会创建一个新的数据库连接。                    - POOLED：连接池数据源，可以复用数据库连接，提高性能。                    - JNDI：通过 JNDI 获取数据源，通常用于企业级应用。            --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--                    &lt;property&gt; 用于配置数据源的属性。                    name 属性指定属性名称，value 属性指定属性值。                --&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;!-- 指定 MySQL 数据库驱动类 --&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis-example&quot;/&gt;                &lt;!-- 指定数据库连接 URL，这里连接到名为 &quot;mybatis-example&quot; 的 MySQL 数据库 --&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;!-- 指定数据库用户名 --&gt;                &lt;property name=&quot;password&quot; value=&quot;kuroneko.678&quot;/&gt;                &lt;!-- 指定数据库密码 --&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- 注册映射文件，生成的代理类的实现细节在`EmpMapper.xml`中        通过该配置，MyBatis会将EmpMapper.xml中定义的SQL语句与com.luotao.mapper.EmpMapper接口方法list绑定--&gt;        &lt;mapper resource=&quot;mapper/EmpMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\r\n实体类\r\npackage com.luotao.domian;import lombok.Data;/** * @Classname Employ * @Description 员工实体类 * @Version 1.0.0 * @Date 2025/4/11 0:48 * @Author LuoTao */@Datapublic class Employ &#123;    private Integer empId;    private String empName;    private Double empSalary;    private Double doubleEmpSalary; //非数据库字段&#125;\r\nmapper接口\r\npackage com.luotao.mapper;import com.luotao.domian.Employ;import org.apache.ibatis.annotations.MapKey;import org.apache.ibatis.annotations.Param;import java.util.List;import java.util.Map;public interface EmpMapper &#123;    // 查询所有员工    List&lt;Employ&gt; list(@Param(&quot;empName&quot;)String empName,@Param(&quot;minEmpSalary&quot;) Double minEmpSalary);    List&lt;Employ&gt; listByResultMap();    // 通过姓名查询。  @Param 注解为方法参数指定一个名称，可以在 XML 中通过该名称引用这些参数    Employ getEmpByName(@Param(&quot;abc&quot;)String empName,@Param(&quot;tableName&quot;) String tableName);    Integer addEmploy(Employ employ);    Integer addEmployByMap(Map map);    Double getEmpSalaryById(Integer id);    //@MapKey(&quot;emp_id&quot;) //@MapKey的作用是将查询结果映射为一个嵌套的 Map，外层 Map 的键是 @MapKey 指定的列值，内层 Map 是其他列名和列值的键值对。如果未指定 @MapKey：MyBatis 将查询结果映射为一个普通的 Map，键是列名，值是对应的列值。    Map&lt;String,Double&gt; getMinMaxAvgSalary();&#125;\r\nEmpMapper\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- MyBatis配置文件约束声明 --&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 映射器定义：将XML映射到EmpMapper接口，实现接口方法与SQL的绑定 --&gt;&lt;mapper namespace=&quot;com.luotao.mapper.EmpMapper&quot;&gt;    &lt;!--将重复的sql定义为独立的SQL 片段，&lt;include&gt; 标签用于引用已定义的 SQL 片段，通过 refid 属性指定要引用的片段的 id。--&gt;    &lt;sql id=&quot;allColumns&quot;&gt;        emp_id as &#x27;empId&#x27;,   &lt;!-- 将数据库字段 emp_id 映射为 Employ 对象的属性 empId --&gt;        emp_name as &#x27;empName&#x27;,        emp_salary as &#x27;empSalary&#x27;    &lt;/sql&gt;    &lt;!-- 查询符合条件的所有员工信息         id: 对应Mapper接口方法名         resultType: 返回结果映射的实体类         MyBatis 会根据方法签名自动推断参数类型,可以省略parameterType         在 XML 配置中，resultType 必须显式声明--&gt;    &lt;select id=&quot;list&quot; resultType=&quot;我是在mybatis配置文件中定义的Employ的别名&quot;&gt;        &lt;!-- SQL查询字段与实体类属性映射             通过as别名实现数据库字段到Java属性的映射,解决字段名与属性名不一致的问题             别名与Employ属性名的匹配是大小写不敏感的。例如，empsalary 可以匹配 empSalary。             如果未指定别名，字段名与属性名需要完全一致（包括大小写）。--&gt;        select            &lt;include refid=&quot;allColumns&quot;&gt;&lt;/include&gt;, emp_salary * 2 as &#x27;doubleEmpSalary&#x27;        from t_emp        where        1=1        &lt;if test=&quot;empName != null and empName != &#x27;&#x27; &quot;&gt;            AND (            emp_name LIKE CONCAT(&#x27;%&#x27;, #&#123;empName&#125;, &#x27;%&#x27;)            )        &lt;/if&gt;        &lt;if test=&quot;minEmpSalary != null &quot;&gt;            AND (            emp_salary &gt;= #&#123;minEmpSalary&#125;            )        &lt;/if&gt;    &lt;/select&gt;    &lt;!--  已经配置了mapUnderscoreToCamelCase,这样可以不用编写resultMap,mybatis自动将emp_id映射为实体的empId  --&gt;    &lt;select id=&quot;listByResultMap&quot; resultType=&quot;我是在mybatis配置文件中定义的Employ的别名&quot;&gt;    &lt;!-- &lt;select id=&quot;listByResultMap&quot; resultMap=&quot;employResultMap&quot;&gt; --&gt;        select *, emp_salary * 2 as &#x27;doubleEmpSalary&#x27; from t_emp    &lt;/select&gt;    &lt;!--   描述实体与查询结果的映射规则。这里的命名很规范，可以不使用这个规则，到MyBatis配置文件中配置mapUnderscoreToCamelCase,自动将emp_id映射为实体的empId        &lt;resultMap id=&quot;employResultMap&quot; type=&quot;我是在mybatis配置文件中定义的Employ的别名&quot;&gt;            &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;/&gt;            &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;/&gt;            &lt;result column=&quot;emp_salary&quot; property=&quot;empSalary&quot;/&gt;            &lt;result column=&quot;doubleEmpSalary&quot; property=&quot;doubleEmpSalary&quot;/&gt;        &lt;/resultMap&gt;    --&gt;    &lt;select id=&quot;getEmpByName&quot; resultType=&quot;com.luotao.domian.Employ&quot;&gt;        select        emp_id as &#x27;empId&#x27;,        emp_name as &#x27;empName&#x27;,        emp_salary as &#x27;empSalary&#x27;        from        $&#123;tableName&#125;        &lt;!--            #&#123;&#125; 做的是预编译处理（PreparedStatement），可以有效防止 SQL 注入。            #&#123;abc&#125; 表示从传入的参数中获取名为 abc 的值，并将其作为 PreparedStatement 的参数。        --&gt;        where        emp_name=#&#123;abc&#125;        &lt;!--            $&#123;&#125; 做的是字符串拼接，直接将变量值插入到 SQL 语句中。            $&#123;abc&#125; 会直接将 abc 的值替换到 SQL 语句中，不进行任何转义，存在 SQL 注入风险。            示例：where emp_name=&#x27;$&#123;abc&#125;&#x27;        --&gt;    &lt;/select&gt;    &lt;select id=&quot;getEmpSalaryById&quot; resultType=&quot;double&quot;&gt;        select emp_salary        from t_emp        where emp_id = #&#123;empId&#125;    &lt;/select&gt;    &lt;select id=&quot;getMinMaxAvgSalary&quot; resultType=&quot;map&quot;&gt;        select            emp_id,            min(emp_salary) as &#x27;minSalary&#x27;,            max(emp_salary) as &#x27;maxSalary&#x27;,            avg(emp_salary) as &#x27;avgSalary&#x27;        from t_emp    &lt;/select&gt;    &lt;!-- keyProperty 属性用于指定将数据库生成的主键值映射到实体类的哪个属性，key表示数据库的主键，property表示实体类的属性。--&gt;    &lt;insert id=&quot;addEmploy&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;empId&quot;&gt;        &lt;!--parameterType为实体类型，这些参数其实就是Employ的属性名,#&#123;通过getter方法获取Employ属性值与这些参数映射&#125;--&gt;        insert into t_emp(emp_id,emp_name,emp_salary) values (null,#&#123;empName&#125;,#&#123;empSalary&#125;)    &lt;/insert&gt;    &lt;insert id=&quot;addEmployByMap&quot;&gt;        &lt;!--parameterType为Map类型，这些参数其实就是map的key,#&#123;通过map.get(&quot;empName&quot;)获取value与这些参数映射&#125;--&gt;        insert into t_emp(emp_id,emp_name,emp_salary) values (null,#&#123;empName&#125;,#&#123;empSalary&#125;)    &lt;/insert&gt;&lt;/mapper&gt;\r\nLogback\r\n1.添加依赖和配置文件\r\n&lt;!-- Logback (SLF4J 的日志实现) --&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt;\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- XML 文件的版本和编码声明 --&gt;&lt;configuration debug=&quot;true&quot;&gt;    &lt;!-- 定义一个名为 STDOUT 的 Appender，用于将日志输出到控制台 --&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!-- 编码器，用于格式化日志输出 --&gt;        &lt;encoder&gt;            &lt;!-- 日志输出格式：                 - %d&#123;HH:mm:ss.SSS&#125;：时间戳（时:分:秒.毫秒）                 - %-5level：日志级别，左对齐并占位 5 个字符                 - %thread：线程名                 - %logger：日志记录器名称                 - %msg：日志消息                 - %n：换行符            --&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;            &lt;!-- 指定字符集为 UTF-8 --&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 根日志记录器配置，日志级别为 DEBUG --&gt;    &lt;root level=&quot;DEBUG&quot;&gt;        &lt;!-- 引用 STDOUT Appender，表示根日志记录器的日志将输出到控制台 --&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;    &lt;!-- 定义一个名为 com.luotao 的日志记录器，日志级别为 DEBUG --&gt;    &lt;logger name=&quot;com.luotao&quot; level=&quot;DEBUG&quot; /&gt;&lt;/configuration&gt;\r\n2.在mybatis-config.xml中注册\r\n&lt;configuration&gt;    &lt;!--    注册logback配置文件--&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;\r\n单元测试\r\nimport com.luotao.domian.Employ;import com.luotao.mapper.EmpMapper;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Map;/** * @Classname EmpTest * @Description TODO * @Version 1.0.0 * @Date 2025/4/11 1:19 * @Author LuoTao */@Slf4jpublic class EmpTest &#123;    private EmpMapper empMapper;    private SqlSession sqlSession; //SqlSession 的事务默认是被暂存的，直到显示调用commit方法才会提交到数据库    @BeforeEach // @BeforeEach 注解用于标记一个方法，在每个测试方法执行之前都会调用该方法。这通常用于初始化测试环境或资源。    public void setup() throws IOException &#123;        // 步骤1：从类路径（src/main/resources）加载MyBatis全局配置文件        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);        // 步骤2：根据配置文件构建数据库会话工厂        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);        // 步骤3：获取一个数据库连接会话         sqlSession = sqlSessionFactory.openSession();        // 步骤4：获取Mapper代理对象(自动生成EmpMapper接口的实现类)：父接口指向一个实现了EmpMapper的类，实现的细节在`EmpMapper.xml`中(通过EmpMapper.xml中的SQL配置绑定接口方法)         empMapper = sqlSession.getMapper(EmpMapper.class);    &#125;    @Test    public void listTest()  &#123;        // 执行EmpMapper.xml中id=&quot;list&quot;的SQL语句,将查询结果自动映射为Employ对象列表//        empMapper.list(&quot;t&quot;,200D).forEach(System.out::println);        // 可以不用mapper,直接引用配置文件的命名空间下的id为list的SQL 查询。        // 第一个参数是 SQL 语句的完整路径，格式为 命名空间 + SQL 语句的 id，例如 com.luotao.mapper.EmpMapper.list。        //第二个参数是传递给 SQL 语句的参数，可以是一个 Map 或实体对象，        // 这里通过 HashMap 传递 empName 和 minEmpSalary 参数，key是String类型的sql占位符，value是Object类型可以自动转换empName的String或minEmpSalary的Double类型。        sqlSession.selectList(&quot;com.luotao.mapper.EmpMapper.list&quot;,new HashMap&lt;String,Object&gt;()&#123;&#123;            put(&quot;empName&quot;, &quot;t&quot;);           // 对应 SQL 中的 #&#123;empName&#125;            put(&quot;minEmpSalary&quot;, 200D);  // 对应 SQL 中的 #&#123;minEmpSalary&#125;        &#125;&#125;).forEach(System.out::println);    &#125;    @Test    public void listByResultMapTest()&#123;        empMapper.listByResultMap().forEach(System.out::println);    &#125;    @Test    public void getEmpByNameTest()  &#123;        // 执行EmpMapper.xml中id=&quot;getEmpByName&quot;的SQL语句,将查询结果自动映射为Employ对象        System.out.println(empMapper.getEmpByName(&quot;luotao&quot;,&quot;t_emp&quot;));    &#125;    @Test    public void getEmpSalaryById()  &#123;        System.out.println(String.format(&quot;该员工薪资为%s&quot;,  empMapper.getEmpSalaryById(Integer.valueOf(1))));    &#125;    @Test    public void getMinMaxAvgSalary()  &#123;         empMapper.getMinMaxAvgSalary().entrySet().forEach(kv -&gt;&#123;            System.out.println(String.format(&quot;%s=&gt;%s&quot;,kv.getKey(),kv.getValue() ));        &#125;);    &#125;    @Test    public void addEmployTest()  &#123;        Employ employ = new Employ();        employ.setEmpName(&quot;旺财&quot;);        employ.setEmpSalary(8000D);        try &#123;            // 执行EmpMapper.xml中id=&quot;addEmploy&quot;的SQL语句,将查询结果自动映射为Employ对象            System.out.println(empMapper.addEmploy(employ));            System.out.println(employ); // 如果配置了keyProperty=&quot;empId&quot;，则会将生成的主键映射到实体类的empId属性            sqlSession.commit();        &#125; catch (Exception e) &#123;            sqlSession.rollback();            System.out.println(e.getMessage());        &#125; finally &#123;            sqlSession.close();        &#125;    &#125;    @Test    public void addEmployByMap()  &#123;/*        Map map = Map.of(                &quot;empName&quot;,&quot;旺财&quot;,                &quot;empSalary&quot;,8000D);*/        // key必须和实体的属性名对应才能映射结果        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(&quot;empName&quot;, &quot;旺财1&quot;);        map.put(&quot;empSalary&quot;, 8000D);        try &#123;            // 执行EmpMapper.xml中id=&quot;addEmployByMap&quot;的SQL语句,将查询结果自动映射为Map            System.out.println(empMapper.addEmployByMap(map));            sqlSession.commit();        &#125; catch (Exception e) &#123;            sqlSession.rollback();            System.out.println(e.getMessage());        &#125; finally &#123;            sqlSession.close();        &#125;    &#125;&#125;\r\n数据准备\r\nuse `mybatis-example`;create table t_teacher(    tid   int auto_increment primary key,    tname varchar(20));create table t_stu(    sid       int auto_increment primary key,    sname     varchar(20),    teacherId int,    foreign key (teacherId) references t_teacher (tid));insert into t_teachervalues (0, &#x27;jim&#x27;),       (0, &#x27;tom&#x27;);insert into t_stuvalues (0, &#x27;jack&#x27;, 1),       (0, &#x27;john&#x27;, 1),       (0, &#x27;tony&#x27;, 2),       (0, &#x27;tomas&#x27;, 2),       (0, &#x27;tin&#x27;, 2);-- 每个教师的详细信息，教师表和教师资料表一对一CREATE TABLE t_teacher_profile (    profile_id INT AUTO_INCREMENT PRIMARY KEY, -- 主键    teacher_id INT UNIQUE,                     -- 外键，指向 t_teacher 表的 tid    profile_info VARCHAR(255),                 -- 教师的详细信息    FOREIGN KEY (teacher_id) REFERENCES t_teacher(tid));INSERT INTO t_teacher_profile (teacher_id, profile_info) VALUES (1, &#x27;Jim is a senior teacher with 10 years of experience.&#x27;),(2, &#x27;Tom specializes in mathematics and physics.&#x27;);\r\n对一和对多关联\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- MyBatis配置文件约束声明 --&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--在 mybatis-config.xml 中自动注册了 com.luotao.domian以及子包下类的别名,也开启了驼峰命名--&gt;&lt;!-- 映射器定义：将XML映射到EmpMapper接口，实现接口方法与SQL的绑定 --&gt;&lt;mapper namespace=&quot;com.luotao.mapper.TeacherMapper&quot;&gt;    &lt;select id=&quot;getTeacherList&quot; resultMap=&quot;teacherResultMap&quot;&gt;        select *        from t_teacher as tea                 left join             t_stu as stu on tea.tid = stu.teacherId                 left join             t_teacher_profile AS tprof ON tea.tid = tprof.teacher_id    &lt;/select&gt;    &lt;!--   mapUnderscoreToCamelCase已经满足不了需求，所以定义描述实体与查询结果的映射规则resultMap。--&gt;    &lt;resultMap id=&quot;teacherResultMap&quot; type=&quot;teacher&quot;&gt;        &lt;id column=&quot;tid&quot; property=&quot;tId&quot;/&gt;        &lt;result column=&quot;tname&quot; property=&quot;tName&quot;/&gt;        &lt;!-- 一对一关联：教师与教师资料            方式一：&lt;association&gt; 标签将查询结果中的某些列映射到一个 Java 类的属性上。            方式二：给列起别名         --&gt;        &lt;association property=&quot;teacherProfile&quot; javaType=&quot;teacherProfile&quot;&gt;            &lt;id column=&quot;profile_id&quot; property=&quot;profileId&quot;/&gt;            &lt;result column=&quot;teacher_id&quot; property=&quot;teacherId&quot;/&gt;            &lt;result column=&quot;profile_info&quot; property=&quot;profileInfo&quot;/&gt;        &lt;/association&gt;        &lt;!-- collection处理一对多关联：教师与学生            &lt;collection&gt; 标签：指定 Teacher 类中的一个集合属性，该属性用于存储与 Teacher 关联的多个 Student 对象。            ofType=&quot;student&quot;：指定集合中元素的类型。--&gt;        &lt;collection property=&quot;studentList&quot; ofType=&quot;student&quot;&gt;            &lt;id column=&quot;sid&quot; property=&quot;sId&quot;/&gt;            &lt;result column=&quot;sname&quot; property=&quot;sName&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;!--一对一关联：教师与教师资料        方式二：除了使用 &lt;resultMap&gt; 和 &lt;association&gt; 标签来处理复杂对象映射外，还可以通过给列起别名，直接将查询结果中的列名映射到 Java 对象的属性上        数据库列名 as &#x27;Java对象.属性名&#x27;--&gt;    &lt;select id=&quot;getTeacherListByAs&quot; resultType=&quot;teacher&quot;&gt;        select tea.*,               tprof.profile_id as &#x27;teacherProfile.profileId&#x27;,               tprof.teacher_id as &#x27;teacherProfile.teacherId&#x27;,               tprof.profile_info as &#x27;teacherProfile.profileInfo&#x27;        from t_teacher as tea                 left join             t_teacher_profile AS tprof ON tea.tid = tprof.teacher_id    &lt;/select&gt;&lt;/mapper&gt;\r\n"},{"title":"mysql","url":"/2024/02/24/mysql/","content":"死锁\r\n\r\n多线程环境下多个锁导致的交叉产生，这种因争夺资源而陷入相互等待的僵局。\r\n\r\n-- 查看 InnoDB 存储引擎状态信息的 SQL 命令。该命令输出的内容通常被用来分析数据库性能、事务等待、死锁等问题。DEADLOCKS\t最近一次的死锁信息。show engine innodb status;\r\n概念\r\n\r\n\r\n数据库管理系统、数据库和表的关系\r\n\r\n\r\n数据库管理系统 DataBaseSystem 是一套运行在操作系统的软件\r\n通过文件形式管理数据的文件系统\r\n关系型数据库\r\n非关系型数据库\r\nmysql1996年开始运作被oracle收购\r\nmysql不区分大小写\r\nmysql创建数据库默认字符集：latin1\r\n\r\n数据类型\r\n\r\n\r\nmysql数据类型\r\n\r\n字符串类型\r\n\r\nchar 固定长度 适合存储固定大小的字符串如性别、身份证号\r\nvarchar 可变长度\r\n，适合存储一定范围内变化的字符串，如微博留言；频繁扩容或缩容效率低但节省存储\r\n\r\nDDL\r\n数据库定义语言。Data Definition Language 定义数据库、表、字段\r\n创建数据库\r\n-- 数据库不存在则创建utf8编码的数据库create database if not exists db1 character set utf8;\r\n/*SqlServer语法*/-- 创建该数据库CREATE DATABASE 库名\r\n复制表结构\r\n-- 复制表结构create table tb2 like tb1;\r\n\r\n\r\n表复制\r\n\r\n创建表\r\n-- 创建表create table if not exists tb1(\tid int(20) primary key,    uname char(20),    uaddress varchar(50));\r\n展示某数据库详细\r\n-- 选中库use db1;-- 展示某数据库详细show create database db1;\r\n查看正在运行的库\r\n-- 查看正在运行的库select database();\r\n查看所有库\r\n-- 查看所有库SHOW DATABASES;\r\n查看所有表\r\n-- 查看所有表show tables;-- SqlServer查询所有表select name from sys.tables\r\n查看某表的字段定义信息\r\n-- 查看某表的字段定义信息desc tb1;\r\n查看某表的创建语句\r\n-- 查看某表的创建语句show create table tb1;\r\n删除表\r\n-- 删除tb1drop table if exists tb1;\r\n/*sqlserver语法*/use master;-- 删除tb1IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = &#x27;tb1&#x27;)    DROP TABLE SALEHTSP_EQBCS;-- 查询所有表select name from sys.tables;\r\n修改表名\r\n-- 修改表名为tb2rename table tb1 to tb2\r\n修改表默认字符编码\r\n-- 修改 默认字符编码alter table tb1 character set utf8show create table tb1; --修改是否生效\r\n添加字段\r\n-- 添加字段emailalter table tb1 add email VARCHAR(20)desc tb1 -- 查看是否生效\r\n修改字段长度及数据类型\r\n-- 修改字段长度及数据类型alter table tb1 modify email char(20)desc tb1 -- 查看是否生效-- 修改字段名、长度及数据类型alter table tb1 change email phone char(11)desc tb1 -- 查看是否生效\r\n删除字段\r\n-- 删除字段phonealter table tb1 drop phonedesc tb1 -- 查看是否生效\r\nDML\r\n数据库操作语言。Data Manipulation Language 对数据表增删改\r\n-- 学生表use db1;create table student(\tsid int,\tsname varchar(20),\tage int,\tsex char(1),\tsaddress varchar(50));\r\n插入\r\n-- 增insert into student values(1,&quot;罗涛&quot;,&#x27;23&#x27;,&#x27;男&#x27;,&#x27;宝安&#x27;),(2,&quot;周超&quot;,&#x27;24&#x27;,&#x27;男&#x27;,&#x27;福永&#x27;),\r\n更新\r\n-- 改update student set age=18 where sid=1\r\ndelete和truncate影响自增\r\n-- 逐行删除，效率低delete from where sid =1-- truncate先全表删除，然后重新创建一样的表truncate table student-- 1.直接删除studentdrop table if exists student;-- 2.获取定义语句并重新创建表show create table student;\r\nDCL\r\n数据控制语言。Data Controller Language\r\n定义数据库的访问权限、安全级别、存储过程等\r\n创建用户\r\n-- luotao01只能在本机访问目标数据库,密码123456 create user &#x27;luotao01&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;-- luotao02可在任意主机访问目标数据库create user &#x27;luotao02&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;\r\n查询有多少数据库用户\r\n-- 查询有多少数据库用户select * from mysql.user;\r\n用户授权\r\n-- 用户授权all/create/alter/select/insert/update/deletegrant 权限1,权限2...on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名称&#x27;;\r\n查询授权\r\n-- 查询授权show grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;\r\n删除用户\r\n-- 删除用户drop user &#x27;用户名&#x27;@&#x27;主机名称&#x27;;\r\nDQL\r\n数据查询语言，Data Query Language\r\n\r\n\r\n运算符\r\n\r\n\r\n\r\n逻辑运算符\r\n\r\n字段参与运算\r\n-- 员工表use db1;create table emp(\teid int,\tename varchar(20),\tsex char(1),\tsalary double,\thire_date date,\tdepte_name varchar(20));-- 查询结果参与运算：字段值运算select ename,salary+100  from emp where ename=&#x27;罗涛&#x27;select ename,salary+eid  from emp where ename=&#x27;罗涛&#x27;\r\nin\r\n-- in(集合)，每个元素都会与表中指定字段一一比较select * from emp where ename not in (&#x27;罗涛&#x27;,&#x27;周超&#x27;) and ename is nullselect * from emp where ename !=&#x27;罗涛&#x27; and ename is null\r\n区间\r\n-- 区间select * from emp where salary between 5000 and 10000\r\n模糊查询\r\n-- 模糊查询，-表示任意select * from emp where  ename like &#x27;-涛%&#x27;\r\n排序\r\n-- 单列排序 降序descselect * from emp  order by salary desc-- 组合排序,若前字段相同则 排序后一字段select * from emp order by salary desc,eid desc;\r\n聚合函数\r\n纵向查询，根据列筛选保留满足条件的数据。\r\n\r\n\r\nimage-20240331122258240\r\n\r\ngroup by\r\n/*\t1.先根据分组条件划分组\tselect * from emp where sex=&#x27;男&#x27;;\tselect * from emp where sex=&#x27;女&#x27;;\t2.若没有明确展示字段，则取出分组中的第一条记录展示\t3.分组要结合聚合函数使用\tselect sex,count(*) from emp group by sex;\t**/select * from emp group by sex;\r\nhaving\r\n对分组后进一步添加过滤条件，结合group by\r\n/*\t查询部门的平均薪资&gt;6000的部门\t1.分组部门统计平均薪资\t2.分组后过滤**/select depte_name,avg(salary)from emp where depte_name is not null --分组前用where过滤无效数据group by depte_namehaving avg(salary)&gt;6000-- having 条件表达式 and\\or\\not select depte_name,avg(salary)from emp group by depte_namehaving avg(salary)&gt;6000 and depte_name is not null; -- 分组后过滤无效数据\r\nlimit分页查询\r\nlimit 起始行(从0开始),记录数-- 每页3条-- 第1页select * from emp limit 0,3;-- 第2页select * from emp limit 3,3;-- 第3页select * from emp limit 6,3;-- 第4页select * from emp limit 9,3;...-- 第N页,每页记录数Rselect * from emp limit (N-1)*R,R;\r\nSQL约束\r\n对表数据限制以保证数据的正确性。\r\nprimary key\r\n-- primary key 主键约束 标识唯一记录 主键自增 uname非空约束 IDnumber唯一约束create table tb1(\tid int(20) primary key auto_increment,    uname char(20) not null,    IDnumber char(18) unique,    uaddress varchar(50),    dept_id int(20) constraint 外键约束名 foreign key(外键名) references 主表名（关联主表的主键）);create table tb1(\tid int(20) primary key auto_increment,    uname char(20),    uaddress varchar(50),    constraint 外键约束名 foreign key(外键名) references 主表名（关联主表的主键）);-- 添加主键（含非空约束）alter table tb1 primary key(id);desc tb1;-- 查看修改-- 删除主键不会删除非空约束alter table tb1 drop primary key;desc tb1;-- 查看修改-- 联合主键primary key(字段1，字段2);\r\nunique\r\n-- unique 唯一约束（null不参与该约束）\r\nnot null\r\n-- not null 非空约束\r\n默认值\r\n-- 默认值可以防止null值产生create table tb1(\tid int(20) ,    uname char(20),    uaddress varchar(50),    sex char(1) default &#x27;男&#x27;,    salary double default 0.0);desc tb1;\r\nforeign key\r\n/* foreign key 外键约束\t主表：约束从表 部门表\t从表：主表ID作外键\t员工表中部门ID为外键（员工表的非主键字段deptID是部门表的主键，deptID为员工表的外键）。\t添加数据时，先添加主表后添加从表。\t删除数据时，先删除从表后删除主表。**/-- 修改为外键，并分配约束名alter table 从表 constraint 约束名 add foreign key(外键) references 主表(主表的主键)-- 删除外键约束alter table 从表 drop foreign key 约束名\r\n级联操作\r\n删除和更新时，同步主从表的数据。\r\n-- 修改时标记级联alter table 从表 constraint 约束名 add foreign key(外键) references 主表(主表的主键)on delete cascadeon update cascade -- 创建表时标记级联create table tb1(\tid int(20) primary key auto_increment,    uname char(20),    uaddress varchar(50),    constraint 外键约束名 foreign key(外键名) references 主表名（关联主表的主键）    on delete cascade     on update cascade );-- 级联删除delete from tb1 where 指定关联键-- 级联更新update tb1 set 指定关联键 where 指定关联键\r\n事务\r\n\r\n\r\nimage-20240331151659920\r\n\r\n事务由多条sql语句组成整体，若任意一条sql异常都不能提交数据库，全部正常执行则提交，否则回滚到执行事务之前的状态。\r\n\r\nATM取钱 取1k——》校验合法——》update (ATM宕机回滚)\r\ncreate table account(\tid int primary key auto_increment,    username varchar(20),    money double -- 账户余额);insert into account values(null,&#x27;luotao&#x27;,1000),(null,&#x27;zhoucao&#x27;,1000);select * from account;-- 1.开启事务 -- start transaction;begin;-- 2.提交事务 luotao-》zhoucao 转账500update account set money=money-500 where username=&#x27;luotao&#x27;;update account set money=money+500 where username=&#x27;zhoucao&#x27;;commit; -- 提交-- 异常回滚事务 rollback;\r\n\r\n自动提交事务\r\nmysql默认每一条DQL都是一个单独的事务。\r\n查看当前数据库事务默认的提交方式\r\n-- 查看当前数据库事务默认的提交方式show variables like &#x27;autocommit&#x27;;\r\n数据库事务自动提交开关\r\n-- 关闭数据库事务自动提交set @@autocommit=OFF;-- 打开数据库事务自动提交set @@autocommit=ON;\r\n事务四大特性ACID\r\n\r\n\r\n事务四大特性ACID\r\n\r\n事务四个隔离级别\r\n\r\n\r\n事务四个隔离级别\r\n\r\n数据库并发问题\r\n一个数据库服务器可被多个客户端并发访问（多个用户同时涌入服务器）。\r\n脏读\r\n一个事务读到了另一个事务中尚未提交的数据。\r\n\r\n脏读案例\r\n– 修改默认隔离级别为“读未提交” set global transaction isolation level\r\nread uncommitted;\r\n\r\n\r\nimage-20240414111259705\r\n\r\n\r\n\r\nimage-20240414111631608\r\n\r\n– 规避脏读：提升隔离级别\r\n\r\n不可重复读\r\n一个事务中两次读的内容不一致。update时引发的问题。（一个事务里在其他事务提交修改之前和之后读到的数据不一致）\r\n\r\n不可重复读案例\r\n– 修改默认隔离级别为“读已提交” set global transaction isolation level\r\nread committed;\r\n\r\n\r\nimage-20240414114457875\r\n\r\n\r\n\r\n不可重复读\r\n\r\n\r\n幻读\r\n读到的数据状态不准确。一个事务中某次select读到的结果无法支撑后续的业务操作。\r\n（A用户用A事务做查询的时候读到B用户在B事务中提交的修改或新增数据，导致读不准确）\r\n\r\n幻读案例\r\n先select查询，若无记录则注册。\r\n\r\n隔离级别相关命令\r\n-- 当前数据库的默认隔离级别select @@tx_isolation;-- mysql的默认级别为可重复读（幻读问题）-- 修改默认隔离级别set global transaction isolation level 隔离级别名称;\r\n\r\n\r\nmysql默认隔离级别\r\n\r\n数据库设计\r\n一对一\r\nA表与B表中只有一条关联数据。\r\n设计时通常合并成一张表。\r\n-- 顾客——学生create table if not exists  customer(\tid int ,    name char(20) not null,    qq char(12) not null,    phone char(11) not null,    primary key(id) auto_increment);create table if not exists student(\tid int,    name char(20) not null,    sno char(10) not null unique,    primary key(id) auto_increment,    customer_id int unique,    foreign key(customer_id) references customer(id));\r\n/* 夫妇关系表\thusband=0表示同性，不可取丈夫;\twife=0表示同性，不可取妻子；\t男：1001 husband0 \twife1002\t女：1002 husband1001 \twife0**/create table if not exists person(\tid int primary key auto_increment,    sname varchar(20),    sex char(1),    husband int,    wife int);\r\n一对多\r\n\r\n班级——学生：一个班可多个学生，每个学生只能对应一个班级。\r\n客户——订单：一个客户可下多个订单，每个订单只能是一个客户。\r\n部门——员工： 一个部门有多个员工，每个员工只能属于一个部门。\r\n分类——商品：电脑分类下可有小米、联想等多个商品，小米、联想等电脑是一个电脑分类\r\n\r\nA表在B表中有多条关联，B表中每一条只能对应A表的一条。\r\n-- 省份——市create table if not exists province(\tid int primary key auto_increment,    name varchar(20),    description varchar(20));create table if not exists city(\tid int primary key auto_increment,    name varchar(20),    description varchar(20),    pid int,    constraint pro_city_fk foreign key(pid) references province(id));\r\n-- 分类——商品create table if not exists category(    cid varchar(32) primary key,    cname varchar(50));create table if not exists product(\tpid varchar(32) primary key,    pname varchar(50),    price int,    flag varchar(2),-- 商品状态：1上架，2下架    category_id varchar(32),    foreign key(category_id) references category(cid));\r\n多对多\r\nA表和B表都有多条关联对应。\r\n需引入第三张表保存映射关系（A表的外键和B表的外键）。\r\n\r\n老师——学生：一个老师有多个学生，每个学生也有有多个老师。\r\n学生——课程：一个学生可选多个课程，每个课程也有多个学生。中间表：保存两表外键（sid,cid）\r\n用户——角色：一个用户可分配管理员、普通等角色，每个角色也可被多个用户使用。\r\n\r\n-- 演员——角色create table if not exists actor(\tid int primary key auto_increment,    name varchar(20));create table if not exists role(\tid int primary key auto_increment,    name varchar(20));-- 中间表create table if not exists actor_role(\tid int primary key auto_increment,    aid int,    rid int,    foreign key(aid) references actor(id),    foreign key(rid) references role(id));\r\n-- 图书——作者：一个图书可以多个作者，一个作者也可编写多本书create table if not exists book(\tid int primary key auto_increment,    title varchar(10),    price int);create table if not exists author(\tid int primary key auto_increment,\tname char(10),    gender char(1));-- 中间表,并添加级联删除和级联更新create table if not exists book_author(\tid int primary key auto_increment,    book_id int,    author_id int,    foreign key(book_id) references book(id)    on update cascade    on delete cascade,    foreign key(author_id) references author(id)    on update cascade    on delete cascade);\r\n数据库三范式\r\n\r\n原子性:列最小单元\r\n一张表只描述一件事\r\n消除传递依赖\r\n\r\n反三范式：\r\ncross join\r\n交叉连接-笛卡尔积\r\n\r\n\r\n笛卡尔积\r\n\r\ninner join\r\n内连接：将符合比较运算符比较的结果数据重新组合。两表交集。\r\n\r\n隐式内连接\r\n-- category_id作为商品表的外键select p.pname,p.price,c.cname from product p，category c where c.category_id=p.cid\r\n显示内连接\r\n-- category_id作为商品表的外键select p.pname,p.price,c.cname from product pinner join category c on c.category_id=p.cidwhere c.cname=&#x27;鞋服&#x27; and p.price&gt;500\r\n\r\nleft join\r\n左外连接，左表记录全显示以及右表交集。将左表作为基表与右表匹配，若右表匹配为空则NULL显示。\r\n\r\n\r\n左外连接\r\n\r\n-- 每个分类下商品数量,注意count不会过滤NULLselect c.cname &#x27;分类名&#x27;,count(&#x27;pid&#x27;) &#x27;商品数量&#x27; from category c left join  product p on c.category_id=p.cidgroup by c.cname\r\nright join\r\n右外连接，右表记录全显示以及左表交集。将右表作为基表与左表匹配，若左表匹配为空则NULL显示。\r\n子查询\r\n查询块：select-from-where\r\n将一个查询块作为另一个查询块where或having或from部分出现，该查询块作子查询（内层查询），外层查询为父查询。\r\n\r\nwhere型子查询：将子查询结果作父查询的where条件。\r\nform型子查询：将子查询结果作临时表供外层sql父查询。\r\nexists型子查询：父查询结果拿到子查询比较。\r\n\r\n-- 价格最高的商品信息select * from products where price=(select max(price) from product);-- 化妆品分类下的商品名称和价格select p.pname,p.price from product p where p.category_id=(select cid from category where cname=&#x27;化妆品&#x27;)-- 价格&lt;2000的商品来自那个分类select * from category where cid in(select distinct category_id from product where price&lt;2000)\r\n索引\r\n数据库设计时对字段建立引用，使提升查询该字段的效率。\r\n考虑字where及order by涉及的列上建索引。\r\n对表数增删改时索引也要维护。\r\n\r\n主键索引——primary key（unique+not null）\r\n唯一索引——unique index(可以为NULL)\r\n普通索引——index\r\n-- 添加索引create talbe tb1(    id int,    name varchar(20),    hobby varchar(30),    address varchar(30)\tunique index 索引名 (字段));-- 添加索引create unique index 索引名 on tb1(字段)-- 添加索引alter table tb1 add unique index 索引名(字段)-- 删除普通索引alter talbe tb1 drop index 索引名;-- 修改主键自增alter table tb1 modify 主键名 字段类型;-- 先删除主键自增：删除主键索引/删除主键alter talbe tb1 drop primary key;\r\n\r\n视图\r\n\r\n虚表\r\n将指定列映射成一个视图\r\nselect结果集作为视图的数据映射\r\n只有查询操作，做数据的展示\r\n权限控制：某几个列运行运行用户查询，其他列不允许，可以开通视图查询特定列起到权限控制作用\r\n视图本质是将复杂查询构建成一张视图，通过查询视图即可，简化了多表查询\r\n\r\ncreate database if not exists my_db character set utf8;use my_db;-- 分类主表create table if not exists category(\tcid varchar(32) PRIMARY key,\tcname VARCHAR(50));-- 商品从表create table if not exists  product(\tpid VARCHAR(32) PRIMARY key,\tpname VARCHAR(50),\tprice INT,\tflag VARCHAR(2),-- 1上架、0下架\tcategory_id VARCHAR(32),\tFOREIGN KEY(category_id) REFERENCES category(cid)-- 外键约束);\r\ncreate view 视图名 字段别名 as select(字段);-- 基于select将结果集作为视图映射create view  products_category_view as select * from products p left join category c on p.category_id=c.cid;-- 使用视图select cname &#x27;分类名&#x27;,avg(price) &#x27;分类平均价格&#x27; from products_category_view group by cname\r\n-- 鞋服分类下最贵的商品信息select * \tfrom products p\tleft join category c on p.category_id=c.cid\twhere c.cname=&#x27;鞋服&#x27;and p.price=(\tselect max(p.price) &#x27;最贵商品&#x27;\tfrom products p\tleft join category c on p.category_id=c.cid\twhere c.cname=&#x27;鞋服&#x27;;);-- 使用视图select *from products_category_view pcvwhere pcv.cname=&#x27;鞋服&#x27; and pcv.price=(\tselect max(price)    from pcv    where cname=&#x27;鞋服&#x27;);\r\n存储过程\r\n\r\nSQL中加入一些逻辑控制\r\n为了完成特定功能的sql语句集，经编译创建并保存在数据库中，可供外部调用\r\n存储过程调试完成后稳定运行，减少了业务系统与数据库的交互\r\n业务需求在不断变化，存储过程难以维护\r\n\r\n无参存储过程\r\ndelimiter $$ -- 标记开始create procedure 存储过程名称()begin -- 标记SQL开始\tend $$ -- 标记结束\r\n-- 调用存储过程call 存储过程名称\r\n\r\ncreate table goods(\tgid int,    name varchar(20),    num int -- 库存);create table orders(\toid int,\tgid int,\tprice int -- 订单金额);insert into goods values (1,&#x27;奶茶&#x27;,20),(2,&#x27;绿茶&#x27;,100),(3,&#x27;花茶&#x27;,25);-- 查询所有商品delimiter $$create procedure goods_proc()begin \tselect * from goods;end $$-- 调用存储过程call goods_proc();\r\n\r\n有参存储过程\r\ndelimiter $$create procedure orers_proc(\tin o_oid int,    in o_gid int,    in o_price int,    out out_num int)begin-- sql\tinsert into orders values(\to_oid int,o_gid int,o_price int);    -- 给输出变量out_num赋值\tset @out_num=10;\t-- 返回参数\tselect @out_num;end $$-- 调用存储过程call orers_proc(1,2,100,@out_num)\r\n-- 存储过程接受商品ID并根据ID删除商品数据delimiter $$create procedure goods_delById_proc(in goods_id int)begin\tdelete from goods where gid=goods_id;end $$---- 删除goods_id=3的商品call goods_delById_proc(3);\r\n触发器\r\n\r\n某些sql在特定条件下作为触发条件自动执行\r\n针对表增删改（before/after）触发增删改的操作\r\n一个表最多三种触发器（增删改），每个触发器只能作用一张表\r\n视图和临时表不能添加触发器\r\ntruncate表时触发器不会被删除，delete会删除。\r\n\r\n\r\n客户下单：订单表插入一条数据，更新商品表的库存-1\r\n\r\n-- 触发器和存储过程delimiter $\tcreate trigger\t\t触发器名称 触发器时间 触发事件 on tb1\t\tfor each row -- 按行触发\t\tbegin\t\t-- sql\t\tend$\r\n-- 用户下一个订单之后，然后将库存减1delimiter $\tcreate trigger \ttri_xd after insert on orders\tfor each row\tbegin\tupdate goods set num=num-1 where gid=1;\tend $\t-- 编写触发事件:客户下单奶茶insert into orders values(1,1,20)\r\n查询触发器\r\n-- 查询触发器show triggers;\r\n删除触发器\r\ntruncate表时触发器不会被删除，delete会删除。\r\n-- 逐行删除，效率低delete from where sid =1-- truncate先全表删除，然后重新创建一样的表truncate table student-- 1.直接删除studentdrop table if exists student;-- 2.获取定义语句并重新创建表show create table student;\r\n-- 删除触发器if(object_id(&#x27;触发器名称&#x27;) is not null)drop trigger 触发器名称go\r\ntrigger_name\r\n触发器名称在当前数据库唯一\r\ntrigger_time\r\n触发时间(before/after)\r\n\r\nbefore——希望验证新数据是否满足条件\r\nafter——希望在激活触发器的sql之后完成多个更改\r\n\r\ntrigger——event\r\n触发事件（增删改可激活触发器）\r\nfor each row\r\n行级触发,触发影响的每一行都会激活触发器的动作。增删改都有before/after，故每个表最多支持6个触发器,每个表的每个增删改都只对应一个触发器。\r\ntrigger_stmt\r\n触发激活的sql\r\n数据库备份\r\n-- 备份数据库mysqldump -u用户名称 -p密码 数据库名称 &gt; 脚本保存路径.sql\r\n-- mysql备份数据库mysqldump -uroot -proot db1 &gt;./db1.sql-- mysql还原数据库mysql -u -p;source 目标路径;\r\nSqlServer备份还原\r\n/*SqlServer备份还原*/-- 1.sqlserver备份BACKUP DATABASE QPSDZLCTO DISK=&#x27;D:\\QPSDZLC.bak&#x27;-- 2.检查备份文件的逻辑信息，主要为LogicName，一个是数据文件mdf，一个是日志文件ldfRESTORE FILELISTONLYFROM DISK = &#x27;D:\\QPSDZLC.bak&#x27;;-- 3.还原use masterRESTORE DATABASE QPSDZLCFROM DISK=&#x27;D:\\QPSDZLC.bak&#x27;\r\n因为数据库正在使用，所以无法获得对数据库的独占访问权\r\n报以上错误时执行以下语句：\r\nuse masterALTER  DATABASE QPSDZLC SET OFFLINE WITH ROLLBACK IMMEDIATE\r\n数据恢复之后，使用以下语句\r\nALTER  database   QPSDZLC   set   online \r\n导入脚本还原\r\n参考\r\n\r\n数据库排名\r\nsqlLite嵌入式小型数据库应用手机端\r\nfrm——表结构文件； ibd——表数据和索引；\r\n\r\n","tags":["dba"]},{"title":"vscode","url":"/2025/04/14/vscode/","content":"插件\r\n\r\nIntelliJ IDEA Keybindings\r\nIntellij IDEA light theme\r\nJetBrains IDEA Icons\r\nPath Autocomplete\r\nCode Spell checker\r\nTODO Highlight\r\nError Lens\r\nImage preview\r\nCodeSnap\r\nprettier-code formatter\r\n\r\n基础配置\r\n&#123;    // ============== 外观与主题配置 ==============    &quot;workbench.colorTheme&quot;: &quot;Idea intellij light theme&quot;,  // JetBrains风格亮色主题    &quot;workbench.preferredDarkColorTheme&quot;: &quot;Idea intellij light theme&quot;,  // 统一亮色主题    &quot;workbench.iconTheme&quot;: &quot;jetbrainsicons&quot;,              // JetBrains风格图标（需安装插件）    &quot;editor.minimap.enabled&quot;: false,                     // 禁用右侧代码缩略图    // ============== 编辑器基础配置 ==============    &quot;editor.fontFamily&quot;: &quot;Consolas&quot;,                     // Windows经典等宽字体    &quot;editor.fontSize&quot;: 14,                               // 适中字号    &quot;editor.fontLigatures&quot;: true,                        // 启用编程连字（如=&gt;显示为箭头）    &quot;editor.mouseWheelZoom&quot;: true,                       // 支持Ctrl+滚轮缩放编辑器    &quot;window.zoomLevel&quot;: 2,                               // 整体界面缩放（根据显示器DPI调整）        // ============== 光标与动画配置 ==============    &quot;editor.cursorSmoothCaretAnimation&quot;: &quot;on&quot;,           // 光标平滑移动动画    &quot;editor.cursorBlinking&quot;: &quot;smooth&quot;,      // 光标平滑闪烁效果                     // ============== 工作区行为配置 ==============    &quot;window.restoreWindows&quot;: &quot;none&quot;,                     // 启动时不恢复上次会话    &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;,        // 启动时创建新文件    // ============== 终端配置 ==============     // &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Command Prompt&quot;,         // Git Bash        &quot;terminal.integrated.profiles.windows&quot;: &#123;            &quot;Git-Bash&quot;: &#123;                &quot;path&quot;: &quot;D:\\\\software\\\\Git\\\\bin\\\\bash.exe&quot;,                 &quot;args&quot;: [&quot;--login&quot;],                &quot;icon&quot;: &quot;terminal-bash&quot;            &#125;        &#125;,        &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git Bash&quot;, // 设为默认终端            // 环境变量配置（增强Git Bash兼容性）        &quot;terminal.integrated.env.windows&quot;: &#123;            &quot;MSYS_NO_PATHCONV&quot;: &quot;1&quot;        &#125;,        // ============== 语言与框架支持 ==============    // Vue开发支持（需安装Volar插件）    &quot;[vue]&quot;: &#123;        &quot;editor.defaultFormatter&quot;: &quot;Vue.volar&quot;           // Vue官方格式化工具    &#125;,        // HTML格式化配置（需安装Prettier插件）    &quot;[html]&quot;: &#123;        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;    &#125;,    // ============== 路径与自动补全配置 ==============    // @符号路径提示（需安装Path Autocomplete插件）    &quot;path-autocomplete.pathMappings&quot;: &#123;        &quot;@&quot;: &quot;$&#123;folder&#125;/src&quot;  // 适用于Vue/React等基于src目录的项目结构    &#125;,    // ============== 其他工具配置 ==============    // Emmet模板配置    &quot;emmet.variables&quot;: &#123;        &quot;lang&quot;: &quot;zh-CN&quot;,                                 // 中文文档        &quot;charset&quot;: &quot;UTF-8&quot;                               // 统一编码格式    &#125;,        // console-ninja插件    &quot;console-ninja.featureSet&quot;: &quot;Community&quot; ,                 // Live Server配置（需安装Live Server插件）    &quot;liveServer.settings.CustomBrowser&quot;: &quot;microsoft-edge&quot;, // 指定Edge作为调试浏览器        // GitHub Copilot配置    &quot;github.copilot.enable&quot;: &#123;        &quot;*&quot;: false,                                      // 全局禁用AI代码补全        &quot;plaintext&quot;: false,        &quot;markdown&quot;: false,        &quot;scminput&quot;: false,        &quot;html&quot;: false    &#125;,&#125;\r\n\r\n打开后新建未命名文件\r\n\r\n\r\nimage-20250414201624402\r\n\r\n\r\n"},{"title":"spring-base","url":"/2025/04/17/spring-base/","content":"\r\n\r\nimage-20250417184634377\r\n\r\n"},{"title":"helloweb","url":"/2024/10/06/helloweb/","content":"Hyper Text Markup Language\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;!-- 兼容IE --&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;!-- 3秒后自动刷新跳转百度 --&gt;    &lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.baidu.com&quot;&gt; --&gt;    &lt;!-- 配置移动端 --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;!-- 要求搜索爬虫不索引此页面 --&gt;    &lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;Tao&#x27;s Blog&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;Tao&quot;&gt;    &lt;title&gt;Taoの博客&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 文本类行内元素 --&gt;    &lt;p&gt; &lt;em&gt;要着重阅读的内容&lt;/em&gt;&lt;/p&gt;    &lt;p&gt; &lt;strong&gt;十分重要的内容(语气比em要强)&lt;/strong&gt;&lt;/p&gt;    &lt;p&gt; &lt;cite&gt;《作品标题》&lt;/cite&gt;&lt;/p&gt;    &lt;p&gt; &lt;dfn&gt;特殊术语，鸡你太美&lt;/dfn&gt;&lt;/p&gt;    &lt;p&gt; 商品原价：&lt;del&gt;删除内容199&lt;/del&gt;&lt;ins&gt;插入内容1&lt;/ins&gt;&lt;/p&gt;    &lt;p&gt;下标H&lt;sub&gt;2&lt;/sub&gt;O,上标2&lt;sup&gt;4&lt;/sup&gt;&lt;/p&gt;    &lt;p&gt;&lt;code&gt;int &lt;var&gt;&lt;/var&gt;a= 1&lt;/code&gt;&lt;/p&gt;    &lt;p&gt;&lt;kbd&gt;键盘输入Ctrl+S&lt;/kbd&gt;&lt;/p&gt;    &lt;p&gt;&lt;abbr title=&quot;英雄联盟&quot;&gt;LOL&lt;/abbr&gt;缩写&lt;/p&gt;    &lt;p&gt;&lt;bdo dir=&quot;rtl&quot;&gt;颠倒&lt;/bdo&gt;&lt;/p&gt;    &lt;p&gt;&lt;small&gt;附属细则，包括版权、法律文本&lt;/small&gt;&lt;/p&gt;    &lt;p&gt;&lt;b&gt;商品名称&lt;/b&gt;&lt;/p&gt;    &lt;p&gt;&lt;q&gt;短引用，路漫漫其修远兮&lt;/q&gt;&lt;/p&gt;    &lt;!-- 文本类块元素 --&gt;    &lt;p&gt;    &lt;blockquote&gt;长引用，路漫漫其修远兮&lt;/blockquote&gt;    &lt;/p&gt;    &lt;p&gt;    &lt;address&gt;地址，深圳科技园&lt;/address&gt;    &lt;/p&gt;    &lt;!-- 图片标签 --&gt;    &lt;img src=&quot;./img/me.png&quot; alt=&quot;我的证件照&quot; width=&quot;200&quot;&gt;&lt;/img&gt;    &lt;hr&gt;    &lt;!-- 列表 --&gt;    &lt;ol&gt;        &lt;li&gt;Ordered List&lt;/li&gt;    &lt;/ol&gt;    &lt;hr&gt;    &lt;ul&gt;        &lt;li&gt;Unordered List&lt;/li&gt;    &lt;/ul&gt;    &lt;hr&gt;    &lt;dl&gt;        &lt;!-- 定义术语 Description List --&gt;        &lt;dt&gt;关于我们&lt;/dt&gt;        &lt;!-- 描述术语 --&gt;        &lt;dd&gt;            &lt;ul&gt;                &lt;li&gt;网站声明&lt;/li&gt;                &lt;li&gt;广告营销&lt;/li&gt;            &lt;/ul&gt;        &lt;/dd&gt;    &lt;/dl&gt;    &lt;hr&gt;    &lt;!-- 表格:单元格间距cellspacing为0 --&gt;    &lt;div&gt;        &lt;table border=&quot;1&quot; width=&quot;200&quot; hight=&quot;200&quot; cellspacing=&quot;0&quot;&gt;            &lt;!-- 表格标题 --&gt;            &lt;caption&gt;学生信息表&lt;/caption&gt;            &lt;!-- 表头 --&gt;            &lt;thead height=&quot;50&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt;                &lt;tr&gt;                    &lt;th width=&quot;50&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt;姓名&lt;/th&gt;                    &lt;th&gt;性别&lt;/th&gt;                    &lt;th&gt;年龄&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;!-- 表体 --&gt;            &lt;tbody height=&quot;100&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt;                &lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;                    &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;张三&lt;/td&gt;                    &lt;td&gt;男&lt;/td&gt;                    &lt;td&gt;18&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;            &lt;!-- 脚注 --&gt;            &lt;tfoot height=&quot;50&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt;                &lt;tr&gt;                    &lt;td colspan=&quot;3&quot;&gt;版权所有&lt;/td&gt;                &lt;/tr&gt;            &lt;/tfoot&gt;        &lt;/table&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;div&gt;        &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;            &lt;caption&gt;跨行跨列&lt;/caption&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;项目&lt;/th&gt;                    &lt;th colspan=&quot;5&quot;&gt;上课&lt;/th&gt;                    &lt;th colspan=&quot;2&quot;&gt;活动与休息&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;tr&gt;                    &lt;td rowspan=&quot;3&quot;&gt;星期&lt;/td&gt;                    &lt;td&gt;星期一&lt;/td&gt;                    &lt;td&gt;星期二&lt;/td&gt;                    &lt;td&gt;星期三&lt;/td&gt;                    &lt;td&gt;星期四&lt;/td&gt;                    &lt;td&gt;星期五&lt;/td&gt;                    &lt;td rowspan=&quot;3&quot;&gt;活动&lt;/td&gt;                    &lt;td rowspan=&quot;3&quot;&gt;休息&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;星期一&lt;/td&gt;                    &lt;td&gt;星期二&lt;/td&gt;                    &lt;td&gt;星期三&lt;/td&gt;                    &lt;td&gt;星期四&lt;/td&gt;                    &lt;td&gt;星期五&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;星期一&lt;/td&gt;                    &lt;td&gt;星期二&lt;/td&gt;                    &lt;td&gt;星期三&lt;/td&gt;                    &lt;td&gt;星期四&lt;/td&gt;                    &lt;td&gt;星期五&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;!-- 按原文显示 --&gt;    &lt;pre&gt;        I       LOVE        YOU            I   LOVE    YOU                LOVE     &lt;/pre&gt;    &lt;hr&gt;    &lt;!-- 表单--&gt;    &lt;form action=&quot;https://www.baidu.com/s&quot; target=&quot;_blank&quot; method=&quot;get&quot;&gt;        &lt;fieldset&gt;            &lt;legend&gt;分组1&lt;/legend&gt;            &lt;!-- &lt;label for=&quot;zhanghu&quot;&gt;账号：&lt;/label&gt;&lt;input  id=&quot;zhanghu&quot; type=&quot;text&quot; name=&quot;wd&quot; value=&quot;密码框&quot;&gt;&lt;br&gt; --&gt;            &lt;label&gt;账号：&lt;input id=&quot;zhanghu&quot; type=&quot;text&quot; name=&quot;wd&quot; value=&quot;密码框&quot;&gt;&lt;/label&gt;            密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; maxlength=&quot;6&quot;&gt;&lt;br&gt;        &lt;/fieldset&gt;        &lt;fieldset&gt;            &lt;legend&gt;分组2&lt;/legend&gt;            &lt;!-- 单选框 --&gt;            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked&gt;男            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot;&gt;女&lt;br&gt;            &lt;!-- 多选框 --&gt;            爱好：            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;sing&quot;&gt;唱            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;jump&quot;&gt;跳            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;打篮球&lt;br&gt;            籍贯：            &lt;select name=&quot;province&quot;&gt;                &lt;option value=&quot;京&quot;&gt;北京&lt;/option&gt;                &lt;option value=&quot;沪&quot;&gt;上海&lt;/option&gt;                &lt;option value=&quot;粤&quot; selected&gt;广东&lt;/option&gt;            &lt;/select&gt;&lt;br&gt;            其他：            &lt;textarea name=&quot;other&quot; id=&quot;&quot; cols=&quot;23&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt;            &lt;!-- 隐藏域&amp;from=baidu --&gt;            &lt;input type=&quot;hidden&quot; name=&quot;from&quot; value=&quot;baidu&quot;&gt;&lt;br&gt;        &lt;/fieldset&gt;        &lt;!-- 按钮 --&gt;        &lt;input type=&quot;submit&quot; value=&quot;确认&quot;&gt;        &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;        &lt;input disabled type=&quot;button&quot; value=&quot;检查&quot;&gt;    &lt;/form&gt;    &lt;hr&gt;    &lt;!-- 框架标签 --&gt;    &lt;iframe name=&quot;container&quot; src=&quot;https://www.baidu.com&quot; frameborder=&quot;0&quot; width=&quot;800px&quot; height=&quot;200px&quot;&gt;&lt;/iframe&gt;    &lt;fieldset&gt;        &lt;legend&gt;框架标签配合超链接的target属性&lt;/legend&gt;        &lt;a href=&quot;https://www.taobao.com&quot; target=&quot;container&quot;&gt;点我看淘宝&lt;/a&gt;&lt;br&gt;    &lt;/fieldset&gt;    &lt;fieldset&gt;        &lt;legend&gt;框架标签配合表单target属性&lt;/legend&gt;        &lt;form action=&quot;https://so.toutiao.com/search&quot; target=&quot;container&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;keyword&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;搜索头条&quot;&gt;        &lt;/form&gt;    &lt;/fieldset&gt;&lt;/body&gt;&lt;/html&gt;\r\nCascading Style Sheets\r\n\r\n层叠样式表\r\n\r\n\r\n\r\nimage-20250225184507262\r\n\r\n交集选择器\r\n\r\n\r\nimage-20250225195144902\r\n\r\n并集选择器\r\n\r\n\r\nimage-20250225195034722\r\n\r\n后代选择器\r\n\r\n\r\nimage-20250225194947103\r\n\r\n子代选择器\r\n\r\n\r\nimage-20250225194756424\r\n\r\n兄弟选择器\r\n\r\n\r\nimage-20250225194842685\r\n\r\n属性选择器\r\n\r\n\r\nimage-20250225194426521\r\n\r\n伪类选择器\r\n\r\n\r\nimage-20250226131930863\r\n\r\n动态伪类选择器\r\n\r\n\r\nimage-20250226135100816\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;/meta&gt;        &lt;title&gt;动态伪类选择器，遵循LVHA的顺序&lt;/title&gt;        &lt;style&gt;            /* 选中没有访问过的链接 */             a:link&#123;                color: black;             &#125;            /* 选中访问过的链接 */             a:visited&#123;                color: red;            &#125;            /* 选中正在被鼠标悬停的链接  */            a:hover&#123;                color: blue;            &#125;            /* 选中正在被选中激活的链接 */             a:active&#123;                color: green;            &#125;            /* 选中正在获得焦点的表单元素 */            input:focus&#123;                background-color:red;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;            &lt;a href=&quot;https://www.baidu.com/&quot;&gt;去百度&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;https://www.jd.com/&quot;&gt;去京东&lt;/a&gt;&lt;br&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt;    &lt;/body&gt;    &lt;/html&gt;\r\n结构伪类\r\n\r\n\r\nimage-20250226152946246\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;/meta&gt;    &lt;title&gt;结构伪类选择器&lt;/title&gt;    &lt;style&gt;        /* 测试2和测试3变红：div的后代p并且是第一个子元素（不管它的父元素是谁，这里测试3的p是父元素marquee的第一个子元素） */        div p:first-child &#123;            color: red;        &#125;        /* 测试6变绿：div的直接子元素p并且是最后一个子元素(不管它的父元素是谁) */        div&gt;p:last-child &#123;            color: green ;        &#125;        /* 测试4变蓝：div的直接子元素p并且是父元素的第3个子元素(不管它的父元素是谁) */        /*              偶数：nth-child(2n)或者nth-child(even))            奇数：nth-child(2n+1)或者nth-child(odd)            前5个：nth-child(-n+5)        */        div&gt;p:nth-child(3) &#123;            color: blue;        &#125;        /* 测试1变紫色：第一个同类型的元素             p:last-of-type：最后一个同类型的元素         */        p:first-of-type&#123;            color: orchid;        &#125;        /* 测试5:同类型的第3个元素         */        /* p:nth-of-type(3)&#123;            color:aqua        &#125; */        /* 测试5:同类型倒数第2个元素  */        /* p:nth-last-of-type(2)&#123;            color:aqua        &#125; */        /* 测试5:倒数第2个子元素(不管它的父元素是谁)  */        /* p:nth-last-child(2)&#123;            color:aqua        &#125; */        /* 测试7: 独生子 */        span:only-child&#123;            color:darkkhaki;        &#125;        /* 测试7、测试8: 没有同类型的元素 */        /* span:only-of-type&#123;            color:darkkhaki;        &#125; */        /* 根元素html */        /* :root&#123;            background-color: antiquewhite;        &#125; */        /* 没有内容的div */        div:empty&#123;            width: 100px;            height: 100px;            background-color: red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;        &lt;p&gt;测试1&lt;/p&gt;    &lt;div&gt;        &lt;p&gt;测试2&lt;/p&gt;        &lt;marquee&gt;&lt;p&gt;测试3&lt;/p&gt;&lt;/marquee&gt;        &lt;p&gt;测试4&lt;/p&gt;        &lt;p&gt;测试5&lt;/p&gt;        &lt;p&gt;测试6&lt;/p&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;span&gt;测试7&lt;/span&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;span&gt;测试8&lt;/span&gt;&lt;/span&gt;        &lt;h1&gt;测试9&lt;/h1&gt;    &lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n否定伪类\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;否定伪类&lt;/title&gt;        &lt;style&gt;            /* 排除指定类的元素 */            /* div&gt;p:not(.loser)&#123;                color:green;            &#125; */            /* 排除指定属性的元素 */            /* div&gt;p:not([title^=&quot;失败&quot;])&#123;                color:green;            &#125; */                         /* 排除第一个子元素（不管父元素是谁） */            div&gt;p:not(:first-child)&#123;                color: red;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;            &lt;p&gt;张三&lt;/p&gt;            &lt;p&gt;李四&lt;/p&gt;            &lt;p&gt;王五&lt;/p&gt;            &lt;p&gt;赵六&lt;/p&gt;            &lt;p class=&quot;loser&quot; title=&quot;失败者&quot;&gt;孙七&lt;/p&gt;            &lt;p class=&quot;loser&quot; title=&quot;失败者&quot;&gt;老八&lt;/p&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\nUI伪类\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;UI伪类&lt;/title&gt;        &lt;style&gt;            /* 选中勾选的 input */            input:checked&#123;                width: 100px;                height: 100px;            &#125;            /* 选中禁用的 input */            input:disabled&#123;                background-color: red;            &#125;             /* 选中可用的 input */            input:enabled&#123;                background-color: green;            &#125;             /* 选中焦点的 input */            input:focus&#123;                background-color: yellow;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;tbody&gt;        &lt;input type=&quot;checkbox&quot;&gt;&lt;/input&gt;&lt;br&gt;        &lt;input type=&quot;radio&quot; name=&quot;r&quot;&gt;&lt;/input&gt;        &lt;input type=&quot;radio&quot; name=&quot;r&quot;&gt;&lt;/input&gt;&lt;br&gt;        &lt;input type=&quot;text&quot; &gt;&lt;/input&gt;&lt;br&gt;        &lt;input type=&quot;text&quot; disabled&gt;&lt;/input&gt;    &lt;/tbody&gt;&lt;/html&gt;\r\n目标伪类\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;目标伪类&lt;/title&gt;        &lt;style&gt;            div&#123;                width: 200px;                height: 200px;                background-color: gray;            &#125;            /* 选中锚点指向的元素 */            div:target&#123;                background-color: red;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;#one&quot;&gt;看第1个&lt;/a&gt;        &lt;a href=&quot;#two&quot;&gt;看第2个&lt;/a&gt;        &lt;a href=&quot;#three&quot;&gt;看第3个&lt;/a&gt;        &lt;a href=&quot;#four&quot;&gt;看第4个&lt;/a&gt;        &lt;div id=&quot;one&quot;&gt;第一个&lt;/div&gt;        &lt;div id=&quot;two&quot;&gt;第二个&lt;/div&gt;        &lt;div id=&quot;three&quot;&gt;第三个&lt;/div&gt;        &lt;div id=&quot;four&quot;&gt;第四个&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n语言伪类\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;        &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;语言伪类&lt;/title&gt;        &lt;style&gt;            div:lang(en)&#123;                color: red;            &#125;            :lang(zh-CN)&#123;                color: green;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;英语&lt;/div&gt;        &lt;div lang=&quot;en&quot;&gt;English&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n伪元素选择器\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;伪元素选择器: 元素中的一些特殊位置&lt;/title&gt;        &lt;style&gt;            /* 第一个字母 */            div::first-letter &#123;                color: red;            &#125;            /* 第一行 */             div::first-line &#123;                color: green;            &#125;            /* 鼠标选中的文字 */            div::selection &#123;                background-color: yellow;            &#125;            /* 选中提示文字 */            input::placeholder &#123;                color: orange;            &#125;            /* 在指定元素最开始的位置创建一个子元素 */            p::before&#123;                content: &quot;￥&quot;;                color: red;            &#125;            /* 在指定元素最后的位置创建一个子元素 */            p::after&#123;                content: &quot;.00&quot;;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Aperiam delectus maiores perspiciatis iste sed repellat voluptatum expedita enim? Mollitia possimus officia quisquam eius. Sapiente aspernatur vitae sunt officiis doloremque voluptate consequuntur nesciunt iste! Culpa laborum eum, suscipit ipsum voluptate, nihil, modi maiores fugit quisquam aspernatur alias recusandae aliquam unde delectus quibusdam eveniet impedit ex dolorem. Doloremque exercitationem explicabo accusantium ut consequatur ipsum nesciunt blanditiis soluta consequuntur alias libero eveniet ratione neque labore provident excepturi non, eligendi illo. Quod, deleniti doloremque! Excepturi, veniam voluptates dolorum, corporis incidunt explicabo cumque mollitia repudiandae eligendi nostrum sint in culpa! Explicabo doloribus eveniet ullam rem.&lt;/div&gt;        &lt;br&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt;        &lt;p&gt;998&lt;/p&gt;        &lt;p&gt;99&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;\r\ncss选择器优先级\r\n\r\n\r\nimage-20250226171747600\r\n\r\n\r\n\r\nimage-20250226172042203\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;选择器优先级&lt;/title&gt;        &lt;style&gt;            #ids&#123;                color: red;            &#125;            .cls&#123;                color: blue;            &#125;            *&#123;                color: purple;                font-size: 50px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h2 id=&quot;ids&quot; class=&quot;cls&quot;&gt;行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器&gt;通配选择器&lt;/h2&gt;    &lt;/body&gt;&lt;/html&gt;\r\ncss三大特性\r\n层叠性：同一个样式名被设置了不同值，会根据选择器优先级进行样式覆盖。\r\n\r\n\r\nimage-20250226173406405\r\n\r\n字体族\r\n\r\n\r\nimage-20250226183625982\r\n\r\n文本属性\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;文本属性&lt;/title&gt;        &lt;style&gt;            .love1&#123;                /*                 color: red;                font-style: italic;                font-size:  100px ;                font-family: &quot;华文彩云&quot;,&quot;华文行楷&quot;,sans-serif; */                font: italic 100px &quot;华文彩云&quot;,&quot;华文行楷&quot;,sans-serif;            &#125;            .love2&#123;                /* 字母间距 */                letter-spacing: 10px;            &#125;            .love3&#123;                /* 单词间距：通过空格识别单词 */                word-spacing: 20px;            &#125;            .hate1&#123;                /* 上划红色虚线、下划红色波浪线、删除线 */                /* text-decoration:overline dotted red;                text-decoration:underline wavy red; */                text-decoration:line-through;                             &#125;            .hate2,ins,del&#123;                /* 无装饰线 */                text-decoration:none;            &#125;            .indent&#123;                background-color: orange;                font-size: 20px;                /* 首行缩进 */                text-indent: 40px;                /* 对齐 */                text-align: left;                /* 对于单行：让height等于line-height，可以实现文字垂直居中                    对于多行：可以控制行间距                    垂直方向上的底部对齐：line-height=(height*2)-fontsize                */                /* 行高可以被继承：行高为font-size的1.5倍 */                line-height: 1.5;            &#125;            span&#123;                font-size: 200px;                /*                     这里继承了.indent的font-size                    span的font-size是200px，span的行高是200px的1.5倍，即300px                    相当于加上了line-height: 1.5;                */            &#125;            .logo&#123;                font-size: 100px;                background-color: red;            &#125;            img&#123;                height: 30px;                /* 用于指定同一行元素之间，或表格单元格内文字的垂直对齐方式。注意不能控制块元素 */                vertical-align: top;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;love1&quot;&gt;我爱你1&lt;/div&gt;        &lt;div class=&quot;love2&quot;&gt;我爱你2&lt;/div&gt;        &lt;div class=&quot;love3&quot;&gt;i love you3&lt;/div&gt;        &lt;div class=&quot;hate1&quot;&gt;我恨你1&lt;/div&gt;        &lt;a class=&quot;hate2&quot; href=&quot;http://www.baidu.com&quot;&gt;我恨你2&lt;/a&gt;        &lt;ins&gt;我恨你3&lt;/ins&gt;        &lt;del&gt;我恨你4&lt;/del&gt;        &lt;div class=&quot;indent&quot;&gt;Lorem ipsum&lt;span&gt;我爱你&lt;/span&gt; dolor sit amet consectetur adipisicing elit. Voluptas rem dolorum, officiis eligendi amet possimus incidunt ut delectus et at vel facere tempore assumenda atque quia eos deleniti architecto cumque.&lt;/div&gt;        &lt;div class=&quot;logo&quot;&gt;            我的自拍x&lt;img src=&quot;./img/me.png&quot;&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\nvertical-align\r\n\r\n\r\nimage-20250301123450088\r\n\r\n列表属性\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;列表属性&lt;/title&gt;        &lt;style&gt;            li&#123;                background-color: orange;            &#125;            ul&#123;                /* 列表符号 */                /* list-style-type: decimal; */                /* 列表符号位置 */                /* list-style-position: inside;                list-style-image: url(&quot;./img/me.png&quot;); */                /* 复合属性 */                /* list-style: decimal inside url(&quot;./img/me.png&quot;); */            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul&gt;            &lt;li&gt;张三&lt;/li&gt;            &lt;li&gt;李四&lt;/li&gt;            &lt;li&gt;王二&lt;/li&gt;        &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;\r\n边框表格属性\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;边框属性&lt;/title&gt;        &lt;style&gt;           table&#123;                             /* border-color: green;                border-width: 2px;                border-style: solid; */                border: green 2px solid;                width: 500px;                /* 表格列宽 固定 */                table-layout: fixed;                /* 单元格间距 （没有合并单元格边框时生效）*/                border-spacing: 10px;                /* 合并相邻的单元格边框 */                /* border-collapse: collapse; */                /* 隐藏没有内容的单元格 */                empty-cells: hide;                /* 设置表格标题位置 */                caption-side: bottom;           &#125;           th,td&#123;                border: 2px solid orange;           &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table&gt;            &lt;caption&gt;人员信息&lt;/caption&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;序号&lt;/th&gt;                    &lt;th&gt;姓名&lt;/th&gt;                    &lt;th&gt;年龄&lt;/th&gt;                    &lt;th&gt;性别&lt;/th&gt;                    &lt;th&gt;政治面貌&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;tr&gt;                    &lt;td&gt;1&lt;/td&gt;                    &lt;td&gt;张三&lt;/td&gt;                    &lt;td&gt;18&lt;/td&gt;                    &lt;td&gt;男&lt;/td&gt;                    &lt;td&gt;党员&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;2&lt;/td&gt;                    &lt;td&gt;李四&lt;/td&gt;                    &lt;td&gt;19&lt;/td&gt;                    &lt;td&gt;女&lt;/td&gt;                    &lt;td&gt;团员&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;3&lt;/td&gt;                    &lt;td&gt;王五&lt;/td&gt;                    &lt;td&gt;20&lt;/td&gt;                    &lt;td&gt;&lt;/td&gt;                    &lt;td&gt;群众&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;4&lt;/td&gt;                    &lt;td&gt;赵六&lt;/td&gt;                    &lt;td&gt;21&lt;/td&gt;                    &lt;td&gt;女&lt;/td&gt;                    &lt;td&gt;党员&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;\r\n背景属性\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;背景属性&lt;/title&gt;        &lt;style&gt;            div&#123;                background-color: skyblue;                width: 200px;                height: 200px;                border: 5px;                font-size: 20px;                /* 背景图片 */                background-image: url(&quot;./favicon.ico&quot;);                /* 背景图片重复方式 */                background-repeat: no-repeat;                /* 背景图片位置 */                background-position: right bottom;                /* 复合写法 */                /* background: skyblue url(&quot;./favicon.ico&quot;) no-repeat 100px; */            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;我爱你&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n鼠标属性\r\n\r\n\r\nimage-20250228151234024\r\n\r\ncss长度单位\r\n\r\n\r\nimage-20250228153023735\r\n\r\n盒子模型\r\n\r\n\r\nimage-20250228160812082\r\n\r\n\r\n\r\nimage-20250228160621338\r\n\r\npadding\r\n\r\n\r\nimage-20250228163605082\r\n\r\nmargin\r\n\r\n\r\nimage-20250228170548524\r\n\r\nmargin塌陷与合并\r\n\r\n\r\nimage-20250228172621694\r\n\r\n\r\n\r\nimage-20250228174243964\r\n\r\n内容溢出\r\n\r\n\r\nimage-20250228175337059\r\n\r\n默认样式\r\n\r\n\r\nimage-20250228181352491\r\n\r\n让子元素（块元素）在父元素中垂直居中布局\r\n\r\n\r\nimage-20250301102517344\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;让子元素（块元素）在父元素中垂直居中布局&lt;/title&gt;        &lt;style&gt;            .outer&#123;                width: 400px;                height: 400px;                background-color: gray;                /* 解决margin塌陷 */                overflow: hidden;            &#125;            .inner&#123;                width: 200px;                height: 100px;                background-color: orange;                /*上下0 左右自动 */                margin:0 auto;                /*                    上边距覆盖为（400-100）/2                    使子元素在父元素中垂直居中                    即：若子元素为块元素，给子元素加上margin-top，值为(父元素content-子元素盒子总高)/2                */                margin-top: 150px;                 /* 水平居中 */                text-align: center;                /* line-height=height 时垂直居中*/                line-height: 100px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;outer&quot;&gt;            &lt;div class=&quot;inner&quot;&gt;我爱你&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;/head&gt;    &lt;/html&gt;\r\n让子元素（行内元素、行内块元素）在父元素中垂直居中布局\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;让子元素（行内元素、行内块元素）在父元素中垂直居中布局:            让父元素height=line-height,每个子元素都加上vertical-align: middle            若想绝对垂直居中，可让父元素font-size设置为0            或者直接让其变为行内块元素,使其可以受 text-align 属性的影响。        &lt;/title&gt;        &lt;style&gt;            .outer&#123;                width: 400px;                height: 400px;                background-color: gray;                text-align: center;                line-height: 400px;                /* 消除基线&quot;x&quot;影响,以达到绝对的垂直居中 */                font-size: 0px;            &#125;            span&#123;                background-color: orange;                vertical-align: middle;                font-size: 20px;            &#125;            img&#123;                width: 100px;                vertical-align: middle;                /*使图片受 text-align 属性的影响。*/                /*display: inline-block;*/            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;outer&quot;&gt;            &lt;span&gt;this&#x27;s meX&lt;/span&gt;            &lt;img src=&quot;./img/me.png&quot;&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;/head&gt;    &lt;/html&gt;\r\n行内块的幽灵空白问题\r\n\r\n\r\nimage-20250301121226324\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;行内块的幽灵空白问题：行内块元素与文本的基线对其，而文本的基线与文本最底端之间有一定距离&lt;/title&gt;        &lt;Style&gt;            div&#123;                width: 600px;                background-color: skyblue;                /* 方法三：给父元素设置font-size: 0,若该行内块内部还有文本则单独设置font-size */                /* font-size: 0px; */            &#125;            img&#123;                height: 200px;                /* 方法一：与文字的顶端垂直对其 */                vertical-align: top;                /* 方法二：若只有一张图片，则设置为块元素铺满 */                /* display: block; */                            &#125;            /* 方法三：给父元素设置font-size: 0,若该行内块内部还有文本则单独设置font-size */            /* span&#123;                font-size: 20px;            &#125; */        &lt;/Style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;            &lt;img src=&quot;./img/me.png&quot; &gt;X&lt;/img&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n浮动\r\n\r\n\r\nimage-20250301130652127\r\n\r\n\r\n\r\nimage-20250301145456187\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;浮动案例&lt;/title&gt;        &lt;style&gt;            *&#123;                margin: 0;                padding: 0;                /* 文本水平居中 */                text-align: center;            &#125;            /* 左浮动 */            .leftfix&#123;                float: left;            &#125;            /* 右浮动 */            .rightfix&#123;                float: right;            &#125;            /* 清除浮动 */            .clearfix::after&#123;                content: &#x27;&#x27;;                display: block;                clear: both;            &#125;            .container&#123;                width: 960px;                /* height: 200px;                background-color: gray; */                /* 上下外边距0 左右居中 */                margin: 0 auto;            &#125;            .logo,.banner1,.banner2&#123;                height: 80px;                background-color: #ccc;                /* 垂直居中：行高=高 */                line-height: 80px;            &#125;            .banner1&#123;                /* 左右外边距 */                margin: 0 10px;            &#125;            .logo&#123;                width: 200px;            &#125;            .banner1&#123;                width: 540px;            &#125;            .banner2&#123;                width: 200px;            &#125;            .menu&#123;                height: 30px;                background-color: #ccc;                margin-top: 10px;                line-height: 30px;            &#125;            .item1,.item2&#123;                border: 1px solid black;                /* 370宽度要减去boder */                width: 368px;                /* 200高度也要减去boder */                height: 198px;                line-height: 198px;                margin-right: 10px;            &#125;            .content &#123;                /* 内容区外边距离菜单 */                margin-top: 10px;            &#125;            .item3,.item4,.item5,.item6&#123;                border: 1px solid black;                width: 178px;                height: 198px;                /* 每个栏目都设置右边距 */                margin-right: 10px;                line-height:198px;            &#125;            .bottom&#123;                margin-top: 10px;            &#125;            .item7,.item8,.item9&#123;                border: 1px solid black;                width: 198px;                height: 128px;            &#125;            .item8&#123;                /* 上下10，左右0 */                margin:10px 0;            &#125;            .footer&#123;                margin-top: 10px;                height: 60px;                background-color: #ccc;                line-height: 60px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;!-- 头部 --&gt;            &lt;div class=&quot;page-header clearfix&quot;&gt;                &lt;div class=&quot;logo leftfix&quot;&gt;log&lt;/div&gt;                &lt;div class=&quot;banner1 leftfix&quot;&gt;banner1&lt;/div&gt;                &lt;div class=&quot;banner2 leftfix&quot;&gt;banner2&lt;/div&gt;            &lt;/div&gt;            &lt;!-- 菜单 --&gt;             &lt;div class=&quot;menu&quot;&gt;菜单&lt;/div&gt;             &lt;!-- 内容区 --&gt;              &lt;div class=&quot;content clearfix&quot; &gt;                &lt;!-- 左侧 --&gt;                &lt;div class=&quot;left leftfix&quot;&gt;                    &lt;div class=&quot;top clearfix&quot;&gt;                        &lt;div class=&quot;item1 leftfix&quot;&gt;栏目一&lt;/div&gt;                        &lt;div class=&quot;item2 leftfix&quot;&gt;栏目二&lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;bottom clearfix&quot;&gt;                        &lt;div class=&quot;item3 leftfix&quot;&gt;栏目三&lt;/div&gt;                        &lt;div class=&quot;item4 leftfix&quot;&gt;栏目四&lt;/div&gt;                        &lt;div class=&quot;item5 leftfix&quot;&gt;栏目五&lt;/div&gt;                        &lt;div class=&quot;item6 leftfix&quot;&gt;栏目六&lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;!-- 右侧 --&gt;                &lt;div class=&quot;right leftfix&quot;&gt;                    &lt;div class=&quot;item7&quot;&gt;栏目七&lt;/div&gt;                    &lt;div class=&quot;item8&quot;&gt;栏目八&lt;/div&gt;                    &lt;div class=&quot;item9&quot;&gt;栏目九&lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;              &lt;!-- 页脚 --&gt;               &lt;div class=&quot;footer&quot;&gt;页脚&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n清除浮动\r\n\r\n\r\nimage-20250301142601611\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;style&gt;            .outer&#123;                width:500px;                background-color: gray;                border: 1px solid black;            &#125;            .box&#123;                width: 200px;                height: 200px;                background-color: skyblue;                margin: 10px;            &#125;           .box1&#123;                 /* float: right; */                /* box1浮上来，box2盒子顶上去，但是2的文字要环绕box1，所以2的文字与box3的文本重叠 */                float: left;            &#125;         &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;outer&quot;&gt;            &lt;div class=&quot;box box1&quot;&gt;1&lt;/div&gt;            &lt;div class=&quot;box box2&quot;&gt;2&lt;/div&gt;            &lt;div class=&quot;box box3&quot;&gt;3&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n定位\r\n\r\n\r\nimage-20250302131303301\r\n\r\n\r\n\r\nimage-20250302133847612\r\n\r\n\r\n\r\nimage-20250302134736627\r\n\r\n\r\n\r\nimage-20250302140124842\r\n\r\n\r\n\r\nimage-20250302141753818\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;定位层级&lt;/title&gt;        &lt;style&gt;            .outer&#123;                width: 500px;                background-color: skyblue;                border: 1px solid black;                padding: 20px;                /* 给一个定位属性：作为box3的包含块：作为box3的第一个拥有position属性的祖先元素*/                position: relative;                /* 图层z轴高于box5 */                z-index: 2;            &#125;            .box&#123;                width: 200px;                height: 200px;                font-size: 20px;            &#125;            .box1&#123;                background-color: #666;            &#125;                        .box2&#123;                background-color: orange;                /* 相对定位：不会脱离文档流 */                position: relative;                top: -150px;                left: 50px;            &#125;            .box3&#123;                background-color: green;                /* 绝对定位：脱离文档流                    包含块：第一个拥有position属性的祖先元素作为参考，若都没有则为html元素                */                position: absolute;                top:130px;                left:130px;            &#125;            .box4&#123;                background-color: red;                /* 固定定位 : 脱离文档流                    参考视口                */                position: fixed;                top: 200px;                left: 200px;            &#125;            .box5&#123;                background-color: purple;                position: fixed;                top: 300px;                left: 300px;                z-index: 1;            &#125;                    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;outer&quot;&gt;            &lt;div class=&quot;box box1&quot;&gt;1&lt;/div&gt;            &lt;div class=&quot;box box2&quot;&gt;2&lt;/div&gt;            &lt;div class=&quot;box box3&quot;&gt;3&lt;/div&gt;            &lt;div class=&quot;box box4&quot;&gt;4&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box box5&quot;&gt;5&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n定位的应用\r\n\r\n\r\nimage-20250302153814790\r\n\r\n\r\n\r\nimage-20250302153837342\r\n\r\n撑满包含块\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/meta&gt;     \t&lt;title&gt;撑满包含块&lt;/title&gt;        &lt;style&gt;            .outer&#123;                height: 400px;                background-color: #888;                /* 给一个定位属性：作为inner的包含块：作为inner的第一个拥有position属性的祖先元素*/                position: relative;            &#125;            .inner&#123;                background-color: orange;                font-size: 20px;                padding: 20px;                border: 10px solid black;                /* 绝对定位：                    脱离文档流                    包含块：第一个拥有position属性的祖先元素作为参考，若都没有则为html元素                */                position:absolute;                /* 撑满整个包含块 */                top: 0;                bottom: 0;                left: 0;                right: 0;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;outer&quot;&gt;            &lt;div class=&quot;inner&quot;&gt;我爱你&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\n居中-在包含块里\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            width: 1000px;            height: 900px;            /* 给一个定位属性：作为inner的包含块：作为inner的第一个拥有position属性的祖先元素*/            position: relative;        &#125;        .inner &#123;            background-color: skyblue;            width: 200px;            height: 200px;            box-sizing: border-box;            border: 1px solid black;            /* 在包含块里居中 */            /* 绝对定位：                 脱离文档流                 包含块：第一个拥有position属性的祖先元素作为参考，若都没有则为html元素             */            position:absolute;            top: 0;            bottom: 0;            left: 0;            right: 0;            margin: auto;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n页面Demo\r\nreset.css\r\n/* 基础设置 */body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td&#123;  margin: 0;  padding: 0;&#125;ul,ol &#123;  list-style: none;&#125;img &#123;  /* 底部留白 */  display: block;border:0;&#125;b,strong &#123;  font-weight: 400;&#125;h1,h2,h3,h4,h5,h6 &#123;  /* 父元素字号的百分比 */  font-size: 100%;  font-weight: normal;&#125;i,em &#123;  /* 不倾斜 */  font-style: normal;&#125;u,ins,s,del &#123;  /* 去掉中划线和下划线 */  text-decoration: none;&#125;table &#123;  border: 1px solid #999;  /* 相当于是cellspacing */  border-spacing: 0;  /* 1px边框 */  border-collapse: collapse;&#125;td,th &#123;  border: 1px solid #999;&#125;input,button &#123;  /* 去掉轮廓线 */  outline: none;  border:none;&#125;/* 风格设置 */body &#123;  font: 12px/1.5 &quot;Microsoft YaHei&quot;, Tahoma, Helvetica, Arial, &quot;\\5b8b\\4f53&quot;, sans-serif;  color: #333;&#125;a &#123;  text-decoration: none;  color: #666;&#125;a:hover &#123;  color:#DD302D;  text-decoration: none;&#125;.leftfix &#123;  float: left;&#125;.rightfix &#123;  float: right;&#125;/* 元素选择器: 在指定元素最后的位置创建一个空子元素*/.clearfix::after&#123;  content: &quot;&quot;;  display: block;  clear: both;&#125;\r\nindex.html\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;!-- 兼容IE --&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;!-- 配置移动端 --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;!-- 要求搜索爬虫不索引此页面 --&gt;    &lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;Tao&#x27;s Blog&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;Tao&quot;&gt;    &lt;title&gt;千裳集&lt;/title&gt;    &lt;!--  页签图标--&gt;    &lt;link rel=&quot;shortcut icon&quot; href=&quot;./img/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;    &lt;!-- 重置样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt;&lt;/link&gt;    &lt;!-- 页面样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;&lt;/link&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 顶部导航条 --&gt;&lt;div class=&quot;topbar&quot;&gt;    &lt;!-- 版心 --&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;!-- 左侧欢迎区 --&gt;        &lt;div class=&quot;welcome leftfix&quot;&gt;            &lt;span class=&quot;hello&quot;&gt;千裳集欢迎您&lt;/span&gt;            &lt;span&gt;请&lt;/span&gt;            &lt;a href=&quot;#&quot; class=&quot;login&quot;&gt;登录&lt;/a&gt;            &lt;a href=&quot;#&quot; class=&quot;register&quot;&gt;免费注册&lt;/a&gt;        &lt;/div&gt;        &lt;!-- 右侧导航区 --&gt;        &lt;div class=&quot;topbar-nav rightfix&quot;&gt;            &lt;ul class=&quot;list clearfix&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我的订单&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我的购物车&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我的千裳集&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;千裳集会员&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;企业采购&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关注千裳集&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;合作招商&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商家后台&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--头部--&gt;&lt;div class=&quot;header&quot;&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;!--        左侧logo区--&gt;        &lt;div class=&quot;logo leftfix&quot;&gt;            &lt;img src=&quot;./img/logo.png&quot; alt=&quot;logo&quot;&gt;        &lt;/div&gt;        &lt;!--        右侧搜索区--&gt;        &lt;div class=&quot;search rightfix&quot;&gt;            &lt;form action=&quot;#&quot;&gt;                &lt;input type=&quot;text&quot;&gt;                &lt;button&gt;&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--主导航--&gt;&lt;div class=&quot;main-nav&quot;&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;div class=&quot;all-types leftfix&quot;&gt;全部商品分类&lt;/div&gt;        &lt;ul class=&quot;main-nav-list leftfix&quot;&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;千裳集周边&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;优惠卷&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PLUS会员&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- 主要内容区--&gt;&lt;div class=&quot;main-content&quot;&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;ul class=&quot;slide-nav leftfix&quot;&gt;            &lt;li&gt;                &lt;!--                一级菜单--&gt;                &lt;a href=&quot;#&quot;&gt;古风仙侠类&lt;/a&gt;                &lt;!--                二级菜单--&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;!--                    自定义列表--&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;国风汉服类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;国风汉服类&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;动漫cos类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;动漫cos&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Lolita类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;Lolita&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;现代礼服类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;现代礼服&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;div class=&quot;banner leftfix&quot;&gt;            &lt;img src=&quot;./img/banner主图.png&quot; alt=&quot;banner主图&quot;&gt;        &lt;/div&gt;        &lt;div class=&quot;slide-other  leftfix&quot;&gt;            &lt;div class=&quot;message&quot;&gt;                &lt;div class=&quot;title clearfix&quot;&gt;                    &lt;span class=&quot;leftfix&quot;&gt;快报&lt;/span&gt;                    &lt;a href=&quot;#&quot; class=&quot;rightfix&quot;&gt;更多&amp;nbsp;&amp;gt;&lt;/a&gt;                &lt;/div&gt;                &lt;ul class=&quot;msg-list&quot;&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发财&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发疯&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;            &lt;div class=&quot;other-nav&quot;&gt;                &lt;ul class=&quot;other-nav-list clearfix&quot;&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;话费&lt;/span&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;火车票&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;加油卡&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;礼品卡&lt;/span&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;ul class=&quot;other-nav-list clearfix&quot;&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;话费&lt;/span&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;火车票&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;加油卡&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;礼品卡&lt;/span&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;ul class=&quot;other-nav-list clearfix&quot;&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;话费&lt;/span&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;火车票&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;加油卡&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;礼品卡&lt;/span&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- 秒杀区--&gt;&lt;div class=&quot;kill&quot;&gt;    &lt;div class=&quot;container &quot;&gt;        &lt;img src=&quot;img/banner1.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;img/banner2.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;./img/banner3.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;./img/banner4.jpg&quot; alt=&quot;&quot;&gt;        &lt;span&gt;X&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--楼层--&gt;&lt;div class=&quot;floor&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;!--        上部分--&gt;        &lt;div class=&quot;floor-nav clearfix&quot;&gt;            &lt;span class=&quot;floor-name leftfix clearfix&quot;&gt;家用电器&lt;/span&gt;            &lt;ul class=&quot;floor-nav-list rightfix&quot;&gt;                &lt;li&gt;                    &lt;a href=&quot;#&quot;&gt;热门&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;#&quot;&gt;生活电器&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;#&quot;&gt;厨房电器&lt;/a&gt;                &lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;!--        下部分--&gt;        &lt;div class=&quot;floor-info clearfix&quot;&gt;            &lt;div class=&quot;item item1&quot;&gt;                &lt;ul class=&quot;item1-list clearfix&quot; &gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;节能补贴&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4K电视&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;节能补贴&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4K电视&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;节能补贴&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4K电视&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;            &lt;div class=&quot;item item2&quot;&gt;                &lt;img src=&quot;./img/loli.jpg&quot; alt=&quot;&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;            &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;            &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--页脚--&gt;&lt;div class=&quot;footer&quot;&gt;    &lt;div class=&quot;container&quot;&gt;&lt;!--        顶部连接--&gt;        &lt;div class=&quot;top-links clearfix&quot;&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;&lt;!--        分割线--&gt;        &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;!--        底部连接--&gt;        &lt;div class=&quot;bottom-links&quot;&gt;            &lt;ul class=&quot;bottom-links-list clearfix&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;合作招商&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;友情链接&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;隐式政策&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;div class=&quot;copyright&quot;&gt;&amp;copy;2025 Tao 版权所有&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\nindexdemo1.html\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;!-- 兼容IE --&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;!-- 配置移动端 --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;!-- 要求搜索爬虫不索引此页面 --&gt;    &lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;Tao&#x27;s Blog&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;Tao&quot;&gt;    &lt;title&gt;千裳集&lt;/title&gt;    &lt;!--  页签图标--&gt;    &lt;link rel=&quot;shortcut icon&quot; href=&quot;./img/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;    &lt;!-- 重置样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt;&lt;/link&gt;    &lt;!-- 页面样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;&lt;/link&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 顶部导航条 --&gt;&lt;div class=&quot;topbar&quot;&gt;    &lt;!-- 版心 --&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;!-- 左侧欢迎区 --&gt;        &lt;div class=&quot;welcome leftfix&quot;&gt;            &lt;span class=&quot;hello&quot;&gt;千裳集欢迎您&lt;/span&gt;            &lt;span&gt;请&lt;/span&gt;            &lt;a href=&quot;#&quot; class=&quot;login&quot;&gt;登录&lt;/a&gt;            &lt;a href=&quot;#&quot; class=&quot;register&quot;&gt;免费注册&lt;/a&gt;        &lt;/div&gt;        &lt;!-- 右侧导航区 --&gt;        &lt;div class=&quot;topbar-nav rightfix&quot;&gt;            &lt;ul class=&quot;list clearfix&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我的订单&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我的购物车&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我的千裳集&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;千裳集会员&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;企业采购&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关注千裳集&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;合作招商&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商家后台&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--头部--&gt;&lt;div class=&quot;header&quot;&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;!--        左侧logo区--&gt;        &lt;div class=&quot;logo leftfix&quot;&gt;            &lt;div class=&quot;mask&quot;&gt;                大牛            &lt;/div&gt;            &lt;img src=&quot;./img/logo.png&quot; alt=&quot;logo&quot;&gt;        &lt;/div&gt;        &lt;!--        右侧搜索区--&gt;        &lt;div class=&quot;search rightfix&quot;&gt;            &lt;form action=&quot;#&quot;&gt;                &lt;input type=&quot;text&quot;&gt;                &lt;button&gt;&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--主导航--&gt;&lt;div class=&quot;main-nav&quot;&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;div class=&quot;all-types leftfix&quot;&gt;全部商品分类&lt;/div&gt;        &lt;ul class=&quot;main-nav-list leftfix&quot;&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;千裳集周边&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;优惠卷&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PLUS会员&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- 主要内容区--&gt;&lt;div class=&quot;main-content&quot;&gt;    &lt;div class=&quot;container clearfix&quot;&gt;        &lt;ul class=&quot;slide-nav leftfix&quot;&gt;            &lt;li&gt;                &lt;!--                一级菜单--&gt;                &lt;a href=&quot;#&quot;&gt;古风仙侠类&lt;/a&gt;                &lt;!--                二级菜单--&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;!--                    自定义列表--&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;国风汉服类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;国风汉服类&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;动漫cos类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;动漫cos&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Lolita类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;Lolita&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;现代礼服类&lt;/a&gt;                &lt;div class=&quot;second-menu&quot;&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;现代礼服&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                    &lt;dl class=&quot;clearfix&quot;&gt;                        &lt;dt&gt;&lt;a href=&quot;#&quot;&gt;仙侠&lt;/a&gt;&lt;/dt&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠长袍&lt;/a&gt;&lt;/dd&gt;                        &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;仙侠披风&lt;/a&gt;&lt;/dd&gt;                    &lt;/dl&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;div class=&quot;banner leftfix&quot;&gt;            &lt;img src=&quot;./img/banner主图.png&quot; alt=&quot;banner主图&quot;&gt;        &lt;/div&gt;        &lt;div class=&quot;slide-other  leftfix&quot;&gt;            &lt;div class=&quot;message&quot;&gt;                &lt;div class=&quot;title clearfix&quot;&gt;                    &lt;span class=&quot;leftfix&quot;&gt;快报&lt;/span&gt;                    &lt;a href=&quot;#&quot; class=&quot;rightfix&quot;&gt;更多&amp;nbsp;&amp;gt;&lt;/a&gt;                &lt;/div&gt;                &lt;ul class=&quot;msg-list&quot;&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发财&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发疯&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;            &lt;div class=&quot;other-nav&quot;&gt;                &lt;ul class=&quot;other-nav-list clearfix&quot;&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;话费&lt;/span&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;火车票&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;加油卡&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;礼品卡&lt;/span&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;ul class=&quot;other-nav-list clearfix&quot;&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;话费&lt;/span&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;火车票&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;加油卡&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;礼品卡&lt;/span&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;ul class=&quot;other-nav-list clearfix&quot;&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;话费&lt;/span&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;火车票&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;加油卡&lt;/span&gt;&lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt;                        &lt;span&gt;礼品卡&lt;/span&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- 秒杀区--&gt;&lt;div class=&quot;kill&quot;&gt;    &lt;div class=&quot;container &quot;&gt;        &lt;img src=&quot;img/banner1.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;img/banner2.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;./img/banner3.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;./img/banner4.jpg&quot; alt=&quot;&quot;&gt;        &lt;span&gt;X&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--楼层--&gt;&lt;div class=&quot;floor&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;!--        上部分--&gt;        &lt;div class=&quot;floor-nav clearfix&quot;&gt;            &lt;span class=&quot;floor-name leftfix clearfix&quot;&gt;家用电器&lt;/span&gt;            &lt;ul class=&quot;floor-nav-list rightfix&quot;&gt;                &lt;li&gt;                    &lt;a href=&quot;#&quot;&gt;热门&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;#&quot;&gt;生活电器&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;#&quot;&gt;厨房电器&lt;/a&gt;                &lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;!--        下部分--&gt;        &lt;div class=&quot;floor-info clearfix&quot;&gt;            &lt;div class=&quot;item item1&quot;&gt;                &lt;ul class=&quot;item1-list clearfix&quot; &gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;节能补贴&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4K电视&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;节能补贴&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4K电视&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;节能补贴&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4K电视&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;            &lt;div class=&quot;item item2&quot;&gt;                &lt;img src=&quot;./img/loli.jpg&quot; alt=&quot;&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;            &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;            &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--页脚--&gt;&lt;div class=&quot;footer&quot;&gt;    &lt;div class=&quot;container&quot;&gt;&lt;!--        顶部连接--&gt;        &lt;div class=&quot;top-links clearfix&quot;&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;ul class=&quot;links-list &quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物指南&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;&lt;!--        分割线--&gt;        &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;!--        底部连接--&gt;        &lt;div class=&quot;bottom-links&quot;&gt;            &lt;ul class=&quot;bottom-links-list clearfix&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;合作招商&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;友情链接&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;隐式政策&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;div class=&quot;copyright&quot;&gt;&amp;copy;2025 Tao 版权所有&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\nindex.css\r\n/* 基础设置 */.container&#123;    /* 版心由内容撑开，不需要设置高度 */    width: 1190px;    /* 版心居中 */    margin: 0 auto;    /* height: 100px;    background-color: red; */&#125;/* #region 顶部导航条start */.topbar&#123;    height: 30px;    background-color: #ececec;&#125;.welcome&#123;    height: 30px;    /* 行内元素可以像文本一样处理居中 */    line-height: 30px;    color: #666;    /* 删除文字换行导致的空格，后面用选择器单独设置文字大小 */    font-size: 0;&#125;.welcome span,.welcome a&#123;    font-size: 12px;&#125;.welcome .hello&#123;    margin-right: 28px;&#125;.welcome .login&#123;    border-right: 1px solid #666;    padding-right: 10px;    /*background-color: orange;*/&#125;.welcome .register&#123;    padding-left: 10px;&#125;.topbar-nav .list li&#123;    float: left;&#125;.topbar-nav .list&#123;    height: 30px;    line-height: 30px;&#125;.topbar .list li a&#123;    /*background-color: orange;*/    border-right:  1px solid #666;    /* 上下内边距0，左右内边距15 */    padding: 0 15px;&#125;.topbar-nav .list li:first-child a&#123;    padding-left: 0;&#125;.topbar-nav .list li:last-child a&#123;    padding-right: 0;    border-right: 0;&#125;/* #endregion顶部导航条end *//* #region 头部start */.header .container&#123;    /*background-color: skyblue;*/&#125;.header .logo&#123;    position: relative;&#125;@keyframes p1 &#123;    from&#123;&#125;    to&#123;        opacity: 1;    &#125;&#125;.header .logo img &#123;    width: 190px;    height: 190px;    position: absolute;    top: 0;    left: 0;    opacity: 0;&#125;.logo:hover img&#123;    /*图片显示出来*/    opacity: 1;    /*动画*/    /*animation: p1 0.5s 1s linear forwards;*/&#125;.logo img&#123;    /*0.5秒线性过度效果**/    transition: 0.5s linear all;&#125;.logo .mask&#123;    width: 190px;    height: 190px;    color: white;    font-size: 50px;    text-align: center;    line-height: 190px;    background-color: black;&#125;.header .search input &#123;    /*background-color: red;*/    width: 508px;    height: 34px;    border: 1px solid #DD302D;&#125;.header .search button &#123;    width: 80px;    height: 36px;    background-color: #DD302D;    /*使元素的顶部与所在行的顶部对齐*/    vertical-align: top;    /*    背景图 */    background-image: url(&quot;../img/serch_icon.png&quot;);    background-repeat: no-repeat;    background-position: 28px 6px;&#125;.header .search form &#123;    margin-top: 42px;    /*    去掉换行导致的空格    */    font-size: 0;&#125;/* #region 头部end */.main-nav &#123;    height: 48px;    border-bottom: 1px solid #DD302D;&#125;/* #region 主导航start */.main-nav .all-types &#123;    background-color: #DD302D;    width: 190px;    height: 48px;    line-height: 48px;    text-align: center;    font-size: 16px;&#125;.main-nav .main-nav-list li&#123;    /*background-color: orange;*/    float: left;    height: 48px;    line-height: 48px;    margin: 0 10px;    font-size: 16px;&#125;/* #region 主要内容区start */.main-content .slide-nav &#123;    width: 190px;    height: 458px;    background-color: #F4F4F4;    /* 给一个定位属性：作为.second-menu的包含块：作为.second-menu的第一个拥有position属性的祖先元素*/    position: relative;&#125;.main-content .slide-nav li&#123;    height: 28px;    line-height: 28px;    font-size: 14px;    padding-left: 16px;&#125;.main-content .slide-nav li:hover&#123;    /*注意背景色不填充margin*/    background-color: #DD302D;&#125;.main-content .slide-nav li:hover .second-menu&#123;    display: block;&#125;.main-content .slide-nav li:hover&gt;a&#123;    /* 已经重置了a标签的样式，这些样式会覆盖从父元素继承过来的样式。*/    color: white;&#125;.second-menu &#123;    width: 680px;    height: 458px;    left: 190px;    top:0;    /*background-color: skyblue;*/    background-image: url(&quot;../img/bk.png&quot;) ;    /*opacity: 0.5; !* 设置透明度为50% *!*/    /*绝对定位,用.slide-nav作为参考        定位可以越过pading    */    position: absolute;    padding-left: 20px;    display: none;&#125;.second-menu dl:first-child&#123;    margin-top: 10px;&#125;.second-menu dl &#123;    height: 36px;    line-height: 36px;&#125;.second-menu dt&#123;    float: left;    width: 70px;    font-weight: bold;    margin-right: 10px;&#125;.second-menu dd&#123;    float: left;    /*background-color: cornflowerblue;*/&#125;.second-menu dd a&#123;    padding: 0 10px;    border-left: 1px solid #666;&#125;.main-content&#123;    margin-top: 10px;&#125;.main-content .banner &#123;    width: 690px;    height: 460px;    background-color: green;    margin:0 10px;&#125;.main-content .slide-other &#123;    width: 290px;    height: 458px;    /*background-color: orange;*/&#125;.slide-other .message&#123;    width: 260px;    height: 156px;    border: 1px solid #D9D9D9;    padding: 0 14px;&#125;.slide-other .message .title &#123;    height: 38px;    line-height: 38px;    border-bottom: 1px solid #D9D9D9;&#125;.slide-other .message .title span&#123;    font-size: 14px;&#125;.slide-other .msg-list li&#123;    height: 26px;    line-height: 26px;&#125;.slide-other .other-nav &#123;    margin-top: 10px;    width: 290px;    height: 290px;    /*background-color: grey;*/    /*解决margin塌陷*/    overflow: hidden;&#125;.other-nav ul&#123;    /*background-color: skyblue;*/&#125;.other-nav ul:first-child&#123;    margin-top: 16px;&#125;.other-nav ul:nth-child(2)&#123;    margin: 17px 0;&#125;.other-nav-list li &#123;    width: 48px;    height: 70px;    /*background-color: orange;*/    float: left;    margin: 0px 11px;    text-align: center;    cursor: pointer;&#125;.other-nav-list li:first-child&#123;    margin-left: 16px;&#125;.other-nav-list .picture &#123;    width: 48px;    height: 48px;    background-image: url(&quot;../img/精灵图-侧边功能.png&quot;);&#125;.other-nav-list:nth-child(1) li:nth-child(1) .picture&#123;    background-position: 0 0;&#125;.other-nav-list:nth-child(1) li:nth-child(2) .picture&#123;    background-position: -48px 0;&#125;.other-nav-list:nth-child(1) li:nth-child(3) .picture&#123;    background-position: -96px 0;&#125;.other-nav-list:nth-child(1) li:nth-child(4) .picture&#123;    background-position: -144px 0;&#125;.other-nav-list:nth-child(2) li:nth-child(1) .picture&#123;    background-position: 0 -48px;&#125;.other-nav-list:nth-child(2) li:nth-child(2) .picture&#123;    background-position: -48px -48px;&#125;.other-nav-list:nth-child(2) li:nth-child(3) .picture&#123;    background-position: -96px -48px;&#125;.other-nav-list:nth-child(2) li:nth-child(4) .picture&#123;    background-position: -144px -48px;&#125;.other-nav-list:nth-child(3) li:nth-child(1) .picture&#123;    background-position: 0 -96px;&#125;.other-nav-list:nth-child(3) li:nth-child(2) .picture&#123;    background-position: -48px -96px;&#125;.other-nav-list:nth-child(3) li:nth-child(3) .picture&#123;    background-position: -96px -96px;&#125;.other-nav-list:nth-child(3) li:nth-child(4) .picture&#123;    background-position: -144px -96px;&#125;/* #region主要内容区end  *//* #region秒杀区start  */.kill &#123;    /*height: 90px;*/    /*line-height: 90px;*/    margin-top: 10px;    /*background-color: purple;*/    /*text-align: center;*/    font-size: 0;&#125;.kill .container &#123;    /*多列布局*/    column-count: 4;    /*列边距*/    column-gap: 10px;    /*列间的边框*/    column-rule: 1px dotted green;&#125;.kill img:hover&#123;    box-shadow: 0px 0px 20px black;    /*过度*/    transition: all 0.2s linear;    /*缩放变换*/    transform: scale(1.1);&#125;.kill img &#123;    /*width: 200px;*/    /*占满column列宽*/    width: 100%;    /*margin-right: 10px;*/    cursor: pointer;    /*使图片受 text-align 属性的影响。*/    /*display: inline-block;*/&#125;/* #region秒杀区end  *//* #region楼层区start  */.floor&#123;    margin-top: 10px;    background-color: grey;&#125;.floor-nav &#123;    background-color: orange;    height: 30px;    line-height: 30px;    border-bottom: 2px solid red;&#125;.floor-nav .floor-name&#123;    font-size: 20px;&#125;.floor-nav-list li &#123;    float: left;    font-size: 14px;&#125;.floor-nav-list li a&#123;    padding: 0 10px;    border-right: 1px solid #666;&#125;.floor-nav-list li:first-child a&#123;    padding-left: 0 ;&#125;.floor-nav-list li:last-child a&#123;    border-right: 0 ;&#125;.floor-info .item&#123;    float: left;&#125;.item1&#123;    background-color: #F4F4F4;    width: 198px;    height: 198px;    padding: 20px;&#125;.item1-list li &#123;    background-color: orange;    width: 90px;    height: 22px;    font-size: 16px;    border-bottom: 1px solid #D9D9D9;    /*padding-bottom: 3.5px;*/    text-align: center;&#125;.item1-list li:nth-child(2n-1)&#123;    /*奇数左浮动*/    float: left;&#125;.item1-list li:nth-child(2n)&#123;    /*偶数左浮动*/    float: right;&#125;.item1-list li:nth-child(3),.item1-list li:nth-child(4)&#123;    margin: 10px 0;&#125;.item2&#123;    background-color: green;    width: 238px;    height: 238px;    position: relative;&#125;.item2 img&#123;    width: 238px;    height: 238px;    /* 撑满整个包含块 */    top: 0;    bottom: 0;    left: 0;    right: 0;    position:absolute;&#125;.item3&#123;    background-color: orange;    width: 238px;    height: 238px;&#125;.item4&#123;    background-color: gray;    width: 238px;    height: 238px;&#125;.item5&#123;    background-color: tomato;    width: 238px;    height: 238px;&#125;/* #region楼层区end  *//* #region页脚start  */.footer&#123;    background-color: #483E3E;    height: 440px;    margin-top: 10px;&#125;.footer .links-list &#123;    background-color: orange;    float: left;    width: 190px;    height: 176px;    margin-top: 48px;    margin-right: 10px;    /*text-align: center;*/&#125;.footer .links-list:last-child&#123;    /*background-color: red;*/    margin-right: 0;&#125;.footer .links-list a&#123;    color: white;&#125;.line &#123;    height: 1px;    background-color: white;    margin-top: 22px;&#125;.bottom-links&#123;    background-color: hotpink;    text-align: center;    margin-top: 47px;&#125;.bottom-links-list&#123;    /*使ul受 text-align 属性的影响。*/    display: inline-block;&#125;.bottom-links-list li&#123;    float: left;&#125;.bottom-links-list li a&#123;    border-right: 1px solid white;    padding: 0 26px;    color: white;&#125;.bottom-links-list li:first-child a&#123;    padding-left: 0;&#125;.bottom-links-list li:last-child a&#123;    border-right: 0;&#125;.copyright&#123;    color: white;    margin-top: 10px;&#125;/* #region页脚区end  */\r\nH5\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;新增标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--状态标签--&gt;    &lt;div&gt;        &lt;span&gt;米&lt;/span&gt;        &lt;meter min=&quot;0&quot; max=&quot;100&quot; value=&quot;9&quot; low=&quot;10&quot; high=&quot;20&quot; optimum=&quot;90&quot;&gt;&lt;/meter&gt;        &lt;meter min=&quot;0&quot; max=&quot;100&quot; value=&quot;19&quot; low=&quot;10&quot; high=&quot;20&quot; optimum=&quot;90&quot;&gt;&lt;/meter&gt;        &lt;meter min=&quot;0&quot; max=&quot;100&quot; value=&quot;21&quot; low=&quot;10&quot; high=&quot;20&quot; optimum=&quot;90&quot;&gt;&lt;/meter&gt;        &lt;span&gt;进度条&lt;/span&gt;        &lt;progress max=&quot;100&quot; value=&quot;50&quot;&gt;&lt;/progress&gt;    &lt;/div&gt;    &lt;!--列表标签--&gt;    &lt;div&gt;        &lt;form action=&quot;#&quot;&gt;            &lt;input type=&quot;text&quot; list=&quot;mydata&quot;&gt;            &lt;button&gt;搜索&lt;/button&gt;        &lt;/form&gt;        &lt;datalist id=&quot;mydata&quot;&gt;            &lt;option value=&quot;11&quot;&gt;11&lt;/option&gt;            &lt;option value=&quot;12&quot;&gt;12&lt;/option&gt;            &lt;option value=&quot;21&quot;&gt;21&lt;/option&gt;            &lt;option value=&quot;22&quot;&gt;22&lt;/option&gt;            &lt;option value=&quot;31&quot;&gt;31&lt;/option&gt;        &lt;/datalist&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;details&gt;            &lt;summary&gt;总结概要&lt;/summary&gt;            欢迎来到英雄联盟        &lt;/details&gt;    &lt;/div&gt;    &lt;!--文字标签--&gt;    &lt;div&gt;        &lt;!--    注音--&gt;        &lt;ruby&gt;爱            &lt;rt&gt;ai&lt;/rt&gt;        &lt;/ruby&gt;        &lt;br&gt;        &lt;span&gt;我&lt;mark&gt;爱&lt;/mark&gt;你&lt;/span&gt;    &lt;/div&gt;&lt;!--表单控件属性--&gt;    &lt;div&gt;&lt;!--        pattern 配合 required 使用--&gt;&lt;!--        &lt;form action=&quot;#&quot; novalidate 不校验表单&gt;--&gt;        &lt;form action=&quot;#&quot; &gt;            账号:            &lt;input                    type=&quot;text&quot;                    name=&quot;account&quot;                    placeholder=&quot;占位字符&quot;                    autofocus                    aria-autocomplete=&quot;on&quot;                    required                    pattern=&quot;\\w&#123;6&#125;&quot;                &gt;            &lt;br&gt;            密码:            &lt;input type=&quot;password&quot; name=&quot;pwd&quot; &gt;            &lt;br&gt;            邮箱:            &lt;input type=&quot;email&quot; name=&quot;youxiang&quot; &gt;            &lt;br&gt;            网站:            &lt;input type=&quot;url&quot; name=&quot;wangzhang&quot; &gt;            &lt;br&gt;            数值:            &lt;input type=&quot;number&quot; name=&quot;shuzhi&quot; step=&quot;2&quot; max=&quot;100&quot; min=&quot;60&quot; &gt;            &lt;br&gt;            电话:            &lt;input type=&quot;tel&quot; name=&quot;dianhua&quot;  &gt;            &lt;br&gt;            搜索:            &lt;input type=&quot;search&quot; name=&quot;keyword&quot;&gt;            &lt;br&gt;            光照强度:            &lt;input type=&quot;range&quot; name=&quot;range&quot; max=&quot;100&quot; min=&quot;60&quot; value=&quot;90&quot;&gt;            &lt;br&gt;            颜色:            &lt;input type=&quot;color&quot; name=&quot;color&quot; &gt;            &lt;br&gt;            日期:            &lt;input type=&quot;date&quot; name=&quot;date&quot;&gt;            &lt;br&gt;            月份:            &lt;input type=&quot;month&quot; name=&quot;month&quot;&gt;            &lt;br&gt;            周:            &lt;input type=&quot;week&quot; name=&quot;week&quot;&gt;            &lt;br&gt;            时间:            &lt;input type=&quot;time&quot; name=&quot;time&quot;&gt;            &lt;br&gt;            日期+时间:            &lt;input type=&quot;datetime-local&quot; name=&quot;time2&quot;&gt;            &lt;br&gt;            性别:            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; required&gt;            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot;&gt;            &lt;br&gt;            爱好:            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;sing&quot; checked&gt;唱            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;dance&quot;&gt;跳            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;rap&quot; required&gt;rap            &lt;br&gt;            其他:            &lt;textarea name=&quot;other&quot;  cols=&quot;5&quot; rows=&quot;5&quot; required&gt;&lt;/textarea&gt;            &lt;br&gt;            &lt;button&gt;提交&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;!--        媒体标签--&gt;    &lt;div&gt;        &lt;video src=&quot;./video/1.mp4&quot; controls  muted autoplay loop preload=&quot;metadata&quot;&gt;            您的浏览器不支持视频播放        &lt;/video&gt;        &lt;audio src=&quot;./video/1.mp3&quot; controls autoplay loop preload=&quot;metadata&quot;&gt;            您的浏览器不支持音频播放        &lt;/audio&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n新增语义化标签\r\n\r\n\r\nimage-20250305153706750\r\n\r\n状态标签\r\n\r\n\r\nimage-20250305160242984\r\n\r\n列表标签\r\n\r\n\r\nimage-20250305162625771\r\n\r\n文本标签\r\n\r\n\r\nimage-20250305163351468\r\n\r\n表单控件\r\n\r\n\r\nimage-20250306152050318\r\n\r\n\r\n\r\nimage-20250306154626810\r\n\r\n多媒体标签\r\n\r\n\r\nimage-20250306161350390\r\n\r\n全局属性\r\n\r\n\r\nimage-20250306175416046\r\n\r\nH5兼容性\r\n\r\n\r\nimage-20250306180433663\r\n\r\n\r\n\r\nimage-20250306180511004\r\n\r\ncss3\r\n\r\n\r\nimage-20250306181043152\r\n\r\n\r\n\r\nimage-20250306182436945\r\n\r\n\r\n长度属性\r\n\r\n\r\nimage-20250307091842508\r\n\r\nbox-sizing\r\n\r\n\r\nimage-20250307092743743\r\n\r\nresize\r\n\r\n\r\nimage-20250307093209630\r\n\r\nbox-shadow\r\nbox-shadow: 0px 0px 20px black;\r\n\r\n\r\nimage-20250307094514573\r\n\r\n\r\n\r\nimage-20250307094547447\r\n\r\nopacity\r\n\r\n\r\nimage-20250307095723700\r\n\r\nbackground\r\n\r\n\r\nimage-20250307115143226\r\n\r\n\r\n\r\nimage-20250307115618729\r\n\r\nbackground-origin\r\n\r\n\r\nimage-20250307114612093\r\n\r\nbackground-clip\r\n\r\n\r\nimage-20250307114649892\r\n\r\nbackground-size\r\n\r\n\r\nimage-20250307114740460\r\n\r\n边框圆角border-radius\r\n\r\n\r\nimage-20250307120435612\r\n\r\n边框外轮廓outline\r\n\r\n文本text-shadow\r\n\r\n\r\nimage-20250307121311791\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;style&gt;    body&#123;      background-color: black;    &#125;    h1 &#123;      color: white;      font-size: 80px;      text-align: center;      text-shadow: 0px 0px 20px red;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;你好呀&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\r\n文本换行white-space\r\n\r\n\r\nimage-20250307121859101\r\n\r\n文本溢出text-overflow\r\n\r\n\r\nimage-20250307122526554\r\n\r\n\r\n\r\nimage-20250307122602222\r\n\r\n\r\n\r\nimage-20250307122512204\r\n\r\n文本修饰text-decoration\r\n\r\n\r\nimage-20250307122823791\r\n\r\n文本描边\r\n\r\n\r\nimage-20250307123024950\r\n\r\n渐变gradient\r\n\r\n线性渐变\r\n径向渐变\r\n重复渐变\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;style&gt;      .box1 &#123;        width: 600px;        height: 800px;        /*background-color:orange ;*/        margin: 0 auto;        border: 1px solid black;        padding: 20px;        /*  线性渐变*/        background-image: repeating-linear-gradient(transparent 0px,transparent 29px,grey 30px);        /*背景色会填充padding，所以要剪掉内容区背景*/        background-clip: content-box;      &#125;      .box2&#123;        width: 200px;        height: 200px;        /*半径为父元素的一半*/        border-radius: 50%;        /*background-color: orange;*/        background-image: radial-gradient(at 80px 80px,white,black);      &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n\r\n\r\nimage-20250307130609492\r\n\r\n\r\n\r\nimage-20250307130659303\r\n\r\nweb字体\r\n\r\n\r\nimage-20250307174341673\r\n\r\n字体图标\r\n\r\n\r\nimage-20250307180422748\r\n\r\n2D变换位移transform\r\n\r\n\r\nimage-20250307181819320\r\n\r\n\r\n\r\nimage-20250307181916438\r\n\r\n缩放scale\r\n\r\n\r\nimage-20250307182923121\r\n\r\n旋转rotate\r\n\r\n\r\nimage-20250307183436307\r\n\r\n扭曲skew\r\n\r\n\r\nimage-20250307201759437\r\n\r\n多重变换\r\n\r\n\r\nimage-20250307203000183\r\n\r\n变换原点transform-origin\r\n\r\n\r\nimage-20250307204022815\r\n\r\n3d变换景深perspective\r\n\r\n\r\nimage-20250307205520578\r\n\r\n透视点位置perspective-origin\r\n\r\n\r\nimage-20250307210313373\r\n\r\n3D位移\r\n\r\n\r\nimage-20250307214822307\r\n\r\n3d旋转\r\n\r\n\r\nimage-20250307215423729\r\n\r\n3d缩放\r\n\r\n\r\nimage-20250307221519811\r\n\r\n3d多重变换\r\n\r\n\r\nimage-20250307222353164\r\n\r\n过度transition\r\n\r\n\r\nimage-20250307223648238\r\n\r\n\r\n\r\nimage-20250307225234204\r\n\r\n\r\n\r\nimage-20250307225733703\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;style&gt;    .outer&#123;        width: 200px;        /*background-color: grey;*/        position: relative;        overflow: hidden;    &#125;    .outer:hover .mask&#123;        opacity: 0.5;    &#125;    .mask &#123;        width: 200px;        height: 200px;        background-color: black;        color: white;        position: absolute;        top: 0;        left: 0;        text-align: center;        font-size: 100px;        opacity: 0;    /*    过度所有能过度的属性，1秒线性过度效果*/        transition: 1s linear all;        cursor: pointer;    &#125;    img&#123;        width: 200px;        height: 200px;        vertical-align: bottom;        /*0.5秒线性过度效果**/        transition: 0.5s linear all;    &#125;    .outer:hover img&#123;        transform: scale(1.5) rotate(20deg);    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;outer&quot;&gt;        &lt;img src=&quot;../img/logo.png&quot; alt=&quot;&quot;&gt;        &lt;div class=&quot;mask&quot;&gt;深圳&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n动画animation\r\n\r\n\r\nimage-20250308154258864\r\n\r\n\r\n\r\nimage-20250308152202074\r\n\r\n\r\n\r\nimage-20250308152225703\r\n\r\n\r\n\r\nimage-20250308153542944\r\n\r\n\r\n\r\nimage-20250308153614034\r\n\r\n动画与过度\r\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;动画不需要触发条件，可以通过关键字精确控制。过度需要触发条件，从始到末不可操作&lt;/title&gt;        &lt;style&gt;            .lin&#123;               width: 100%;               height: 1px;               background: #000;            &#125;            .outer&#123;               width: 1000px;               height: 201px;               border: 1px solid #000;            &#125;            .inner-animation&#123;               width: 100px;               height: 100px;               background: skyblue;               animation: demo2;               /* 动画持续时间 */               animation-duration: 3s;               /* 动画延迟 */               animation-delay: 1s;               /* 动画播放次数 */               /* animation-iteration-count: infinite; */               /* 动画播放方向 */               /* animation-direction: alternate; */               /* 动画播放速度 */               /* animation-timing-function: linear; */               /* 不发生动画的时候在哪里 */               animation-fill-mode: forwards;               /* 复合写法 */               /* animation: demo2 3s 1s linear  infinite alternate forwards; */            &#125;            .outer:hover .inner-animation&#123;                /* 动画播放状态 */               animation-play-state: paused;                          &#125;            /* 定义关键帧 */            @keyframes demo&#123;                /* 第一帧 */                from&#123;                                               &#125;                /* 最后帧 */                to&#123;                       transform: translate(900px,0);                           &#125;            &#125;            @keyframes demo2&#123;                0%&#123;                    transform:rotate(90deg)                &#125;                50%&#123;                    background-color: red;                &#125;                100%&#123;                    transform:  translate(900px,0);                    border-radius:  50%;                    background-color: green;                &#125;            &#125;            .inner-transition&#123;               width: 100px;               height: 100px;               background-color: orange;               transition: all 3s linear;            &#125;            .outer:hover .inner-transition&#123;                transform: translate(900px,0);                background-color: red;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;outer&quot;&gt;            &lt;div class=&quot;inner-animation&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;lin&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;inner-transition&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\r\ncase-logo用过度效果\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;过度效果&lt;/title&gt;    &lt;style&gt;        .logo &#123;            position: relative;        &#125;        .logo img &#123;            width: 190px;            height: 190px;            position: absolute;            top: 0;            left: 0;            opacity: 0;        &#125;        .logo:hover img &#123;            /*图片显示出来*/            opacity: 1;        &#125;        .logo img &#123;            /*0.5秒线性过度效果**/            transition: 0.5s linear all;        &#125;        .logo .mask &#123;            width: 190px;            height: 190px;            color: white;            font-size: 50px;            text-align: center;            line-height: 190px;            background-color: black;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;logo &quot;&gt;    &lt;div class=&quot;mask&quot;&gt;        大牛    &lt;/div&gt;    &lt;img src=&quot;../img/logo.png&quot; alt=&quot;logo&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\ncase-logo用动画效果\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;动画效果&lt;/title&gt;    &lt;style&gt;        .logo &#123;            position: relative;        &#125;        @keyframes p1 &#123;            from&#123;&#125;            to&#123;                opacity: 1;            &#125;        &#125;        .logo img &#123;            width: 190px;            height: 190px;            position: absolute;            top: 0;            left: 0;            opacity: 0;        &#125;        .logo:hover img&#123;            /*动画*/            animation: p1 0.5s 1s linear forwards;        &#125;        .logo .mask &#123;            width: 190px;            height: 190px;            color: white;            font-size: 50px;            text-align: center;            line-height: 190px;            background-color: black;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;logo &quot;&gt;    &lt;div class=&quot;mask&quot;&gt;        大牛    &lt;/div&gt;    &lt;img src=&quot;../img/logo.png&quot; alt=&quot;logo&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\ncase-图片动画效果\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;动画效果&lt;/title&gt;    &lt;style&gt;        @keyframes p1 &#123;            from&#123;            &#125;            to&#123;                background-position: 0 -123px;            &#125;        &#125;        .logo&#123;            background-color: grey;            position: relative;        &#125;        .logo .mask1 &#123;            width: 190px;            height: 123px;            background-image: url(&quot;../img/animation.jpg&quot;);            /*等比缩放*/            background-size: cover;            position: absolute;            top: 0;            left: 0;            opacity: 0;        &#125;        .logo:hover .mask1&#123;            opacity: 1;            transition: 0.5s linear all;            /*steps(图片高度/指定宽度)*/            animation: p1 1s  steps(50) infinite;        &#125;        .logo .mask0 &#123;            width: 190px;            line-height: 123px;            height: 123px;            font-size: 50px;            background-color: black;            color: white;            text-align: center;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;logo &quot;&gt;    &lt;div class=&quot;mask mask0&quot;&gt;大牛&lt;/div&gt;    &lt;div class=&quot;mask mask1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\ncase-flex布局\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style&gt;       * &#123;           font-family: Arial;           font-size: 14px;           margin: 0;           padding: 0;           border:none;       &#125;       a&#123;           text-decoration: none;       &#125;       ul&#123;           list-style: none;       &#125;       html, body&#123;           width: 100%;           height: 100%;       &#125;       body &#123;           /*background-image: url(&quot;../img/background.png&quot;);*/           background-repeat: no-repeat;           /*按比例盖住*/           background-size: cover;       &#125;       .page-header &#123;           height: 70px;           background-color: rgba(0, 0, 0, 0.7);           display: flex;           /*主轴方向两端对齐*/           justify-content: space-between;           /*侧轴方向居中对齐*/           align-items: center;           padding: 0 20px;       &#125;       .header-nav &#123;           display: flex;       &#125;       .header-nav li a &#123;           color: white;           font-size: 20px;           border: 1px solid white;           border-radius: 8px;           padding: 10px;           margin-right: 20px;       &#125;       .header-nav li:last-child a&#123;           margin-right: 0;       &#125;       .page-content&#123;           display: flex;           /*视口高度-header高度*/           height: calc(100vh - 70px);       &#125;       .content-nav &#123;           width: 1000px;           height: 300px;           background-color: skyblue;           margin: auto;           display: flex;           justify-content: space-evenly;           align-items: center;       &#125;       .content-nav .item:hover&#123;           box-shadow: 0px 0px 20px black;       &#125;       .content-nav .item &#123;           width: 180px;           height: 200px;           background-color: orange;           display: flex;           /*主轴方向从上到下*/           flex-direction: column;           /*align-items: center;*/           justify-content: space-evenly;           /*     过度效果*/           transition: all 0.2s linear;           cursor: pointer;       &#125;       .content-nav .item img&#123;           align-items: center;       &#125;       .content-nav .item span&#123;           font-size: 20px;       &#125;       span&#123;           background-color: red;       &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;header class=&quot;page-header&quot;&gt;        &lt;a href=&quot;#&quot;&gt;            &lt;img src=&quot;../img/logo1.png&quot; alt=&quot;&quot;&gt;        &lt;/a&gt;        &lt;ul class=&quot;header-nav&quot;&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;欧美&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;日本&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;缅甸&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;非洲&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/header&gt;    &lt;!--    内容区--&gt;    &lt;div class=&quot;page-content&quot;&gt;        &lt;div class=&quot;content-nav&quot;&gt;            &lt;div class=&quot;item&quot;&gt;                &lt;img src=&quot;../img/banner1.jpg&quot; alt=&quot;&quot;&gt;                &lt;span&gt;X1&lt;/span&gt;            &lt;/div&gt;            &lt;div class=&quot;item&quot;&gt;                &lt;img src=&quot;../img/banner2.jpg&quot; alt=&quot;&quot;&gt;                &lt;span&gt;X2&lt;/span&gt;            &lt;/div&gt;            &lt;div class=&quot;item&quot;&gt;                &lt;img src=&quot;../img/banner3.jpg&quot; alt=&quot;&quot;&gt;                &lt;span&gt;X3&lt;/span&gt;            &lt;/div&gt;            &lt;div class=&quot;item&quot;&gt;                &lt;img src=&quot;../img/banner4.jpg&quot; alt=&quot;&quot;&gt;                &lt;span&gt;X4&lt;/span&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n多列布局column\r\n\r\n\r\nimage-20250309000416381\r\n\r\n\r\n\r\nimage-20250309000359757\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;给图片增加过度和变换&lt;/title&gt;    &lt;style&gt;        .container&#123;            /* 版心由内容撑开，不需要设置高度 */            width: 1190px;            /* 版心居中 */            margin: 0 auto;            background-color: grey;        &#125;        .kill &#123;            margin-top: 10px;            font-size: 0;        &#125;        .kill .container &#123;            /*多列布局*/            column-count: 4;            /*列边距*/            column-gap: 10px;            /*列间的边框*/            column-rule: 10px dotted green;        &#125;        .kill img:hover&#123;            box-shadow: 0px 0px 20px black;            /*过度*/            transition: all 0.2s linear;            /*缩放变换*/            transform: scale(1.1);        &#125;        .kill img &#123;            /*占满column列宽*/            width: 100%;            cursor: pointer;            /*图片由行内块元素（宽高可以通过CSS调整且不占满整行）变为块元素（占整行）占满整列，            否则当图片不足以填满一列的高度时，浏览器会自动将剩余的内容移到下一行，从而导致图片换行*/            display: block;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;kill&quot;&gt;    &lt;div class=&quot;container &quot;&gt;        &lt;img src=&quot;../img/banner1.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;../img/banner2.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;../img/banner3.jpg&quot; alt=&quot;&quot;&gt;        &lt;img src=&quot;../img/banner4.jpg&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n元素的显示模式display\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;display&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            /*每块砖在墙中都占据一个独立的空间，砖块可以根据CSS切割成不同的尺寸*/            /*display: block;*/            /*就像单词在句子中并排排列，多个 inline 元素可以在同一行内并排显示，你不能改变单个单词的高度或宽度*/            /*display: inline;*/            /*就像图片或图标在句子中与其他文字并排排列，你可以明确指定图片或图标的大小*/            /*display: inline-block;*/            /* 占据整个行宽，独立的智能大货架 是一个占据整个行宽的大型货架，它可以动态调整布局，决定如何排列和对齐上面的商品（弹性项目）。它会独占一行，并且其内部的商品可以根据需要灵活排列。*/            /*display: flex;*/            /*不独占一行，句子中的智能小货架 是一个小货架，它可以像单词一样在句子中流动，与其他文本或行内元素并排显示*/            display: inline-flex;        &#125;        .inner&#123;            box-sizing: border-box;/*设置盒子大小*/            width: 100px;            height: 100px;            border:1px solid black;            background-color: skyblue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt;&lt;/div&gt;XX&lt;/body&gt;&lt;/html&gt;\r\n\r\n\r\nimage-20250228153712903\r\n\r\n\r\n\r\nimage-20250228153842254\r\n\r\n\r\n\r\nimage-20250228154646764\r\n\r\n\r\n\r\nimage-20250228155211572\r\n\r\n弹性盒子flex\r\n\r\n\r\nimage-20250309133300154\r\n\r\n\r\n\r\nimage-20250309134748949\r\n\r\nflex-direction主轴方向\r\n\r\n\r\nimage-20250309161042256\r\n\r\n主轴换行flex-wrap\r\n\r\n\r\nimage-20250309162014336\r\n\r\n换行复合flex-flow\r\n\r\n\r\nimage-20250309162454675\r\n\r\n主轴对齐方式justify-content\r\n\r\n\r\nimage-20250309185025360\r\n\r\n\r\n\r\nimage-20250309185101817\r\n\r\n侧轴单行对齐align-items\r\n\r\n\r\nimage-20250309190146827\r\n\r\n\r\n\r\nimage-20250309190215860\r\n\r\n\r\n\r\nimage-20250309190234946\r\n\r\n侧轴多行对齐align-content\r\n\r\n\r\nimage-20250309215813737\r\n\r\n\r\n\r\nimage-20250309215935246\r\n\r\n\r\n\r\nimage-20250309220004524\r\n\r\n\r\n\r\nimage-20250309220034550\r\n\r\n\r\n\r\nimage-20250309220049917\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            width: 1000px;            height: 900px;            margin: 0 auto;            display: flex;            /*主轴换行*/            flex-wrap: wrap;            /*主轴默认从左到右*/            flex-direction: row;             /*主轴默认对齐方式*/            justify-content: flex-start;            /*侧轴单行对齐方式默认stretch拉伸,当items没有设置高度时*/            /*align-items: stretch;*/            /*侧轴多行对齐方式stretch拉伸,当items没有设置高度时*/            align-content: stretch;        &#125;        .inner&#123;            background-color: skyblue;            width: 200px;            height: 200px;            /*调整盒子的总宽高*/            box-sizing: border-box;            border:1px solid black;        &#125;        .inner2&#123;            height: 300px;        &#125;        .inner3&#123;            height: 100px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner3&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner4&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner5&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner6&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner7&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner8&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner9&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner10&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;inner inner11&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n水平垂直居中-方法一flex轴居中\r\n/*方法一：在父容器中设置以下属性*//*开启弹性盒子*/display: flex;/*主轴居中*/justify-content: center;/*    侧轴单行居中*/align-items: center;\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            width: 1000px;            height: 900px;            display: flex;            /*默认值，主轴不换行*/            flex-wrap: nowrap;            /*默认值，主轴从左到右*/            flex-direction: row;            /*默认值，主轴齐方式*/            justify-content: center;        &#125;        .inner &#123;            background-color: skyblue;            width: 200px;            height: 200px;            box-sizing: border-box;            border: 1px solid black;        &#125;        .inner2 &#123;            width: 300px;            height: 300px;            /*侧轴单独调整item对其方式，默认值是auto*/            align-self: center;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;1&lt;/div&gt;    &lt;div class=&quot;inner inner2&quot;&gt;2&lt;/div&gt;    &lt;div class=&quot;inner inner3&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n水平垂直居中-方法二-flex自动margin\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;flex&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            width: 1000px;            height: 900px;            /*方法二：父容器开启弹性盒子*/            display: flex;        &#125;        .inner&#123;            background-color: skyblue;            width: 200px;            height: 200px;            box-sizing: border-box;            border:1px solid black;            /*子元素中设置自动外边距*/            margin:auto;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n水平垂直居中-方法三-margin计算\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;flex&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            width: 1000px;            height: 900px;            /* 解决margin塌陷 */            overflow: hidden;        &#125;        .inner &#123;            background-color: skyblue;            width: 200px;            height: 200px;            box-sizing: border-box;            border: 1px solid black;            /*(900-200)/2  即（父元素高度-子元素高度）/2 */            margin: 350px auto;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n水平垂直居中-方法四-定位\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            width: 1000px;            height: 900px;            /* 给一个定位属性：作为inner的包含块：作为inner的第一个拥有position属性的祖先元素*/            position: relative;        &#125;        .inner &#123;            background-color: skyblue;            width: 200px;            height: 200px;            box-sizing: border-box;            border: 1px solid black;            /* 在包含块里居中 */            /* 绝对定位：                 脱离文档流                 包含块：第一个拥有position属性的祖先元素作为参考，若都没有则为html元素             */            position:absolute;            top: 0;            bottom: 0;            left: 0;            right: 0;            margin: auto;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n复合属性flex\r\n\r\n\r\nimage-20250310130109337\r\n\r\n\r\n\r\nimage-20250310125758168\r\n\r\n\r\n\r\nimage-20250310130012341\r\n\r\n\r\n\r\nimage-20250310132916533\r\n\r\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style&gt;        .outer &#123;            background-color: grey;            width: 1000px;            height: 900px;            display: flex;            /*默认值，主轴不换行*/            flex-wrap: nowrap;            /*默认值，主轴从左到右*/            flex-direction: row;            /*默认值，主轴齐方式*/            justify-content: flex-start;            /*默认值，侧轴单行对齐方式stretch拉伸,当items没有设置高度时*/            /*align-items: stretch;*/            /*默认值，侧轴多行对齐方式stretch拉伸,当items没有设置高度时*/            /*align-content: stretch;*/        &#125;        .inner &#123;            background-color: skyblue;            width: 200px;            height: 200px;            box-sizing: border-box;            border: 1px solid black;            /*默认值，即使主轴有剩余也不拉伸*/            flex-grow: 0;            /*默认值，按计算缩小*/            flex-shrink: 1;            /*    简写flex110 可以拉伸，可以压缩，基准长度为0 */            flex: 1;        &#125;        .inner2 &#123;            width: 300px;            height: 300px;        /*    默认值，排序*/            order: 0;            /*侧轴单独调整item对其方式，默认值是auto*/            align-self: auto;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner inner1&quot;&gt;1&lt;/div&gt;    &lt;div class=&quot;inner inner2&quot;&gt;2&lt;/div&gt;    &lt;div class=&quot;inner inner3&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n基准长度flex-basis\r\n\r\n\r\nimage-20250310121453654\r\n\r\n伸flex-grow\r\n\r\n\r\nimage-20250310122432957\r\n\r\n缩flex-shrink\r\n\r\n\r\nimage-20250310124458330\r\n\r\n媒体查询\r\n\r\n\r\nimage-20250310162435257\r\n\r\n媒体特性\r\n\r\n\r\nimage-20250310163403049\r\n\r\n\r\nBFC\r\n\r\n\r\nimage-20250310170317895\r\n\r\n\r\n\r\nimage-20250310164757080\r\n\r\n\r\n\r\nimage-20250310165023504\r\n\r\n\r\n\r\nimage-20250310165242407\r\n\r\n"},{"title":"数据结构","url":"/2023/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"temp\r\n\r\nlist顺序存储。LinkedList、ArrayList、Vector\r\nset的实现类都有一套自己的排序算法，每添加一个都会按照算法将其添加到合适位置，所以set无序且不能重复元素。HashSet、LinkedHashSet\r\nMap.keyset()这里用set集合存储key\r\n\r\n"},{"title":"浏览器存储机制","url":"/2025/04/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/","content":"🍪 cookie (小饼干)\r\n\r\n适用于在客户端和服务器间共享数据，并且可设置长期存储\r\n\r\n\r\n由服务器端产生内容，发送浏览器保存到本地，每次浏览器向同一服务器发送请求时都会携带cookie(增加流量浪费性能)，这样在浏览器和服务器间被来回传递，所以它主要用于记录用户的会话状态、身份验证和跟踪用户的行为。需要自行设置过期时间。在HTTP中明文传传输不安全。存储容量为4KB\r\n\r\n\r\n比如可以在用户浏览网站时收集有关他们的偏好信息以此提供定制广告，或者跟踪用户添加的购物车商品，下次用户访问时购物车中就仍有相同的商品。\r\n\r\n📦local storage(本地储物柜)\r\n\r\n适用于只在客户端的长期存储,比如保存用户自定义的网站主题；保存未发送的邮件草稿等。\r\n\r\n\r\n是H5提供的webapi,通过JS访问,运行在客户端中永久存储键值对不会随HTTP发送到服务器。容量为5M。只能在同域名下访问\r\n\r\n🏷️ session\r\nstorage(临时标签页储物箱)\r\n\r\n适用于只在客户端的会话期间暂存数据。比如你在一个购物网站的不同页面间跳转时，临时记录一些信息，但当你关闭这个网站的标签页或整个浏览器后，这些信息就消失了。\r\n\r\n\r\n与ls类似，数据也只在客户端，但只在关闭浏览器前有效，每个标签或窗口间的数据独立不共享。同域名下的单个标签页（标签页之间不共享）。\r\n\r\n"},{"title":"javaee","url":"/2024/01/23/javaee/","content":"Shortcut keys\r\n\r\n列出代码模板ctrl + j\r\n删除当前行ctrl + y\r\nCtrl + Alt + 左箭头：返回到上一个光标位置\r\nalt + 1\r\n标记书签ctrl + F11\r\n按 Shift + F11 查看所有书签并快速跳转\r\n复制全类名ctrl + shift + alt + c\r\n分屏shift + enter\r\n语句块ctrl + alt + t\r\n按快捷键 Ctrl + E 打开“最近文件”列表\r\n移到方法结尾Ctrl + ]\r\n批量重命名指定变量名、方法名、类名shift + f6\r\n列出当前类结构filestructure,搜索指定方法ctrl + f12\r\n查看继承结构type Hierarchyctrl + h\r\n回溯变量、方法的来源go to implementation\r\nctal + alt + b\r\n查看在上下文中的引用ctal + f7,用f3选择\r\n\r\n断点调试\r\n自定义视图\r\n\r\n\r\nimage-20250414141245429\r\n\r\n快捷操作\r\n\r\n\r\nimage-20250413204815819\r\n\r\n\r\n\r\nimage-20250413205201892\r\n\r\n\r\n\r\nimage-20250413205224136\r\n\r\n方法之间分隔符\r\n\r\n\r\nimage-20250413195615800\r\n\r\n代码补全\r\n\r\n\r\nimage-20250413195930745\r\n\r\n自动导包\r\n\r\n\r\nimage-20250413200238385\r\n\r\n多行显示选项卡\r\n\r\n\r\nimage-20250413201439473\r\n\r\n多模块指定不同编码\r\n\r\n\r\nimage-20250413203659244\r\n\r\nIDEA热部署\r\n\r\n运行时自动编译\r\n引入devtools热部署\r\n&lt;!--devtools热部署--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;plugin&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;configuration&gt;\t\t&lt;!--开启热部署devtools--&gt;        &lt;fork&gt;true&lt;/fork&gt;    &lt;/configuration&gt;&lt;/plugin&gt;\r\n\r\n注释颜色\r\n6A9955\r\n\r\n\r\nimage-20250417175903179\r\n\r\nIDEA注释模板\r\n类模板\r\n\r\n\r\nimage-20240502144049837\r\n\r\n#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end#parse(&quot;File Header.java&quot;)/** * @Classname $&#123;NAME&#125; * @Description TODO * @Version 1.0.0 * @Date $&#123;DATE&#125; $&#123;TIME&#125; * @Author LuoTao */public class $&#123;NAME&#125; &#123;&#125;\r\n方法注释模板\r\n\r\n\r\nimage-20240504043217134\r\n\r\n*** @Description $desc$* @Author LuoTao* @Date $date$* @return $return$* @param $param$**/\r\ntemplateVariables\r\ndesc\r\nmethodName()\r\ndate\r\ndate(&quot;yyyy-MM-dd HH:mm:ss&quot;)\r\nreturn\r\ngroovyScript(&quot;def returnType = \\&quot;$&#123;_1&#125;\\&quot;; def result = returnType; return result == &#x27;&#x27; ? null : result;&quot;, methodReturnType()); \r\nparam\r\ngroovyScript(&quot;def result = &#x27;&#x27;;def params = \\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;if(!params[i].isBlank())result+=(i==0?&#x27;&#x27;:&#x27;* @param &#x27; ) + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\\\r\\\\n &#x27; : &#x27;&#x27;)&#125;; return result == &#x27;&#x27; ? null : result&quot;, methodParameters())\r\n文档级注释\r\n*** @Description: $desc$* @Author: LuoTao* @Date: $date$**/\r\n测试模板\r\n@Testpublic void test$var1$()&#123;    $var2$&#125;\r\n添加模板应用场景\r\n\r\n\r\nimage-20240502141853977\r\n\r\nEnvironmentConstruction\r\n\r\njdk下载\r\n\r\n// 环境变量JAVA_HOME%JAVA_HOME%\\bin// 验证java -version\r\nCrossPlatform\r\n\r\n\r\njava跨平台\r\n\r\n\r\nc+使用平台相关的编译器生成对应平台的可执行文件\r\n\r\nDataType\r\n浮点数属于近视值，运算可能出现精度丢失。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n取值范围\r\n用途\r\n\r\n\r\n\r\n\r\nbyte(1)\r\n-128 到 127\r\n存储较小的整数值，节省内存\r\n\r\n\r\nshort(2)\r\n-32,768 到 32,767 即 -2^15 到 2^15 - 1\r\n存储中等大小的整数值，节省内存\r\n\r\n\r\nint(4)\r\n-2^31 到 2^31 - 1\r\n通用整数类型\r\n\r\n\r\nlong(8)\r\n-2^63 到 2^63 - 1\r\n存储大整数值\r\n\r\n\r\nfloat(4)\r\n大约 ±3.4e±38（7 位精度）\r\n\r\n\r\n\r\ndouble(8)\r\n大约±1.7e±308（15 位精度）\r\n\r\n\r\n\r\nchar(2)\r\n\\u0000'到 \\uffff\r\n存储单个字符\r\n\r\n\r\nboolean(1)\r\ntrue 或 false\r\nJVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1\r\n来表示 true，0 表示 false。JVM支持 boolean\r\n数组，但是是通过读写 byte 数组来实现的。\r\n\r\n\r\n\r\n\r\n\r\nimage-20241213122939589\r\n\r\n   // @Description: a++ 先算表达式再自加；--a 先自减再表达式public static void main(String[] args) &#123;       int a = 100;       int b = 200;       b += a++;//b=300 a=101       b += --a;//a=100 b=300 +100=400       System.out.println(a);// 100       System.out.println(b);// 400   &#125;\r\n// @Description: 单目运算符自动发生强制类型转换public static void main(String[] args) &#123;     byte a=10;     a += 10; //a = (byte)(a + 10); &#125;\r\ncase1-whileDemo-反转四位正整数\r\n\r\n\r\nimage-20241216183924152\r\n\r\npackage com.rabbiter.nekofun; class App &#123;    /**     * 反转一个四位正整数并打印结果。     *     * @param num 四位正整数     */    public static void reverse(int num) &#123;        // 检查输入是否为四位正整数        if (num &lt; 1000 || num &gt; 9999) &#123;            System.out.println(&quot;请输入一个四位正整数！&quot;);            return;        &#125;        int reversedNum = 0;        while (num != 0) &#123;            //将 reversedNum 左移一位（乘以10），然后加上 num 的最后一位（通过取模运算 % 10 获得）            reversedNum = reversedNum * 10 + num % 10;            num /= 10;//去掉 num 的最后一位，为下一次迭代做准备        &#125;        System.out.println(&quot;反转后的数字是: &quot; + reversedNum);    &#125;    public static void main(String[] args) &#123;        reverse(5678);    &#125;&#125;\r\ncase2-whileDemo-四叶玫瑰数\r\npackage com.rabbiter.nekofun; class App &#123;    /**     * 找出所有的四叶玫瑰数（四位数，个位、十位、百位、千位上数字的4次方之和等于数字本身）     */    public static void whileDemo() &#123;        // 遍历所有四位数        for (int num = 1000; num &lt;= 9999; num++) &#123;            if (isFourLeafRose(num)) &#123;                System.out.println(&quot;找到四叶玫瑰数: &quot; + num);            &#125;        &#125;    &#125;    /**     * 判断给定的四位数是否为四叶玫瑰数     */    private static boolean isFourLeafRose(int num) &#123;        int originalNum = num;        int sumOfPowers = 0;        while (num != 0) &#123;            int digit = num % 10;//每次取出末位            sumOfPowers += Math.pow(digit, 4);            num /= 10;//每次去掉末位        &#125;        return sumOfPowers == originalNum;    &#125;    public static void main(String[] args) &#123;        whileDemo();    &#125;&#125;\r\ncase3-whileDemo-模拟电量消耗\r\npackage com.rabbiter.nekofun;class LoopDemo &#123;    /**     * @Description: 模拟电量消耗的 while 循环示例。     * 初始电量为 65%，每次循环（即一圈）减少 10% 的电量，     * 直到剩余电量不足以完成一圈为止。     * @CoreKnowledge: - 条件语句：在循环中使用条件判断来决定是否继续执行循环体。     * - 变量作用域：定义了两个变量用于跟踪电量和圈数。     */    public static void whileDemo() &#123;        int remainCharge = 65; // 剩余电量        int count = 0; // 记录圈数        // 当剩余电量大于等于 10 时，可以跑一圈        while (remainCharge &gt;= 10) &#123;            count++; // 累加圈数            remainCharge -= 10; // 每跑完一圈减少 10            System.out.printf(&quot;第 %d 圈：剩余电量为 %d\\n&quot;, count, remainCharge); // 格式化输出        &#125;        // 当剩余电量不足 10        if (remainCharge &lt; 10) &#123;            System.out.println(&quot;快没电啦：剩余电量为 &quot; + remainCharge);        &#125;    &#125;    public static void main(String[] args) &#123;        whileDemo();    &#125;&#125;\r\ncase4-whileDemo-定速巡航\r\n\r\n循环次数未知时用while,且循环体要包含趋于结束的语句\r\n\r\npackage com.rabbiter.nekofun;/** * 定速巡航，初始速度50，每隔 1h 提升10,1h、2h后共行驶多少KM **/class LoopDemo&#123;    public static void forDemoCalculateDistance(int speed,int hour)&#123;        int i = 1;        double distance=0;        for(;i&lt;=hour;i++)&#123;              distance += speed * 1;// 每个小时的路程            speed +=10;        &#125;        System.out.println(hour + &quot;小时后行驶了&quot; + distance + &quot;KM&quot;);    &#125;    public static void WhileDemoCalculateDistance(int speed,int hour)&#123;        int i = 1;        double distance=0;        while (i&lt;=hour)&#123;            distance += speed * 1;            speed+=10;            i++;        &#125;        System.out.println(hour + &quot;小时后行驶了&quot; + distance + &quot;KM&quot;);    &#125;    public static void DoWhileDemoCalculateDistance(int speed,int hour)&#123;        int i = 1;        double distance=0;        do&#123;            distance += speed * 1;            speed+=10;            i++;        &#125;while (i&lt;=hour);        System.out.println(hour + &quot;小时后行驶了&quot; + distance + &quot;KM&quot;);    &#125;    public static void main(String[] args) &#123;        forDemoCalculateDistance(50, 5);        System.out.println(&quot;\\n&quot;);        WhileDemoCalculateDistance(50, 5);        System.out.println(&quot;\\n&quot;);        DoWhileDemoCalculateDistance(50, 5);    &#125;&#125;\r\ncase5-whileDemo-考试系统\r\n\r\n\r\nimage-20241215160842540\r\n\r\n\r\n\r\nimage-20241215161119207\r\n\r\npackage com.rabbiter.nekofun;import java.util.Scanner;/** * Exam 类模拟了一个考试系统，考生有5次抽题机会。 * 每次抽取包含 &quot;笔试&quot; 和 &quot;机试&quot; 的两份试题，先进行笔试后进行机试。 * 笔试不及格需要重新抽题；笔试及格但机试不及格也需要重新抽题。 * 如果在5次机会内两项考试均及格，则考试结束，不再抽题。 */ class Exam &#123;    /**     * 执行考试过程的方法。     */    public static void exam() &#123;        int count = 0; // 抽题次数        Scanner sc = new Scanner(System.in); // 创建 Scanner 对象用于输入        try &#123;            while (count &lt; 5) &#123;                count++;                System.out.println(&quot;====第 &quot; + count + &quot; 次考试=====&quot;);                // 笔试部分                System.out.print(&quot;请输入笔试成绩：&quot;);                if (!sc.hasNextInt()) &#123;                    System.out.println(&quot;输入错误，请输入整数！&quot;);                    sc.next(); // 清除无效输入                    continue;                &#125;                int score_1 = sc.nextInt();                if (score_1 &lt; 60) &#123;                    System.out.println(&quot;笔试不及格需重新抽题，总成绩：&quot; + score_1);                    continue;                &#125; else &#123;                    System.out.println(&quot;笔试通过, 成绩：&quot; + score_1);                &#125;                // 机试部分                System.out.print(&quot;请输入机试成绩：&quot;);                if (!sc.hasNextInt()) &#123;                    System.out.println(&quot;输入错误，请输入整数！&quot;);                    sc.next(); // 清除无效输入                    continue;                &#125;                int score_2 = sc.nextInt();                if (score_2 &lt; 60) &#123;                    System.out.println(&quot;机试不及格需重新抽题，总成绩：&quot; + (score_1 + score_2));                    continue;                &#125; else &#123;                    System.out.println(&quot;恭喜，两项考试均合格，总成绩：&quot; + (score_1 + score_2));                    break;                &#125;            &#125;            if (count == 5) &#123;                System.out.println(&quot;5次机会用完，考试结束！&quot;);            &#125;        &#125; finally &#123;            sc.close(); // 确保关闭 Scanner 资源        &#125;    &#125;    public static void main(String[] args) &#123;        exam();    &#125;&#125;\r\ncase6-whileDemo-猜年龄\r\npackage com.rabbiter.nekofun;import java.util.Scanner; class App &#123;    /**     * @Description 猜年龄游戏     * @Author LuoTao     * @Date 2024/12/17 14:28     * @param attempts 抽奖次数     * @param actualAge 真实年龄     */    public static void guessAge(int attempts, int actualAge) &#123;        Scanner sc = new Scanner(System.in);        int age;        boolean guessedCorrectly = false;         System.out.println(&quot;欢迎来到猜年龄游戏！你有 &quot; + attempts + &quot; 次机会。&quot;);        while (attempts &gt; 0 &amp;&amp; !guessedCorrectly) &#123;            System.out.print(&quot;请输入年龄：&quot;);            if (sc.hasNextInt()) &#123;                age = sc.nextInt();                if (age == actualAge) &#123;                    System.out.println(&quot;恭喜你，猜对了！&quot;);                    guessedCorrectly = true;                &#125; else &#123;                    attempts--;                    if (attempts &gt; 0) &#123;                        System.out.println(&quot;没猜对，再来一次吧，你还剩 &quot; + attempts + &quot; 次机会。&quot;);                    &#125;                &#125;            &#125; else &#123;                System.out.println(&quot;输入无效，请输入一个整数。&quot;);                sc.next(); // 清除无效输入            &#125;        &#125;        if (!guessedCorrectly) &#123;            System.out.println(&quot;很遗憾，你没有猜对。正确答案是：&quot; + actualAge);        &#125;        sc.close();    &#125;    public static void main(String[] args) &#123;        guessAge(3, 18);    &#125;&#125;\r\ncase1-DoWhileDemo-购物支付\r\npackage com.rabbiter.nekofun;import java.util.InputMismatchException;import java.util.Scanner;/** （1）计算机输出：请输入钢笔的价格（元）： （2）用户输入：15 （3）计算机输出：请输入水杯的价格（元）： （4）用户输入：22 （5）计算机输出：一共需要支付 37.0 元**/ class DoWhileDemo &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double penPrice = 0.0;        double cupPrice = 0.0;        boolean validInput = false;        // 提示用户输入钢笔的价格，并确保输入有效        do &#123;            try &#123;                System.out.print(&quot;请输入钢笔的价格（元）：&quot;);                penPrice = scanner.nextDouble();                validInput = true; // 如果没有抛出异常，则输入有效            &#125; catch (InputMismatchException e) &#123;                System.out.println(&quot;输入错误，请确保输入的是有效的数字！&quot;);                scanner.nextLine(); // 清除错误输入                validInput = false;            &#125;        &#125; while (!validInput);        validInput = false; // 重置标志位以用于下一个输入        // 提示用户输入水杯的价格，并确保输入有效        do &#123;            try &#123;                System.out.print(&quot;请输入水杯的价格（元）：&quot;);                cupPrice = scanner.nextDouble();                validInput = true; // 如果没有抛出异常，则输入有效            &#125; catch (InputMismatchException e) &#123;                System.out.println(&quot;输入错误，请确保输入的是有效的数字！&quot;);                scanner.nextLine(); // 清除错误输入                validInput = false;            &#125;        &#125; while (!validInput);        // 计算总价        double totalPrice = penPrice + cupPrice;        // 输出总价        System.out.printf(&quot;一共需要支付 %.1f 元\\n&quot;, totalPrice);        // 关闭 Scanner 对象以释放资源        scanner.close();    &#125;&#125;\r\ncase1-forDemo-逢7拍手\r\npackage com.rabbiter.nekofun;class LoopDemo &#123;    /**     * @Description 逢7拍手     **/    public static void forDemo()&#123;        /**        * 个位是7：num %10==7         * 十位是7：num /10 %10==7         * 7的倍数：num %7==0        **/        int num =1;//        for(int num =1;;num&lt;=100;i++)&#123;        for(;;)&#123;            System.out.println(&quot;==第&quot; + num + &quot;次循环==&quot;);            if (num %10==7 || num /10 %10==7 || num %7==0)&#123;                System.out.println(&quot;逢&quot;+ num +&quot;拍手&quot;);            &#125;            num++; //第一百次循环时，num=101跳出循环            if(num &gt;100)&#123;                System.out.println(&quot;num=&quot; + num + &quot;跳出循环&quot;);                break;            &#125;        &#125;        System.out.println(num);//101    &#125;    public static void main(String[] args) &#123;        forDemo();    &#125;&#125;\r\ncase2-forDemo-前 10\r\n排的座位号\r\npackage com.rabbiter.nekofun; class SeatNumberGenerator &#123;    public static void main(String[] args) &#123;        // 输出前10排的座位号        for (int row = 1; row &lt;= 10; row++) &#123;            for (char col = &#x27;A&#x27;; col &lt;= &#x27;F&#x27;; col++) &#123;                System.out.print(row + &quot;&quot; + col + &quot; &quot;);            &#125;            System.out.println(); // 换行        &#125;    &#125;&#125;\r\nBoxingUnboxing\r\npackage com.rabbiter.hello;/** * @Description 自动装箱和拆箱 * 频繁的拆装箱可能会导致影响性能，因为每次转换都会涉及对象的创建和销毁 * * 使用基本类型可以避免装箱和拆箱，提高性能 **/public class BoxingUnboxingExample &#123;    public static void main(String[] args) &#123;        // 装箱        Integer x = 2;     // 装箱，调用了 Integer.valueOf(2)        // 拆箱        int y = x;         // 拆箱，调用了 x.intValue()        // 空指针异常        Integer z = null;        int w = z;  // 抛出 NullPointerException        // 性能考虑        long startTime = System.currentTimeMillis();        Integer sum = 0;        for (int i = 0; i &lt; 1000000; i++) &#123;            /**            * @Description: 每次循环都会进行装箱和拆箱操作             * 拆箱：sum 是一个 Integer 对象，i 是一个 int 类型的变量。在执行 sum += i; 时，sum 首先会被拆箱为 int 类型，即调用 sum.intValue()。             * 装箱：计算结果 sum + i 是一个 int 类型的值，然后这个结果会被装箱为 Integer 类型，即调用 Integer.valueOf(sum + i)。             * 为什么拆箱先行？             *      +运输符要求两操作数都是int类(或同一种基本类型）,首先需要将 sum 拆箱为 int 类型，才能进行加法运算            **/            sum += i;        &#125;        long endTime = System.currentTimeMillis();        System.out.println(&quot;装箱和拆箱耗时: &quot; + (endTime - startTime) + &quot; ms&quot;);        // 使用基本类型替代        startTime = System.currentTimeMillis();        int sum2 = 0;        for (int i = 0; i &lt; 1000000; i++) &#123;            sum2 += i;  // 使用基本类型，避免装箱和拆箱        &#125;        endTime = System.currentTimeMillis();        System.out.println(&quot;基本类型耗时: &quot; + (endTime - startTime) + &quot; ms&quot;);    &#125;&#125;\r\nIntegerCache\r\npackage com.rabbiter.hello;/** * @Classname 缓存池 * Integer 缓存池是Java为了提高性能和减少内存开销而引入的一个机制 * 减少内存开销，提高性能，因为它会重用已有的对象 * 尽量避免使用 new 关键字创建 Integer 对象 *  * Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的 * 在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小 */public class IntegerCacheExample &#123;    public static void main(String[] args) &#123;        // 使用 new 关键字创建 Integer 对象，每次都会创建新对象实例        Integer x = new Integer(123);        Integer y = new Integer(123);        System.out.println(x == y);    // false        /*            Integer.valueOf 方法会使用缓存池来管理 Integer 对象。            对于 -128 到 127 之间的整数，valueOf 方法会返回缓存池中的对象，而不是每次都创建新的对象。         */        Integer z = Integer.valueOf(123);        Integer k = Integer.valueOf(123);        System.out.println(z == k);   // true,对象引用相同        // 超出缓存范围的整数对象也不会共享相同的引用,而会创建新对象        Integer a = Integer.valueOf(128);        Integer b = Integer.valueOf(128);        System.out.println(a == b);   // false        // 使用基本类型比较，==比较的是值而非引用        int m = 123;        int n = 123;        System.out.println(m == n);   // true    &#125;&#125;\r\nString_StringBuffer_StringBuilder\r\npackage com.luotao.job.utils.demo;/*性能比较: *       单线程场景：StringBuilder &gt; StringBuffer &gt; String *       多线程场景：StringBuffer &gt; String * *//** * @Description String * 被声明为 final 而不可被继承 * 不可变：创建后内容不可变（原字符串不变，会在常量池中创建新的字符串），线程安全 * 性能较低：频繁的字符串操作会创建大量临时对象导致性能下降 * * 适用于当字符串内容无需修改时 * java8版本中使用char数组存储数据 * java9版本中改用byte数组存储字符串 * * 不可变的优点： *      String的hash经常被使用，如作为HashMap的key； *      如果一个String对象已被创建过则会从StringPool取得引用； *      String作为网络连接参数时若可变则可能出现安全性问题； *\t\t可以安全地在多个线程间共享； * **/class StringExample &#123;    public static void main(String[] args) &#123;        String str = &quot;neko&quot;;        str += &quot;fun&quot;;// 创建了一个新String对象        System.out.println(str);    &#125;&#125;/** * @Description StringBuffer * 内部使用 synchronized 进行同步以保证线程安全，使用与字符串内容需要频繁修改且在多线程环境的场景 **/class StringBufferExample&#123;    public static void main(String[] args) &#123;        StringBuffer sb = new StringBuffer(&quot;neko&quot;);        sb.append(&quot;fun&quot;);// 修改现有的StringBuffer对象        System.out.println(sb.toString());    &#125;&#125;/** * @Description StringBuilder * 非线程安全，没有同步开销，适用于字符串内容频繁修改且单线程的场景 * **/class StringBuilderExample&#123;    public static void main(String[] args) &#123;        StringBuilder sb1 = new StringBuilder(); // 创建空字符串对象，默认容量16个字符        StringBuilder sb = new StringBuilder(&quot;没头脑和不高兴&quot;);        sb.append(&quot;。&quot;);//没头脑和不高兴。        // 都是左闭右开原则        sb.replace(3,4,&quot;LOVE&quot;); // 没头脑LOVE不高兴。        sb.insert(0, &quot;888&quot;); //888没头脑LOVE不高兴。        sb.delete(0, 3);//没头脑LOVE不高兴。        sb.reverse();        System.out.println(sb.toString());    &#125;&#125;\r\nString Pool\r\n\r\n\r\nimage-20250313141641676\r\n\r\npackage com.rabbiter.hello;/** * @Classname 字符串常量池 * JVM 中用于存储字符串字面量和字符串对象的引用的一块内存区域来管理和重用字符串对象以节省内存 * 池中的对象的唯一的 */ class StringPoolExample &#123;    public static void main(String[] args) &#123;        String user1 = &quot;neko&quot;;        String user2 = &quot;neko&quot;;// 若字符串常量池中存在相同字符串则返回已有字符串引用        System.out.println(user1 == user2);// ture,都引用字符串常量池中的同一个 neko 对象        String userA = new String(&quot;admin&quot;);// 两次创建对象：池中不存在 admin 则在池中将其创建，同时在堆内存中也创建一个新 String 对象，其内容是池中的 admin        String userB = new String(&quot;admin&quot;);        System.out.println(userA==userB);// false,引用不同，都会在堆内存中创建新的对象    &#125;&#125;/*** @Description: intern 若池中已存在相同字符串则返回其引用，否则将字符串对象添加到池中并返回其引用**/class StringInternExample&#123;    public static void main(String[] args) &#123;        String stu1 = new String(&quot;kuroneko&quot;);        String stu2 = &quot;kuroneko&quot;;        System.out.println(stu1==stu2);//false        System.out.println(stu1.equals(stu2);// true 比较内容        System.out.println(&quot;abc&quot;.equalsIgnoreCase(&quot;ABC&quot;)); // true 忽略大小写比较内容        stu1 = new String(&quot;kuroneko&quot;).intern();// 引用了已存在的 kuroneko        System.out.println(stu1==stu2);// true    &#125;&#125;    static void equalsDemo(String userName, String password, String verifyCode) &#123;        if (verifyCode.equals(&quot;abc&quot;.toLowerCase()))&#123;            if (userName.length()!=0 &amp;&amp; password.length()!=0)&#123;                if (userName.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;123&quot;))&#123;                    System.out.println(&quot;登录成功&quot;);                &#125;else &#123;                    System.out.println(&quot;用户名或密码错误&quot;);                &#125;            &#125;else&#123;                System.out.println(&quot;用户名或密码不能为空&quot;);            &#125;        &#125;else&#123;            System.out.println(&quot;验证码错误&quot;);        &#125;    &#125;                               static void strDemo() &#123;        String img_path = &quot;C:\\\\Users\\\\T\\\\Pictures\\\\img.png&quot;;        int index1 = img_path.indexOf(&quot;\\\\&quot;);        if (index1 != -1) &#123;            System.out.println(&quot;盘符&quot; + img_path.substring(0,index1 ));         &#125;        int index2 = img_path.lastIndexOf(&quot;\\\\&quot;);        if (index2 != -1) &#123;            System.out.println(&quot;文件名&quot; + img_path.substring(index2+1));        &#125;        System.out.println(img_path.replace(&quot;png&quot;,&quot;jpg&quot;));    &#125;\r\n数组\r\n\r\n\r\n数组的元素相同数据类型、是有序的、可重复的\r\n创建后长度和类型不可变\r\n\r\n\r\n\r\n\r\nimage-20250313112746476\r\n\r\n\r\n\r\nimage-20250313112858349\r\n\r\npackage com.luotao.container;import java.util.Arrays;/** * @Classname ArrayDemo * @Description 数组 * - 数组的元素相同数据类型、是有序的、可重复的 * - 创建后长度和类型不可变 * 缺点：(后来设计出集合来规避这些缺点) * - 底层基于紧密结构(即顺序结构)导致增删效率低 * - 数组中实际存储的元素数量没有提供对应方法来获取 * @Version 1.0.0 * @Date 2025/2/25 20:24 * @Author LuoTao */public class ArrayDemo &#123;    public static void main(String[] args) &#123;        arrayInit();        arrayBubbleSort();        arrayReverse();        arrayTwo();    &#125;    /**     * @Description 创建数组的三种写法     * 有序。     * 创建后长度不可变。     * 元素的数据类型相同。     * @Author LuoTao     * @Date 2025/2/25 20:44     **/    static void arrayInit()&#123;        int[] arrA;        arrA= new int[5];        int[] arrB=&#123;1,2,3,4,5&#125;;// 静态初始化        int[] arrC = new int[]&#123;6,7&#125;;// 静态初始化        System.out.println(arrA.length); //数组长度        arrB=arrC; //true 引用类型: arrB和arrC指向同一块堆内存地址        System.out.println(arrB==arrC);        System.out.println(Arrays.toString(arrB));    &#125;    /**     * @Description: 冒泡排序     * @Author: LuoTao     * @Date: 2025-02-25 20:47:54     **/    static void arrayBubbleSort()&#123;        //重复地遍历待排序的序列，依次比较相邻的两个元素并交换顺序不对的元素，直到整个序列有序为止。        int[] ages = &#123;5,4,3,2,1&#125;;        System.out.println(Arrays.toString(ages));        //外层循环的次数决定了需要进行多少轮比较和交换。(第0轮比较，未排序的有length个，需要两两比较length-1次；第1轮比较，为排序的有length-1个，需要两两比较length-1-1次        for (int i=0;i&lt;ages.length-1;i++)&#123;            System.out.println(&quot;第&quot;+i+&quot;轮比较,未排序的有&quot; +(ages.length-i) + &quot;个,需要两两交换&quot; + (ages.length-i-1) + &quot;次(每轮循环结束后都排好了一位):&quot;   );            for (int j=0;j&lt;ages.length-1-i;j++)&#123;//在每一轮外层循环结束时，最大的元素会被移动到数组的末尾位置，因此不需要再对其进行比较。                if( ages[j] &gt;ages[j+1] )&#123;                    // 交换顺序                    int tmp = ages[j];                    ages[j] = ages[j+1];                    ages[j+1] = tmp;                &#125;                System.out.println(Arrays.toString(ages));            &#125;        &#125;//        Arrays.sort(ages); //默认升序 [1, 2, 3, 4, 5]    &#125;    /**     * @Description: 数组元素颠倒顺序     * 可以想象成一个队伍中的人在换位子，站在队头第一个人和队尾最后一个人交换位置，第二个人和倒数第二个人交换位置，以此类推，直到中间位置为止     * @Author: LuoTao     * @Date: 2025-03-03 11:02:24     **/    static void arrayReverse()&#123;        int[] ages = &#123;5,4,3,2,1&#125;;        for (int i=0;i&lt;ages.length/2;i++)&#123;            // 保存当前元素到临时变量            int tmp = ages[i];            // 将当前元素替换为对称位置的元素            ages[i] = ages[ages.length-1-i];            // 将对称位置的元素替换为临时变量中的元素，完成两个元素的交换            ages[ages.length-1-i] = tmp;            System.out.println(&quot;第&quot; +i+&quot;轮比较&quot; + Arrays.toString(ages) );        &#125;    &#125;    /**     * @Description: 二维数组计算个人平均分和各科平均分     * @Author: LuoTao     * @Date: 2025-03-13 11:24:13     **/    static void arrayTwo()&#123;        float[][] score = &#123;&#123;100f, 99f, 98.5f&#125;, &#123;80f, 95f, 92f&#125;, &#123;100f, 95.5f, 95f&#125;&#125;;        float sumScore;// 个人总分        float avgScore;// 个人平均分        float sum_chinese=0.0f;//语文总分        float sum_math=0.0f;//数学总分        float sum_english=0.0f;//英语总分        for (int row = 0; row &lt; score.length; row++) &#123;            sumScore=0.0f;            avgScore=0.0f;            for (int col = 0; col &lt; score[row].length; col++)&#123;                sumScore += score[row][col];                avgScore=sumScore/score[row].length;            &#125;            System.out.println(&quot;第&quot; + (row+1) + &quot;个学生平均分：&quot; + avgScore);            sum_chinese +=score[row][0];            sum_math +=score[row][1];            sum_english +=score[row][2];        &#125;        System.out.println(&quot;语文平均分：&quot; + sum_chinese/score.length);        System.out.println(&quot;数学平均分：&quot; + sum_math/score.length);        System.out.println(&quot;英语平均分：&quot; + sum_english/score.length);    &#125;&#125;\r\nJava面向对象编程(OOP)学习笔记\r\n1. 面向对象基本概念\r\n面向对象编程(Object-Oriented\r\nProgramming)是一种编程范式，它将现实世界中的事物抽象为程序中的对象。\r\n面向对象编程就像是在搭建乐高积木。每个积木块都是一个对象，它们有自己的特征（属性）和功能（方法）。通过组合不同的积木块，我们可以创建出复杂的结构。\r\n主要特点： 1. 对象是程序的基本单元 2. 每个对象都包含数据和代码 3.\r\n程序是多个对象相互协作的结果\r\n面向对象的基本原则\r\n\r\n封装：把相关的数据和方法组织在一起\r\n继承：在已有类的基础上创建新类\r\n多态：同一个操作作用于不同的对象，产生不同的执行结果\r\n\r\n1.1 类与对象的关系\r\n\r\n类(Class)：对象的模板，定义对象的属性和行为\r\n对象(Object)：类的具体实例\r\n关系：类好比是设计图，对象则是根据设计图制造的具体产品\r\n\r\n1.2 三大特性\r\n(1) 封装性(Encapsulation)\r\n\r\n封装就像是把糖果放在盒子里，外界只能通过盒子提供的方式（开盖子）来访问里面的糖果，而不能直接触碰糖果。\r\n\r\n\r\n定义：将对象的属性和方法包装在一起，隐藏实现细节\r\n目的：\r\n\r\n保护数据安全\r\n提高代码可维护性\r\n降低代码耦合度\r\n\r\n实现方式：\r\n\r\n使用访问修饰符(private, protected, public)\r\n提供getter/setter方法访问私有属性\r\n\r\n\r\n(2) 继承性(Inheritance)\r\n\r\n继承就像父母和孩子的关系，孩子会继承父母的特征，同时也可以拥有自己的特征。\r\n\r\n\r\n定义：子类继承父类的属性和方法，实现代码复用\r\n特点：\r\n\r\nJava只支持单继承（一个类只能有一个直接父类）\r\n可以实现多个接口\r\n所有类都默认继承Object类\r\n\r\n关键字：\r\n\r\nextends：类继承\r\nimplements：实现接口\r\n\r\n\r\n(3) 多态性(Polymorphism)\r\n\r\n多态就像遥控器，同一个按钮可以控制不同的电器，产生不同的效果。\r\n\r\n\r\n定义：同一个行为具有多个不同表现形式\r\n实现方式：\r\n\r\n方法重载(Overload)：同一个类中，方法名相同，参数列表不同,如有参构造和无参构造方法也是重载。\r\n方法重写(Override)：子类重写父类的方法\r\n\r\n\r\n2. 面向对象vs面向过程\r\n\r\n\r\n\r\n面向对象\r\n面向过程\r\n\r\n\r\n\r\n\r\n以对象为中心\r\n以过程为中心\r\n\r\n\r\n更接近人类思维方式\r\n按步骤顺序执行\r\n\r\n\r\n更容易维护、复用、扩展\r\n代码复用性差\r\n\r\n\r\n适合大型项目\r\n适合简单的功能实现\r\n\r\n\r\n\r\n3. 对象内存\r\n3.1 Java内存区域\r\nJava虚拟机(JVM)在运行时将数据分为以下几个区域：\r\n\r\n栈内存(Stack)\r\n\r\n存储局部变量\r\n基本数据类型直接存储在栈中\r\n引用类型变量存储对象的引用（地址）\r\n特点：\r\n\r\n线程私有\r\n随方法调用而创建，方法结束而销毁\r\n存取速度快\r\n\r\n\r\n堆内存(Heap)\r\n\r\n存储对象的实际内容\r\n所有通过new关键字创建的对象\r\n特点：\r\n\r\n线程共享\r\n由垃圾回收器管理\r\n存取速度相对较慢\r\n\r\n\r\n\r\n3.2 对象的创建和使用过程\r\nclass Person &#123;    private String name;  // 实例变量，存储在堆内存    private int age;      // 实例变量，存储在堆内存&#125;public void test() &#123;    // 1. 在栈内存中创建p1引用变量    // 2. 在堆内存中创建Person对象    // 3. p1引用变量存储Person对象的地址    Person p1 = new Person();          // p2和p1指向同一个对象    Person p2 = p1;  &#125;\r\n3.3 内存分配示意图\r\n\r\n\r\nimage-20250313134944581\r\n\r\n5. Java参数传递机制\r\nJava中的参数传递机制是初学者容易混淆的概念之一。正确理解这一机制对于编写可靠的代码至关重要。\r\n5.1 基本概念：Java只有”值传递”\r\nJava的参数传递机制可以概括为一句话：Java只有值传递，没有引用传递。\r\n\r\n值传递(Pass by\r\nValue)：方法调用时，实际参数的值被复制一份传递给形式参数。方法内对参数的修改不会影响到实际参数。\r\n引用传递(Pass by\r\nReference)：方法调用时，传递的是实际参数的引用（即内存地址）。方法内对参数的修改会影响到实际参数。Java中不存在这种机制。\r\n\r\n5.2 基本类型参数传递\r\n对于基本数据类型（如int, float, boolean等），传递的是值的副本。\r\npublic static void main(String[] args) &#123;    int x = 10;    System.out.println(&quot;调用前 x = &quot; + x);  // 输出：调用前 x = 10    changeValue(x);    System.out.println(&quot;调用后 x = &quot; + x);  // 输出：调用后 x = 10（不变！）&#125;public static void changeValue(int num) &#123;    num = 20;  // 只改变了副本，不影响原始值    System.out.println(&quot;方法内 num = &quot; + num);  // 输出：方法内 num = 20&#125;\r\n5.3 引用类型参数传递\r\n对于引用类型（如类、数组等），传递的是引用（地址）的副本，而不是对象本身的副本。\r\npublic static void main(String[] args) &#123;    Person p = new Person(&quot;张三&quot;);    System.out.println(&quot;调用前 name = &quot; + p.name);  // 输出：调用前 name = 张三    changeName(p);    System.out.println(&quot;调用后 name = &quot; + p.name);  // 输出：调用后 name = 李四（改变了！）&#125;public static void changeName(Person person) &#123;    person.name = &quot;李四&quot;;  // 修改的是同一个对象&#125;class Person &#123;    String name;    public Person(String name) &#123;        this.name = name;    &#125;&#125;\r\n5.4 容易混淆的案例\r\n虽然对象传递看起来像”引用传递”，但下面的例子可以证明Java确实是值传递：\r\npublic static void main(String[] args) &#123;    Person p = new Person(&quot;张三&quot;);    System.out.println(&quot;调用前 p.name = &quot; + p.name);  // 输出：调用前 p.name = 张三    System.out.println(&quot;调用前 p = &quot; + p);            // 输出对象的内存地址        changeReference(p);        System.out.println(&quot;调用后 p.name = &quot; + p.name);  // 输出：调用后 p.name = 张三（不变！）    System.out.println(&quot;调用后 p = &quot; + p);            // 内存地址不变&#125;public static void changeReference(Person person) &#123;    person = new Person(&quot;李四&quot;);  // 创建新对象，改变了副本引用的指向    System.out.println(&quot;方法内 person.name = &quot; + person.name);  // 输出：方法内 person.name = 李四&#125;\r\n在这个例子中，虽然在changeReference方法内部创建了新的Person对象并将参数引用指向它，但这只改变了参数引用的副本，原始引用p仍然指向原来的对象。\r\n5.5 参数传递机制的内存分析\r\n基本类型传递：\r\n调用changeValue(x)前：    栈内存：    +--------+    | x = 10 |    +--------+调用changeValue(x)时：    栈内存：    +--------+    +----------+    | x = 10 |    | num = 10 |  (x的值复制给num)    +--------+    +----------+changeValue执行后：    栈内存：    +--------+    +----------+    | x = 10 |    | num = 20 |  (num改变，x不受影响)    +--------+    +----------+\r\n引用类型传递：\r\n调用changeName(p)前：    栈内存：              堆内存：    +-------+             +----------------+    | p -&gt;  |-----------&gt;| Person对象      |    +-------+             | name = &quot;张三&quot;   |                         +----------------+调用changeName(p)时：    栈内存：              堆内存：    +-------+             +----------------+    | p -&gt;  |--+          | Person对象      |    +-------+  |          | name = &quot;张三&quot;   |               |          +----------------+    +-----------+                 ^    | person -&gt; |-----------------|    +-----------+  (p的引用复制给person)changeName执行后：    栈内存：              堆内存：    +-------+             +----------------+    | p -&gt;  |--+          | Person对象      |    +-------+  |          | name = &quot;李四&quot;   | (对象内容改变)               |          +----------------+    +-----------+                 ^    | person -&gt; |-----------------|    +-----------+调用changeReference(p)前：    栈内存：              堆内存：    +-------+             +----------------+    | p -&gt;  |-----------&gt;| Person对象1     |    +-------+             | name = &quot;张三&quot;   |                         +----------------+调用changeReference(p)时：    栈内存：              堆内存：    +-------+             +----------------+    | p -&gt;  |--+          | Person对象1     |    +-------+  |          | name = &quot;张三&quot;   |               |          +----------------+    +-----------+                 ^    | person -&gt; |-----------------|    +-----------+  (p的引用复制给person)changeReference执行中创建新对象后：    栈内存：              堆内存：    +-------+             +----------------+    | p -&gt;  |-----------&gt;| Person对象1     |    +-------+             | name = &quot;张三&quot;   |                         +----------------+    +-----------+             | person -&gt; |--------&gt;+----------------+    +-----------+         | Person对象2     |                          | name = &quot;李四&quot;   |                         +----------------+\r\n5.6 最佳实践\r\n\r\n清晰理解：记住Java总是值传递，但对于对象，传递的是引用的值（地址）。\r\n方法返回：如果需要在方法中修改对象并保留更改，可以：\r\n\r\n修改传入对象的属性（如上例中的changeName）\r\n返回新的对象\r\n\r\n不可变对象：使用不可变对象（如String）可以减少副作用。\r\n注意事项：\r\n\r\n方法内创建的新对象不会影响原始引用\r\n对数组和集合的操作会影响原始数据\r\nString是特例，由于其不可变性，所有看似”修改”的操作实际上都是创建新的String对象\r\n\r\n\r\n5.7 实际应用示例\r\n例1：交换两个数（不成功）\r\npublic static void main(String[] args) &#123;    int a = 10, b = 20;    System.out.println(&quot;交换前：a = &quot; + a + &quot;, b = &quot; + b);    swap(a, b);    System.out.println(&quot;交换后：a = &quot; + a + &quot;, b = &quot; + b);  // 值不变&#125;public static void swap(int x, int y) &#123;// xy其实是a,b的副本    int temp = x;    x = y;    y = temp;&#125;\r\n例2：交换数组元素（成功）\r\npublic static void main(String[] args) &#123;    int[] arr = &#123;10, 20&#125;;    System.out.println(&quot;交换前：arr[0] = &quot; + arr[0] + &quot;, arr[1] = &quot; + arr[1]);    swapElements(arr);    System.out.println(&quot;交换后：arr[0] = &quot; + arr[0] + &quot;, arr[1] = &quot; + arr[1]);  // 值改变&#125;public static void swapElements(int[] arr) &#123;// arr的值是引用（地址）的副本，值与实参arr的值相同，都是数组在堆内存中的地址,会直接影响原始对象。    int temp = arr[0];    arr[0] = arr[1];    arr[1] = temp;&#125;\r\n抽象类与接口\r\n\r\n实现多态和代码复用的重要工具\r\n\r\n抽象类的本质\r\n定义与特点\r\n\r\n抽象类是一种不能被实例化的类，它的目的是为子类提供一个通用的模板，强制子类实现某些方法，同时允许复用公共代码。\r\n抽象类就像是一个半成品的模具，需要子类来完善。\r\n\r\npackage com.luotao.job.utils.demo;public abstract class Animal&#123;    // 实例变量    protected String name;    protected int age;    //构造方法    public Animal(String name,int age)&#123;        this.name=name;        this.age=age;    &#125;    // 具体方法（可以被继承）    public void sleep()&#123;        System.out.println(name + &quot; is sleeping&quot;);    &#125;        //抽象方法（必须被子类实现）    public abstract void makeSound();&#125;\r\n抽象类的关键特点：\r\n\r\n使用abstract关键字声明\r\n不能被实例化\r\n可以包含抽象方法（无方法体的方法）\r\n子类必须实现所有抽象方法，除非子类也是抽象类\r\n可以包含具体方法（有方法体的方法）\r\n可以包含构造方法、实例变量、静态方法、静态变量等\r\n\r\n抽象类的设计理念\r\n抽象类体现了“是什么”的关系，定义了一系列子类的共同特性。它表达了继承层次中的抽象概念，如”动物”、“形状”、“车辆”等。\r\n抽象类的核心设计理念：\r\n\r\n*强制规范*：通过抽象方法强制子类提供特定行为的实现\r\n*代码复用*：通过具体方法提供可被所有子类继承的公共代码\r\n*类型统一*：提供一个统一类型，使得不同子类对象可以被一致处理\r\n\r\n接口的本质\r\n\r\n接口就像是一份合同，实现接口的类必须履行合同规定的义务。\r\n在 Java\r\n中，接口可以被看作是一种“契约”，只要某个类实现了某个接口，它就可以被视为该接口类型的对象。\r\n\r\n接口是一种完全抽象的类型，它只定义行为的规范（方法签名），不提供具体实现（java8之前）。接口代表了能做什么的契约。\r\npublic interface Flyable&#123;    // 抽象方法（隐式public abstract）    void fly();        // 常量（隐式public static final）    int MAX_ALTITUDE=10000;        // java8引入：默认方法    default void glide()&#123;        System.out.println(&quot;Gliding in the air&quot;)    &#125;        // java8引入：静态方法    static boolean canFly(Object obj)&#123;        return ojb instanceof Flyable;    &#125;        // java9引入：私有方法    private void calculateTrajectory()&#123;        // 内部计算逻辑    &#125;&#125;\r\n接口的关键特点：\r\n\r\n使用interface关键字声明\r\n所有方法隐式为public abstract(除非是默认、静态或私有方法)\r\n所有字段隐式为public static final(常量)\r\n一个类可以实现多个接口（弥补了java单继承的局限性）\r\n接口可以继承一个或多个其他接口\r\n\r\n接口的设计理念\r\n接口体现了“能做什么”的关系，定义了对象的能力或行为契约。它表达了不同对象间的共同行为，如”可飞行的”、“可比较的”、“可运行的”等。\r\n接口的核心设计理念： 1.\r\n行为契约：定义对象应该具备的能力，而不关心对象”是什么”\r\n2.\r\n松耦合：允许不同类型的对象只要实现相同接口就能被一致处理\r\n3. 多重实现：一个类可以实现多个接口，获得多种能力 4.\r\n插件式设计：为系统提供可插拔的功能模块\r\n7.3 抽象类与接口的深度对比\r\n7.3.1 本质区别\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\n抽象类\r\n接口\r\n\r\n\r\n\r\n\r\n核心理念\r\n是什么 - 强调本质\r\n能做什么 - 强调能力\r\n\r\n\r\n继承关系\r\n单继承（一个子类只能继承一个抽象类）\r\n多实现（一个类可以实现多个接口）\r\n\r\n\r\n方法特性\r\n可以有具体方法和抽象方法\r\n主要是抽象方法（Java 8后可有默认方法）\r\n\r\n\r\n字段特性\r\n可以有实例变量、常量\r\n只能有常量（隐式public static final）\r\n\r\n\r\n构造方法\r\n可以有构造方法\r\n不能有构造方法\r\n\r\n\r\n访问修饰符\r\n方法可以是private、protected等\r\n方法隐式为public（Java 9开始可有private方法）\r\n\r\n\r\n实例化\r\n不能直接实例化\r\n不能实例化\r\n\r\n\r\n使用场景\r\n定义具有相似特性的类的共同基类\r\n定义不相关类之间的共同行为规范\r\n\r\n\r\n\r\n7.3.2 深层理解\r\n\r\n抽象类是对类的抽象，表达的是”is-a”关系（继承体系）\r\n接口是对行为的抽象，表达的是”has-a”关系（能力）\r\n抽象类可以对方法提供默认实现，更注重复用性\r\n接口更纯粹地关注行为规范，更注重解耦\r\n\r\n7.4 Java 8+对接口的增强\r\nJava 8及以后版本对接口做了重要增强，使接口的功能更加强大。\r\n7.4.1 默认方法（Default Methods）\r\n允许接口提供方法的默认实现，实现类可以直接使用或覆盖。\r\npublic interface Vehicle &#123;    void accelerate();        // 默认方法    default void brake() &#123;        System.out.println(&quot;Standard braking mechanism&quot;);    &#125;&#125;\r\n默认方法的意义： - 允许在不破坏现有实现的情况下扩展接口 -\r\n提供可选功能的实现 - 减少接口实现类中的重复代码\r\n7.4.2 静态方法（Static Methods）\r\n允许接口包含静态方法，这些方法属于接口本身，不能被实现类继承。\r\npublic interface MathOperations &#123;    // 静态方法    static int add(int a, int b) &#123;        return a + b;    &#125;&#125;// 调用方式int result = MathOperations.add(5, 3);\r\n静态方法的意义： - 为接口提供工具方法 - 增强接口的自包含性 -\r\n减少对工具类的依赖\r\n7.4.3 私有方法（Java 9引入）\r\n允许接口包含私有方法，用于在默认方法之间共享代码。\r\npublic interface Logger &#123;    default void logInfo(String message) &#123;        log(message, &quot;INFO&quot;);    &#125;        default void logError(String message) &#123;        log(message, &quot;ERROR&quot;);    &#125;        // 私有方法（Java 9+）    private void log(String message, String level) &#123;        System.out.println(level + &quot;: &quot; + message);    &#125;&#125;\r\n私有方法的意义： - 提高接口内部代码的复用性 - 使默认方法更简洁 -\r\n增强封装性\r\n7.5 实际应用案例\r\n7.5.1 抽象类的典型应用\r\n模板方法模式：定义算法骨架，让子类实现特定步骤。\r\npublic abstract class DataProcessor &#123;    // 模板方法    public final void processData() &#123;        readData();        processData();        saveData();        notifyCompletion();    &#125;        // 抽象方法 - 子类必须实现    protected abstract void readData();    protected abstract void processData();    protected abstract void saveData();        // 具体方法 - 提供默认实现    protected void notifyCompletion() &#123;        System.out.println(&quot;Data processing completed&quot;);    &#125;&#125;\r\n7.5.2 接口的典型应用\r\n策略模式：定义一系列算法，使它们可以互相替换。\r\n// 定义策略接口public interface SortingStrategy &#123;    void sort(int[] array);&#125;// 实现具体策略public class QuickSort implements SortingStrategy &#123;    @Override    public void sort(int[] array) &#123;        // 快速排序实现    &#125;&#125;public class MergeSort implements SortingStrategy &#123;    @Override    public void sort(int[] array) &#123;        // 归并排序实现    &#125;&#125;// 使用策略public class Sorter &#123;    private SortingStrategy strategy;        public Sorter(SortingStrategy strategy) &#123;        this.strategy = strategy;    &#125;        public void doSort(int[] array) &#123;        strategy.sort(array);    &#125;&#125;\r\n7.6\r\n何时使用抽象类，何时使用接口？\r\n7.6.1 选择抽象类的情况\r\n\r\n需要在多个相关类之间共享代码\r\n需要定义非静态或非常量字段（实例变量）\r\n相关类之间存在”is-a”关系\r\n需要为子类提供多个方法的默认实现\r\n需要非公开的方法\r\n需要构造方法\r\n\r\n7.6.2 选择接口的情况\r\n\r\n需要定义一种能力，多个不相关的类可能具备此能力\r\n需要支持多继承的类型\r\n只关心对象能做什么，而不关心对象是什么\r\n需要指定的行为契约，但不关心该行为如何实现\r\n需要将行为从具体实现中解耦\r\n\r\n7.7 最佳实践与设计原则\r\n\r\n优先使用接口：\r\n\r\n接口提供了更好的解耦性和灵活性\r\n接口更容易适应未来的变化\r\n“面向接口编程，而不是面向实现编程”\r\n\r\n合理组合使用：\r\n\r\n抽象类与接口可以配合使用\r\n接口定义能力，抽象类提供部分默认实现\r\n\r\n接口隔离原则：\r\n\r\n一个类不应该被迫依赖它不使用的方法\r\n接口应该小而精，而不是大而全\r\n\r\n设计层次分明的继承体系：\r\n\r\n抽象应该从具体中提取\r\n避免过深的继承层次\r\n\r\n避免接口污染：\r\n\r\n不要在接口中添加过多方法\r\nJava 8后，可以使用默认方法扩展接口\r\n\r\n\r\n访问权限修饰符\r\n\r\n\r\n访问权限修饰符\r\n\r\n\r\nprivate——仅在 当前类中访问（private 方法隐式地被指定为 final）\r\ndefault——同包访问\r\nprotected——同包访问、子类访问\r\npublic——所有类访问\r\n\r\n封装\r\n设计良好的模块会隐藏所有的实现细节，把它的\r\nAPI与它的实现清晰地隔离开来。模块之间只通过它们的\r\nAPI进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。\r\n通过将属性设为私有并提供公共的getter和setter方法，将数据和操作数据的方法绑定在一起，隐藏对象的内部实现细节，只暴露必要的接口给外部使用。我们实现了对类的封装。这样可以保护类的内部状态，防止外部直接修改，同时提供必要的接口供外部使用。\r\n构造方法\r\n特殊成员方法，在实例化对象时JVM自动调用构造方法。构造方法被调用时JVM自动根据参数类型匹配对象的构造方法的参数列表，若和某个构造方法的参数列表匹配上了则将其调用。\r\n\r\n\r\n构造方法\r\n\r\n\r\n默认构造方法——若类没有显示声明构造则在编译时自动添加无参构造\r\n\r\ncase-银行存取款\r\npackage com.rabbiter.hello;/** * @ClassName BankAccount * @Description 银行存取款 * @Author LuoTao * @Date 2024-05-02 14:42 * @Version 1.0 **/public class BankAccount &#123;    /**     * 账户     */    private int accountNumber;    /**     * 余额     */    private double leftmoney;    /**     * @param number 账号     * @param money 初始余额     * @return null     * @Author LuoTao     * @Description 构造方法     * @Date 2024-05-02 15:27:21     **/    public BankAccount(int number, double money) &#123;        this.accountNumber = number;        this.leftmoney = money;    &#125;    /**     * @return 存的钱     * @Author LuoTao     * @Description 存款方法     * @Date 2024-05-02 15:09:59     * @Param 存的钱     **/    public double saveMoney(double money) &#123;        this.leftmoney += money;        return money;    &#125;    /**     * @return 现有余额     * @Author LuoTao     * @Description 获取现有余额     * @Date 2024-05-02 15:12:25     * @Param     **/    public double getLeftmoney() &#123;        return this.leftmoney;    &#125;    /**     * @return 取走金额     * @Author LuoTao     * @Description 取款     * @Date 2024-05-02 15:14:42     * @Param     **/    public double getMoney(double money) &#123;        this.leftmoney -= money;        return money;    &#125;&#125;/** * @Description 客户端存取钱 **/class BankAccountClient &#123;    public static void main(String[] args) &#123;        BankAccount ba = new BankAccount(10086, 0);        System.out.println(&quot;存款&quot; + ba.saveMoney(1000) + &quot;, 余额=&quot; + ba.getLeftmoney() );//存款1000.0, 余额=1000.0        System.out.println(&quot;取款&quot; + ba.getMoney(1000) + &quot;, 余额=&quot; + ba.getLeftmoney() );//取款1000.0, 余额=0.0    &#125;&#125;\r\ncase-查看手机配置与功能\r\npackage com.rabbiter.hello;/** * @Description case-查看手机配置与功能 **/public class Phone &#123;    /**     * 手机品牌     */    private String brand;    /**     * 手机价格     */    private double price;    /**     * 手机型号     */    private String type;    /**     * 手机内存     */    private int memorySize;    public Phone() &#123;    &#125;    public Phone(String brand, double price, String type, int memorySize) &#123;        this.brand = brand;        this.price = price;        this.type = type;        this.memorySize = memorySize;    &#125;    public String showInfo() &#123;        return &quot;Phone&#123;&quot; +                &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &quot;, type=&#x27;&quot; + type + &#x27;\\&#x27;&#x27; +                &quot;, memorySize=&quot; + memorySize +                &#x27;&#125;&#x27;;    &#125;    /**     * @Author LuoTao     * @Description 打游戏     * @Date 2024-05-02 16:04:12     * @Param 游戏名     * @return 游戏名     **/    public String playGame(String gameName)&#123;        return gameName + &quot;启动！&quot;;    &#125;    /***     * @Author LuoTao     * @Description 下载音乐     * @Date 2024-05-02 16:02:50     * @Param 下载音乐名     * @return 下载音乐名     **/    public String downMusic(String musicName)&#123;        return &quot;&lt;&quot;+ musicName + &quot;&gt;&quot; + &quot;下载成功！&quot;;    &#125;&#125;class PhoneTest &#123;    public static void main(String[] args) &#123;        Phone p1 = new Phone(&quot;xiaomi&quot;, 1000, &quot;安卓&quot;, 123);        System.out.println(p1.downMusic(&quot;如果没有你&quot;));        System.out.println(p1.playGame(&quot;原神&quot;));        System.out.println(p1.showInfo());    &#125;&#125;\r\nthis调用属性\r\n\r\nthis就是类实例化的对象，和构造方法无关。类中没创建对象，不知道是哪个对象，那就用this来代替，this就表示一个对象。\r\npackage com.luotao.case3;public class User &#123;    private String name;//全局变量null    private int age;//0    // 全局变量和局部变量冲突(参数名和全局变量名重复)则变量取值采取作用域就近原则    public User(String name, int age) &#123;        name = name; // 左边的name和右边的name是同一个变量,相当于屏蔽了全局变量,此处应改为this.name=name        age = age;    &#125;    public void showInfo() &#123;        System.out.println(&quot;姓名：&quot; + name + &quot;,年龄：&quot; + age);    &#125;    public static void main(String[] args) &#123;        User admin = new User(&quot;旺财&quot;,18);        admin.showInfo();//姓名：null,年龄：0    &#125;&#125;\r\nthis调用构造方法\r\npackage com.luotao.case3;public class User &#123;    private String name;    private int age;    public User()&#123;        /**        * @Description: this调用构造方法：this(方法参数列表)        * @Author: LuoTao        * @Date: 2024-05-05 14:18:08        **/        /*           - 必须位于构造方法的第一行           - 原因：对象创建时会调用构造方法，在调用其他构造方法前不能操作对象的成员           - 一个构造方法中只能调用一个其他构造方法        */        this(&quot;旺财&quot;, 18);        System.out.println(name+age);    &#125;    public User(String name, int age) &#123;        //当局部变量与实例变量同名时，使用this区分        this.name = name;        this.age = age;    &#125;    public static void main(String[] args) &#123;        /*        当执行`User user1 = new User();`时：            1. 创建User对象，分配内存空间            2. 调用无参构造方法`public User()`            3. 在无参构造方法中，`this(&quot;旺财&quot;, 18)`调用带参构造方法            4. 执行带参构造方法`public User(String name, int age)`               - `this.name = name`将参数&quot;旺财&quot;赋值给实例变量name               - `this.age = age`将参数18赋值给实例变量age            5. 带参构造方法执行完毕，返回到无参构造方法            6. 执行`System.out.println(name+age)`，输出&quot;旺财18&quot;            7. 无参构造方法执行完毕，对象创建完成        */        User user1 = new User();//旺财18        /*\r\n    栈内存                    堆内存\r\n    +----------+          +-------------------+\r\n    | user1    |---------&gt;|  User对象          |\r\n    +----------+          |  name: &quot;旺财&quot;      |\r\n                          |  age: 18          |\r\n                          +-------------------+\r\n            */    &#125;&#125;\r\nthis和super\r\n\r\n\r\nthis表示当前类对象，可访问当前类的成员，若本类中找不到则从父类中找。调用本类构造，需放在构造的首行\r\nsuper表示父类的成员调用，调父类的构造需放在子类构造的首行\r\n\r\n\r\n\r\n\r\nimage-20250313122205379\r\n\r\ncase-基于控制台的购书系统\r\npackage com.luotao.case4;/** * @Classname Book * @Description 图书实体 * @Version 1.0.0 * @Date 2024/5/5 14:44 * @Author LuoTao */public class Book &#123;    /***    * @Description: 图书编号    * @Author: LuoTao    * @Date: 2024-05-05 14:50:57    **/    private int id;    /**    * @Description: 图书名称    * @Author: LuoTao    * @Date: 2024-05-05 14:51:30    **/    private String name;    /**    * @Description: 图书单价    * @Author: LuoTao    * @Date: 2024-05-05 14:51:40    **/    private  double price;    /**    * @Description: 图书库存    * @Author: LuoTao    * @Date: 2024-05-05 14:52:28    **/    private int storage;    public Book() &#123;    &#125;    public Book(int id, String name, double price, int storage) &#123;        this.id = id;        this.name = name;        this.price = price;        this.storage = storage;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double getPrice() &#123;        return price;    &#125;    public void setPrice(double price) &#123;        this.price = price;    &#125;    public int getStorage() &#123;        return storage;    &#125;    public void setStorage(int storage) &#123;        this.storage = storage;    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &quot;, storage=&quot; + storage +                &#x27;&#125;&#x27;;    &#125;&#125;\r\npackage com.luotao.case4;/** * @Classname Order * @Description 订单实体 * @Version 1.0.0 * @Date 2024/5/5 14:48 * @Author LuoTao */public class Order &#123;    /**    * @Description: 订单号    * @Author: LuoTao    * @Date: 2024-05-05 15:02:31    **/    private int orderId;    /**    * @Description: 订单总金额    * @Author: LuoTao    * @Date: 2024-05-05 15:02:57    **/    private double total;    /**    * @Description: 订单项数组    * @Author: LuoTao    * @Date: 2024-05-05 15:06:25    **/    private OrderItem[] items;    public Order(int orderId)&#123;        this.orderId = orderId;        /**        * @Description: 初始化数组长度3：强制购买3次图书        * @Author: LuoTao        * @Date: 2024-05-05 15:09:30        **/        this.items = new OrderItem[3];    &#125;    public int getOrderId() &#123;        return orderId;    &#125;    public void setOrderId(int orderId) &#123;        this.orderId = orderId;    &#125;    public double getTotal() &#123;        return total;    &#125;    public void setTotal(double total) &#123;        this.total = total;    &#125;    public OrderItem[] getItems() &#123;        return items;    &#125;    public void setItems(OrderItem[] items) &#123;        this.items = items;    &#125;    /**     * @Description setItem     * @Author LuoTao     * @Date 2024/5/5 16:16     * @return void     * @param index items下标     * @param orderItem     **/    public void setItem(int index,OrderItem orderItem)&#123;        this.items[index] = orderItem;    &#125;&#125;\r\npackage com.luotao.case4;import jdk.nashorn.internal.ir.IfNode;import java.util.Scanner;/** * @Classname PayBooks * @Description 程序入口：支付图书 * @Version 1.0.0 * @Date 2024/5/5 15:12 * @Author LuoTao */public class PayBooks &#123;    public static void main(String[] args) &#123;        /**        * @Description: 展示库房3种类型的图书        * @Author: LuoTao        * @Date: 2024-05-05 15:18:58        **/        Book[] books = new Book[3];        outBooks(books);        Order order = purchase(books);        outOrder(order);    &#125;    /**     * @Description 展示图书实体信息     * @Author LuoTao     * @Date 2024/5/5 15:19     * @return void     * @param books     **/    public static void outBooks(Book[] books)&#123;        System.out.println(&quot;-------基于控制台的购书系统-------&quot;);        System.out.println(&quot;图书编号\\t图书名称\\t图书单价\\t图书库存&quot;);        for(int i=0;i&lt;books.length;i++)&#123;            /**             * @Description 初始化库房图书信息             **/            books[i] = new Book(i + 1, &quot;java&quot; + i, 10 + i, 30);            System.out.println(books[i].getId()+&quot;\\t\\t&quot;+                    books[i].getName()+&quot;\\t\\t&quot;+                    books[i].getPrice()+&quot;\\t\\t&quot;+                    books[i].getStorage());        &#125;        System.out.println(&quot;------------------------------&quot;);    &#125;    /**     * @Description 购买图书方法     * @Author LuoTao     * @Date 2024/5/5 15:46     * @return com.luotao.case4.Order 返回购书订单实体     * @param books 所购买的图书     **/    public static Order purchase(Book[] books)&#123;        Order order = new Order(1001);        OrderItem orderItem=null;        double total=0;//订单总金额        Scanner input = new Scanner(System.in);        for (int i = 0; i &lt; books.length; i++) &#123;            System.out.println(&quot;请输入购买图书编号:&quot;);            int id = input.nextInt();            System.out.println(&quot;请输入购买图书数量&quot;);            int num = input.nextInt();            Book book = books[i];            total += book.getPrice() * num;            orderItem = new OrderItem(book, num);            order.setItem(i,orderItem);            System.out.println(&quot;请继续购买图书...&quot;);        &#125;        order.setTotal(total);        return order;    &#125;    /**     * @param order     * @return void     * @Description 打印订单信息     * @Author LuoTao     * @Date 2024/5/5 16:33     **/    private static void outOrder(Order order) &#123;        System.out.println(&quot;---------------------------&quot;);        System.out.println(&quot;订单编号：&quot;+order.getOrderId());        System.out.println(&quot;订单总金额：&quot;+order.getTotal());        System.out.println(&quot;---------订单项信息---------&quot;);        System.out.println(&quot;图书编号\\t图书名称\\t购买数量\\t图书单价\\t合计&quot;);        for (OrderItem item : order.getItems()) &#123;            System.out.println(item.getBook().getId()+&quot;\\t&quot;+                    item.getBook().getName()+&quot;\\t&quot;+                    item.getNum()+&quot;\\t&quot;+                    item.getBook().getPrice()+&quot;\\t&quot;+                    item.getBook().getPrice()*(item.getNum()));        &#125;    &#125;&#125;\r\n构造代码块\r\n\r\n构造代码块的执行时间由于构造方法，一般用来做类的初始化（读取、加载配置文件）\r\n\r\nclass Student &#123;      private String name;        // 构造代码块      &#123;          name = &quot;luotao&quot;; // 直接访问和修改类成员变量          System.out.println(name); // 打印成员变量的值      &#125;        // 可以添加一个无参构造器来显示构造代码块被调用      public Student() &#123;          // 构造代码块会在这里之前执行      &#125;  &#125;    public class Application &#123;      public static void main(String[] args) &#123;          Student stu = new Student(); // 创建Student对象时，构造代码块将被执行      &#125;  &#125;\r\nstatic\r\n\r\n\r\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\r\n静态字段属于所有实例“共享”的字段，实际上是属于class的字段；\r\n调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法；\r\n静态方法常用于工具类和辅助方法。\r\n因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型\r\n因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。\r\n静态先初始化，先有对象才有对象的成员，非静态成员要先创建对象才能访问，静态成员优于非静态创建，所以静态只能访问静态。即加载时间不一样导致的。\r\n被修饰的属性只会分配一块内存空间，该属性是被所有对象共享的全局或静态属性。\r\n在定义一个类时，只是在描述某事物的特征和行为，并没有产生具体的数据，只有new对象才会开辟栈内存及堆内存。\r\n堆内存中每个对象都有自己的属性，若希望某些属性被所有对象共享则用该关键字修饰。\r\n\r\n\r\nclass Student&#123;    String name;    int age;    Static String school=&quot;A大学&quot;;//被修饰的属性只会分配一块内存空间，该属性是被所有对象共享的全局或静态属性        public Student(String name,int age)&#123;        this.name=name;        this.age=age;            &#125;        public void showInfo()&#123;        System.out.println(name + school);    &#125;&#125;public class Application &#123;    public static void mian(String[] args)&#123;        Student stu1 = new Student(&quot;张三&quot;,18);        Student stu2 = new Student(&quot;张三&quot;,18);        Student stu3 = new Student(&quot;张三&quot;,18);        System.out.println(stu1.school);//对象.属性访问                Student.school=&quot;B大学&quot;;//类名.属性访问并修改值        new Student(&quot;luotao&quot;,24).showInfo();//张三 B大学    &#125;&#125;\r\n\r\n\r\nimage-20240702230631427\r\n\r\n静态代码块\r\n\r\n\r\n对类的成员变量进行初始化\r\n类初次加载时被执行，只一次\r\n静态代码块&gt;构造代码块&gt;构造方法\r\n\r\n\r\npackage com.luotao.demo1;//构造代码块与静态代码块的执行时机 class Student &#123;    //@Description: 1静态代码块    static &#123;        System.out.println(&quot;1静态代码块&quot;);    &#125;    // @Description: 2构造代码块    &#123;        System.out.println(&quot;2构造代码块&quot;);    &#125;    // @Description: 3构造方法    public Student()&#123;        System.out.println(&quot;3构造方法&quot;);    &#125;&#125;/** * @Description: 主线程 * @Author: LuoTao * @Date: 2024-08-13 21:10:23 **/public class App&#123;    public static void main(String[] args)&#123;        //类初次加载时静态代码块被执行，只一次        Student stu1 = new Student();        Student stu2 = new Student();//        1静态代码块//        2构造代码块//        3构造方法//        2构造代码块//        3构造方法    &#125;&#125;\r\nextend\r\npackage com.rabbiter.hello.demo;/*** 用final修饰的类不能被继承* * 继承用来描述类间关系。在现有类基础上构建出的新类作为子类继承父类的属性和方法，使得子类对象具有父类的特征和行为。 * 通过继承复用代码以获得父类的所有功能。 * 子类无法访问父类的`private`字段或方法。 * &lt;p&gt; * 只要某个class没有final修饰符，那么任何类都可以从该class继承。 **/class Main &#123;    public static void main(String[] args) &#123;        Student s = new Student(&quot;Xiao Ming&quot;, 12, 89);        /**         *         *         * Student继承Person,因此拥有父类的全部功能         * Person类型的变量指向Student类型的实例，对其操作没有问题         * 当前继承树：Student &gt; Person &gt; Object         * 向上转型：         *      把子类类型安全的变为父类类型的赋值         *      把子类类型安全的变为更加抽象的父类类型         *         **/        Person p1 = new Student(); // upcasting, ok        Person p2 = new Person();        Student s1 = (Student) p1; // 在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例        /**         * Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。         *         * runtime error! ClassCastException! 把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。         * 因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException         **/        if (p2 instanceof Student) &#123;            // 所指向的实例是否是指定类型才会向下转型            Student s2 = (Student) p2;        &#125;    &#125;&#125;class Person &#123;    protected String name;    protected int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;class Student extends Person &#123;    protected int score;    public Student() &#123;        super();    &#125;    public Student(String name, int age) &#123;        super(name, age);    &#125;    public Student(String name, int age, int score) &#123;        /**         *         * 任何class的构造方法，第一行语句必须是调用父类的构造方法。         * 如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();         *         * 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。         **/        super(name, age);        this.score = score;    &#125;&#125;\r\nPolymorphic\r\npackage com.rabbiter.hello.polymorphic;/*** @Description: 多态* @Author: LuoTao* @Date: 2024-11-21 11:14:26**/public class PolymorphicDemo &#123;    public static void main(String[] args) &#123;        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:        Income[] incomes = new Income[] &#123;                new Income(3000),//300                new Salary(7500),//2500*0.2=500                new StateCouncilSpecialAllowance(15000)//津贴免税        &#125;;        System.out.println(totalTax(incomes));    &#125;    //接受可变数量的 Income 对象,参数会被自动封装成incomes数组    public static double totalTax(Income... incomes) &#123;        double total = 0;        for (Income income: incomes) &#123;            total = total + income.getTax();        &#125;        return total;    &#125;&#125;class Income &#123;    protected double income;    public Income(double income) &#123;        this.income = income;    &#125;    public double getTax() &#123;        return income * 0.1; // 税率10%    &#125;&#125;class Salary extends Income &#123;    public Salary(double income) &#123;        super(income);    &#125;    @Override    public double getTax() &#123;        if (income &lt;= 5000) &#123;            return 0;        &#125;        return (income - 5000) * 0.2;    &#125;&#125;class StateCouncilSpecialAllowance extends Income &#123;    public StateCouncilSpecialAllowance(double income) &#123;        super(income);    &#125;    @Override    public double getTax() &#123;        return 0;    &#125;&#125;\r\n方法重写\r\n\r\n具有直接或间接继承关系且非私有方法。\r\n名称、参数列表及返回值类型需保持一致且权限&gt;=被重写方法的权限。\r\n注解@Override\r\nfinal修饰的方法不能被Override\r\n\r\npackage com.luotao.demoExtends;/** * @Classname Animal * @Description 父类 * @Version 1.0.0 * @Date 2024/10/3 14:51 * @Author LuoTao */class Animal &#123;    private String name;//在子类中无法直接访问私有属性或方法    int age;    public Animal() &#123;        System.out.println(&quot;我是父类无参构造&quot;);    &#125;    public Animal(String name, int age) &#123;        this.name = name;        this.age = age;        System.out.println(&quot;我是父类有参构造&quot;);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Animal&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;    public void eat()&#123;        System.out.println(&quot;所有动物都会叫&quot;);    &#125;&#125;/** * @Description: Cat继承Animal的属性和方法 * @Author: LuoTao * @Date: 2024-10-03 14:55:23 */class Cat extends Animal &#123;    private String color; // 子类特有的属性：颜色    // 子类构造    public Cat() &#123;        super();        System.out.println(&quot;我是子类无参构造&quot;);    &#125;    public Cat(String name,int age) &#123;        super(name,age);        this.eat();//当前类没有就找父类        System.out.println(&quot;我是子类有参构造&quot;);    &#125;    public String getColor() &#123;        return color;    &#125;    public void setColor(String color) &#123;        this.color = color;    &#125;    /**     * @Description 重写,在父类的基础上添加颜色信息     * @Author LuoTao     * @Date 2024/10/3 16:13     * @return java.lang.String     * @param     **/    @Override    public String toString() &#123;        return super.toString() + &quot;, color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27;;    &#125;&#125;/** * @Description: 主类 * @Author: LuoTao * @Date: 2024-10-03 15:17:16 */public class DemoExtends &#123;    public static void main(String[] args) &#123;        // 子类中调用父类的属性和方法        Cat cat = new Cat();        cat.setName(&quot;罗涛&quot;);        cat.setAge(18);        cat.setColor(&quot;白色&quot;);        System.out.println(cat.toString());        new Cat(&quot;1&quot;, 2);    &#125;&#125;\r\nfinal\r\n\r\n\r\n修饰的属性不能更改\r\n修饰的类不能被继承\r\n修饰的方法不能被重写，可以被子类继承\r\nprivate 方法隐式地被指定为\r\nfinal，如果在子类中定义的方法和基类中的一个 private\r\n方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\r\n修饰的引用数据类型在堆中的地址不可更改，可修改对象内部数据\r\njvm使用内嵌机制加载final方法，更高效\r\n声明作为全局变量时若不赋值则需在构造中初始化\r\n\r\n\r\npackage com.luotao;/** * @Classname Final修饰引用类型时在堆中的地址不可更改，可更改其内部数据 * @Description TODO * @Version 1.0.0 * @Date 2024/10/4 16:36 * @Author LuoTao */public class DemoFinal &#123;    String name;    final int age;//final属性作为全局变量需在构造中初始化。即用final修饰的字段在初始化后不能被修改，可以在构造方法中初始化final字段。    public DemoFinal() &#123;        this.age = 18;    &#125;    public DemoFinal(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;DemoFinal&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;    public static void main(String[] args) &#123;       final DemoFinal demoFinal = new DemoFinal();        demoFinal.setName(&quot;旺财&quot;);        System.out.println(demoFinal.toString());;    &#125;&#125;\r\ncase-学生投票系统\r\n\r\n班级学生人数为100人，每个学生只能投一票，投票成功提示’感谢投票’，重复投票则提示‘请勿重复投票’，当投票总数达到100或者主观结束投票时，统计投票学生人数和投票结果。\r\n\r\nSet集合存储不重复元素\r\n\r\n\r\npackage com.luotao.caseVoter;import java.util.HashSet;import java.util.Set;/** * @Classname Voter * @Description 投票者类 * @Version 1.0.0 * @Date 2024/10/4 17:03 * @Author LuoTao */public class Voter &#123;    private static final int MAX_COUNT = 10;// 学生数量    private String name;//投票者    private String answer;//投票意见    private static int count;//计数器，记录投票者投票数    private static Set&lt;Voter&gt; voters= new HashSet();//存储投票者,set存储不重复元素    public Voter(String name) &#123;        this.name = name;    &#125;    /**     * @Description 投票方法     * @Author LuoTao     * @Date 2024/10/4 17:22     * @return void     * @param answer 投票意见     **/    public void voterFor(String answer)&#123;        if(count == MAX_COUNT)&#123;            System.out.println(&quot;票数已满，不能再继续投票！&quot;);        &#125;else &#123;            if( voters.contains(this))&#123;                System.out.println(this.name + &quot;不能重复投票！&quot;);            &#125;else&#123;                this.answer = answer;                count++;                voters.add(this);                System.out.println(this.name + &quot;投票成功！&quot;);            &#125;        &#125;    &#125;    /**     * @Description 投票结果汇总     * @Author LuoTao     * @Date 2024/10/4 17:35     * @return void     * @param     **/    public static void voterResult()&#123;        System.out.println(&quot;投票总数：&quot; + count +&quot;\\n&quot;+                &quot;投票者名单：&quot;        );        for(Voter v:voters)&#123;            System.out.println(v.name + &quot;:&quot; + v.answer);        &#125;    &#125;    public static void main(String[] args) &#123;        for(int i=0;i&lt;10;i++)&#123;            Voter voter = new Voter(&quot;user&quot; + i);            if(i%2==0)&#123;                voter.voterFor(&quot;OK&quot;);            &#125;else &#123;                voter.voterFor(&quot;NO&quot;);            &#125;        &#125;        Voter.voterResult();    &#125;&#125;\r\n抽象类\r\n\r\n\r\nimage-20241121170219127\r\n\r\n\r\n\r\n在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。\r\n如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口。\r\n由于多态的存在，每个子类都可以覆写父类的方法，如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法，具体的业务逻辑由不同的子类实现，调用者并不关心\r\n无法实例化的抽象类有什么用？\r\n因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。\r\n在对类设计的时候,不能具象表示某一类实物,需要将该类定义成抽象类.\r\n抽象类用来提供一个基础类的骨架，并允许子类扩展和重用代码。而接口用来定义一组行为规范,允许多个类实现这些行为，并支持多重继承的概念。\r\n继承限制：Java中一个类只能继承一个抽象类。\r\n构造器：抽象类可以有构造器，虽然它本身不能被实例化，但子类在构造时可能会用到。\r\n抽象类可以提供部分方法的具体实现,接口只能定义静态常量\r\n抽象方法必须在子类中实现,继承该抽象类的子类必须重写父类的所有抽象方法。\r\n不能被实例化，可借助匿名内部类实现实例化。在子类中可用super调用父类（抽象类）的构造方法完成属性的初始化。\r\n抽象方法不能私有化，因为私有化的抽象方法不能被子类所访问，谈不上重写，无意义。\r\n当需要提供一个基本的类框架，允许子类在此基础上添加自己的行为时，使用抽象类。\r\n当需要提供一些默认实现，但又不想让别人直接实例化该类时，使用抽象类。\r\n\r\n\r\npackage com.luotao.demoAbstract;/** * @Classname Animal * @Description 抽象类 * @Version 1.0.0 * @Date 2024/10/4 18:56 * @Author LuoTao */abstract class Animal &#123;    private String name;    private String sex;    public Animal() &#123;    &#125;    public Animal(String name, String sex) &#123;        this.name = name;        this.sex = sex;        System.out.println(&quot;Animal中的有参构造&quot; + name + sex);    &#125;    /**     * @param     * @return void     * @Description 抽象方法-所有动物都会吃     * @Author LuoTao     * @Date 2024/10/4 18:58     **/    public abstract void eat();    &#123;        System.out.println(&quot;父类Animal构造代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;父类Animal静态代码块&quot;);    &#125;&#125;/*** @Description: 父类的抽象方法eat也被继承* @Author: LuoTao* @Date: 2024-10-04 19:13:39**/abstract class  Bird extends Animal &#123;    private String color;//特有颜色    public Bird() &#123;    &#125;    public Bird(String name, String sex, String color) &#123;        super(name, sex);        this.color = color;    &#125;    public abstract void fly();&#125;/** * @Description 麻雀类 * @Author LuoTao * @Date 2024/10/4 19:11 **/class sparrow extends Bird&#123;    private int age;//特有属性    public sparrow() &#123;    &#125;    public sparrow(String name, String sex, String color, int age) &#123;        super(name, sex, color);        this.age = age;    &#125;    /**     * @Description 继承该抽象类的子类需重写父类的抽象方法，这里有两个抽象方法，eat是被Bird继承的     * @Author LuoTao     * @Date 2024/10/4 19:13     * @return void     * @param     **/    @Override    public  void fly()&#123;        System.out.println(&quot;鸟飞&quot;);    &#125;    @Override    public void eat() &#123;        System.out.println(&quot;鸟吃&quot;);    &#125;    &#123;        System.out.println(&quot;子类sparrow构造代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;子类sparrow静态代码块&quot;);    &#125;&#125;public class DemoAbstract &#123;    public static void main(String[] args) &#123;        new sparrow(&quot;旺财&quot;,&quot;男&quot;,&quot;橘色&quot;,18).fly();        /**         父类Animal静态代码块         子类sparrow静态代码块         父类Animal构造代码块         Animal中的有参构造旺财男         子类sparrow构造代码块         鸟飞        **/    &#125;&#125;\r\ncase-学生和老师\r\npackage com.luotao.case5;/** * @Classname Person * @Description TODO * @Version 1.0.0 * @Date 2024/10/4 22:11 * @Author LuoTao */public abstract class Person &#123;    private  String name;    private  int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    /**     * @Description 输出基本信息     * @Author LuoTao     * @Date 2024/10/4 22:20     * @return void     * @param     **/    public void say()&#123;        System.out.println(getContent());    &#125;    public abstract String getContent();&#125;\r\npackage com.luotao.case5;/** * @Classname Student * @Description TODO * @Version 1.0.0 * @Date 2024/10/4 22:22 * @Author LuoTao */ class Student extends  Person&#123;    private  double score;//学生成绩    /**     * @Description 父类显示声明构造后子类要对其属性做初始化     * @Author LuoTao     * @Date 2024/10/4 22:28     **/    public Student(String name,int age,double score)&#123;        super(name,age);        this.score = score;    &#125;    @Override    public String getContent() &#123;        return &quot;学生信息：&quot;+                &quot;姓名：&quot; + super.getName() + &quot;\\n&quot; +                &quot;年龄：&quot; + super.getAge() + &quot;\\n&quot; +                &quot;成绩&quot; + this.score;    &#125;&#125;class Teacher extends Person&#123;    private  double salary;//老师薪资    /**     * @Description 父类显示声明构造后子类要对其属性做初始化     * @Author LuoTao     * @Date 2024/10/4 22:28     **/    public Teacher(String name, int age,double salary) &#123;        super(name, age);        this.salary = salary;    &#125;    @Override    public String getContent() &#123;        return &quot;老师信息：&quot;+                &quot;姓名：&quot; + super.getName() + &quot;\\n&quot; +                &quot;年龄：&quot; + super.getAge() + &quot;\\n&quot; +                &quot;薪水&quot; + this.salary;    &#125;&#125;public class caseApp &#123;    public static void main(String[] args) &#123;        new Student(&quot;旺财&quot;, 18, 100).say();        new Teacher(&quot;小黑&quot;, 18, 5000).say();        System.out.println(new Student(&quot;旺财1&quot;, 20, 99).getContent());        /**         学生信息：姓名：旺财         年龄：18         成绩100.0         老师信息：姓名：小黑         年龄：18         薪水5000.0         学生信息：姓名：旺财1         年龄：20         成绩99.0        **/    &#125;&#125;\r\ncase-经理与员工工资\r\npackage com.luotao.case6;abstract class Person&#123;    private String name;    private String address;    public Person(String name, String address) &#123;        this.name = name;        this.address = address;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;abstract class Employee extends Person&#123;    private int id;    private double salary;    private int age;    public Employee(String name,String address,int id,double salary,int age)&#123;        super(name, address);        this.id=id;        this.salary=salary;        this.age=age;    &#125;    /**     * @Description 员工涨薪的抽象方法     * @Author LuoTao     * @Date 2024/10/5 13:53     * @return void     * @param     **/    public abstract void addSalary();    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public double getSalary() &#123;        return salary;    &#125;    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;class Manager extends  Employee&#123;    /**    * @Description: 员工级别:0普通级别,1经理级别    * @Author: LuoTao    * @Date: 2024-10-05 13:58:42    **/    private int level;    public Manager(String name, String address, int id, double salary, int age, int level) &#123;        super(name, address, id, salary, age);        this.level = level;    &#125;    /**     * @return void     * @Description 员工涨薪的抽象实现,根据level判断是员工还是经理     * @Author LuoTao     * @Date 2024/10/5 13:53     **/    @Override    public void addSalary() &#123;        double salary = getSalary();// 原来的薪资        if(level==0)&#123;            super.setSalary(salary + 100);//普通级别涨薪100        &#125;else if(level == 1)&#123;            super.setSalary(salary + 500);//经理级别涨薪500        &#125;else&#123;            System.out.println(&quot;当前员工级别异常!&quot;);        &#125;        System.out.println(getName() + &quot;涨薪后的工资=&quot; + getSalary());    &#125;&#125;public class DemoApp &#123;    public static void main(String[] args) &#123;        new Manager(&quot;员工牛马&quot;,&quot;翻斗花园&quot;,1,1000,18,1).addSalary();        new Manager(&quot;经理旺财&quot;,&quot;翻斗花园2号&quot;,1,1000,18,0).addSalary();    &#125;&#125;\r\ninterface\r\n\r\n\r\nimage-20241121171023070\r\n\r\n\r\n\r\n因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型\r\n接口的所有方法都是抽象方法，接口不能定义实例字段\r\n约束和规范,遵循统一的设计\r\n抽象类用来提供一个基础类的骨架，并允许子类扩展和重用代码。而接口用来定义一组行为规范,允许多个类实现这些行为，并支持多重继承的概念。\r\n1.8之间只能定义静态常量,1.8之后增加了默认方法和静态方法\r\n接口中的方法默认是public abstract的，字段只能是public static final\r\n类实现接口后需重新接口中所有的抽象方法,否则本类需定义成抽象类.\r\n接口中的静态方法默认不能被子类重写\r\njava是单继承的,为了扩充子类的功能,引入接口,因为接口是多基础的.\r\n当需要定义一组操作的规范，而不关心具体实现时，使用接口。\r\n当需要多个类共享某些行为，而又不想让它们之间有继承关系时，使用接口。\r\n当需要模拟“多重继承”的时候，使用接口\r\n通过实现接口，类必须提供接口中所有抽象方法的具体实现\r\n\r\n\r\npackage com.luotao.interfaceDemo;public interface interfaceDemo &#123;    /**    * @Description: 静态常量,默认加上public static final    * @Author: LuoTao    * @Date: 2024-10-05 14:38:13    **/     double PI=3.1415926;     /**      * @Description 抽象方法(无方法体)简写, 默认加上public abstract,      * @Author LuoTao      * @Date 2024/10/5 14:41      * @return void      * @param a      * @param b      **/     void add(int a, int b);     /**      * @Description 静态方法,默认加上public 需构建方法体      * @Author LuoTao      * @Date 2024/10/5 14:46      * @return void      * @param a      * @param b      **/    static void sum(int a, int b)&#123;        System.out.println(&quot;接口中的静态方法可通过接口名直接调用&quot;);    &#125;    /**     * @Description 默认方法, 默认加上public, 需构建方法体     * @Author LuoTao     * @Date 2024/10/5 14:52     * @return int     * @param a     * @param b     **/    default void sub(int a,int b)&#123;        System.out.println(&quot;a-b:&quot; + (a-b));    &#125;&#125;\r\npackage com.luotao.interfaceDemo;/** * @Classname interfaceDemo的实现类.类实现接口后需重新接口中所有的抽象方法,否则本类需定义成抽象类.接口中的静态方法默认不能被子类重写 * @Description TODO * @Version 1.0.0 * @Date 2024/10/5 15:31 * @Author LuoTao */public class interfaceDemoImpl implements interfaceDemo &#123;    @Override    public void add(int a, int b) &#123;        System.out.println(&quot;重写接口中的抽象方法&quot; );    &#125;    @Override    public void sub(int a, int b) &#123;        System.out.println(&quot;重写接口中的默认方法&quot; );    &#125;&#125;class main&#123;    public static void main(String[] args) &#123;        new interfaceDemoImpl().add(1,2);        new interfaceDemoImpl().sub(3,4);        interfaceDemo.sum(5, 6);//接口中的静态方法可通过接口名直接调用    &#125;&#125;\r\ncase-研究生薪资管理\r\n\r\n学生要学费,老师有月薪资,在职研究生既是老师又是学生,所以既要缴学费又有薪资.实现一个程序统计在职研究生的收入与学费,若收入&lt;学费则输出需要贷款,否则不需要贷款.\r\n\r\npackage com.luotao.case7Demo;/*** @Description: 学生学费功能接口* @Author: LuoTao* @Date: 2024-10-05 22:50:45**/public interface StudentManager &#123;    /**     * @Description 获取学生学费     * @Author LuoTao     * @Date 2024/10/5 22:49     * @return double     * @param     **/    double getFree();    /**     * @Description 设置学生学费     * @Author LuoTao     * @Date 2024/10/5 22:49     * @return void     * @param     **/    void setFree(double free);&#125;\r\npackage com.luotao.case7Demo;/*** @Description: 老师薪资功能接口* @Author: LuoTao* @Date: 2024-10-05 22:52:30**/public interface TeacherManager &#123;    /**     * @Description 获取老师薪资     * @Author LuoTao     * @Date 2024/10/5 22:53     * @return double     * @param     **/    double getSalary();    /**     * @Description 设置老师薪资     * @Author LuoTao     * @Date 2024/10/5 22:53     * @return double     * @param     **/    void setSalary(double salary);&#125;\r\npackage com.luotao.case7Demo;/** * @Classname 研究生类,有两个功能接口:老师和学生 * @Description TODO * @Version 1.0.0 * @Date 2024/10/5 22:54 * @Author LuoTao */public class Graduate implements StudentManager,TeacherManager&#123;    private String name;    private String sex;    private int age;    private double free;//学费    private double salary;//薪资    public Graduate(String name, String sex, int age, double free, double salary) &#123;        this.name = name;        this.sex = sex;        this.age = age;        this.free = free;        this.salary = salary;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public double getFree() &#123;        return free;    &#125;    @Override    public void setFree(double free) &#123;        this.free = free;    &#125;    @Override    public double getSalary() &#123;        return salary;    &#125;    @Override    public void setSalary(double salary) &#123;        this.salary = salary;    &#125;&#125;class AppMain&#123;    public static void main(String[] args) &#123;        Graduate graduate = new Graduate(&quot;旺财&quot;, &quot;男&quot;, 18, 8000, 3000);        System.out.println(graduate.getSalary()*12 -graduate.getFree());        if (graduate.getSalary()*12 -graduate.getFree() &lt;0) &#123;            System.out.println( &quot;需要贷款&quot;);        &#125;else &#123;            System.out.println(&quot;无需贷款&quot;);        &#125;    &#125;&#125;\r\ninstance of\r\n\r\n判断对象数据类型.\r\n\r\npackage com.luotao.case8Demo;/** * @Classname Animal抽象类 * @Description TODO * @Version 1.0.0 * @Date 2024/10/5 23:25 * @Author LuoTao */ abstract class Animal &#123;    private  String name;    private  int age;    public abstract void run();&#125;/*** @Description: 动物的行为功能接口* @Author: LuoTao* @Date: 2024-10-05 23:28:13**/interface Action&#123;    void eat();&#125;/** * @Description 猫咪类 * @Author LuoTao * @Date 2024/10/5 23:29 **/class Cat extends Animal implements Action&#123;    @Override    public void run() &#123;        System.out.println(&quot;猫跑&quot;);    &#125;    @Override    public void eat() &#123;        System.out.println(&quot;猫吃&quot;);    &#125;    public void eat(String food) &#123;        System.out.println(&quot;猫吃&quot; + food);    &#125;&#125;/** * @Description 狗狗类 * @Author LuoTao * @Date 2024/10/5 23:29 **/class Dog extends Animal implements Action&#123;    @Override    public void run() &#123;        System.out.println(&quot;狗跑&quot;);    &#125;    @Override    public void eat() &#123;        System.out.println(&quot;狗吃&quot;);    &#125;&#125;public class AppMain &#123;    public static void main(String[] args) &#123;        Cat cat = new Cat();        cat.eat();        cat.eat(&quot;鱼&quot;);        cat.run();        Animal cat1 = new Cat();//父类的引用指向子类对象,向上转型        System.out.println(cat1 instanceof Animal);//true        System.out.println(cat1 instanceof Cat);//true        cat1.run();        Animal an1 = new Cat();        Cat cat3=(Cat)an1;// 向下转型,需先向上转型        System.out.println(cat3 instanceof Animal);//true        System.out.println(cat3 instanceof Cat);//true        Dog dog = new Dog();        System.out.println(dog instanceof Animal);//true        dog.eat();        dog.run();        Action dog1 = new Dog();//引用接口,向上转型        dog1.eat();    &#125;&#125;\r\ncase-图形面积与周长计算程序\r\n\r\n计算不同图形的面积和周长\r\n\r\n抽象类:\r\npackage com.luotao.caseShape;/*** @Description: 定义功能抽象求周长和面积* @Author: LuoTao* @Date: 2024-10-06 12:16:50**/abstract class Shape&#123;    /**     * @Description 求面积     **/    public abstract double getArea();    /**     * @Description 求周长     **/    public abstract double getPerimeter();&#125;/** * @Description: 圆形 * @Author: LuoTao * @Date: 2024-10-06 12:19:37 **/class Circle extends Shape &#123;    /**    * @Description: 半径    **/    private double radius;    /**     * @Description: 圆周率     **/    private static final double PI=3.14;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return PI * radius * radius;    &#125;    @Override    public double getPerimeter() &#123;        return 2* PI * radius;    &#125;    public double getRadius() &#123;        return radius;    &#125;    public void setRadius(double radius) &#123;        this.radius = radius;    &#125;&#125;/*** @Description: 长方形* @Author: LuoTao* @Date: 2024-10-06 12:19:15**/class  Rectangle extends Shape&#123;    /**    * @Description: 宽    **/    private double width;    /**     * @Description: 长     **/    private double length;    public Rectangle(double width, double length) &#123;        this.width = width;        this.length = length;    &#125;    @Override    public double getArea() &#123;        return width * length;    &#125;    @Override    public double getPerimeter() &#123;        return 2 * (width + length);    &#125;    public double getWidth() &#123;        return width;    &#125;    public void setWidth(double width) &#123;        this.width = width;    &#125;    public double getLength() &#123;        return length;    &#125;    public void setLength(double length) &#123;        this.length = length;    &#125;&#125;/*** @Description: 图形面积周长计算器* @Author: LuoTao* @Date: 2024-10-06 12:20:39**/class ShapeCalculator&#123;    public double getShapeArea(Shape shape)&#123;        double area=0;        if(shape instanceof Circle)&#123;            area = shape.getArea();        &#125;else if(shape instanceof Rectangle)&#123;            area = shape.getArea();        &#125;        return area;    &#125;    public double getShapePerimeter(Shape shape)&#123;        double perimeter=0;        if(shape instanceof Circle)&#123;            perimeter = shape.getPerimeter();        &#125;else if(shape instanceof Rectangle)&#123;            perimeter = shape.getPerimeter();        &#125;        return perimeter;    &#125;&#125;public class AppMain &#123;    public static void main(String[] args) &#123;        ShapeCalculator calculator = new ShapeCalculator();        // 计算圆形的面积        Circle circle = new Circle(1);        System.out.println(&quot;Circle Area: &quot; + calculator.getShapeArea(circle));        // 计算长方形的周长        Rectangle rectangle = new Rectangle(1, 2);        System.out.println(&quot;Rectangle Perimeter: &quot; + calculator.getShapePerimeter(rectangle));    &#125;&#125;\r\n引入接口\r\npackage com.luotao.caseShape;/*** @Description: 定义功能抽象求周长和面积* @Author: LuoTao* @Date: 2024-10-06 12:16:50**/interface Shape &#123;    /**     * @Description 求面积     **/double getArea();    /**     * @Description 求周长     **/ double getPerimeter();&#125;/** * @Description: 新接口，定义计算直径的行为 * @Author: LuoTao * @Date: 2024-10-06 12:20:39 */interface DiameterShape &#123;    /**     * @Description 求直径     */    Double getDiameter();&#125;/** * @Description: 圆形 * @Author: LuoTao * @Date: 2024-10-06 12:19:37 **/class Circle implements Shape,DiameterShape &#123;    /**    * @Description: 半径    **/    private double radius;    /**     * @Description: 圆周率     **/    private static final double PI=3.14;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return PI * radius * radius;    &#125;    @Override    public double getPerimeter() &#123;        return 2* PI * radius;    &#125;    public double getRadius() &#123;        return radius;    &#125;    public void setRadius(double radius) &#123;        this.radius = radius;    &#125;    @Override    public Double getDiameter() &#123;        return  2 * radius;    &#125;&#125;/*** @Description: 长方形* @Author: LuoTao* @Date: 2024-10-06 12:19:15**/class  Rectangle implements Shape&#123;    /**    * @Description: 宽    **/    private double width;    /**     * @Description: 长     **/    private double length;    public Rectangle(double width, double length) &#123;        this.width = width;        this.length = length;    &#125;    @Override    public double getArea() &#123;        return width * length;    &#125;    @Override    public double getPerimeter() &#123;        return 2 * (width + length);    &#125;    public double getWidth() &#123;        return width;    &#125;    public void setWidth(double width) &#123;        this.width = width;    &#125;    public double getLength() &#123;        return length;    &#125;    public void setLength(double length) &#123;        this.length = length;    &#125;&#125;/*** @Description: 图形面积周长计算器* @Author: LuoTao* @Date: 2024-10-06 12:20:39**/class ShapeCalculator&#123;    public double getShapeArea(Shape shape)&#123;        double area=0;        if(shape instanceof Circle)&#123;            area = shape.getArea();        &#125;else if(shape instanceof Rectangle)&#123;            area = shape.getArea();        &#125;        return area;    &#125;    public double getShapePerimeter(Shape shape)&#123;        double perimeter=0;        if(shape instanceof Circle)&#123;            perimeter = shape.getPerimeter();        &#125;else if(shape instanceof Rectangle)&#123;            perimeter = shape.getPerimeter();        &#125;        return perimeter;    &#125;    public double getShapeDiameter(Shape shape)&#123;        double diameter=0;        if(shape instanceof Circle)&#123;            diameter = ((Circle) shape).getDiameter();        &#125;        return diameter;    &#125;&#125;public class AppMain &#123;    public static void main(String[] args) &#123;        ShapeCalculator calculator = new ShapeCalculator();        // 计算圆形的面积        Circle circle = new Circle(1);        System.out.println(&quot;Circle Area: &quot; + calculator.getShapeArea(circle));// 向上转型        System.out.println(&quot;Circle Diameter: &quot; + calculator.getShapeDiameter(circle));        // 计算长方形的周长        Rectangle rectangle = new Rectangle(1, 2);        System.out.println(&quot;Rectangle Perimeter: &quot; + calculator.getShapePerimeter(rectangle));    &#125;&#125;\r\ncase-运输任务\r\npackage com.rabbiter.hello;/** * @Description: 交通工具抽象类 * @Author: LuoTao * @Date: 2024-10-06 14:03:00 **/abstract class Transportation&#123;    /**     * @Description: 车牌号     **/    private  String number;    /**     * @Description: 型号     **/    private String bom;    /**     * @Description: 车辆责任人     **/    private String admin;    public Transportation(String number, String bom, String admin) &#123;        this.number = number;        this.bom = bom;        this.admin = admin;    &#125;    /**     * @Description 交通工具进行运输操作     * @Author LuoTao     * @Date 2024/10/6 14:07     * @return void     * @param     **/    public abstract void transport();    public String getNumber() &#123;        return number;    &#125;    public void setNumber(String number) &#123;        this.number = number;    &#125;    public String getBom() &#123;        return bom;    &#125;    public void setBom(String bom) &#123;        this.bom = bom;    &#125;    public String getAdmin() &#123;        return admin;    &#125;    public void setAdmin(String admin) &#123;        this.admin = admin;    &#125;&#125;/** * @Description: 车辆保养功能接口 * @Author: LuoTao * @Date: 2024-10-06 14:09:20 **/interface Maintain&#123;    /**     * @Description 车辆保养     * @Author LuoTao     * @Date 2024/10/6 14:10     * @return void     * @param     **/    void upkeep();&#125;/** * @Description: GPS功能接口 * @Author: LuoTao * @Date: 2024-10-06 14:09:20 **/interface GPS&#123;    /**     * @Description 展示GPS位置     * @Author LuoTao     * @Date 2024/10/6 14:10     * @return void     * @param     **/    String showGPS();&#125;class Phone implements GPS&#123;    @Override    public String showGPS() &#123;        return &quot;1314520&quot;;    &#125;&#125;/** * @Description: 运输任务 * @Author: LuoTao * @Date: 2024-10-06 14:24:34 **/class SendTask&#123;    /**     * @Description: 运输单号     **/    private  String number;    /**     * @Description: 货物重量     **/    private  String goodsWeight;    public SendTask(String number, String goodsWeight) &#123;        this.number = number;        this.goodsWeight = goodsWeight;    &#125;    /**     * @Description 运输任务准备     * @Author LuoTao     * @Date 2024/10/6 14:27     * @return void     * @param     **/    public void sendBefore()&#123;        System.out.println(&quot;验仓中...货物重量:&quot; + goodsWeight  + &quot;运输单号:&quot; + number);    &#125;    /**     * @Description 运输中     * @Author LuoTao     * @Date 2024/10/6 14:27     * @return void     * @param     **/    public void send(Transportation t,GPS g)&#123;        System.out.println(&quot;运输责任人:&quot; + t.getAdmin() + &quot;车辆型号:&quot; + t.getBom() + &quot;,开始运输任务...&quot;);        t.transport();// 开始运输        System.out.println(&quot;车辆GPS:&quot; + g.showGPS());    &#125;    /**     * @Description 归还汽车     * @Author LuoTao     * @Date 2024/10/6 14:27     * @return void     * @param     **/    public void sendAfter(Transportation t)&#123;        System.out.println(&quot;运输责任人:&quot; + t.getAdmin() + &quot;已归还汽车:&quot; + t.getBom());    &#125;&#125;/** * @Description: 专用汽车类 * @Author: LuoTao * @Date: 2024-10-06 14:12:11 **/class ZTransportation extends Transportation implements Maintain&#123;    public ZTransportation(String number, String bom, String admin) &#123;        super(number, bom, admin);    &#125;    @Override    public void transport() &#123;        System.out.println(&quot;正在运输货物...&quot;);    &#125;    @Override    public void upkeep() &#123;        System.out.println(&quot;专用车保养完成&quot;);    &#125;&#125;/*** @Description: 客户端**/ class Client &#123;    public static void main(String[] args) &#123;        SendTask sendTask = new SendTask(&quot;AE86&quot;, &quot;10kg&quot;);//运输任务        sendTask.sendBefore();//验仓完毕        ZTransportation t = new ZTransportation(&quot;渝888&quot;, &quot;小米su7&quot;, &quot;旺财&quot;);//运输车        sendTask.send(t, new Phone());//发送车辆GPS        sendTask.sendAfter(t);//归还汽车        t.upkeep();//保养汽车    &#125;&#125;\r\nequals\r\n\r\n对于基本类型，== 判断两个值是否相等，基本类型没有 equals()\r\n方法。\r\n对于引用类型，== 判断两个变量是否引用同一个对象，而 equals()\r\n判断引用的对象是否等价。\r\n\r\npackage com.luotao.caseRing;class  Student&#123;    private  String name;    private  int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public boolean equals(Object obj) &#123;        /**         * @Description: 若堆地址相同则指两个对象的数据相等         * @Author: LuoTao         * @Date: 2024-10-06 15:23:57         **/        if(this == obj)&#123;            System.out.println(&quot;若堆地址相同则指两个对象的数据相等&quot;);            return true;        &#125;        /**        * @Description: 向下转型获取Student对象的成员信息         * 若对象的所有属性都相同则两个对象的数据相同        * @Author: LuoTao        * @Date: 2024-10-06 15:27:56        **/        Student s= (Student) obj;        if(this.name==s.name &amp;&amp; this.age==s.age)&#123;            System.out.println(&quot;若对象的所有属性都相同则两个对象的数据相同&quot;);            return true;        &#125;        /**        * @Description: 加载器不同        * @Author: LuoTao        * @Date: 2024-10-06 15:29:52        **/        if(obj == null || this.getClass() != obj.getClass())&#123;            return false;        &#125;        return false;    &#125;&#125;public class AppMain &#123;    public static void main(String[] args) &#123;        Student student = new Student(&quot;旺财&quot;, 18);        Student student2 = new Student(&quot;旺财&quot;, 18);        /**        * @Description: false,若没有重写Object的equals方法则比较的是对象在堆中的地址        **/        System.out.println(student.equals(student2));    &#125;&#125;\r\nnative\r\n\r\nhashCode 输出对象的散列码(哈希码)\r\nnative方法表示将具体实现交由C语言完成\r\n\r\nJava面向对象编程学习笔记\r\n8. 内部类与匿名内部类\r\n内部类是Java中一种特殊的类结构，它允许在一个类内部定义另一个类。这种设计为Java提供了更强大的封装能力和更灵活的代码组织方式。\r\n8.1 内部类的概念与分类\r\n内部类可以分为四种类型： 1. 成员内部类（Member Inner Class） 2.\r\n静态内部类（Static Nested Class） 3. 局部内部类（Local Inner Class） 4.\r\n匿名内部类（Anonymous Inner Class）\r\n内部类├── 成员内部类（非静态内部类）├── 静态内部类（静态嵌套类）├── 局部内部类（方法内定义的类）└── 匿名内部类（没有名字的内部类）\r\n8.2 成员内部类\r\n成员内部类是定义在类内部的非静态类，它与外部类的实例变量和方法享有相同的地位。\r\n8.2.1 基本特性\r\n\r\n可以访问外部类的所有成员（包括私有成员）\r\n隐式持有外部类的引用（外部类名.this）\r\n不能包含静态成员（Java 16之前）\r\n必须通过外部类实例才能创建\r\n\r\n8.2.2 代码示例\r\npublic class Outer &#123;    private int outerField = 1;    private static int staticOuterField = 2;        // 成员内部类    public class Inner &#123;        private int innerField = 3;                public void display() &#123;            // 可以直接访问外部类的实例变量            System.out.println(&quot;外部类成员变量: &quot; + outerField);                        // 可以访问外部类的静态变量            System.out.println(&quot;外部类静态变量: &quot; + staticOuterField);                        // 可以使用外部类.this引用外部类实例            System.out.println(&quot;通过Outer.this访问: &quot; + Outer.this.outerField);                        // 内部类自己的实例变量            System.out.println(&quot;内部类成员变量: &quot; + innerField);        &#125;    &#125;        // 外部类方法，创建内部类实例并调用其方法    public void createInner() &#123;        Inner inner = new Inner();        inner.display();    &#125;&#125;\r\n8.2.3 创建内部类实例\r\n在外部类以外的地方创建内部类的实例：\r\npublic class Main &#123;    public static void main(String[] args) &#123;        // 先创建外部类实例        Outer outer = new Outer();                // 使用外部类实例创建内部类实例        Outer.Inner inner = outer.new Inner();                // 调用内部类方法        inner.display();    &#125;&#125;\r\n8.2.4 应用场景\r\n\r\n当内部类与外部类有紧密关系时\r\n需要内部类访问外部类的实例成员\r\n封装仅由外部类使用的辅助类\r\n实现回调机制\r\n\r\n8.3 静态内部类（静态嵌套类）\r\n静态内部类是使用static关键字修饰的内部类。与成员内部类不同，它不持有外部类的引用。\r\n8.3.1 基本特性\r\n\r\n可以访问外部类的静态成员，但不能直接访问实例成员\r\n可以包含静态成员和实例成员\r\n不需要外部类实例即可创建\r\n相对独立，行为更像一个独立的类\r\n\r\n8.3.2 代码示例\r\npublic class Outer &#123;    private int outerField = 1;    private static int staticOuterField = 2;        // 静态内部类    public static class StaticNested &#123;        private int innerField = 3;        private static int staticInnerField = 4;                public void display() &#123;            // 可以访问外部类的静态成员            System.out.println(&quot;外部类静态变量: &quot; + staticOuterField);                        // 不能直接访问外部类的实例成员            // System.out.println(outerField); // 编译错误                        // 可以访问自己的实例成员            System.out.println(&quot;内部类实例变量: &quot; + innerField);                        // 可以访问自己的静态成员            System.out.println(&quot;内部类静态变量: &quot; + staticInnerField);        &#125;                public static void staticDisplay() &#123;            System.out.println(&quot;内部类的静态方法&quot;);            System.out.println(&quot;外部类静态变量: &quot; + staticOuterField);        &#125;    &#125;        public void createStaticNested() &#123;        StaticNested nested = new StaticNested();        nested.display();    &#125;&#125;\r\n8.3.3 创建静态内部类实例\r\npublic class Main &#123;    public static void main(String[] args) &#123;        // 不需要外部类实例，可以直接创建静态内部类的实例        Outer.StaticNested nested = new Outer.StaticNested();        nested.display();                // 可以直接调用静态内部类的静态方法        Outer.StaticNested.staticDisplay();    &#125;&#125;\r\n8.3.4 应用场景\r\n\r\n不需要访问外部类实例成员时\r\n内部类需要定义静态成员\r\n将相关类组织在一起，但保持独立性\r\n实现工具类或辅助类\r\n实现构建器模式（Builder Pattern）\r\n\r\n8.4 局部内部类\r\n局部内部类是定义在方法或作用域块内的类，只在定义它的方法或作用域内可见。\r\n8.4.1 基本特性\r\n\r\n只能在定义它的方法或作用域内使用\r\n可以访问外部类的所有成员（包括私有成员）\r\n可以访问方法中的final或effectively final局部变量\r\n不能定义静态成员（Java 16之前）\r\n作用域限制在方法内\r\n\r\n8.4.2 代码示例\r\npublic class Outer &#123;    private int outerField = 1;        public void methodWithLocalClass(final int param) &#123;        final int localVar = 10;        int effectivelyFinalVar = 20; // Java 8后，effectively final变量                // 局部内部类        class LocalInner &#123;            private int innerField = 3;                        public void display() &#123;                // 可以访问外部类成员                System.out.println(&quot;外部类成员: &quot; + outerField);                                // 可以访问方法的final参数                System.out.println(&quot;方法参数: &quot; + param);                                // 可以访问方法的局部final变量                System.out.println(&quot;局部final变量: &quot; + localVar);                                // 可以访问effectively final变量                System.out.println(&quot;Effectively final变量: &quot; + effectivelyFinalVar);                                // 内部类自己的成员                System.out.println(&quot;内部类成员: &quot; + innerField);            &#125;        &#125;                // 创建局部内部类实例并调用方法        LocalInner inner = new LocalInner();        inner.display();                // 一旦这里修改了effectivelyFinalVar，它就不再是effectively final        // effectivelyFinalVar = 30; // 会导致内部类中使用此变量出错    &#125;&#125;\r\n8.4.3 应用场景\r\n\r\n方法中需要辅助类，且这个类只在该方法中使用\r\n需要访问方法的局部变量\r\n实现特定逻辑的一次性类\r\n增强封装\r\n\r\n8.5 匿名内部类\r\n匿名内部类是没有名字的局部内部类，用于创建某个类（具体类或抽象类）的子类实例，或某个接口的实现类实例。\r\n8.5.1 基本特性\r\n\r\n没有类名，在创建实例的同时定义类\r\n必须继承一个父类或实现一个接口\r\n不能定义构造方法（因为没有类名）\r\n可以访问外部类所有成员\r\n可以访问方法中的final或effectively final局部变量\r\n不能定义静态成员（Java 16之前）\r\n一次性使用\r\n\r\n8.5.2 代码示例\r\n继承类的匿名内部类：\r\npublic class Outer &#123;    public void createThread() &#123;        // 创建Thread子类的匿名内部类实例        Thread thread = new Thread() &#123;            @Override            public void run() &#123;                System.out.println(&quot;匿名内部类实现的线程&quot;);            &#125;        &#125;;        thread.start();    &#125;&#125;\r\n实现接口的匿名内部类：\r\npublic class Outer &#123;    public void createRunnable() &#123;        // 创建Runnable接口实现的匿名内部类实例        Runnable runnable = new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;匿名内部类实现的Runnable&quot;);            &#125;        &#125;;        new Thread(runnable).start();                // 更简洁的写法：直接作为参数传递        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;直接作为参数的匿名内部类&quot;);            &#125;        &#125;).start();    &#125;&#125;\r\n8.5.3 与Lambda表达式对比\r\nJava\r\n8引入了Lambda表达式，可以替代只有一个抽象方法的接口的匿名内部类（函数式接口）：\r\npublic class Outer &#123;    public void createRunnableWithLambda() &#123;        // 使用匿名内部类        Runnable r1 = new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;匿名内部类&quot;);            &#125;        &#125;;                // 使用Lambda表达式        Runnable r2 = () -&gt; System.out.println(&quot;Lambda表达式&quot;);                new Thread(r1).start();        new Thread(r2).start();    &#125;&#125;\r\n8.5.4 应用场景\r\n\r\n需要快速实现接口或扩展类\r\n一次性使用的实现类\r\n事件监听器\r\n回调函数\r\n策略模式的简单实现\r\n比较器的实现\r\n\r\n8.6 内部类的内存结构\r\n内部类在编译后会生成独立的字节码文件，命名方式为外部类名$内部类名.class。不同类型的内部类在内存中的表示方式也不同。\r\n8.6.1 成员内部类的内存结构\r\n\r\n编译后生成：Outer$Inner.class\r\n每个内部类实例隐式持有外部类实例的引用\r\nJVM通过合成字段this$0存储外部类引用\r\n\r\n8.6.2 静态内部类的内存结构\r\n\r\n编译后生成：Outer$StaticNested.class\r\n不持有外部类实例的引用\r\n行为类似独立的类\r\n\r\n8.6.3 局部内部类的内存结构\r\n\r\n编译后生成：Outer$1LocalInner.class（数字表示定义顺序）\r\n通过合成字段引用外部类实例\r\n通过合成字段引用方法中的局部变量\r\n\r\n8.6.4 匿名内部类的内存结构\r\n\r\n编译后生成：Outer$1.class（数字表示定义顺序）\r\n通过合成字段引用外部类实例\r\n通过合成字段引用方法中的局部变量\r\n\r\n8.7 内部类的性能考虑\r\n\r\n内部类增加了类加载的开销\r\n非静态内部类的实例持有外部类的引用，可能导致外部类实例无法被垃圾回收\r\n过多使用内部类会使代码结构复杂\r\n当不需要访问外部类实例时，应优先使用静态内部类\r\n\r\n8.8 内部类的最佳实践\r\n\r\n恰当选择内部类类型：\r\n\r\n需要访问外部类实例成员：成员内部类\r\n不需要访问外部类实例成员：静态内部类\r\n仅在方法中使用：局部内部类\r\n一次性实现：匿名内部类\r\n\r\n访问控制：\r\n\r\n根据封装原则设置适当的访问修饰符\r\n尽量减少暴露内部类\r\n\r\n避免持有不必要的引用：\r\n\r\n使用静态内部类避免持有外部类引用\r\n注意潜在的内存泄漏问题\r\n\r\n简化代码：\r\n\r\n对于函数式接口，优先使用Lambda表达式而非匿名内部类\r\n使用内部类组织相关类，提高代码可读性\r\n\r\n\r\n成员内部类\r\npackage com.luotao.caseRing;/*** @Description: 外部类 * 外部类可以通过内部类对象访问内部类成员 * 外部类不可访问局部内部类**/class  Outer&#123;    private String name;    static final double E = 666;    public void add()&#123;        System.out.println(new Inner().inName);        System.out.println(new Sinner().sinName);    &#125;    public static void sum()&#123;        System.out.println(&quot;外部类静态方法&quot;);    &#125;    public void run()&#123;        int num =1;        final double G = 9.8;        /**        * @Description: 局部内部类        **/        class LocalInner&#123;            int a=1;            static  final double money=100;            public void local()&#123;                System.out.println(&quot;局部内部类方法&quot;);            &#125;        &#125;    &#125;    /**    * @Description: 成员内部类中不能定义静态代码块及静态方法     * 成员内部类可以访问外部类的所有成员    * @Author: LuoTao    * @Date: 2024-10-06 16:03:55    **/    class Inner&#123;        String inName ;        static final double PT = 3.14;        &#123;            System.out.println(name);            System.out.println(Outer.E);        &#125;        public void test()&#123;            System.out.println(&quot;执行成员内部类方法&quot;);        &#125;    &#125;    /**     * @Description: 静态内部类     * @Author: LuoTao     * @Date: 2024-10-06 16:03:55     **/    static class Sinner&#123;        String sinName ;        static final double PT = 3.14;        &#123;            System.out.println(new Outer().name);            System.out.println(Outer.E);        &#125;        public void stest()&#123;            System.out.println(&quot;执行静态内部类方法&quot;);        &#125;    &#125;&#125;public class AppMain &#123;    public static void main(String[] args) &#123;        Outer.Inner inner = new Outer().new Inner();        inner.test();        Outer.Sinner sinner =  new Outer.Sinner();        sinner.stest();    &#125;&#125;\r\n匿名内部类\r\npackage com.rabbiter.hello;interface Animal &#123;    void eat();//吃&#125;/** * @Description: 匿名内部类 **/class Appmain&#123;    public static void main(String[] args) &#123;        /**        * @Description: 等同于        System.out.println(animal.getClass().getName());//com.rabbiter.hello.Appmain$1         class Appmain$1 extends Animal&#123;            @Override            public void eat() &#123;            System.out.println(&quot;干饭&quot;);            &#125;        &#125;;         Animal animal = new Appmain$1();//多态之向上转型        animal.eat();        **/        Animal animal = new Animal() &#123;            @Override            public void eat() &#123;                System.out.println(&quot;干饭&quot;);            &#125;        &#125;;        animal.eat();    &#125;&#125;\r\n基于抽象工厂模式的单图形和颜色系统\r\n\r\n\r\nimage-20241119123641397\r\n\r\n/** * @Description 基于抽象工厂模式的单图形和颜色系统 * * 允许客户端通过工厂来创建一系列相关或依赖的对象，而无需指定它们的具体类,通过工厂生产器，客户端代码与具体工厂解耦，增加了系统的灵活性和可扩展性。 * 想添加新的形状或颜色，只需添加新的实现类并更新工厂类，无需修改客户端代码。 * * 引入了大量的类和接口，对于简单的问题可能造成过度设计。 * 抽象工厂模式适用于当一个系统需要独立于其组成部分的具体类时，或者当一个系统需要由多个产品系列中的一个来配置时。这种模式有助于构建高度可维护和可扩展的软件架构。 **/package com.rabbiter.hello;/** * @Description 图形接口 **/interface Shape&#123;    /**     * @Description 图形绘制抽象方法     **/    void draw();&#125;/** * @Description 颜色接口 **/interface Color&#123;    /**     * @Description 填充颜色抽象方法     **/    void fill();&#125;/** * @Description 圆形 **/class Circle implements Shape&#123;    @Override    public void draw() &#123;        System.out.println(&quot;绘制圆形&quot;);    &#125;&#125;/** * @Description 长方形 **/class Rectangle implements Shape&#123;    @Override    public void draw() &#123;        System.out.println(&quot;绘制长方形&quot;);    &#125;&#125;/** * @Description 正方形 **/class Square implements Shape&#123;    @Override    public void draw() &#123;        System.out.println(&quot;绘制正方形&quot;);    &#125;&#125;/** * @Description 图形工厂类 **/class ShapeFactory extends AbstractFactory&#123;    @Override    Color getColor(String colorName) &#123;        throw new UnsupportedOperationException(&quot;ShapeFactory cannot produce Color&quot;);    &#125;    @Override    Shape getShape(String shapeName)&#123;        if(shapeName == null)&#123;            return null;        &#125;else if(shapeName.equalsIgnoreCase(&quot;circle&quot;))&#123;            return new Circle();        &#125;else if(shapeName.equalsIgnoreCase(&quot;rectangle&quot;))&#123;            return new Rectangle();        &#125;else if(shapeName.equalsIgnoreCase(&quot;square&quot;))&#123;            return new Square();        &#125;else&#123;            return null;        &#125;    &#125;&#125;/** * @Description 颜色工厂类 **/class ColorFactory extends AbstractFactory&#123;    @Override    Color getColor(String colorName) &#123;        if (colorName==null)&#123;            return  null;        &#125;else if(colorName.equalsIgnoreCase(&quot;red&quot;))&#123;            return new Red();        &#125;else if(colorName.equalsIgnoreCase(&quot;green&quot;))&#123;            return new Green();        &#125;else if(colorName.equalsIgnoreCase(&quot;blue&quot;))&#123;            return new Blue();        &#125;        return null;    &#125;    @Override    Shape getShape(String shapeName) &#123;        throw new UnsupportedOperationException(&quot;ColorFactory cannot produce Shape&quot;);    &#125;&#125;/** * @Description 填充红色 **/class Red implements Color&#123;    @Override    public void fill() &#123;        System.out.println(&quot;填充红色&quot;);    &#125;&#125;/** * @Description 填充绿色 **/class Green implements Color&#123;    @Override    public void fill() &#123;        System.out.println(&quot;填充绿色&quot;);    &#125;&#125;/** * @Description 填充蓝色 **/class Blue implements Color&#123;    @Override    public void fill() &#123;        System.out.println(&quot;填充蓝色&quot;);    &#125;&#125;/** * @Description 抽象工厂类 **/abstract class AbstractFactory&#123;    /**     * @Description 获取颜色     **/    abstract Color getColor(String colorName);    /**     * @Description 获取形状     **/    abstract Shape getShape(String shapeName);&#125;/** * @Description 工厂生成器类:根据工厂名称返回对应的工厂实例 **/class FactoryProducer&#123;    static AbstractFactory getFactory(String factoryName)&#123;        if(factoryName==null)&#123;            return null;        &#125;else if(factoryName.equalsIgnoreCase(&quot;shape&quot;))&#123;            return new ShapeFactory();        &#125;else if(factoryName.equalsIgnoreCase(&quot;color&quot;))&#123;            return new ColorFactory();        &#125;        return null;    &#125;&#125;/** * @Description 客户端代码 **/class AbstractFactoryPattern&#123;    public static void main(String[] args) &#123;        /*        ShapeFactory shapeFactory = new ShapeFactory();        Shape circle = shapeFactory.getShape(&quot;circle&quot;);//向上转型        circle.draw();        Rectangle rectangle = (Rectangle)shapeFactory.getShape(&quot;rectangle&quot;);//向下转型        rectangle.draw();         */        //图形工厂绘制图形        AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;shape&quot;);//通过工厂生产器获取工厂实例        Shape circle = shapeFactory.getShape(&quot;circle&quot;);        if (circle != null )&#123;            circle.draw();//绘制圆形        &#125;        //颜色工厂填充颜色        AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;color&quot;);        Color red = colorFactory.getColor(&quot;red&quot;);        if (red !=null) &#123;            red.fill();//填充红色        &#125;    &#125;&#125;\r\n/** * 添加新的形状只需添加新的实现类三角形，无需修改客户端代码 */class Triangle implements Shape &#123;    @Override    public void draw() &#123;        System.out.println(&quot;绘制三角形&quot;);    &#125;&#125;// 更新 ShapeFactoryclass ShapeFactory extends AbstractFactory &#123;    @Override    Color getColor(String colorName) &#123;        throw new UnsupportedOperationException(&quot;ShapeFactory cannot produce Color&quot;);    &#125;    @Override    Shape getShape(String shapeName) &#123;        if (shapeName == null) &#123;            return null;        &#125;        switch (shapeName.toLowerCase()) &#123;            case &quot;circle&quot;:                return new Circle();            case &quot;rectangle&quot;:                return new Rectangle();            case &quot;square&quot;:                return new Square();            case &quot;triangle&quot;: // 新增三角形                return new Triangle();            default:                return null;        &#125;    &#125;&#125;// 客户端代码中测试新的形状public class AbstractFactoryPattern &#123;    public static void main(String[] args) &#123;        // 图形工厂绘制图形        AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;shape&quot;);        Shape triangle = shapeFactory.getShape(&quot;triangle&quot;);        if (triangle != null) &#123;            triangle.draw(); // 绘制三角形        &#125;                // ...其余代码保持不变...    &#125;&#125;\r\n单例模式\r\n\r\n招聘网可视化分析系统\r\n\r\n\r\nimage-20241223131750714\r\n\r\nspringboot\r\n\r\n\r\n快速构建：相当于半成品的基础架构，等待填充业务逻辑完善细节\r\n约定优于配置：如连接数据库、日志处理等提供默认约定\r\n\r\n\r\n@SpringBootApplication\r\n\r\n\r\n@SpringBootApplication\r\n启动类注解 包装了@SpringBootConfiguration@EnableAutoConfiguration、@ComponentSan。是一个组合注解。\r\n@SpringBootConfiguration\r\n封装了@Configuration,定义了一系列的配置信息。\r\n@EnableAutoConfiguration\r\n开启自动配置。\r\n@ComponentScan\r\n扫描启动类及其子集将符合条件的组件自动发现和装配。\r\n\r\n\r\n\r\n\r\nimage-20241223155741285\r\n\r\n@SpringBootConfiguration\r\n\r\n定义管理配置信息\r\n封装了@Configuration\r\n\r\n@Configuration\r\n\r\n作用: 标识该类是一个配置类，Spring 容器会将其作为一个 Bean\r\n定义的来源。\r\n场景: 通常用于定义 Spring 应用上下文中的 Bean。\r\n\r\n@EnableAutoConfiguration\r\n\r\n开启自动配置功能\r\n\r\n@ComponentScan\r\n\r\n扫描并加载符合条件的组件\r\n将启动类同级及子集扫描出来自动发现和装配组件\r\n\r\n统一响应\r\n\r\n\r\n枚举类：列出响应状态码\r\n响应结果类：封装响应结果\r\n\r\n\r\n枚举响应状态码：\r\npackage com.luotao.job.utils.enums;import lombok.Getter;/** * @Classname ResultCodeEnum * @Description 枚举类：统一响应状态码 * @Version 1.css.0.0 * @Date 2024/12/24 16:56 * @Author LuoTao */@Getter // 自动生成getter方法public enum ResultCodeEnum &#123;    SUCCESS(200, &quot;请求成功&quot;),    PARAM_ERROR(400, &quot;参数错误&quot;),    NOT_FOUND(404, &quot;接口不存在&quot;),    SERVER_ERROR(500, &quot;服务器错误&quot;),    DB_ERROR(505, &quot;数据库错误&quot;),    UNKNOWN_ERROR(600, &quot;未知错误&quot;),    UNIQUE_KEY_ERROR(506, &quot;唯一键冲突&quot;)    ;    /**     响应状态码     **/    private Integer code;    /**     状态码描述     **/    private String msg;    ResultCodeEnum(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;&#125;\r\n封装响应结果：\r\npackage com.luotao.job.utils;import com.luotao.job.utils.enums.ResultCodeEnum;import lombok.Data;/** * @Classname ResponseResult * @Description 封装响应结果 * @Version 1.css.0.0 * @Date 2024/12/26 16:43 * @Author LuoTao */@Datapublic class ResponseResult &#123;    private Integer code;    private String msg;    private Object data;    /**     * @Description 自定义返回     * @Author LuoTao     * @Date 2024/12/26 16:52     * @param code 自定义状态码     * @param msg 自定义提示信息     * @param data 自定义返回数据     **/    public ResponseResult(Integer code,String msg,Object data)&#123;        this.code=code;        this.msg=msg;        this.data=data;    &#125;    /**     * @Description 自定义返回-不返回对象     **/    public ResponseResult(Integer code,String msg)&#123;        this.code=code;        this.msg=msg;        this.data=null;    &#125;    /**    * @Description: 请求成功-不返回对象，使用默认的成功消息    * @Author: LuoTao    * @Date: 2024-12-26 16:58:39    **/    public ResponseResult()&#123;        this.code = ResultCodeEnum.SUCCESS.getCode();        this.msg=ResultCodeEnum.SUCCESS.getMsg();        this.data=null;    &#125;    /**     * @Description 请求成功返回对象，使用默认的成功消息     * @Author LuoTao     * @Date 2024/12/26 17:11     **/    public ResponseResult(Object data) &#123;            this.code=ResultCodeEnum.SUCCESS.getCode();            this.msg=ResultCodeEnum.SUCCESS.getMsg();            this.data = data;    &#125;&#125;\r\n@RestController\r\n\r\n组合功能 @RestController 是 @Controller 和 @ResponseBody\r\n的组合注解。 @Controller：标记一个类为控制器类，Spring\r\n容器会扫描并注册该类为一个 Bean。 @ResponseBody：标记在方法上时，表示该方法的返回值将直接写入\r\nHTTP 响应体中，而不是解析为视图。\r\n自动处理响应体 使用 @RestController\r\n注解后，控制器中的所有方法默认都会使用 @ResponseBody\r\n注解，这意味着这些方法的返回值会被转换为 JSON、XML 等格式，并直接写入\r\nHTTP 响应体中，而不需要再手动添加 @ResponseBody 注解。\r\n\r\npackage com.luotao.job.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;/** * @Classname DemoController * @Description 处理客户端的HTTP请求，协调业务处理，根据请求返回数据 * @Version 1.0.0 * @Date 2024/12/23 16:24 * @Author LuoTao *///@Controller@RestController // @RestController 是 @ResponseBody、@Controller 的组合注解public class DemoController &#123;    @GetMapping(&quot;get/userinfo&quot;)    //@ResponseBody//将返回值作为响应体返回客户端    public String getUserinfo(@RequestParam(value = &quot;username&quot;,required = true) String nickname)&#123;        return &quot;昵称&quot; + nickname;    &#125;    @PostMapping(&quot;/login&quot;)    //@ResponseBody    public String login()&#123;        return &quot;login success&quot;;    &#125;&#125;\r\nvalidation校验注解\r\n\r\n放在实体类的字段或方法参数上，以验证用户输入或其他数据源提供的信息。\r\n1.引入validation依赖；2.实体类添加注解；3.控制器方法签名添加@Valid注解\r\n\r\n\r\n\r\n\r\n校验功能\r\n注解\r\n描述\r\n\r\n\r\n\r\n\r\n空、非空校验\r\n@Null\r\n验证对象是否为Null\r\n\r\n\r\n\r\n@NotNull\r\n验证是否不为Null\r\n\r\n\r\n\r\n@NotBlank\r\n验证字符串不为空\r\n\r\n\r\n\r\n@NotEmpty\r\n元素不为Null、不为Empty\r\n\r\n\r\n布尔校验\r\n@AssertTrue\r\n验证布尔对象是否为True\r\n\r\n\r\n\r\n@AssertFalse\r\n验证是否为False\r\n\r\n\r\n长度校验\r\n@Size\r\n对象长度必须在给定范围之内\r\n\r\n\r\n\r\n@Length\r\n元素值长度在给定范围之内\r\n\r\n\r\n邮箱校验\r\n@Email\r\n验证是否为电子邮箱\r\n\r\n\r\n\r\n&lt;!--        validation参数校验--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;        &lt;/dependency&gt;\r\n@Data // 自动生成getter、setter及toString方法@NoArgsConstructor // 自动生成无参构造@AllArgsConstructor // 自动生成全参构造public class JobCategory &#123;    private int id;    @NotBlank(message = &quot;分类名称不能为空&quot;)    @Length(min = 2,max = 20,message = &quot;分类名称长度为2-20位&quot;)    private String categoryName;    private String categoryDesc;&#125;\r\n@PostMapping(&quot;/add/category&quot;)public ResponseResult addJobCategory(@Validated JobCategory jobCategory) &#123;    return jobCategoryService.addJobCategory(jobCategory);&#125;\r\n读取配置文件\r\n# 应用服务 WEB 访问端口server:  port: 8080# 数据库spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/job?serverTimezone=Asia/Shanghai    username: root    password: root\r\n用@value注解：\r\n/** * @Description Value注解可以读取配置文件 * http://127.0.0.1:8080/get/yaml **/@GetMapping(&quot;/get/yaml&quot;)public void getPropertiesValue(@Value(&quot;$&#123;server.port&#125;&quot;) String port)&#123;    System.out.println(&quot;================&quot;);    System.out.println(&quot;port is &quot; + port);    System.out.println(&quot;================&quot;);&#125;\r\n用@ConfigurationProperties注解：\r\npackage com.luotao.job.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;/** * @Description 处理客户端的HTTP请求，协调业务处理，根据请求返回数据 */@RestController // @RestController 是 @ResponseBody、@Controller 的组合注解@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)//读取配置文件的属性注解,属性名需一致并通过setter注入public class DemoController &#123;    private String username;    private String password;    public void setUsername(String username)&#123;        this.username=username;    &#125;    public void setPassword(String password)&#123;        this.password = password;    &#125;    /**     * @Description Value注解可以读取配置文件     * http://127.0.0.1:8080/get/yaml     **/    @GetMapping(&quot;/get/yaml&quot;)    public void getPropertiesValue(@Value(&quot;$&#123;server.port&#125;&quot;) String port)&#123;        System.out.println(&quot;================&quot;);        System.out.println(&quot;port is &quot; + port);        System.out.println(username + &quot;:&quot; + password);        System.out.println(&quot;================&quot;);    &#125;&#125;\r\n统一响应\r\n\r\n1.枚举类：统一响应状态码\r\n2.封装响应结果\r\n\r\npackage com.luotao.job.utils.enums;import lombok.Getter;/** * @Classname ResultCodeEnum * @Description 枚举类：统一响应状态码 * @Version 1.0.0 * @Date 2024/12/24 16:56 * @Author LuoTao */@Getter // 自动生成getter方法public enum ResultCodeEnum &#123;    SUCCESS(200, &quot;请求成功&quot;),    PARAM_ERROR(400, &quot;参数错误&quot;),    NOT_FOUND(404, &quot;接口不存在&quot;),    SERVER_ERROR(500, &quot;服务器错误&quot;),    DB_ERROR(505, &quot;数据库错误&quot;),    UNKNOWN_ERROR(600, &quot;未知错误&quot;),    UNIQUE_KEY_ERROR(506, &quot;唯一键冲突&quot;)    ;    /**     响应状态码     **/    private Integer code;    /**     状态码描述     **/    private String msg;    ResultCodeEnum(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;&#125;\r\npackage com.luotao.job.utils.enums;import lombok.Data;/** * @Classname ResponseResult * @Description 封装响应结果 * @Version 1.0.0 * @Date 2024/12/26 16:43 * @Author LuoTao */@Datapublic class ResponseResult &#123;    private Integer code;    private String msg;    private Object data;    /**     * @Description 自定义返回     * @Author LuoTao     * @Date 2024/12/26 16:52     * @param code 自定义状态码     * @param msg 自定义提示信息     * @param data 自定义返回数据     **/    public ResponseResult(Integer code,String msg,Object data)&#123;        this.code=code;        this.msg=msg;        this.data=data;    &#125;    /**     * @Description 自定义返回-不返回对象     **/    public ResponseResult(Integer code,String msg)&#123;        this.code=code;        this.msg=msg;        this.data=null;    &#125;    /**    * @Description: 请求成功-不返回对象    * @Author: LuoTao    * @Date: 2024-12-26 16:58:39    **/    public ResponseResult()&#123;        this.code = ResultCodeEnum.SUCCESS.getCode();        this.msg=ResultCodeEnum.SUCCESS.getMsg();        this.data=null;    &#125;    /**     * @Description 请求成功返回对象，使用默认的成功消息     * @Author LuoTao     * @Date 2024/12/26 17:11     **/    public ResponseResult(Object data) &#123;            this.code=ResultCodeEnum.SUCCESS.getCode();            this.msg=ResultCodeEnum.SUCCESS.getMsg();            this.data = data;    &#125;&#125;\r\n全局异常处理\r\n@RestControllerAdvice\r\n@ExceptionHandler(BindException.class)\r\npackage com.luotao.job.utils.enums.exception;import com.luotao.job.utils.enums.ResponseResult;import com.luotao.job.utils.enums.ResultCodeEnum;import org.springframework.dao.DuplicateKeyException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;/** * @Classname GlobalExceptionHandler * @Description 全局异常处理 * @Version 1.0.0 * @Date 2024/12/27 15:49 * @Author LuoTao */@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    /**     * @Description 参数校验异常处理     **/    @ExceptionHandler(BindException.class)    public ResponseResult bindException(BindException e) &#123;        /**         * @Description 从BindingResult对象中获取错误信息         **/        BindingResult bindingResult = e.getBindingResult();        StringBuilder stringBuilder = new StringBuilder(&quot;校验失败：&quot;);        for (FieldError fieldError : bindingResult.getFieldErrors()) &#123;            stringBuilder                    .append(fieldError.getField())                    .append(&quot;:&quot;)                    .append(fieldError.getDefaultMessage())                    .append(&quot;,&quot;);        &#125;        String msg = stringBuilder.toString();        return new ResponseResult(ResultCodeEnum.PARAM_ERROR.getCode(),msg);    &#125;    /**     * @Description 唯一键异常处理     **/    @ExceptionHandler(DuplicateKeyException.class)    public ResponseResult duplicateKeyException(Exception e) &#123;        return new ResponseResult(ResultCodeEnum.UNIQUE_KEY_ERROR.getCode(),e.getCause().getMessage());    &#125;    /**     * @Description 未知异常处理     **/    @ExceptionHandler(Exception.class)    public ResponseResult unknownException(Exception e) &#123;        return new ResponseResult(ResultCodeEnum.UNKNOWN_ERROR.getCode(),e.getMessage());    &#125;&#125;s\r\n日志对象Logger\r\n\r\n1.properties配置日志输出目录\r\n2.xml配置文件\r\n3.在全局统一异常处理类中应用：\r\n1.两种方式创建log日志对象\r\n：在类上加@Slf4j注解或者手动创建Logger对象\r\n2.记录日志：用log.error将错误代码和错误消息记录到日志中\r\n\r\npackage com.luotao.job.utils.enums.exception;import com.luotao.job.utils.enums.ResponseResult;import com.luotao.job.utils.enums.ResultCodeEnum;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.dao.DuplicateKeyException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;/** * @Classname GlobalExceptionHandler * @Description 全局异常处理 * @Version 1.0.0 * @Date 2024/12/27 15:49 * @Author LuoTao */@Slf4j //注解创建日志对象@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    // public static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);// 手动创建日志对象    /**     * @Description 参数校验异常处理     **/    @ExceptionHandler(BindException.class)    public ResponseResult bindException(BindException e) &#123;        /**         * @Description 从BindingResult对象中获取错误信息         **/        BindingResult bindingResult = e.getBindingResult();        StringBuilder stringBuilder = new StringBuilder(&quot;校验失败：&quot;);        for (FieldError fieldError : bindingResult.getFieldErrors()) &#123;            stringBuilder                    .append(fieldError.getField())                    .append(&quot;:&quot;)                    .append(fieldError.getDefaultMessage())                    .append(&quot;,&quot;);        &#125;        String msg = stringBuilder.toString();        log.error(ResultCodeEnum.PARAM_ERROR.getCode() + msg);//记录日志：将错误代码和错误消息记录到日志中        return new ResponseResult(ResultCodeEnum.PARAM_ERROR.getCode(),msg);    &#125;    /**     * @Description 唯一键异常处理     **/    @ExceptionHandler(DuplicateKeyException.class)    public ResponseResult duplicateKeyException(Exception e) &#123;        log.error(ResultCodeEnum.UNIQUE_KEY_ERROR.getCode() + e.getCause().getMessage());        return new ResponseResult(ResultCodeEnum.UNIQUE_KEY_ERROR.getCode(),e.getCause().getMessage());    &#125;    /**     * @Description 未知异常处理     **/    @ExceptionHandler(Exception.class)    public ResponseResult unknownException(Exception e) &#123;        log.error(ResultCodeEnum.UNKNOWN_ERROR.getCode() + e.getMessage());        return new ResponseResult(ResultCodeEnum.UNKNOWN_ERROR.getCode(),e.getMessage());    &#125;&#125;\r\n# 日志输出目录logging:  file:    path: ./logs\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--logback-spring.xml    1.日志级别及含义：    FATAL-严重问题,通常是导致程序退出的错误    ERROR-记录程序错误或异常情况    WARN-警告信息，低于WARN的日志不输出    INFO-记录程序运行状态或异常情况    DEBUG-输出详细的调试信息    TRACE-级别最低    OFF-特殊级别，关闭所有的日志记录--&gt;&lt;!-- configuration:根节点    debug:为ture时，打印出logback内部日志信息，实时查看logback运行状态    scan:为true时，配置文档如果改变，将会重新加载    scanPeriod:监测配置文档是否有修改的时间间隔，当scan为true时生效--&gt;&lt;configuration debug=&quot;false&quot; scan=&quot;true&quot; scanPeriod=&quot;30 seconds&quot;&gt;    &lt;!--   logger上下文名称--&gt;    &lt;contextName&gt;logback&lt;/contextName&gt;    &lt;!--    属性配置--&gt;    &lt;!--    name:属性名,value:属性值,使用$&#123;&#125;引用属性--&gt;    &lt;property name=&quot;log.path&quot; value=&quot;$&#123;LOG_PATH&#125;&quot;/&gt;    &lt;!--  彩色日志依赖的渲染类  --&gt;    &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot;/&gt;    &lt;conversionRule conversionWord=&quot;wex&quot;                    converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;/&gt;    &lt;conversionRule conversionWord=&quot;wEx&quot;                    converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;/&gt;    &lt;!--    彩色日志格式--&gt;    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;              value=&quot;%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr(%5p) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n%wex&quot;/&gt;    &lt;!--    输出到控制台--&gt;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!--        控制台输出&gt;=此级别的日志信息--&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;            &lt;level&gt;debug&lt;/level&gt;        &lt;/filter&gt;        &lt;encoder&gt;            &lt;!--   日志输出格式         --&gt;            &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!--    输出到文档--&gt;    &lt;!--    ERROR级别日志，时间滚动输出--&gt;    &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!--        正在记录的日志文档路径及文档名--&gt;        &lt;file&gt;$&#123;log.path&#125;/error.log&lt;/file&gt;        &lt;!--        日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:%line - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;        &lt;!--   日志记录器的滚动策略，按日期、文件大小记录     --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!--        日志记录文件名，日志记录文件名后缀为.log--&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/error.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--            日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!--        此日志文档只记录ERROR级别日志--&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;ERROR&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!--    WARN级别日志，时间滚动输出--&gt;    &lt;appender name=&quot;WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!--        正在记录的日志文档路径及文档名--&gt;        &lt;file&gt;$&#123;log.path&#125;/warn.log&lt;/file&gt;        &lt;!--        日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:%line - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;        &lt;!--   日志记录器的滚动策略，按日期、文件大小记录     --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--            日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!--        此日志文档只记录  WARN 级别日志--&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;WARN&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!--    DEBUG级别日志，时间滚动输出--&gt;    &lt;appender name=&quot;DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!--        正在记录的日志文档路径及文档名--&gt;        &lt;file&gt;$&#123;log.path&#125;/debug.log&lt;/file&gt;        &lt;!--        日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:%line - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;        &lt;!--        日志记录器的滚动策略，按日期、文件大小记录--&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!--            日志归档--&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/debug.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--            日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!--        此日志文档只记录 DEBUG 级别日志--&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;DEBUG&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!--    INFO 级别日志，时间滚动输出--&gt;    &lt;appender name=&quot;INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!--        正在记录的日志文档路径及文档名--&gt;        &lt;file&gt;$&#123;log.path&#125;/info.log&lt;/file&gt;        &lt;!--        日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;:%line - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;        &lt;!--        日志记录器的滚动策略，按日期、文件大小记录--&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!--            日志归档--&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/info.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--            日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!--        此日志文档只记录 INFO 级别日志--&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;INFO&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!--        root, 必选节点，指定基础日志输出级别        appender-ref 指定日志输出到哪个appender    --&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;        &lt;appender-ref ref=&quot;DEBUG&quot;/&gt;        &lt;appender-ref ref=&quot;INFO&quot;/&gt;        &lt;appender-ref ref=&quot;ERROR&quot;/&gt;        &lt;appender-ref ref=&quot;WARN&quot;/&gt;    &lt;/root&gt;    &lt;!--    指定某个包下的日志级别,默认使用 root 标签配置,打印 MyBatis 的日志级别为 DEBUG--&gt;    &lt;logger name=&quot;com.luotao.job.mapper&quot; level=&quot;DEBUG&quot;/&gt;&lt;/configuration&gt;\r\n设计模式-mvc\r\n\r\n\r\nimage-20241223174716970\r\n\r\n\r\n\r\n设计模式，将程序的业务逻辑、数据和用户界面分离\r\n实现代码分离模块化\r\n用户通过view发送请求给服务器，controller对请求解析并找到model,model对请求处理完毕后将结果返回给controller，controller找到view，view将结果渲染呈现\r\nmodel封装业务相关数据及数据的处理方法。\r\nview对数据渲染\r\ncontroller接受用户输入，决定调用哪个模型处理，然后选择视图来展示处理结果。负责协调view和model的交互。\r\n\r\n\r\nmodel\r\n\r\n封装业务相关数据以及数据的处理方法，如数据的存储、读取及验证\r\n\r\nview\r\n\r\n数据展示\r\n\r\ncontroller\r\n\r\n\r\n需求——》服务员（controller）——》厨师长（service）\r\n控制业务流程，协调model和view的交互。接受前端请求调用service层并接受返回的数据，最后返回给前端\r\n\r\n\r\n@RequestMapping\r\n@RequestMapping 用于映射 HTTP\r\n请求到处理请求的控制器方法上。用来指定 URL 映射、HTTP 方法类型（如\r\nGET、POST 等）、请求参数、请求头等。\r\n@PathVariabl\r\n@PathVariable\r\n注解是 Spring MVC 中用于处理 URL\r\n路径变量的重要工具，它可以方便地从请求路径中提取动态部分，并将其作为参数传递给控制器方法，从而实现更灵活和强大的路由功能。\r\nservice\r\n\r\n\r\n需求——》服务员（controller）——》厨师长（service）\r\n由具体实现类实现具体的业务逻辑\r\n\r\n\r\npackage com.luotao.job.service;import com.luotao.job.domain.JobCategory;import com.luotao.job.utils.ResponseResult;public interface JobCategoryService &#123;    /**        获取所有岗位类别    **/    ResponseResult getAllJobCategory();    /**     * 新增岗位类别     **/    ResponseResult addJobCategory(JobCategory jobCategory);    /**     * 删除岗位类别     **/    ResponseResult deleteJobCategory(Integer id);    /**     * 更新岗位类别     **/    ResponseResult updateJobCategory(JobCategory jobCategory);&#125;\r\nservice实现类\r\npackage com.luotao.job.service;import com.luotao.job.domain.JobCategory;import com.luotao.job.mapper.JobCategoryMapper;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.ResultCodeEnum;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.annotation.Resource;import javax.swing.*;import java.util.HashMap;/** * @Classname JobCategoryServiceImpl * @Description TODO * @Version 1.css.0.0 * @Date 2024/12/24 16:56 * @Author LuoTao */@Servicepublic class JobCategoryServiceImpl implements JobCategoryService &#123;    /*让 Spring 容器自动为 jobCategoryMapper 成员变量注入一个实现了 JobCategoryMapper 接口的实例对象。    javax.swing.Spring 会根据配置（例如 MyBatis 的配置）动态生成JobCategoryMapper 实现类的代理对象。这个代理对象会被注入到 jobCategoryMapper 中     */    @Resource// 注入    private JobCategoryMapper jobCategoryMapper;    /**     * 获取所有岗位类别     **/    @Override    public ResponseResult getAllJobCategory() &#123;        return new ResponseResult(jobCategoryMapper.allJobCategory());    &#125;    /**     * 新增岗位类别     *     * @param jobCategory     */    @Override    public ResponseResult addJobCategory(JobCategory jobCategory) &#123;        HashMap&lt;String, Integer&gt; idMap = new HashMap&lt;&gt;();        int increamentID = jobCategoryMapper.insertJobCategory(jobCategory);//        System.out.println(increamentID);        if (increamentID &gt;0 )&#123;            idMap.put(&quot;id&quot;, jobCategory.getId());            return new ResponseResult(idMap);        &#125;        return new ResponseResult(ResultCodeEnum.SERVER_ERROR);    &#125;    /**     * 删除岗位类别     *     * @param id     */    @Override    public ResponseResult deleteJobCategory(Integer id) &#123;        if (jobCategoryMapper.deleteByPrimaryKey(id) &gt; 0) &#123;            return new ResponseResult();        &#125;        return new ResponseResult(ResultCodeEnum.DB_ERROR);    &#125;    /**     * 更新岗位类别     *     * @param jobCategory     */    @Override    public ResponseResult updateJobCategory(JobCategory jobCategory) &#123;        if (jobCategoryMapper.updateByPrimaryKey(jobCategory)&gt;0)&#123;            return new ResponseResult();        &#125;        return new ResponseResult(ResultCodeEnum.DB_ERROR);    &#125;&#125;\r\nmapper\r\n\r\n\r\n副手，完成厨师长的任务\r\n1.编写mapper接口;2.配置xml文件;3.properties配置xml路径；4.启动类上标识扫描注解\r\nMapper作为连接应用层和数据库层的关键组件，充当数据库操作的接口,简化数据库交互过程\r\n定义sql语句：mapper中的方法签名和xml的SQL语句一一对应\r\n参数映射：java对象或基本类型可以映射为SQL语句中的占位符使得可以通过代码传递对象或参数\r\n结果映射：mpper可将查询结果映射为java对象，简单的标量值还是复杂的数据结构都可以通过配置实现\r\n\r\n\r\n@Bean\r\n\r\n作用: 标识方法会返回一个对象，该对象会被注册到 Spring 容器中作为一个\r\nBean\r\n\r\n@MapperScan\r\n自动发现并注册所有的 Mapper 接口，并将其注册为 Spring 的 Bean。\r\n@MapperScan(&quot;com.luotao.job.mapper&quot;)// 启动类上标识扫描接口所在包\r\n# application.yaml 中配置mpper位置mybatis:  mapper-locations: classpath:/mapper/**/*.xml\r\nmapper.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.luotao.job.mapper.JobCategoryMapper&quot;&gt;&lt;!--* 副手，完成厨师长的任务* Mapper作为连接应用层和数据库层的关键组件，充当数据库操作的接口,简化数据库交互过程* 定义sql语句：mapper中的方法签名和xml的SQL语句一一对应* 参数映射：java对象或基本类型可以映射为SQL语句中的占位符使得可以通过代码传递对象或参数* 结果映射：mpper可将查询结果映射为java对象，简单的标量值还是复杂的数据结构都可以通过配置实现--&gt;    &lt;select id=&quot;allJobCategory&quot; resultType=&quot;com.luotao.job.domain.JobCategory&quot;&gt;        select * from `job_category`    &lt;/select&gt;    &lt;!--keyProperty=&quot;id&quot; 表示插入操作完成后，新生成的主键将被映射到传入的 JobCategory 对象的 id 属性上。--&gt;    &lt;insert id=&quot;insertJobCategory&quot; parameterType=&quot;com.luotao.job.domain.JobCategory&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;        insert into `job_category`(category_name,category_desc) values (#&#123;category_name&#125;,#&#123;category_desc&#125;)    &lt;/insert&gt;    &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; &gt;        delete from `job_category` where id=#&#123;id&#125;    &lt;/delete&gt;    &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.luotao.job.domain.JobCategory&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;        update `job_category` set category_name=#&#123;category_name&#125;,category_desc=#&#123;category_desc&#125;  where id=#&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;\r\nmapper接口\r\npackage com.luotao.job.mapper;import com.luotao.job.domain.JobCategory;import java.util.List;/** * @Classname JobCategoryMapper */public interface JobCategoryMapper &#123;    /**     查询数据    **/    List&lt;JobCategory&gt; allJobCategory();    /**        添加数据    **/    int insertJobCategory(JobCategory jobCategory);    /**     * 删除数据     **/    int deleteByPrimaryKey(Integer id);    /**     修改数据     **/    int updateByPrimaryKey(JobCategory jobCategory);&#125;\r\ndomain\r\n\r\n\r\n原材料\r\n定义数据实体，与数据库表的关系。一张表对应一个实体类，类属性值与字段一一对应\r\n\r\n\r\npackage com.luotao.job.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * @Classname JobCategory-- 岗位分类表drop table if exists job_category;create table job_category(id int not null auto_increment comment &#x27;ID&#x27;,category_name varchar(80) not null comment &#x27;分类名称&#x27;,category_desc varchar(200) default null comment &#x27;分类描述&#x27;,primary key (id),unique key category_name_unique(category_name)) engine =innodb default charset =utf8mb4 comment =&#x27;岗位分类表&#x27;; */@Data // 自动生成getter、setter及toString方法@NoArgsConstructor // 自动生成无参构造@AllArgsConstructor // 自动生成全参构造public class JobCategory &#123;    private int id;    /**    * @Description: 分类名称    **/    private String category_name;    /**     * @Description: 分类描述     **/    private String category_desc;&#125;\r\n三层架构\r\n\r\n软件架构\r\n\r\n\r\n\r\nimage-20241223183424895\r\n\r\n岗位分类表数据库设计\r\ncreate schema job collate utf8_general_ci;\r\n-- 岗位分类表drop table if exists job_category;create table job_category(    id int not null auto_increment comment &#x27;ID&#x27;,    category_name varchar(80) not null comment &#x27;分类名称&#x27;,    category_desc varchar(200) default null comment &#x27;分类描述&#x27;,    primary key (id),    unique key category_name_unique(category_name)) engine =innodb default charset =utf8mb4 comment =&#x27;岗位分类表&#x27;;\r\nINSERT INTO job_category (category_name, category_desc)VALUES (&#x27;技术类&#x27;, &#x27;与技术开发和编程相关的工作&#x27;),       (&#x27;管理类&#x27;, &#x27;涉及项目管理和团队领导的工作&#x27;),       (&#x27;销售类&#x27;, &#x27;负责产品销售和市场推广的工作&#x27;),       (&#x27;财务类&#x27;, &#x27;处理财务和会计相关的工作&#x27;),       (&#x27;人力资源类&#x27;, &#x27;负责招聘、培训和员工管理的工作&#x27;);\r\nmybatis\r\n\r\n封装JDBC\r\n\r\n&lt;!--mybatis--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--数据库驱动--&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.33&lt;/version&gt;&lt;/dependency&gt;\r\nappllication.yaml\r\n# 应用服务 WEB 访问端口server:  port: 8080# 数据库spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/job?serverTimezone=Asia/Shanghai    username: root    password: root\r\nlombok\r\n\r\n@Data //\r\n自动生成getter、setter及toString方法 @NoArgsConstructor //\r\n自动生成无参构造 @AllArgsConstructor //\r\n自动生成全参构造\r\n\r\n&lt;!--lombok--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.30&lt;/version&gt;&lt;/dependency&gt;\r\n@Data // 自动生成getter、setter及toString等方法@NoArgsConstructor // 自动生成无参构造@AllArgsConstructor // 自动生成全参构造public class JobCategory &#123;    private int id;    private String category_name;    private String category_desc;&#125;\r\n岗位详情后端实现\r\n数据库设计\r\n\r\n\r\nimage-20250325170403510\r\n\r\n-- 删除已存在的表DROP TABLE IF EXISTS `jobs`;-- 创建 jobs 表CREATE TABLE `jobs`(    `id`            int          NOT NULL AUTO_INCREMENT COMMENT &#x27;ID&#x27;,    `job_title`     varchar(80)  NOT NULL COMMENT &#x27;岗位名称&#x27;,    `category_name` varchar(200) NOT NULL COMMENT &#x27;岗位类别名称&#x27;,    `salary`        varchar(80) DEFAULT NULL COMMENT &#x27;薪资范围&#x27;,    `city`          varchar(80)  NOT NULL COMMENT &#x27;城市&#x27;,    `job_desc`      text         NOT NULL COMMENT &#x27;岗位描述&#x27;,    `company`       varchar(200) NOT NULL COMMENT &#x27;用人单位&#x27;,    `company_info`  varchar(200) NOT NULL COMMENT &#x27;企业类型,经营类型,规模&#x27;,    `author`        varchar(200) NOT NULL COMMENT &#x27;发布者&#x27;,    `author_photo`  varchar(200) NOT NULL COMMENT &#x27;发布者头像&#x27;,    `publish_time`  varchar(200) NOT NULL COMMENT &#x27;发布时间&#x27;,    PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;岗位表&#x27;  ROW_FORMAT = DYNAMIC;\r\nINSERT INTO `jobs` (`job_title`, `category_name`, `salary`, `city`, `job_desc`, `company`,                    `company_info`, `author`, `author_photo`, `publish_time`)VALUES (&#x27;软件工程师&#x27;, &#x27;技术类&#x27;, &#x27;10000-15000&#x27;, &#x27;北京&#x27;, &#x27;负责软件开发和维护工作&#x27;, &#x27;ABC科技有限公司&#x27;,        &#x27;高新技术企业,互联网行业,中型企业&#x27;, &#x27;张三&#x27;, &#x27;https://example.com/avatar.jpg&#x27;, &#x27;2023-10-01&#x27;),       (&#x27;产品经理&#x27;, &#x27;管理类&#x27;, &#x27;12000-18000&#x27;, &#x27;上海&#x27;, &#x27;负责产品规划和市场调研&#x27;, &#x27;XYZ科技有限公司&#x27;,        &#x27;高新技术企业,互联网行业,大型企业&#x27;, &#x27;李四&#x27;, &#x27;https://example.com/avatar2.jpg&#x27;, &#x27;2023-10-02&#x27;),       (&#x27;销售经理&#x27;, &#x27;销售类&#x27;, &#x27;8000-12000&#x27;, &#x27;广州&#x27;, &#x27;负责产品销售和客户关系维护&#x27;, &#x27;DEF贸易有限公司&#x27;,        &#x27;商贸企业,批发零售业,小型企业&#x27;, &#x27;王五&#x27;, &#x27;https://example.com/avatar3.jpg&#x27;, &#x27;2023-10-03&#x27;),       (&#x27;财务分析师&#x27;, &#x27;财务类&#x27;, &#x27;9000-13000&#x27;, &#x27;深圳&#x27;, &#x27;负责财务分析和报表制作&#x27;, &#x27;GHI财务咨询公司&#x27;,        &#x27;咨询服务企业,金融行业,中型企业&#x27;, &#x27;赵六&#x27;, &#x27;https://example.com/avatar4.jpg&#x27;, &#x27;2023-10-04&#x27;),       (&#x27;人力资源专员&#x27;, &#x27;人力资源类&#x27;, &#x27;7000-10000&#x27;, &#x27;杭州&#x27;, &#x27;负责招聘和员工培训&#x27;, &#x27;JKL人力资源公司&#x27;,        &#x27;人力资源服务企业,服务业,小型企业&#x27;, &#x27;孙七&#x27;, &#x27;https://example.com/avatar5.jpg&#x27;, &#x27;2023-10-05&#x27;);\r\nmybatisX\r\n\r\n\r\nimage-20250325172814328\r\n\r\n\r\n\r\nimage-20250325173023922\r\n\r\n引入依赖并注释掉原来的mybatis：\r\n&lt;!--        mybatisplus--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;\r\n将mybatis配置改成mybatisplus配置：\r\n# 添加 MyBatis-Plus 配置mybatis-plus:  # 指定Mapper XML文件的位置  mapper-locations: classpath:/mapper/**/*.xml  configuration:    # 开启驼峰命名转换，例如：数据库字段名 user_name 自动映射到实体类属性 userName    map-underscore-to-camel-case: true      global-config:    db-config:      # 主键生成策略为自增      id-type: auto\r\npackage com.luotao.job.controller;import com.luotao.job.domain.Jobs;import com.luotao.job.service.JobsService;import com.luotao.job.utils.ResponseResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @Classname JobController * @Description TODO * @Version 1.0.0 * @Date 2025/3/25 17:47 * @Author LuoTao */@RestController@RequestMapping(&quot;/job&quot;)public class JobController &#123;    @Resource    private JobsService jobsService;    @GetMapping(&quot;/v1/&#123;id&#125;&quot;)    public ResponseResult getById(@PathVariable Integer id)&#123;        Jobs byId = jobsService.getById(id);        if (byId != null)&#123;            return new ResponseResult(byId);        &#125;else&#123;            return new ResponseResult(401, &quot;不存在对应id的数据&quot;);        &#125;    &#125;&#125;\r\n添加分页插件\r\npackage com.luotao.job.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @Classname MybatisPlusConfig * @Description TODO * @Version 1.0.0 * @Date 2025/3/26 17:32 * @Author LuoTao */@Configuration@MapperScan(&quot;com.luotao.job.mapper&quot;)public class MybatisPlusConfig &#123;    /**    * @Description: 添加分页插件。     * 创建MybatisPlusInterceptor实例。     * 添加PaginationInnerInterceptor作为内部拦截器，并指定数据库类型为MariaDB。     * 返回配置好的拦截器实例。    **/    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor((DbType.MARIADB)));        return interceptor;    &#125;&#125;\r\nservice接口及其实现类：\r\n/** * @Description 分页查询 * @Author LuoTao * @Date 2025/3/26 17:49 * @return 分页对象结果集 * @param pageNum 当前页码 * @param pageSize 每页的数据条数 **/IPage&lt;Jobs&gt; getJobsByPage(int pageNum, int pageSize);\r\npackage com.luotao.job.service.impl;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.luotao.job.domain.Jobs;import com.luotao.job.service.JobsService;import com.luotao.job.mapper.JobsMapper;import org.springframework.stereotype.Service;import javax.annotation.Resource;/*** @author T* @description 针对表【jobs(岗位表)】的数据库操作Service实现* @createDate 2025-03-25 17:30:32*/@Servicepublic class JobsServiceImpl extends ServiceImpl&lt;JobsMapper, Jobs&gt;    implements JobsService&#123;    @Resource    private JobsMapper jobsMapper;    /**     * @Description 定义了getJobsByPage方法，用于根据页码和每页大小查询岗位信息。     * 使用QueryWrapper构造查询条件，选择特定字段并按publish_time降序排序。     * 调用jobsMapper.selectPage执行分页查询并返回结果。     * @return 分页对象结果集     * @param pageNum 当前页码     * @param pageSize 每页的数据条数     **/    @Override    public IPage&lt;Jobs&gt; getJobsByPage(int pageNum, int pageSize) &#123;        Page&lt;Jobs&gt; page = new Page&lt;&gt;(pageNum, pageSize);// 创建分页对象        QueryWrapper&lt;Jobs&gt; jobsQueryWrapper = new QueryWrapper&lt;&gt;();// 创建查询条件包装器构造查询条件        jobsQueryWrapper.select(&quot;id&quot;,                &quot;job_title&quot;,                &quot;category_name&quot;,                &quot;salary&quot;,                &quot;city&quot;,                &quot;company&quot;,                &quot;publish_time&quot;        );        jobsQueryWrapper.orderByDesc(&quot;publish_time&quot;);        Page&lt;Jobs&gt; jobsPage = jobsMapper.selectPage(page, jobsQueryWrapper); // 执行分页查询        return jobsPage;    &#125;&#125;\r\n编写路由：\r\n// 分页查询@GetMapping(&quot;/v1/page/&#123;page&#125;&quot;)public ResponseResult getByPage(@PathVariable Integer page)&#123;    Integer pageSize=20;    IPage&lt;Jobs&gt; jobsByPage = jobsService.getJobsByPage(page, pageSize);    log.info(&quot;总行数:&#123;&#125;&quot;,jobsByPage.getTotal());    log.info(&quot;总页数:&#123;&#125;&quot;,jobsByPage.getPages());    log.info(&quot;当前页:&#123;&#125;&quot;,jobsByPage.getCurrent());    log.info(&quot;当前页行数:&#123;&#125;&quot;,jobsByPage.getRecords());    return new ResponseResult(jobsByPage);&#125;\r\nVO（Value Object）\r\n值对象，通常用于封装数据，表示一个不可变的对象，其值是唯一的标识。主要用于在不同层之间传递数据（如Controller层到Service层，或者Service层到前端）。不直接映射数据库表。\r\n按类别统计岗位数量\r\n\r\n编写SQL：\r\n\r\n# 按类别统计数量select js.category_name,jc.category_desc,count(js.id) as quantityfrom jobs js         left join     job_category jc on js.category_name = jc.category_namegroup by    js.category_nameorder by    quantity desc\r\n\r\n编写vo类结果映射：\r\n\r\npackage com.luotao.job.vo;import lombok.Data;/** * @Classname JobsByCategoryVo * @Description 从数据库中查询每个类别的岗位数量，并将结果映射到 JobsByCategoryVo 对象中。 * 封装岗位类别及其数量的信息，便于在不同层之间传递数据或作为接口返回结果。它是一个典型的值对象，专注于数据传输和展示，而不包含复杂的业务逻辑。 * @Version 1.0.0 * @Date 2025/3/26 18:44 * @Author LuoTao */@Data // 自动getsetterpublic class JobsByCategoryVo &#123;    private String categoryName;    private String categoryDesc;    private Integer quantity;//岗位数量&#125;\r\n\r\n编写mapper接口的方法和SQL 映射文件：\r\n\r\nMyBatis 通过 XML 文件或注解将 Mapper 接口的方法与 SQL\r\n语句关联起来。\r\nMyBatis 通过 SqlSession 执行 SQL 语句。以下是执行流程： 解析 SQL\r\n语句，替换占位符。 通过 JDBC 执行 SQL。 将查询结果映射为 Java\r\n对象并返回。\r\n\r\n\r\npublic interface JobsMapper extends BaseMapper&lt;Jobs&gt; &#123;    // 按类别统计岗位数量    List&lt;JobsByCategoryVo&gt; countByCategoryName();&#125;\r\n&lt;select id=&quot;countByCategoryName&quot; resultType=&quot;com.luotao.job.vo.JobsByCategoryVo&quot;&gt;    select js.category_name, jc.category_desc, count(js.id) as quantity    from jobs js             left join         job_category jc on js.category_name = jc.category_name    group by js.category_name    order by quantity desc&lt;/select&gt;\r\n\r\n补充service接口方法并实现：\r\n\r\n// 按类别统计岗位数量List&lt;JobsByCategoryVo&gt; countByCategoryName();\r\n@Overridepublic List&lt;JobsByCategoryVo&gt; countByCategoryName() &#123;    List&lt;JobsByCategoryVo&gt; jobsByCategoryVos = jobsMapper.countByCategoryName();    return jobsByCategoryVos;&#125;\r\n\r\n编写路由：\r\n\r\n// 分类统计岗位@GetMapping(&quot;/v1/category/statistics&quot;)public ResponseResult getByCategory()&#123;    List&lt;JobsByCategoryVo&gt; jobsByCategoryVos = jobsService.countByCategoryName();    return new ResponseResult(jobsByCategoryVos);&#125;\r\n按城市统计岗位数量\r\n\r\n编写SQL：\r\n\r\n# 按城市统计数量select js.city, jc.category_desc, count(js.id) as quantityfrom jobs js         left join     job_category jc on js.category_name = jc.category_namegroup by cityorder by quantity desc\r\n\r\n编写vo类结果映射：\r\n\r\npackage com.luotao.job.vo;import lombok.Data;/** * @Classname JobsByCityVo * @Description 按城市统计岗位，从数据库中查询每个城市的岗位数量，并将结果映射到 Vo 对象中。 * @Version 1.0.0 * @Date 2025/3/26 19:15 * @Author LuoTao */@Datapublic class JobsByCityVo &#123;    private String city;    private Integer quantity;&#125;\r\n\r\n编写mapper接口及xml实现数据查询：\r\n\r\n// 按城市统计岗位数量   List&lt;JobsByCityVo&gt; countByCity();\r\n&lt;select id=&quot;countByCity&quot; resultType=&quot;com.luotao.job.vo.JobsByCityVo&quot;&gt;    select js.city, jc.category_desc, count(js.id) as quantity    from jobs js             left join         job_category jc on js.category_name = jc.category_name    group by city    order by quantity&lt;/select&gt;\r\n\r\n补充service接口方法并实现：\r\n// 按城市统计岗位数量List&lt;JobsByCityVo&gt; countByCity();\r\n@Overridepublic List&lt;JobsByCityVo&gt; countByCity() &#123;    List&lt;JobsByCityVo&gt; jobsByCityVos = jobsMapper.countByCity();    return jobsByCityVos;&#125;\r\n编写路由：\r\n// 按城市统计岗位@GetMapping(&quot;/v1/city/statistics&quot;)public ResponseResult getByCity()&#123;    List&lt;JobsByCityVo&gt; JobsByCityVos = jobsService.countByCity();    return new ResponseResult(JobsByCityVos);&#125;\r\n\r\n按省份统计岗位数量\r\n-- 城市-省级 citydrop table if exists `city`;CREATE TABLE `city` (                        `id` int NOT NULL AUTO_INCREMENT,                        `city` varchar(50) NOT NULL COMMENT &#x27;城市名称&#x27;,                        `province` varchar(50) NOT NULL COMMENT &#x27;省级名称&#x27;,                        PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC;\r\n\r\n编写SQL：\r\n/* 按省份统计岗位: jobs.city 去和  city.city和city.province 模糊匹配 CONCAT(&#x27;%&#x27;, c.city, &#x27;%&#x27;) 的作用是将 % 和 c.city 拼接成一个模糊匹配的模式。例如：如果 c.city 的值是 &#x27;北京&#x27;，那么 CONCAT(&#x27;%&#x27;, c.city, &#x27;%&#x27;) 的结果是 &#x27;%北京%&#x27;。这个结果可以用于 LIKE 操作符，表示匹配包含 &#x27;北京&#x27; 的字符串。*/SELECT    c.province,    COUNT(js.id) AS quantityFROM    jobs js        LEFT JOIN    city c    ON        (js.city LIKE CONCAT(&#x27;%&#x27;, c.city, &#x27;%&#x27;) OR js.city LIKE CONCAT(&#x27;%&#x27;, c.province, &#x27;%&#x27;))WHERE    c.province IS NOT NULL  AND c.province != &#x27;&#x27;GROUP BY    c.provinceORDER BY    quantity DESC;\r\n编写vo类结果映射：\r\n@Datapublic class JobsByProvinceVo &#123;    private String province;    private Integer quantity;&#125;\r\n编写mapper接口的方法和SQL 映射文件：\r\n// 按省份统计岗位数量    List&lt;JobsByProvinceVo&gt; countByProvince();\r\n&lt;select id=&quot;countByProvince&quot; resultType=&quot;com.luotao.job.vo.JobsByProvinceVo&quot;&gt;       SELECT           c.province,           COUNT(js.id) AS quantity       FROM           jobs js               LEFT JOIN           city c           ON               (js.city LIKE CONCAT(&#x27;%&#x27;, c.city, &#x27;%&#x27;) OR js.city LIKE CONCAT(&#x27;%&#x27;, c.province, &#x27;%&#x27;))       WHERE           c.province IS NOT NULL         AND c.province != &#x27;&#x27;       GROUP BY           c.province       ORDER BY           quantity DESC;   &lt;/select&gt;\r\n补充service接口方法并实现：\r\n// 按省份统计岗位数量List&lt;JobsByProvinceVo&gt; countByProvince();\r\n@Overridepublic List&lt;JobsByProvinceVo&gt; countByProvince() &#123;    List&lt;JobsByProvinceVo&gt; jobsByProvinceVos = jobsMapper.countByProvince();    return jobsByProvinceVos;&#125;\r\n编写路由：\r\n// 按省份统计岗位@GetMapping(&quot;/v1/province/statistics&quot;)@ApiOperation(&quot;按省份统计岗位&quot;)public ResponseResult getByProvince()&#123;    List&lt;JobsByProvinceVo&gt; jobsByProvinceVos = jobsService.countByProvince();    return new ResponseResult(jobsByProvinceVos);&#125;\r\n\r\nSwagger生成在线API文档\r\n引入依赖：\r\n      &lt;!--        Swagger      &lt;dependency&gt;          &lt;groupId&gt;io.springfox&lt;/groupId&gt;          &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;          &lt;version&gt;3.0.0&lt;/version&gt;      &lt;/dependency&gt;--&gt;      &lt;!--        Knife4j-Swaggerui增强--&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;          &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;3.0.3&lt;/version&gt;      &lt;/dependency&gt;\r\n编写Swagger配置类：\r\npackage com.luotao.job.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.bind.annotation.RestController;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;/** * Swagger配置类，用于配置Swagger生成 RESTful API 文档 * 该配置类指定了哪些接口将被生成文档，以及文档的基本信息 */@Configurationpublic class SwaggerConfig &#123;    /**     * 创建 RESTful API 文档的配置     * 使用 Docket 对象来配置 Swagger，包括文档类型、API 信息选择器等     *     * @return Docket 实例，用于构建和配置 Swagger 文档     */    @Bean    public Docket createRestApi()&#123;        // 创建并配置Docket对象，使用OpenAPI 3.0规范        return new Docket(DocumentationType.OAS_30)                // 设置API文档的基本信息，如标题、描述、版本等                .apiInfo(apiInfo())                .select()                // 选择带有@RestController注解的类中的API进行文档化                .apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))                // 对所有路径的API进行文档化                .paths(PathSelectors.any())                .build();    &#125;    /**     * 构建 API 文档的详细信息     * 包括标题、描述、许可证信息、版本号等     *     * @return ApiInfo 实例，含了API文档的元数据信息     */    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;可视化分析系统&quot;)  // 设置API文档的标题                .description(&quot;后端接口文档&quot;)     // 设置API文档的描述                .license(&quot;luotao&quot;)               // 设置API文档的许可证信息                .licenseUrl(&quot;https://luotaofun.github.io/&quot;) // 设置许可证的URL                .version(&quot;1.0&quot;)                  // 设置API的版本                .build();                        // 构建并返回ApiInfo对象    &#125;&#125;\r\n启动类上添加注解@EnableOpenApi激活 API 文档功能：\r\n@SpringBootApplication@MapperScan(&quot;com.luotao.job.mapper&quot;)// 扫描接口所在包@EnableOpenApi // 激活 API 文档功能public class JobApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(JobApplication.class, args);    &#125;&#125;\r\nyaml配置文件中添加Spring MVC 的路径匹配策略：\r\nspring:  mvc:    # Spring MVC 的路径匹配策略    pathmatch:      matching-strategy: ant_path_matcher\r\n@Api(tags = &quot;岗位管理相关接口&quot;)//标记在一个类上，用于描述该控制器（Controller）的整体功能。public class JobController &#123;    @ApiOperation(&quot;根据id获取岗位数据&quot;)//标记在一个方法上，用于描述该方法的具体功能。\t// 方法&#125;\r\nvue3\r\n// ::v-deep  可以穿透并修改子组件的样式\r\n# 用于更改 PowerShell 脚本的执行策略:允许运行本地创建的脚本Set-ExecutionPolicy RemoteSigned\r\nvue create job-web\r\n\r\n\r\nimage-20250326230048396\r\n\r\n\r\n\r\nimage-20250326230215596\r\n\r\nvue-生命周期\r\n\r\n实例从创建到销毁的过程\r\n\r\n\r\n\r\nimage-20250104151543030\r\n\r\n&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;生命周期&lt;/h1&gt;        &lt;p&gt;&lt;button @click=&quot;changeCount&quot;&gt;点击修改count值-- &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/p&gt;        &lt;p&gt;&lt;button @click=&quot;destroy&quot;&gt;点击销毁&lt;/button&gt;&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;        import &#123; getCurrentInstance,            reactive,             toRefs,            onBeforeMount,            onMounted,            onBeforeUpdate,            onUpdated,            onBeforeUnmount,            onUnmounted         &#125; from &#x27;vue&#x27;                export default &#123;            setup () &#123;                console.log(&quot;开始创建组件--setup&quot;)                const instance = getCurrentInstance(); //获取当前组件实例                console.log(&quot;当前组件实例--instance&quot; , instance);                const state = reactive(&#123; //定义响应式数据对象                    count: 0,                &#125;)                function changeCount() &#123; //触发组件更新                    state.count++;                &#125;                function destroy() &#123; //触发销毁组件                    instance.appContext.app.unmount();                &#125;                            onBeforeMount(() =&gt; &#123;                     console.log(&quot;组件挂载前--onBeforeMount&quot;)                &#125;)                onMounted(() =&gt; &#123;                     console.log(&quot;组件挂载后--onMounted&quot;)                    console.log(instance)                &#125;)                onBeforeUpdate(() =&gt; &#123;                     console.log(&quot;组件更新前--onBeforeUpdate&quot;)                &#125;)                onUpdated(() =&gt; &#123;                     console.log(&quot;组件更新后--onUpdated&quot;)                &#125;)                onBeforeUnmount(() =&gt; &#123;                     console.log(&quot;组件卸载前--onBeforeUnmount&quot;)                &#125;)                onUnmounted(() =&gt; &#123;                     console.log(&quot;组件卸载后--onUnmounted&quot;)                &#125;)                return &#123;                    ...toRefs(state),// 将响应式对象转为普通对象(每一个属性都是响应式)                    changeCount,                    destroy                &#125;            &#125;        &#125;    &lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;\r\nsetup语法糖写法\r\n&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;生命周期&lt;/h1&gt;        &lt;p&gt;&lt;button @click=&quot;changeCount&quot;&gt;点击修改count值-- &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/p&gt;        &lt;p&gt;&lt;button @click=&quot;destroy&quot;&gt;点击销毁&lt;/button&gt;&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;        import &#123; getCurrentInstance,            reactive,             toRefs,            onBeforeMount,            onMounted,            onBeforeUpdate,            onUpdated,            onBeforeUnmount,            onUnmounted         &#125; from &#x27;vue&#x27;                console.log(&quot;开始创建组件--setup&quot;)        const instance = getCurrentInstance(); //获取当前组件实例        console.log(&quot;当前组件实例--instance&quot; , instance);        const state = reactive(&#123; //定义响应式数据对象            count: 0,        &#125;)        function changeCount() &#123; //触发组件更新            state.count++;        &#125;        function destroy() &#123; //触发销毁组件            instance.appContext.app.unmount();        &#125;            onBeforeMount(() =&gt; &#123;             console.log(&quot;组件挂载前--onBeforeMount&quot;)        &#125;)        onMounted(() =&gt; &#123;             console.log(&quot;组件挂载后--onMounted&quot;)        &#125;)        onBeforeUpdate(() =&gt; &#123;             console.log(&quot;组件更新前--onBeforeUpdate&quot;)        &#125;)        onUpdated(() =&gt; &#123;             console.log(&quot;组件更新后--onUpdated&quot;)        &#125;)        onBeforeUnmount(() =&gt; &#123;             console.log(&quot;组件卸载前--onBeforeUnmount&quot;)        &#125;)        onUnmounted(() =&gt; &#123;             console.log(&quot;组件卸载后--onUnmounted&quot;)        &#125;)        const &#123;count&#125;=&#123;   ...toRefs(state)&#125;// 将响应式对象转为普通对象(每一个属性都是响应式)    &lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;\r\n组件间的交互\r\n父组件\r\n&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;!-- v-bind  传递给子组件--&gt;    &lt;myheader     v-bind:msg=&quot;parentMsg&quot;     @event=&quot;func&quot;    @event2=&quot;func2&quot;    &gt;&lt;/myheader&gt;    &lt;!-- &lt;lifeCycle&gt;&lt;/lifeCycle&gt; --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import MyHeader from &#x27;@/components/MyHeader.vue&#x27;;import LifeCycle from &#x27;@/components/LifeCycle.vue&#x27;;const parentMsg = &#x27;我是父组件-----&gt;给子组件带句话&#x27;;const func =() =&gt; &#123;  alert(&#x27;我是父组件中的函数&#x27;);&#125;const func2 =(childMsg) =&gt; &#123;  alert(childMsg);&#125;&lt;/script&gt;\r\n子组件\r\n&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;luotaofun&lt;/h1&gt;        &lt;img class=&quot;logo&quot; src=&quot;@/assets/logo.jpg&quot;&gt;        &lt;p&gt;展示父组件传递的数据:&#123;&#123;prop.msg &#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;emit(&#x27;event&#x27;)&quot;&gt;触发父组件事件event&lt;/button&gt;        &lt;button @click=&quot;emit(&#x27;event2&#x27;,childMsg)&quot;&gt;触发父组件事件event2,从父组件中获取子组件信息&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;    // defineProps 接受父组件传递的数据    const prop = defineProps(&#123;        msg: &#123;            type: String,            required: true        &#125;    &#125;)    const childMsg = &#x27;我是子组件&#x27;;    //defineEmits 注册事件,返回触发器    const emit = defineEmits(&quot;event&quot;,&quot;event2&quot;);&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;\r\n首页\r\n引入element-plus组件库：\r\nnpm install element-plus --save\r\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;// 引入element-plus组件库import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;// 定义特性标志解决控制台警告：在生产环境中，为了获得更好的树摇优化，Vue 需要特定的特性标志，以减小生成的生产包的大小。window.__VUE_PROD_DEVTOOLS__ = false;window.__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;createApp(App) .use(store) // vuex状态管理.use(router).use(ElementPlus).mount(&#x27;#app&#x27;) // 绑定到id为app的元素上\r\n根组件引入Container布局容器\r\n&lt;template&gt;  &lt;div class=&quot;common-layout&quot;&gt;    &lt;el-container&gt;      &lt;!-- 头部 --&gt;      &lt;el-header&gt;          &lt;Header&gt;&lt;/Header&gt;      &lt;/el-header&gt;      &lt;el-container&gt;        &lt;!-- 左侧边栏 --&gt;        &lt;el-aside width=&quot;200px&quot;&gt;          &lt;LeftMenu&gt;&lt;/LeftMenu&gt;        &lt;/el-aside&gt;        &lt;!-- 主体内容 --&gt;        &lt;el-main&gt;          &lt;!-- 路由视图 --&gt;          &lt;router-view/&gt;        &lt;/el-main&gt;      &lt;/el-container&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;  import Header from &#x27;@/components/Header.vue&#x27;  import LeftMenu from &#x27;@/components/LeftMenu.vue&#x27;    // debounce: 限制一个函数的执行频率，确保在一定时间间隔内只执行一次  // fn: 要执行的函数  // delay: 延迟时间  // 函数内部使用setTimeout来实现延迟执行，每次调用时会清除之前的定时器，然后设置一个新的定时器来延迟执行目标函数  const debounce = (fn, delay) =&gt; &#123;    let timer = null;    return function () &#123;      let context = this;      let args = arguments;      clearTimeout(timer);      timer = setTimeout(function () &#123;        fn.apply(context, args);      &#125;, delay);    &#125;  &#125;  // 将原始的ResizeObserver保存为_ResizeObserver  const _ResizeObserver = window.ResizeObserver;  // 定义新的ResizeObserver类，重写构造函数  // 在新的构造函数中，传入的回调函数被debounce函数处理，确保回调函数在16毫秒的间隔时间内执行一次  window.ResizeObserver = class ResizeObserver extends _ResizeObserver &#123;    constructor(callback) &#123;      callback = debounce(callback, 16);      super(callback);    &#125;  &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;  .el-header &#123;      background-color: #545c64;  &#125;  .el-aside &#123;      font-weight: bold;  &#125;&lt;/style&gt;\r\n创建头部组件和左侧导航组件\r\nHeader.vue\r\n&lt;template&gt;    &lt;div&gt;        &lt;el-row&gt;          &lt;el-col :span=&quot;3&quot;&gt;            &lt;div class=&quot;grid-content ep-bg-purple&quot; /&gt;            &lt;img src=&quot;@/assets/logo.jpg&quot; class=&quot;logo&quot; &gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;21&quot;&gt;            &lt;div class=&quot;grid-content ep-bg-purple-light&quot; /&gt;            物流进销存系统          &lt;/el-col&gt;        &lt;/el-row&gt;    &lt;/div&gt;            &lt;/template&gt;&lt;script setup&gt;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;    .logo&#123;        width: 60px;        height: 60px;    &#125;    .el-row&#123;        font-weight: bold;        font-size: larger;        line-height: 60px;        color:#fff;        text-align: left;    &#125;&lt;/style&gt;\r\nLeftMenu.vue\r\n引入垂直菜单,建立三个菜单项\r\n&lt;template&gt;    &lt;div&gt;        &lt;el-menu        default-active=&quot;2&quot;        class=&quot;el-menu-vertical-demo&quot;      &gt;        &lt;el-menu-item index=&quot;2&quot;&gt;            &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt;            &lt;span&gt;数据列表&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;3&quot; &gt;            &lt;el-icon&gt;&lt;document /&gt;&lt;/el-icon&gt;            &lt;span&gt;分类统计&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;4&quot;&gt;            &lt;el-icon&gt;&lt;setting /&gt;&lt;/el-icon&gt;            &lt;span&gt;数据分析&lt;/span&gt;            &lt;/el-menu-item&gt;        &lt;/el-menu&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;\r\n路由配置\r\n\r\n\r\nimage-20250114154037030\r\n\r\n创建数据列表,分类统计,数据分析三个组件\r\nDataList.vue, Statistics.vue, Analyse.vue要有对应路由,点击后才能渲染出对应组件视图\r\n先定义组件的路由对象\r\nimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import DataList from &#x27;@/views/DataList.vue&#x27;import Statistics from &#x27;@/views/Statistics.vue&#x27;import Analysis from &#x27;@/views/Analysis.vue&#x27;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;Analysis&#x27;,    component: Analysis,    meta:&#123;      title: &#x27;数据分析&#x27;    &#125;  &#125;,  &#123;    path: &#x27;/dataList&#x27;,    name: &#x27;DataList&#x27;,    component: DataList,    meta: &#123;      title: &#x27;数据列表&#x27;    &#125;  &#125;,  &#123;    path: &#x27;/statistics&#x27;,    name: &#x27;Statistics&#x27;,    component: Statistics,    meta:&#123;      title: &#x27;数据统计&#x27;    &#125;  &#125;,]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)// 遍历路由以设置titlerouter.beforeEach((to, from, next) =&gt; &#123;  document.title = to.meta.title  next()&#125;)export default router\r\n左侧菜单启用router,配置跳转path\r\n\r\n\r\nimage-20250114155602473\r\n\r\nLeftMenu.vue\r\n&lt;template&gt;    &lt;div&gt;        &lt;el-menu        default-active=&quot;/&quot;        router        class=&quot;el-menu-vertical-demo&quot;        @open=&quot;handleOpen&quot;        @close=&quot;handleClose&quot;        &gt;            &lt;el-menu-item index=&quot;/&quot;&gt;                &lt;el-icon&gt;&lt;DataAnalysis /&gt;&lt;/el-icon&gt;                &lt;span&gt;岗位数据分析&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;/dataList&quot;&gt;                &lt;el-icon&gt;&lt;Grid /&gt;&lt;/el-icon&gt;                &lt;span&gt;岗位数据列表&lt;/span&gt;            &lt;/el-menu-item&gt;                        &lt;el-menu-item index=&quot;/statistics&quot;&gt;                &lt;el-icon&gt;&lt;Histogram /&gt;&lt;/el-icon&gt;                &lt;span&gt;岗位分类统计&lt;/span&gt;            &lt;/el-menu-item&gt;        &lt;/el-menu&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;    import &#123; Grid, Histogram, DataAnalysis &#125; from &#x27;@element-plus/icons-vue&#x27;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;\r\n数据列表\r\n引入带斑马纹表格和分页控件\r\nDataList.vue\r\n&lt;template&gt;    &lt;div&gt;        &lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot;&gt;            &lt;el-table-column fix prop=&quot;jobTitle&quot; label=&quot;岗位名称&quot; width=&quot;180&quot; /&gt;            &lt;el-table-column prop=&quot;salary&quot; label=&quot;薪资&quot; width=&quot;180&quot; /&gt;            &lt;el-table-column prop=&quot;company&quot; label=&quot;企业全称&quot; /&gt;            &lt;el-table-column prop=&quot;city&quot; label=&quot;工作地点&quot; /&gt;            &lt;el-table-column prop=&quot;publishTime&quot; label=&quot;发布时间&quot; /&gt;            &lt;el-table-column prop=&quot;companyInfo&quot; label=&quot;所属行业&quot; /&gt;        &lt;/el-table&gt;    &lt;/div&gt;    &lt;!-- 分页控件 --&gt;    &lt;el-pagination     class=&quot;pagination&quot;    background     layout=&quot;prev, pager, next&quot;     :total=&quot;1000&quot; /&gt;&lt;/template&gt;&lt;script  setup&gt;    const tableData = [        &#123;            jobTitle: &#x27;JAVA工程师&#x27;,            salary: &#x27;1.2K&#x27;,            company: &#x27;腾讯&#x27;,            city:   &#x27;深圳&#x27;,            publishTime: &#x27;2022-01-01&#x27;,            companyInfo: &#x27;计算机软件&#x27;        &#125;    ]&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;    .pagination &#123;        margin-top: 30px;        margin-left: 68%;    &#125;&lt;/style&gt;\r\n封装Axios网络请求\r\n\r\n安装依赖\r\nnpm install axios -S\r\nutils包下新建axiosConfig.js\r\nimport axios from &#x27;axios&#x27;;// 声明函数并将其导出，以便在其他模块中使用。config 参数是一个对象，包含请求的配置信息。export function request(config)&#123;    // 创建Axios实例    const instance = axios.create(&#123;        baseURL:&quot;&quot;, // 请求的基础 URL        timeout:8000,// 请求超时时间    &#125;)    return instance(config); //使用刚刚创建的 Axios 实例发送请求。Axios 实例会根据这些配置发送请求，并返回一个 Promise，该 Promise 解析为响应数据。&#125;\r\n封装业务请求apis.js\r\n// 业务请求import&#123;request&#125; from &#x27;./axiosConfig&#x27;;// `vue.config.js`中配置了代理解决跨域。前端请求时url带该前缀时走代理请求到target指定的后端服务器上，并且请求路径中的该前缀被去掉，还原成后端接口原来的路径。const prefix =&#x27;/api&#x27;// 请求分页查询岗位数据的接口,参数page是想要获取第几页，即当前选中页码export function getJobListData(page)&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/page/&#x27; + page,        method:&#x27;get&#x27;    &#125;)&#125;\r\n发起请求fetch后端数据\r\n&lt;script setup&gt;    import &#123;getJobListData&#125; from &#x27;@/utils/apis&#x27;    import &#123;ref,onMounted&#125; from &#x27;vue&#x27;    const currentPage = ref(1);    const fetchData=(currentPage)=&gt;&#123;        getJobListData(currentPage.value).then(res=&gt;&#123;            console.log(res.data);        &#125;)    &#125;    // 组件已挂载时调用    onMounted(()=&gt;&#123;        fetchData(currentPage)    &#125;)&lt;/script&gt;\r\n域名不同需要解决跨域,可以配置一个代理让前端发起的业务请求通过代理请求到后端的服务器上。根目录下创建vue.config.js\r\n代理配置的工作方式是：前端请求先到达前端开发服务器，然后由开发服务器转发到后端服务器。这个过程对前端代码是透明的，您的代码仍然发送请求到\r\n/api/blog/tags，但实际上这个请求会被代理到\r\nhttp://localhost:8000/blog/tags。\r\n// module相当于当前的jsmodule.exports = &#123;    // 配置代理信息。前端请求时url带该前缀时走代理请求到target指定的后端服务器上，并且请求路径中的该前缀被去掉，还原成后端接口原来的路径。    devServer:&#123;        proxy:&#123;            &#x27;/api&#x27;:&#123;                target:&#x27;http://127.0.0.1:8000/&#x27;,                pathRewrite:&#123;                    &#x27;^/api&#x27;:&#x27;&#x27;                &#125;,                changeOrigin: true,                logLevel: &#x27;debug&#x27;            &#125;        &#125;    &#125;&#125;\r\n\r\n\r\nimage-20250327191219017\r\n\r\n\r\n岗位数据列表前后端联调\r\n\r\n\r\nimage-20250328165237255\r\n\r\n\r\n通过调用之前封装业务请求apis.js的getJobListData函数获取当前页的数据，并将数据存储到tableData中。\r\n处理分页控件。 用current-change\r\n事件来处理当前页变动时候触发的事件，即先获取当前新选中的页码然后再次请求。\r\n\r\n&lt;template&gt;    &lt;div&gt;        &lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot;&gt;            &lt;el-table-column fix prop=&quot;jobTitle&quot; label=&quot;岗位名称&quot; width=&quot;180&quot; /&gt;            &lt;el-table-column prop=&quot;salary&quot; label=&quot;薪资&quot; width=&quot;180&quot; /&gt;            &lt;el-table-column prop=&quot;company&quot; label=&quot;企业全称&quot; /&gt;            &lt;el-table-column prop=&quot;city&quot; label=&quot;工作地点&quot; /&gt;            &lt;el-table-column prop=&quot;publishTime&quot; label=&quot;发布时间&quot; /&gt;            &lt;el-table-column prop=&quot;companyInfo&quot; label=&quot;所属行业&quot; /&gt;        &lt;/el-table&gt;    &lt;/div&gt;    &lt;!-- 分页控件。用current-change 事件来处理当前页变动时候触发的事件 --&gt;    &lt;el-pagination     class=&quot;pagination&quot;    background     layout=&quot;prev, pager, next&quot;     :total=&quot;total&quot;     @current-change=&quot;handleCurrentChange&quot;    /&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; getJobListData &#125; from &#x27;@/utils/apis&#x27;import &#123; reactive &#125; from &#x27;vue&#x27;;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const currentPage = ref(1); // 当前选中的页码const tableData = reactive([])const total = ref(0) // 总记录数const size = ref(0) // 当前页记录数// 通过调用getJobListData接口获取当前页的数据，并将数据存储到tableData中。const fetchData = (currentPage) =&gt; &#123;    getJobListData(currentPage.value).then(res =&gt; &#123;        // 拿数据之前要先将tableData清空，否则数据会累加        tableData.length = 0        // console.log(res.data);        for (let i in res.data.data.records) &#123;            // console.log(res.data.data.records[i]);            tableData.push(res.data.data.records[i]) // 将当前页的每条记录push        &#125;        total.value=res.data.data.total        size.value=res.data.data.size        console.log(&#x27;总记录数：&#x27; + total.value,&#x27;当前页记录数:&#x27; + size.value)    &#125;)&#125;const handleCurrentChange=(newPage)=&gt;&#123;    console.log(&#x27;改变后选中的页码为：&#x27; + newPage)    currentPage.value=newPage    fetchData(currentPage) // 选中的页码改变后再次fetchData发请求&#125;// 组件已挂载时调用onMounted(() =&gt; &#123;    fetchData(currentPage)&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.pagination &#123;    margin-top: 30px;    margin-left: 68%;&#125;&lt;/style&gt;\r\n岗位类别统计联调\r\n\r\n\r\nimage-20250328165156263\r\n\r\n快速上手 -\r\n使用手册 - Apache ECharts\r\n\r\n引入依赖Echarts\r\nnpm install echarts --save\r\n在apis.js`中封装按类别统计的业务请求函数getJobByCategory\r\n// 封装按类别统计的业务请求export function getJobByCategory()&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/category/statistics&#x27;,        method:&#x27;get&#x27;    &#125;)&#125;\r\n在onMounted钩子函数中通过调用之前封装业务请求apis.js的getJobByCategory函数获取categoryName和quantity分别作为x轴和y轴的数据。\r\n&lt;template&gt;    &lt;div id=&quot;chart&quot; class=&quot;chart&quot;&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import * as echarts from &#x27;echarts&#x27;import &#123; getJobByCategory &#125; from &#x27;@/utils/apis&#x27;import &#123; reactive &#125; from &#x27;vue&#x27;;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 用categoryData保存后端接口响应数据const categoryData = reactive(&#123;    category: [],// 岗位名称    count: [] //岗位数量&#125;)// 组件已挂载时调用onMounted(() =&gt; &#123;    // 通过调用 getJobByCategory获取categoryDesc和quantity，并将数据存储到 categoryData 中。    getJobByCategory().then(res =&gt; &#123;        // console.log(res.data);        for (let i in res.data.data) &#123;            categoryData.category.push(res.data.data[i]            [&#x27;categoryDesc&#x27;])            categoryData.count.push(res.data.data[i]            [&#x27;quantity&#x27;])        &#125;        // 基于准备好的DOM，初始化echarts实例        var myChart = echarts.init(document.getElementById(&#x27;chart&#x27;))        var option = &#123;            title: &#123;                // text: &#x27;ECharts 入门示例&#x27;            &#125;,            tooltip: &#123;&#125;,            xAxis: &#123;                data: categoryData.category            &#125;,            yAxis: &#123;&#125;,            series: [                &#123;                    name: &#x27;岗位数量&#x27;,                    type: &#x27;bar&#x27;,                    data: categoryData.count                &#125;            ]        &#125;        // 绘制图表        myChart.setOption(option);    &#125;)&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.chart &#123;    width: 100%;    height: 550px;&#125;&lt;/style&gt;\r\n\r\n岗位分析页面布局\r\n\r\n\r\nimage-20250328165858569\r\n\r\n\r\n从阿里云DataV可视化获取地图数据json\r\n将地图echarts封装成函数，然后在onMounted钩子函数中调用.\r\n&lt;template&gt;    &lt;div class=&quot;analysis&quot;&gt;        &lt;div class=&quot;content&quot;&gt;            &lt;el-row&gt;                &lt;!-- 第一列 --&gt;                &lt;el-col :span=&quot;17&quot;&gt;                    &lt;div class=&quot;grid-content ep-bg-purple&quot; /&gt;                    &lt;!-- 地图 --&gt;                    &lt;div id=&quot;map&quot; class=&quot;map&quot;&gt;&lt;/div&gt;                &lt;/el-col&gt;                &lt;!-- 第二列 --&gt;                &lt;el-col :span=&quot;7&quot;&gt;                    &lt;div class=&quot;grid-content ep-bg-purple-light&quot; /&gt;                    &lt;el-row&gt;                        &lt;!-- 第一个卡片 --&gt;                        &lt;el-card style=&quot;max-width: 480px&quot;&gt;                            &lt;template #header&gt;                                &lt;div class=&quot;card-header&quot;&gt;                                    &lt;span&gt;按『类别』统计数据&lt;/span&gt;                                &lt;/div&gt;                            &lt;/template&gt;                            &lt;p v-for=&quot;o in 5&quot; :key=&quot;o&quot; class=&quot;text item&quot;&gt;                                &#123;&#123; &#x27;Top&#x27; + o &#125;&#125;                            &lt;/p&gt;                        &lt;/el-card&gt;                    &lt;/el-row&gt;                    &lt;el-row&gt;                        &lt;!-- 第二个卡片 --&gt;                        &lt;el-card style=&quot;max-width: 480px&quot;&gt;                            &lt;template #header&gt;                                &lt;div class=&quot;card-header&quot;&gt;                                    &lt;span&gt;按『城市』统计数据&lt;/span&gt;                                &lt;/div&gt;                            &lt;/template&gt;                            &lt;p v-for=&quot;o in 5&quot; :key=&quot;o&quot; class=&quot;text item&quot;&gt;                                &#123;&#123; &#x27;Top&#x27; + o &#125;&#125;                            &lt;/p&gt;                        &lt;/el-card&gt;                    &lt;/el-row&gt;                &lt;/el-col&gt;            &lt;/el-row&gt;        &lt;/div&gt;        &lt;!-- 统计组件 --&gt;        &lt;div class=&quot;statistic&quot;&gt;            &lt;el-statistic title=&quot;岗位总量&quot; :value=&quot;8888&quot; /&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// 引入中国地图json数据import chinamap from &#x27;@/map/chinamap&#x27;import * as echarts from &#x27;echarts&#x27;import &#123; onMounted &#125; from &#x27;vue&#x27;;const mapEcharts = () =&gt; &#123;    let chartDom = document.getElementById(&#x27;map&#x27;)\tif (chartDom) &#123;        // 初始化echarts实例        let mapChart = echarts.init(chartDom);        // 注册地图        echarts.registerMap(&#x27;chinamap&#x27;, chinamap);        // 设置配置项        let options = &#123;            roam: true, // 鼠标缩放地图            // 提示框            tooltip: &#123;                trigger: &#x27;item&#x27;,                formatter: &#x27;&#123;b&#125;&lt;br/&gt;&#123;c&#125;&#x27;            &#125;,            // 工具栏：数据视图、还原、保存为图片            toolbox: &#123;                show: true,                orient: &#x27;vertical&#x27;,                left: &#x27;right&#x27;,                top: &#x27;center&#x27;,                iconStyle: &#123;                    color: &#x27;none&#x27;,                    borderColor: &#x27;#fff&#x27;,                    borderWidth: 1,                    borderType: &#x27;solid&#x27;                &#125;,                feature: &#123;                    dataView: &#123; readOnly: false &#125;,                    restore: &#123;&#125;,                    saveAsImage: &#123;&#125;                &#125;            &#125;,            // 视觉映射组件            visualMap: &#123;                min: 0,                max: 5000,                text: [&#x27;High&#x27;, &#x27;Low&#x27;],                left: &#x27;left&#x27;,                realtime: false,                calculable: true,                textStyle: &#123;                    fontWeight: &#x27;bold&#x27;, // 字体加粗                    color: &#x27;#fff&#x27;, // 字体颜色                &#125;,                inRange: &#123;                    color: [&#x27;lightskyblue&#x27;, &#x27;yellow&#x27;, &#x27;orangered&#x27;]                &#125;            &#125;,            // 地理区域数据可视化，配合visualMap，展示不同区域的数据            series: [                &#123;                    type: &#x27;map&#x27;,                    map: &#x27;chinamap&#x27;,                    zoom: 1.4, // 默认缩放级别                    center: [104.114129, 37.550339], // 缩放中心点，北京的经纬度                    // 地图文字设置                    label: &#123;                        show: true,                        fontSize: 8,                    &#125;,                    itemStyle: &#123;                        borderColor: &#x27;#091A7A&#x27;,                        borderWidth: 1,                    &#125;,                    emphasis: &#123;                        itemStyle: &#123;                            areaColor: &#x27;#0258f0&#x27;, // 高亮时的颜色                        &#125;                    &#125;,                    // 区域数据                    data: [                        &#123; name: &#x27;北京市&#x27;, value: 120 &#125;,                        &#123; name: &#x27;天津市&#x27;, value: 120 &#125;,                        &#123; name: &#x27;河北省&#x27;, value: 220 &#125;,                        &#123; name: &#x27;山西省&#x27;, value: 520 &#125;,                        &#123; name: &#x27;内蒙古自治区&#x27;, value: 220 &#125;,                        &#123; name: &#x27;辽宁省&#x27;, value: 210 &#125;,                        &#123; name: &#x27;吉林省&#x27;, value: 120 &#125;,                        &#123; name: &#x27;黑龙江省&#x27;, value: 120 &#125;,                        &#123; name: &#x27;上海市&#x27;, value: 120 &#125;,                        &#123; name: &#x27;江苏省&#x27;, value: 520 &#125;,                        &#123; name: &#x27;浙江省&#x27;, value: 220 &#125;,                    ],                &#125;            ]        &#125;        // 绘制地图        mapChart.setOption(options);    &#125;&#125;// 挂载后渲染echartsonMounted(() =&gt; &#123;    mapEcharts()&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.map &#123;    height: 630px;    margin-left: 15px;&#125;.analysis &#123;    background-color: #3366FF;    position: relative;    height: 630px;&#125;.content &#123;    position: absolute;    width: 100%;&#125;.statistic &#123;    position: absolute;    z-index: 3;    margin-top: 25px;    margin-left: 25px;&#125;// ::v-deep  可以穿透并修改子组件的样式::v-deep .el-statistic__head &#123;    font-size: 22px;    color: #fff;    font-weight: bolder;    margin-bottom: 10px;&#125;::v-deep .el-statistic__number &#123;    color: #DBA230;    font-weight: bolder;&#125;.el-card &#123;    background-color: transparent;    margin-top: 12px;    margin-bottom: 12px;    margin-left: 30px;    border-color: rgb(62, 94, 221);    border-width: 2px;    font-size: 15px;    color: #fff;&#125;.card-header &#123;    font-weight: bolder;&#125;.r1 &#123;    margin-right: 12px;&#125;.r2 &#123;    width: 185px;    display: inline-block;&#125;.r3 &#123;    color: #DBA230;&#125;&lt;/style&gt;\r\n\r\n岗位分析页面联调\r\n\r\n在apis.js`中封装对应函数\r\n// 封装按城市统计的业务请求export function getJobByCity()&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/city/statistics&#x27;,        method:&#x27;get&#x27;    &#125;)&#125;// 封装按省份统计的业务请求export function getJobByProvince()&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/province/statistics&#x27;,        method:&#x27;get&#x27;    &#125;)&#125;\r\n\r\n联调按【省份】请求后端接口的JobsByProvinceVo填充到echarts配置项的data数据区\r\n\r\n\r\nimage-20250328165336193\r\n\r\n&lt;script setup&gt;import &#123;    getJobByProvince,&#125; from &#x27;@/utils/apis&#x27;import &#123; reactive,ref &#125; from &#x27;vue&#x27;;let dataList = ref([]); //保存后端响应JobsByProvinceVo// 将JobsByProvinceVo转换为echarts规定的数据格式，即&#123; name: &#x27;北京市&#x27;, value: 120 &#125;let dataTemp = reactive(&#123;&#125;) // 挂载后onMounted(() =&gt; &#123;    getJobByProvince().then(res=&gt;&#123;        // console.log(res.data.data);        for (let i in res.data.data)&#123;            // 写法一：使用 Object.assign 进行的是浅拷贝，这意味着如果源对象包含嵌套对象，嵌套对象不会被复制，而是引用同一个对象。            // dataTemp = Object.assign(&#123;&#125;,&#123;            //     name: res.data.data[i][&#x27;province&#x27;],            //     value: res.data.data[i][&#x27;quantity&#x27;]            // &#125;)            // 写法二：使用 reactive 包装新的对象             dataTemp = reactive(&#123;                name: res.data.data[i][&#x27;province&#x27;],                value: res.data.data[i][&#x27;quantity&#x27;]            &#125;);            dataList.value.push(dataTemp)        &#125;        mapEcharts()//渲染echarts    &#125;)    console.log(dataList.value);    &#125;)&lt;/script&gt;\r\n联调按【类别】请求后端接口JobsByCategoryVo，保存到categoryData\r\n\r\n\r\nimage-20250328165408732\r\n\r\n&lt;script setup&gt;import &#123;    getJobByCategory,    getJobByCity,&#125; from &#x27;@/utils/apis&#x27;import &#123; reactive,ref &#125; from &#x27;vue&#x27;;let categoryData = ref([])// 保存后端JobsByCategoryVo的top5// 按类别拿岗位数量const fetchData=()=&gt;&#123;    getJobByCategory().then(res=&gt;&#123;        // console.log(res.data.data)        for(let i in res.data.data.slice(0,5))&#123;            categoryData.value.push(res.data.data[i]);        &#125;            &#125;)&#125;// 挂载后onMounted(()=&gt;&#123;    fetchData()&#125;)&lt;/script&gt;\r\n\r\n将categoryData渲染到页面\r\n&lt;el-row&gt;                        &lt;!-- 第一个卡片 --&gt;                        &lt;el-card style=&quot;max-width: 480px&quot;&gt;                            &lt;template #header&gt;                                &lt;div class=&quot;card-header&quot;&gt;                                    &lt;span&gt;按『类别』统计数据&lt;/span&gt;                                &lt;/div&gt;                            &lt;/template&gt;                            &lt;p v-for=&quot;(item,index) in categoryData&quot; :key=&quot;index&quot; class=&quot;text item&quot;&gt;                                &lt;span class=&quot;r1&quot;&gt;&#123;&#123; &#x27;Top&#x27; + (index+1) &#125;&#125;&lt;/span&gt;                                &lt;span class=&quot;r2&quot;&gt;&#123;&#123; item.categoryDesc &#125;&#125;&lt;/span&gt;                                &lt;span class=&quot;r3&quot;&gt;&#123;&#123; item.quantity &#125;&#125;&lt;/span&gt;                            &lt;/p&gt;                        &lt;/el-card&gt;                    &lt;/el-row&gt;\r\n\r\n联调按【城市】请求后端接口JobsByCityVo，保存到cityData\r\n\r\n\r\nimage-20250328165431294\r\n\r\n&lt;script setup&gt;import &#123;    getJobByCity,&#125; from &#x27;@/utils/apis&#x27;import &#123; reactive,ref &#125; from &#x27;vue&#x27;;let cityData=ref([]) //保存后端JobsByCityVo的top5const fetchData = () =&gt; &#123;        // 按城市拿岗位数据    getJobByCity().then(res =&gt; &#123;        // console.log(res.data.data)        for (let i in res.data.data.slice(0, 5)) &#123;            cityData.value.push(res.data.data[i]);        &#125;    &#125;)&#125;&lt;/script&gt;\r\n\r\n将cityData渲染到页面\r\n&lt;!-- 第二个卡片 --&gt;                        &lt;el-card style=&quot;max-width: 480px&quot;&gt;                            &lt;template #header&gt;                                &lt;div class=&quot;card-header&quot;&gt;                                    &lt;span&gt;按『城市』统计数据&lt;/span&gt;                                &lt;/div&gt;                            &lt;/template&gt;                            &lt;p v-for=&quot;(item, index) in cityData&quot; :key=&quot;index&quot; class=&quot;text item&quot;&gt;                                &lt;span class=&quot;r1&quot;&gt;&#123;&#123; &#x27;Top&#x27; + (index + 1) &#125;&#125;&lt;/span&gt;                                &lt;span class=&quot;r2&quot;&gt;&#123;&#123; item.city &#125;&#125;&lt;/span&gt;                                &lt;span class=&quot;r3&quot;&gt;&#123;&#123; item.quantity &#125;&#125;&lt;/span&gt;                            &lt;/p&gt;                        &lt;/el-card&gt;\r\n\r\n联调【分页查询】请求后端接口JobsByCityVo获取第一页数据，拿到总记录数total并将其渲染到页面\r\n\r\n\r\nimage-20250328165020046\r\n\r\n&lt;script setup&gt;import &#123;    getJobByCity,&#125; from &#x27;@/utils/apis&#x27;import &#123; reactive,ref &#125; from &#x27;vue&#x27;;let total = ref(0) //总记录数const fetchData = () =&gt; &#123;    //获取第一页数据拿到总记录数total    getJobListData(1).then(res=&gt;&#123;        //console.log(res.data.data)        total.value=res.data.data.total    &#125;)&#125;&lt;/script&gt;\r\n&lt;!-- 统计组件 --&gt;&lt;div class=&quot;statistic&quot;&gt;    &lt;el-statistic title=&quot;岗位总量&quot; :value=&quot;total&quot; /&gt;&lt;/div&gt;\r\n报错：ResizeObserver\r\nloop completed with undelivered notifications.\r\n由于 ResizeObserver\r\n在处理元素大小变化时遇到了性能问题或无限循环。\r\n\r\nElement Plus 在某些组件中使用 ResizeObserver\r\n来监听元素大小变化，以实现响应式布局或动态调整。\r\n如果这些组件频繁触发大小变化，可能会导致 ResizeObserver\r\n无法及时处理所有通知，从而引发错误。\r\n\r\n解决方案： 使用 debounce\r\n防抖函数限制回调函数的执行频率。 通过重写\r\nResizeObserver，将防抖逻辑集成到其构造函数中。 确保在监听 DOM\r\n元素尺寸变化时，回调函数只在必要时执行，从而提升页面性能。\r\n&lt;script setup&gt;// debounce 防抖函数: 限制一个函数的执行频率，确保在一定时间间隔内只执行一次const debounce = (fn, delay) =&gt; &#123;  let timer = null;  return function () &#123;    let context = this;    let args = arguments;    clearTimeout(timer);    timer = setTimeout(function () &#123;      fn.apply(context, args);    &#125;, delay);  &#125;&#125;// 将原始的ResizeObserver保存为_ResizeObserverconst _ResizeObserver = window.ResizeObserver;// 定义新的ResizeObserver类，重写构造函数，将防抖逻辑集成到其构造函数中// 在新的构造函数中，传入的回调函数被debounce函数处理，确保回调函数在16毫秒的间隔时间内执行一次window.ResizeObserver = class ResizeObserver extends _ResizeObserver &#123;  constructor(callback) &#123;    callback = debounce(callback, 16);    super(callback);  &#125;&#125;&lt;/script&gt;\r\nlinux环境安装mysql\r\nMySQL\r\nYum Repository\r\n安装mysql：\r\nrpm -qa | grep mysqlcd /homewget https://dev.mysql.com/get/mysql84-community-release-el7-1.noarch.rpmyum install mysqlyum install -y mysql-community-servergroupadd mysqluseradd -r -g mysql mysqlmkdir -p /opt/mysql/logmkdir -p /opt/mysql/datamkdir -p /opt/mysql/sharechown -R mysql:mysql /opt/mysql/mysqld --initialize --user=mysql --basedir=/opt/mysql --datadir=/opt/mysql/data/ --lc_messages_dir=/opt/mysql/share --lc_messages=en_UScat /var/log/mysqld.log | grep passwordvim /etc/my.cnfdatadir=/opt/mysql/datalog-error=/opt/mysql/log/mysqld.loguser=mysql:wq\r\n启动mysql：\r\nsystemctl start mysqldsystemctl status mysqldmysql -uroot -pshow databases;alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;密码&#x27;;flush privileges;\r\n开放远程连接：\r\nupdate user set user.Host=&#x27;%&#x27; where user.User=&#x27;root&#x27;;flush privileges;\r\nlinux环境安装JDK\r\n先将JDK上传到home\r\ntat zxvf jdklsvim /etc/profileexport JAVA_HOME=jkd路径export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH:wqsource /etc/profilejava -version\r\n打包项目\r\n注意要开放服务器mysql3306端口和后端api8000端口。\r\npom文件中&lt;skip&gt;true&lt;/skip&gt;的存在是为了在开发环境中加快构建速度，但在项目上线时必须注释掉或禁用它。\r\n注释掉&lt;skip&gt;true&lt;/skip&gt;的目的是确保\r\nspring-boot-maven-plugin 的 repackage 目标能够正常执行，生成一个可执行的\r\nJAR/WAR 文件。\r\n将jar包和配置文件application.prod.yaml上传到job目录\r\nmkdir jobcd joblsnohup java -jar -Dspring.config.location=application.prod.yaml job-api.jar &gt; start.log 2&gt;&amp;1 &amp;ls\r\n部署前端\r\nnpm run build\r\nbuild完成后将生成的dist目录改名打包成job-web.zip然后上传到服务器的job目录下解压\r\ncd jobunzip job-web.ziplscd job-webls\r\n部署Nginx访问前端页面\r\nyum install nginxsystemctl start nginxsystemctl status nginx\r\n让Nginx加载job-web,同时要配置跨域代理\r\nvim /etc/nginx/nginx.confserver_name 购买的ip;root /home/job/job-web;location /api/ &#123;\tadd_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;\tadd_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;POST,GET,OPTIONS&#x27;;\tadd_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Authorization&#x27;;\tproxy_pass http://域名:端口/;&#125;:wqnginx -s reload\r\n"},{"title":"深入理解Java之反射机制","url":"/2025/03/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","content":"Java反射机制深入理解\r\n一、反射机制概述\r\n1. 什么是反射？\r\n概念： -\r\n反射是Java提供的一种动态获取类信息和操作类的机制 -\r\n可以在运行时获取类的完整信息 -\r\n可以在运行时创建对象、调用方法、访问属性\r\n比喻： - 反射就像一面”魔镜”，可以照出类的所有信息 -\r\n就像X光机，可以看到类的内部结构 - 就像遥控器，可以远程控制类的行为\r\n2. 反射的作用\r\n\r\n动态获取类信息\r\n\r\n获取类的名称、包名、父类、接口\r\n获取类的构造方法、普通方法、属性\r\n获取类的注解信息\r\n\r\n动态创建对象\r\n\r\n通过无参构造创建对象\r\n通过有参构造创建对象\r\n创建数组对象\r\n\r\n动态调用方法\r\n\r\n调用公共方法\r\n调用私有方法\r\n调用静态方法\r\n\r\n动态访问属性\r\n\r\n访问公共属性\r\n访问私有属性\r\n修改属性值\r\n\r\n\r\n二、反射的核心类\r\n1. Class类\r\n获取Class对象的方式： // 方式1：通过类名.classClass&lt;?&gt; clazz1 = String.class;// 方式2：通过对象.getClass()String str = &quot;Hello&quot;;Class&lt;?&gt; clazz2 = str.getClass();// 方式3：通过Class.forName()Class&lt;?&gt; clazz3 = Class.forName(&quot;java.lang.String&quot;);\r\nClass类的常用方法： // 获取类的基本信息String className = clazz.getName();        // 获取类名String simpleName = clazz.getSimpleName(); // 获取简单类名Package pkg = clazz.getPackage();         // 获取包信息Class&lt;?&gt; superClass = clazz.getSuperclass(); // 获取父类Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); // 获取接口// 获取类的成员Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); // 获取构造方法Method[] methods = clazz.getMethods();     // 获取公共方法Field[] fields = clazz.getFields();        // 获取公共属性\r\n2. Constructor类\r\n获取和使用构造方法： // 获取构造方法Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class);// 创建对象Object obj = constructor.newInstance(&quot;Hello&quot;);// 获取构造方法的参数类型Class&lt;?&gt;[] paramTypes = constructor.getParameterTypes();\r\n3. Method类\r\n获取和调用方法： // 获取方法Method method = clazz.getMethod(&quot;length&quot;);// 调用方法Object result = method.invoke(obj);// 获取方法的参数类型和返回类型Class&lt;?&gt;[] paramTypes = method.getParameterTypes();Class&lt;?&gt; returnType = method.getReturnType();\r\n4. Field类\r\n获取和访问属性： // 获取属性Field field = clazz.getDeclaredField(&quot;value&quot;);// 设置访问权限field.setAccessible(true);// 获取和设置属性值Object value = field.get(obj);field.set(obj, &quot;newValue&quot;);\r\n三、反射的实际应用\r\n1. 动态创建对象\r\n// 示例：通过反射创建对象public class ReflectionDemo &#123;    public static void main(String[] args) throws Exception &#123;        // 获取Class对象        Class&lt;?&gt; clazz = Class.forName(&quot;com.example.User&quot;);                // 获取构造方法        Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class);                // 创建对象        Object user = constructor.newInstance(&quot;张三&quot;, 18);                // 调用方法        Method getName = clazz.getMethod(&quot;getName&quot;);        String name = (String) getName.invoke(user);        System.out.println(&quot;用户名：&quot; + name);    &#125;&#125;\r\n2. 动态调用方法\r\n// 示例：通过反射调用方法public class MethodDemo &#123;    public static void main(String[] args) throws Exception &#123;        User user = new User(&quot;李四&quot;, 20);        Class&lt;?&gt; clazz = user.getClass();                // 调用公共方法        Method setName = clazz.getMethod(&quot;setName&quot;, String.class);        setName.invoke(user, &quot;王五&quot;);                // 调用私有方法        Method privateMethod = clazz.getDeclaredMethod(&quot;validateAge&quot;);        privateMethod.setAccessible(true);        privateMethod.invoke(user);    &#125;&#125;\r\n3. 动态访问属性\r\n// 示例：通过反射访问属性public class FieldDemo &#123;    public static void main(String[] args) throws Exception &#123;        User user = new User(&quot;赵六&quot;, 25);        Class&lt;?&gt; clazz = user.getClass();                // 访问公共属性        Field nameField = clazz.getField(&quot;name&quot;);        String name = (String) nameField.get(user);                // 访问私有属性        Field ageField = clazz.getDeclaredField(&quot;age&quot;);        ageField.setAccessible(true);        int age = ageField.getInt(user);                // 修改属性值        ageField.setInt(user, 30);    &#125;&#125;\r\n四、反射的高级特性\r\n1. 泛型擦除\r\n// 示例：通过反射获取泛型信息public class GenericDemo &#123;    public static void main(String[] args) throws Exception &#123;        // 获取泛型类型        Method method = GenericDemo.class.getMethod(&quot;getList&quot;);        Type returnType = method.getGenericReturnType();                if (returnType instanceof ParameterizedType) &#123;            ParameterizedType type = (ParameterizedType) returnType;            Type[] typeArguments = type.getActualTypeArguments();            System.out.println(&quot;泛型类型：&quot; + typeArguments[0]);        &#125;    &#125;        public List&lt;String&gt; getList() &#123;        return new ArrayList&lt;&gt;();    &#125;&#125;\r\n2. 注解处理\r\n// 示例：通过反射处理注解@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String value();&#125;@MyAnnotation(&quot;测试注解&quot;)public class AnnotationDemo &#123;    public static void main(String[] args) &#123;        // 获取类上的注解        MyAnnotation annotation = AnnotationDemo.class.getAnnotation(MyAnnotation.class);        System.out.println(&quot;注解值：&quot; + annotation.value());    &#125;&#125;\r\n五、反射的性能考虑\r\n1. 性能影响\r\n\r\n反射操作比直接调用慢\r\n反射会绕过访问控制\r\n反射会创建额外的对象\r\n\r\n2. 性能优化\r\n// 1. 缓存反射对象private static final Constructor&lt;?&gt; CONSTRUCTOR;private static final Method METHOD;static &#123;    try &#123;        CONSTRUCTOR = clazz.getConstructor(String.class);        METHOD = clazz.getMethod(&quot;getName&quot;);    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;// 2. 使用setAccessible(true)field.setAccessible(true);// 3. 避免频繁创建对象Object obj = CONSTRUCTOR.newInstance(&quot;test&quot;);\r\n六、反射的最佳实践\r\n1. 使用场景\r\n\r\n框架开发\r\n动态代理\r\n单元测试\r\n插件开发\r\n\r\n2. 注意事项\r\n\r\n安全性考虑\r\n\r\n反射可以访问私有成员\r\n需要谨慎处理敏感信息\r\n注意权限控制\r\n\r\n性能考虑\r\n\r\n避免频繁使用反射\r\n缓存反射对象\r\n合理使用setAccessible\r\n\r\n代码维护\r\n\r\n反射代码难以维护\r\n需要详细的注释\r\n做好异常处理\r\n\r\n\r\n3. 示例：框架中的应用\r\n// 示例：简单的IOC容器public class SimpleIOC &#123;    private Map&lt;String, Object&gt; container = new HashMap&lt;&gt;();        public void register(String name, Class&lt;?&gt; clazz) throws Exception &#123;        // 创建对象        Object instance = clazz.newInstance();                // 注入依赖        for (Field field : clazz.getDeclaredFields()) &#123;            if (field.isAnnotationPresent(Autowired.class)) &#123;                field.setAccessible(true);                field.set(instance, container.get(field.getType().getName()));            &#125;        &#125;                container.put(name, instance);    &#125;        public Object get(String name) &#123;        return container.get(name);    &#125;&#125;\r\n七、常见面试题\r\n1. 反射的原理\r\n问题： Java反射是如何实现的？\r\n答案： 1. 类加载机制 -\r\n类加载器加载类文件 - 生成Class对象 - 存储类的元数据\r\n\r\nJVM支持\r\n\r\n提供反射相关的本地方法\r\n维护类的元数据信息\r\n支持动态调用\r\n\r\n\r\n2. 反射的优缺点\r\n优点： - 动态性：运行时获取类信息 -\r\n灵活性：可以访问私有成员 - 扩展性：支持插件开发\r\n缺点： - 性能开销大 - 安全性问题 - 代码可读性差\r\n3. 反射的应用场景\r\n实际应用： - Spring框架的IOC容器 -\r\nMyBatis的Mapper接口 - JUnit的测试框架 - 动态代理实现\r\n"},{"title":"深入理解Java锁机制","url":"/2025/03/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%94%81%E6%9C%BA%E5%88%B6/","content":"Java锁机制深入理解\r\n一、锁的基本概念\r\n1. 什么是锁？\r\n专业概念：\r\n锁是一种同步机制，用于控制多个线程对共享资源的访问。它能够保证在同一时刻只有一个线程可以访问共享资源，从而避免并发问题。\r\n生活化比喻： -\r\n就像”厕所门锁”，确保同一时间只有一个人能使用 -\r\n类似于”银行金库”，需要钥匙才能进入 -\r\n像是一个”会议室”，需要预约才能使用\r\n2. 锁的分类\r\n2.1 乐观锁与悲观锁\r\n专业概念： -\r\n乐观锁：假设不会发生冲突，只在更新时检查是否被修改 -\r\n悲观锁：假设会发生冲突，每次访问都加锁\r\n代码示例： // 乐观锁示例public class OptimisticLock &#123;    private int version;    private int value;        public boolean update(int newValue) &#123;        // 假设不会冲突，直接更新        this.value = newValue;        this.version++;        return true;    &#125;&#125;// 悲观锁示例public class PessimisticLock &#123;    private int value;        public synchronized void update(int newValue) &#123;        // 假设会冲突，加锁保护        this.value = newValue;    &#125;&#125;\r\n生活化比喻： -\r\n乐观锁就像”图书馆借书”，假设不会有人同时借同一本书 -\r\n悲观锁就像”银行取款”，每次都要排队等待\r\n2.2 公平锁与非公平锁\r\n专业概念： - 公平锁：按照申请锁的顺序获取锁 -\r\n非公平锁：允许插队，性能更好\r\n代码示例： // 公平锁ReentrantLock fairLock = new ReentrantLock(true);// 非公平锁ReentrantLock unfairLock = new ReentrantLock(false);\r\n生活化比喻： - 公平锁就像”排队买票”，先来先得 -\r\n非公平锁就像”公交车”，谁先挤上去谁先走\r\n2.3 可重入锁与不可重入锁\r\n专业概念： - 可重入锁：同一线程可以多次获取同一把锁\r\n- 不可重入锁：同一线程不能多次获取同一把锁\r\n代码示例： // 可重入锁示例public class ReentrantLockDemo &#123;    private ReentrantLock lock = new ReentrantLock();        public void outer() &#123;        lock.lock();  // 第一次获取锁        try &#123;            inner();  // 可以再次获取锁        &#125; finally &#123;            lock.unlock();        &#125;    &#125;        public void inner() &#123;        lock.lock();  // 第二次获取锁        try &#123;            // 做一些事情        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;\r\n生活化比喻： - 可重入锁就像”会员卡”，可以重复使用 -\r\n不可重入锁就像”一次性门票”，使用后就不能再用\r\n二、Java中的锁实现\r\n1. synchronized关键字\r\n专业概念：\r\nsynchronized是Java内置的锁机制，可以修饰方法或代码块，保证线程安全。\r\n代码示例： public class SynchronizedDemo &#123;    // 修饰实例方法    public synchronized void method1() &#123;        // 同步代码    &#125;        // 修饰静态方法    public static synchronized void method2() &#123;        // 同步代码    &#125;        // 修饰代码块    public void method3() &#123;        synchronized(this) &#123;            // 同步代码        &#125;    &#125;&#125;\r\n生活化比喻： -\r\n就像”会议室预约系统”，同一时间只能有一个团队使用 -\r\n类似于”图书馆座位”，需要刷卡才能使用\r\n2. ReentrantLock\r\n专业概念：\r\nReentrantLock是Java提供的可重入锁实现，比synchronized更灵活。\r\n代码示例： public class ReentrantLockDemo &#123;    private ReentrantLock lock = new ReentrantLock();        public void method() &#123;        lock.lock();  // 获取锁        try &#123;            // 临界区代码        &#125; finally &#123;            lock.unlock();  // 释放锁        &#125;    &#125;        // 带超时的锁    public boolean tryLockWithTimeout() &#123;        try &#123;            return lock.tryLock(5, TimeUnit.SECONDS);        &#125; catch (InterruptedException e) &#123;            return false;        &#125;    &#125;&#125;\r\n生活化比喻： -\r\n就像”智能门锁”，可以设置密码、指纹等多种方式 -\r\n类似于”预约系统”，可以设置超时时间\r\n3. ReadWriteLock\r\n专业概念：\r\n读写锁允许多个线程同时读取，但写操作需要独占锁。\r\n代码示例： public class ReadWriteLockDemo &#123;    private ReadWriteLock rwLock = new ReentrantReadWriteLock();    private Map&lt;String, String&gt; cache = new HashMap&lt;&gt;();        public String read(String key) &#123;        rwLock.readLock().lock();        try &#123;            return cache.get(key);        &#125; finally &#123;            rwLock.readLock().unlock();        &#125;    &#125;        public void write(String key, String value) &#123;        rwLock.writeLock().lock();        try &#123;            cache.put(key, value);        &#125; finally &#123;            rwLock.writeLock().unlock();        &#125;    &#125;&#125;\r\n生活化比喻： -\r\n就像”图书馆”，可以同时有多个人看书，但只能有一个人整理书架 -\r\n类似于”共享文档”，可以同时有多个人查看，但只能有一个人编辑\r\n三、锁的性能优化\r\n1. 锁的粒度\r\n专业概念：\r\n锁的粒度是指锁定的范围大小，粒度越小，并发性能越好。\r\n代码示例： // 粗粒度锁public class CoarseGrainedLock &#123;    private synchronized void process() &#123;        // 处理大量数据    &#125;&#125;// 细粒度锁public class FineGrainedLock &#123;    private void process() &#123;        synchronized(part1) &#123;            // 处理部分数据        &#125;        synchronized(part2) &#123;            // 处理另一部分数据        &#125;    &#125;&#125;\r\n生活化比喻： -\r\n粗粒度锁就像”整栋楼的门禁”，进出都要刷卡 -\r\n细粒度锁就像”每个房间的门锁”，可以同时使用不同房间\r\n2. 锁分离\r\n专业概念：\r\n将读写操作分离，使用不同的锁，提高并发性能。\r\n代码示例： public class LockSeparation &#123;    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();    private final Lock readLock = rwLock.readLock();    private final Lock writeLock = rwLock.writeLock();        public void read() &#123;        readLock.lock();        try &#123;            // 读取操作        &#125; finally &#123;            readLock.unlock();        &#125;    &#125;        public void write() &#123;        writeLock.lock();        try &#123;            // 写入操作        &#125; finally &#123;            writeLock.unlock();        &#125;    &#125;&#125;\r\n生活化比喻： -\r\n就像”图书馆”，读者和图书管理员使用不同的通道 -\r\n类似于”银行”，客户和工作人员使用不同的窗口\r\n3. 锁消除\r\n专业概念：\r\nJVM在运行时，对一些不可能存在共享资源竞争的锁进行消除。\r\n代码示例： public class LockElimination &#123;    public String concatString(String s1, String s2, String s3) &#123;        return s1 + s2 + s3;  // JVM会消除这里的锁    &#125;&#125;\r\n生活化比喻： - 就像”单人办公室”，不需要上锁 -\r\n类似于”私人储物柜”，不需要密码\r\n四、常见面试题\r\n1.\r\nsynchronized和ReentrantLock的区别\r\n问题： synchronized和ReentrantLock有什么区别？\r\n详细答案： 1. 使用方式 -\r\nsynchronized是关键字，使用更简单 -\r\nReentrantLock是类，需要手动加锁解锁\r\n\r\n功能特性\r\n\r\nReentrantLock可以尝试获取锁\r\nReentrantLock可以响应中断\r\nReentrantLock可以实现公平锁\r\n\r\n性能差异\r\n\r\nJDK1.6后synchronized做了很多优化\r\n两者性能基本持平\r\n\r\n\r\n生活化比喻： - synchronized就像”自动门”，使用简单 -\r\nReentrantLock就像”智能门锁”，功能更多\r\n2. 死锁问题\r\n问题： 什么是死锁？如何避免死锁？\r\n详细答案： 1. 死锁定义 -\r\n多个线程互相持有对方需要的锁 - 导致所有线程都无法继续执行\r\n\r\n避免方法\r\n\r\n固定加锁顺序\r\n使用超时机制\r\n死锁检测\r\n\r\n\r\n代码示例： public class DeadLockDemo &#123;    private Object lock1 = new Object();    private Object lock2 = new Object();        public void method1() &#123;        synchronized(lock1) &#123;            synchronized(lock2) &#123;                // 业务逻辑            &#125;        &#125;    &#125;        public void method2() &#123;        synchronized(lock2) &#123;            synchronized(lock1) &#123;                // 业务逻辑            &#125;        &#125;    &#125;&#125;\r\n生活化比喻： - 就像”两个人互相等待对方让路” -\r\n类似于”两个人都想先过独木桥”\r\n3. 锁升级过程\r\n问题： synchronized锁升级的过程是什么？\r\n详细答案： 1. 无锁 - 初始状态 -\r\n没有线程访问\r\n\r\n偏向锁\r\n\r\n只有一个线程访问\r\n记录线程ID\r\n\r\n轻量级锁\r\n\r\n多个线程交替访问\r\n使用CAS操作\r\n\r\n重量级锁\r\n\r\n多个线程同时访问\r\n使用操作系统互斥量\r\n\r\n\r\n生活化比喻： - 就像”图书馆座位系统” - 无锁：座位空闲\r\n- 偏向锁：常客预约 - 轻量级锁：临时使用 - 重量级锁：高峰期管理\r\n五、实战技巧\r\n1. 锁的选择\r\n选择原则： 1. 优先使用synchronized - 代码简单 -\r\n性能足够 - 自动释放\r\n\r\n需要特殊功能时使用ReentrantLock\r\n\r\n需要超时机制\r\n需要响应中断\r\n需要公平锁\r\n\r\n\r\n生活化比喻： - 就像选择交通工具 -\r\nsynchronized像”公交车”，简单方便 - ReentrantLock像”出租车”，更灵活\r\n2. 锁的使用建议\r\n使用建议： 1. 尽量缩小锁的范围 2. 避免嵌套锁 3.\r\n使用try-finally确保释放锁 4. 注意锁的性能开销\r\n代码示例： public class LockBestPractice &#123;    private final ReentrantLock lock = new ReentrantLock();        public void goodPractice() &#123;        // 1. 缩小锁范围        &#123;            lock.lock();            try &#123;                // 最小范围的同步代码            &#125; finally &#123;                lock.unlock();            &#125;        &#125;                // 2. 避免嵌套锁        // 不好的做法        synchronized(lock1) &#123;            synchronized(lock2) &#123;                // 可能导致死锁            &#125;        &#125;    &#125;&#125;\r\n生活化比喻： - 就像”排队买票” -\r\n缩小范围：只锁住收银台 - 避免嵌套：不要同时排多个队 -\r\n确保释放：买完票就离开\r\n3. 性能优化技巧\r\n优化方法： 1. 使用读写锁 2. 使用分段锁 3. 使用原子类\r\n4. 使用无锁算法\r\n代码示例： public class PerformanceOptimization &#123;    // 1. 使用读写锁    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();        // 2. 使用分段锁    private final Segment[] segments = new Segment[16];        // 3. 使用原子类    private final AtomicInteger counter = new AtomicInteger(0);        // 4. 使用无锁算法    public void lockFreeAlgorithm() &#123;        while(true) &#123;            int current = counter.get();            if(counter.compareAndSet(current, current + 1)) &#123;                break;            &#125;        &#125;    &#125;&#125;\r\n生活化比喻： - 就像”图书馆管理” -\r\n读写锁：读者和管理员分开 - 分段锁：不同区域分开管理 - 原子类：自动计数 -\r\n无锁算法：自助借还书\r\n"},{"title":"深刻理解Java之List集合","url":"/2025/03/14/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3Java%E4%B9%8BList%E9%9B%86%E5%90%88/","content":"深刻理解Java之List集合\r\n\r\n\r\nimage-20250314132644267\r\n\r\n1. List接口概述\r\n1.1 基本特性\r\nList接口继承自Collection接口，代表一个有序的、可重复的元素集合。其主要特点：\r\n\r\n有序性：元素存储和添加的顺序一致\r\n可重复性：允许存储相同的元素\r\n索引访问：可以通过索引精确访问元素\r\n动态扩容：大多数实现类支持动态调整容量\r\n存储引用数据类型\r\n\r\n生活比喻：List就像电影院的一排座位 -\r\n每个座位都有明确的编号(0, 1, 2…)，按顺序排列 -\r\n同一个人可以买多个座位(可重复) -\r\n你可以直接找到”第5号座位”而不需要从头数过去 -\r\n如果需要，影院可以增加更多座位(动态扩容)\r\n1.2 List在集合框架中的位置\r\nCollection (接口)├── List (接口)│   ├── ArrayList (实现类)│   ├── LinkedList (实现类)│   ├── Vector (实现类)│   │   └── Stack (子类)│   └── ...├── Set (接口)└── Queue (接口)\r\n1.3 List接口定义的主要方法\r\n// 添加元素到指定位置void add(int index, E element);// 获取指定索引的元素E get(int index);// 替换指定索引的元素E set(int index, E element);// 移除指定索引的元素E remove(int index);// 查找元素首次出现的索引int indexOf(Object o);// 查找元素最后一次出现的索引int lastIndexOf(Object o);// 获取子列表List&lt;E&gt; subList(int fromIndex, int toIndex);\r\n2. List的主要实现类\r\n2.1 ArrayList -\r\n“整齐排列的火车车厢”\r\nArrayList是List接口最常用的实现类，基于动态数组实现，查询快，但由于不可变性，增删会复制创建新数组。\r\n内部结构： // ArrayList的核心是一个Object数组transient Object[] elementData;// 实际元素数量private int size;\r\n工作原理： - 初始容量为10（默认构造函数） -\r\n当容量不足时，自动扩容为原容量的1.5倍 -\r\n扩容涉及数组复制，是一个相对昂贵的操作\r\n性能特点： - 随机访问性能极佳：O(1) -\r\n尾部添加元素通常为O(1)，但可能触发扩容 -\r\n中间插入/删除元素性能较差：O(n)，因为需要移动元素 - 非线程安全\r\n生活比喻：\r\nArrayList就像一列火车车厢，整齐地排列在铁轨上： -\r\n想找到第N号车厢非常容易，直接数过去就行（随机访问快） -\r\n在中间加入新车厢很麻烦，需要把后面所有车厢都移动（中间插入慢） -\r\n在尾部加车厢相对简单，但偶尔需要换一条更长的铁轨（扩容操作） -\r\n每个车厢紧挨着，占用空间紧凑（内存效率高）\r\n代码示例： // 创建ArrayListList&lt;String&gt; fruits = new ArrayList&lt;&gt;();// 添加元素fruits.add(&quot;Apple&quot;);fruits.add(&quot;Banana&quot;);fruits.add(&quot;Orange&quot;);// 指定位置添加fruits.add(1, &quot;Mango&quot;);  // [Apple, Mango, Banana, Orange]// 访问元素String fruit = fruits.get(0);  // Apple// 修改元素fruits.set(0, &quot;Pineapple&quot;);  // [Pineapple, Mango, Banana, Orange]// 删除元素fruits.remove(2);  // [Pineapple, Mango, Orange]// 查找元素int index = fruits.indexOf(&quot;Mango&quot;);  // 1// 大小int siz = fruits.size();\r\n2.2 LinkedList - “手拉手的人链”\r\nLinkedList是基于双向链表实现的List接口，同时也实现了Deque接口。增删快，只需要改节点的指针，当时查询慢，需要从头开始找。\r\n内部结构： // 链表节点类private static class Node&lt;E&gt; &#123;    E item;           // 元素值    Node&lt;E&gt; next;     // 后继节点    Node&lt;E&gt; prev;     // 前驱节点&#125;// 链表大小transient int size;// 头节点和尾节点transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;\r\n工作原理： - 每个元素都是一个包含前后引用的节点 -\r\n添加元素时创建新节点并调整相关节点的引用 -\r\n删除元素时调整相关节点的引用\r\n性能特点： - 随机访问性能较差：O(n)，需要从头/尾遍历\r\n- 插入/删除元素性能极佳：O(1)，只需调整引用 -\r\n内存占用较大，每个元素需要额外存储前后引用 - 非线程安全\r\n生活比喻： LinkedList就像一群手拉手的人形成的人链：\r\n- 要找到第50个人，你必须从头（或尾）数过去（随机访问慢） -\r\n在任何位置插入新人很容易，只需要松开两个人的手，让新人拉住他们（插入快）\r\n- 每个人除了自己外，还要记住前后两个人是谁（额外内存开销） -\r\n人链的两端可以很方便地加入或移除人员（两端操作高效）\r\n代码示例：\r\n\r\n\r\nimage-20250314144120517\r\n\r\n// 创建LinkedListLinkedList&lt;String&gt; tasks = new LinkedList&lt;&gt;();// 添加元素tasks.add(&quot;Task 1&quot;);tasks.add(&quot;Task 3&quot;);// 在指定位置添加tasks.add(1, &quot;Task 2&quot;);  // [Task 1, Task 2, Task 3]// 作为双端队列使用tasks.addFirst(&quot;Task 0&quot;);  // [Task 0, Task 1, Task 2, Task 3]tasks.addLast(&quot;Task 4&quot;);   // [Task 0, Task 1, Task 2, Task 3, Task 4]// 获取元素String first = tasks.getFirst();  // Task 0String last = tasks.getLast();    // Task 4// 删除元素tasks.removeFirst();  // [Task 1, Task 2, Task 3, Task 4]tasks.removeLast();   // [Task 1, Task 2, Task 3]\r\n2.3 Vector - “带锁的保险柜”\r\nVector是List接口的古老实现类，与ArrayList类似，但是线程安全的。\r\n内部结构： - 与ArrayList类似，基于数组实现 -\r\n方法使用synchronized关键字同步\r\n性能特点： - 随机访问性能好：O(1) -\r\n由于同步机制，性能比ArrayList差 -\r\n扩容时默认增长为原容量的2倍（而ArrayList是1.5倍） - 线程安全\r\n生活比喻：\r\nVector就像一个带锁的保险柜，每次只允许一个人操作： -\r\n查找和存取物品的方式与普通柜子相同 -\r\n但每次操作都需要先开锁，用完再锁上（同步操作的开销） -\r\n安全性高，但效率低\r\n适用场景： - 需要线程安全的动态数组 -\r\n多线程环境下共享集合 -\r\n注：现代Java应用中，通常使用Collections.synchronizedList()或CopyOnWriteArrayList代替Vector\r\n2.4 Stack - “书堆”\r\nStack是Vector的子类，实现了后进先出(LIFO)的栈结构。\r\n主要方法： -\r\npush(E item)：将元素压入栈顶 -\r\npop()：移除并返回栈顶元素 -\r\npeek()：返回栈顶元素但不移除 -\r\nempty()：检查栈是否为空 -\r\nsearch(Object o)：查找元素在栈中的位置\r\n生活比喻： Stack就像一堆叠放的书： -\r\n你只能从顶部放书或取书 - 要拿到底部的书，必须先移除上面所有的书\r\n注意：Stack类已被视为过时设计，现代Java应用通常使用Deque接口的实现（如ArrayDeque）作为栈。\r\n3.\r\nArrayList与LinkedList的深度对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\nArrayList\r\nLinkedList\r\n生活比喻\r\n\r\n\r\n\r\n\r\n内部实现\r\n动态数组\r\n双向链表\r\n整齐排列的停车场 vs 分散但互相连接的停车位\r\n\r\n\r\n随机访问\r\nO(1)，极快\r\nO(n)，较慢\r\n翻书找页码 vs 看连续剧找某一集\r\n\r\n\r\n插入/删除（中间）\r\nO(n)，需移动元素\r\nO(1)，仅调整引用\r\n排队插队(所有人后移) vs 手拉手人链中加人(只调整相邻两人)\r\n\r\n\r\n插入/删除（末尾）\r\n平均O(1)，可能扩容\r\nO(1)\r\n在队尾加人 vs 在人链尾部加人\r\n\r\n\r\n内存占用\r\n较少\r\n较多（存储前后引用）\r\n紧凑的公寓楼 vs 带花园的独栋别墅\r\n\r\n\r\n迭代性能\r\n较好（内存连续）\r\n较差（内存分散）\r\n连续高速公路 vs 有红绿灯的城市道路\r\n\r\n\r\n适用场景\r\n随机访问、尾部操作\r\n频繁插入删除、两端操作\r\n图书馆查书 vs 排队叫号系统\r\n\r\n\r\n\r\n4. List的常用操作\r\n\r\n\r\nimage-20250314124911847\r\n\r\n\r\n\r\nimage-20250314125024121\r\n\r\n4.1 创建List\r\n// 空ArrayListList&lt;String&gt; list1 = new ArrayList&lt;&gt;();// 指定初始容量List&lt;String&gt; list2 = new ArrayList&lt;&gt;(20);// 基于已有集合创建List&lt;String&gt; list3 = new ArrayList&lt;&gt;(anotherCollection);// 使用Arrays.asList创建固定大小的ListList&lt;String&gt; list4 = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);// 注意：Arrays.asList返回的List不支持add/remove操作// Java 9+: 使用List.of创建不可变ListList&lt;String&gt; list5 = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);// 使用Stream创建List&lt;Integer&gt; list6 = IntStream.range(1, 6)                              .boxed()                              .collect(Collectors.toList());\r\n生活比喻： -\r\n创建空ArrayList就像买了一个空相册，准备放照片 -\r\n指定初始容量就像提前准备好20个格子的收纳盒 -\r\nArrays.asList就像买了一个已经放了照片的相册，但相册大小固定\r\n4.2 添加元素\r\nList&lt;String&gt; colors = new ArrayList&lt;&gt;();// 添加单个元素colors.add(&quot;Red&quot;);// 在指定位置添加colors.add(0, &quot;Blue&quot;);// 添加多个元素colors.addAll(Arrays.asList(&quot;Green&quot;, &quot;Yellow&quot;));// 在指定位置添加集合colors.addAll(1, Arrays.asList(&quot;Purple&quot;, &quot;Orange&quot;));\r\n4.3 访问元素\r\nList&lt;String&gt; planets = new ArrayList&lt;&gt;(    Arrays.asList(&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;));// 通过索引访问String earth = planets.get(2);  // Earth// 查找元素位置int index = planets.indexOf(&quot;Mars&quot;);  // 3int lastIndex = planets.lastIndexOf(&quot;Earth&quot;);  // 2// 检查是否包含元素boolean contains = planets.contains(&quot;Venus&quot;);  // true// 获取子列表（视图，非副本）List&lt;String&gt; innerPlanets = planets.subList(0, 4);\r\n4.4 修改元素\r\nList&lt;String&gt; names = new ArrayList&lt;&gt;(    Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;));// 替换元素names.set(1, &quot;Robert&quot;);  // [Alice, Robert, Charlie, David]// 批量替换（Java 8+）names.replaceAll(name -&gt; name.toUpperCase());// [ALICE, ROBERT, CHARLIE, DAVID]\r\n4.5 删除元素\r\nList&lt;String&gt; animals = new ArrayList&lt;&gt;(    Arrays.asList(&quot;Dog&quot;, &quot;Cat&quot;, &quot;Bird&quot;, &quot;Fish&quot;, &quot;Cat&quot;));// 删除指定位置的元素String removed = animals.remove(2);  // Bird// 现在是 [Dog, Cat, Fish, Cat]// 删除指定元素（首次出现）boolean isRemoved = animals.remove(&quot;Cat&quot;);  // true// 现在是 [Dog, Fish, Cat]// 批量删除animals.removeAll(Arrays.asList(&quot;Fish&quot;, &quot;Cat&quot;));// 现在是 [Dog]// 条件删除（Java 8+）animals.add(&quot;Elephant&quot;);animals.add(&quot;Snake&quot;);animals.removeIf(animal -&gt; animal.length() &gt; 3);// 现在是 [Dog]\r\n4.6 遍历List\r\n\r\n\r\n\r\niterator方法\r\n说明\r\n\r\n\r\n\r\n\r\nhasNext()\r\n判断集合中是否还有下一个元素\r\n\r\n\r\nnext()\r\n返回集合中的下一个元素\r\n\r\n\r\nremove()\r\n删除迭代器返回的元素\r\n\r\n\r\n\r\nList&lt;String&gt; fruits = Arrays.asList(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;, &quot;Date&quot;);// 1. 使用for循环（索引）for (int i = 0; i &lt; fruits.size(); i++) &#123;    System.out.println(fruits.get(i));&#125;// 2. 使用增强for循环for (String fruit : fruits) &#123;    System.out.println(fruit);&#125;// 3. 使用迭代器时，集合中的元素删除只能通过迭代器提供remove方法Iterator&lt;String&gt; iterator = fruits.iterator();while (iterator.hasNext()) &#123;    String f = iterator.next()    if(f==&quot;Banana&quot;)&#123;        iterator.remove();    &#125;&#125;// 4. 使用ListIterator（可双向遍历）ListIterator&lt;String&gt; listIterator = fruits.listIterator();while (listIterator.hasNext()) &#123;    System.out.println(listIterator.next());&#125;// 反向遍历while (listIterator.hasPrevious()) &#123;    System.out.println(listIterator.previous());&#125;// 5. 使用forEach方法（Java 8+）fruits.forEach(System.out::println);// 6. 使用Stream API（Java 8+）fruits.stream()      .filter(f -&gt; f.startsWith(&quot;A&quot;))      .map(String::toUpperCase)      .forEach(System.out::println);\r\n生活比喻： - for循环（索引）：就像按座位号点名 -\r\n增强for循环：就像派发礼物，每个人都要领到，但不关心座位号 -\r\n迭代器：就像列队检查，检查完一个人后，才移动到下一个人 - Stream\r\nAPI：就像设置了一条传送带，水果经过清洗(filter)、切片(map)等处理\r\n4.7 排序List\r\nList&lt;String&gt; names = new ArrayList&lt;&gt;(    Arrays.asList(&quot;Zack&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;));// 1. 使用Collections.sort（自然顺序）Collections.sort(names);// [Alice, Bob, Charlie, Zack]// 2. 使用List.sort（Java 8+）names.sort(Comparator.naturalOrder());// [Alice, Bob, Charlie, Zack]// 3. 自定义比较器names.sort(Comparator.comparing(String::length));// 按长度排序: [Bob, Zack, Alice, Charlie]// 4. 反向排序names.sort(Comparator.reverseOrder());// [Zack, Charlie, Bob, Alice]// 5. 复合排序names.sort(    Comparator.comparing(String::length)              .thenComparing(Comparator.naturalOrder()));// 先按长度，再按字母顺序\r\n生活比喻： - 自然顺序排序就像按字母表顺序排队 -\r\n自定义比较器就像可以选择按年龄、身高或成绩给学生排队 -\r\n复合排序就像先按年级分组，再按成绩排序\r\n5. List的线程安全性\r\n5.1 线程不安全的List\r\nArrayList和LinkedList都不是线程安全的，在多线程环境下可能出现： -\r\nConcurrentModificationException - 数据不一致 - 元素丢失\r\n生活比喻：\r\n就像没有管理员的图书馆书架，多人同时取放书可能导致混乱（有人正在整理的书架被其他人打乱）\r\n5.2 创建线程安全的List\r\n// 1. 使用Collections.synchronizedListList&lt;String&gt; syncList = Collections.synchronizedList(new ArrayList&lt;&gt;());// 使用时需要手动同步迭代操作synchronized (syncList) &#123;    Iterator&lt;String&gt; iterator = syncList.iterator();    while (iterator.hasNext()) &#123;        // ...    &#125;&#125;// 2. 使用CopyOnWriteArrayList（适合读多写少的场景）List&lt;String&gt; cowList = new CopyOnWriteArrayList&lt;&gt;();// 写操作会复制整个底层数组，读操作无锁// 迭代器是快照，不会抛出ConcurrentModificationException\r\n生活比喻： -\r\nsynchronizedList就像有管理员的图书馆，一次只允许一个人操作书架，其他人必须等待\r\n-\r\nCopyOnWriteArrayList就像特殊的图书馆，每次有人要修改书架，都会先复制一份完整的书架进行修改，读者始终看到的是完整的旧版本，直到修改完成\r\n6. List的性能优化\r\n6.1 ArrayList优化\r\n// 1. 指定初始容量，避免频繁扩容List&lt;String&gt; list = new ArrayList&lt;&gt;(10000);// 2. 批量添加元素list.addAll(collection);  // 优于循环添加// 3. 使用ensureCapacity预分配空间ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();arrayList.ensureCapacity(10000);// 4. 使用trimToSize释放多余空间arrayList.trimToSize();\r\n生活比喻： -\r\n指定初始容量就像搬家时一开始就租足够大的卡车，比先租小车再换大车要高效得多\r\n- trimToSize就像搬完家后退掉大卡车，换成刚好够用的小车，节省空间\r\n6.2 LinkedList优化\r\n// 1. 使用合适的方法LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();// 使用addFirst/addLast而非add(0, element)linkedList.addFirst(&quot;First&quot;);  // 比add(0, &quot;First&quot;)更高效// 2. 避免随机访问// 不要使用for (int i = 0; i &lt; list.size(); i++)// 而应使用迭代器或增强for循环\r\n生活比喻： - 使用addFirst而非add(0,\r\nelement)就像直接告诉门卫”我要见队伍最前面的人”，而不是让门卫带你从队伍头走到尾\r\n7. List的实际应用场景\r\n7.1 ArrayList应用场景\r\n\r\n实现动态数组\r\n频繁随机访问的数据集合\r\n数据量较大但变化较少的集合\r\n需要快速迭代的场景\r\n\r\n生活比喻：\r\nArrayList就像一本书的目录或索引，需要快速查找但不经常修改\r\n7.2 LinkedList应用场景\r\n\r\n实现队列或栈\r\n频繁插入/删除操作的场景\r\n实现LRU缓存\r\n需要从两端操作的集合\r\n\r\n生活比喻：\r\nLinkedList就像餐厅的等位名单，经常有人加入或离开队伍\r\n7.3 实际案例：分页处理\r\npublic class Pagination&lt;T&gt; &#123;    private final List&lt;T&gt; data;    private final int pageSize;        public Pagination(List&lt;T&gt; data, int pageSize) &#123;        this.data = new ArrayList&lt;&gt;(data);  // 创建副本，避免外部修改        this.pageSize = pageSize;    &#125;        public List&lt;T&gt; getPage(int pageNumber) &#123;        int startIndex = (pageNumber - 1) * pageSize;        int endIndex = Math.min(startIndex + pageSize, data.size());                if (startIndex &gt;= data.size() || startIndex &lt; 0) &#123;            return Collections.emptyList();        &#125;                return data.subList(startIndex, endIndex);    &#125;        public int getTotalPages() &#123;        return (int) Math.ceil((double) data.size() / pageSize);    &#125;&#125;// 使用示例List&lt;Product&gt; allProducts = productRepository.findAll();Pagination&lt;Product&gt; pagination = new Pagination&lt;&gt;(allProducts, 10);List&lt;Product&gt; page1 = pagination.getPage(1);  // 获取第一页\r\n生活比喻：\r\n分页处理就像一本厚书的章节划分，让读者能够一次阅读适量的内容，而不是一次展示所有内容\r\n8. List的最佳实践\r\n\r\n选择合适的实现类\r\n\r\n随机访问多，选择ArrayList\r\n插入/删除多，选择LinkedList\r\n需要线程安全，使用CopyOnWriteArrayList或synchronizedList\r\n\r\n比喻：就像选择交通工具 -\r\n需要在固定站点上下客，选择公交车(ArrayList)；需要灵活穿梭于各个小巷，选择摩托车(LinkedList)\r\n避免频繁扩容\r\n\r\n预估容量，使用带容量参数的构造函数\r\n批量添加元素时使用addAll而非循环add\r\n\r\n比喻：一开始就买足够大的水桶，而不是先买小桶再换大桶\r\n正确使用迭代器\r\n\r\n使用迭代器遍历时不要使用集合的remove方法，应使用迭代器的remove方法\r\n// 错误方式for (String item : list) &#123;    if (condition) list.remove(item);  // ConcurrentModificationException&#125;// 正确方式Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123;    String item = it.next();    if (condition) it.remove();&#125;\r\n\r\n比喻：就像在移动的传送带上拿东西 -\r\n直接改变传送带的结构会导致故障，应该通过传送带提供的控制按钮来移除物品\r\n合理使用视图和包装器\r\n\r\nsubList返回的是原List的视图，修改会影响原List\r\nunmodifiableList创建只读视图，防止修改\r\n\r\n比喻：subList就像房间的窗户，通过窗户看到的变化反映了房间的实际变化；unmodifiableList就像博物馆的展品，只能看不能动\r\n注意List.of和Arrays.asList的限制\r\n\r\nList.of和Arrays.asList创建的List不支持添加/删除操作\r\nArrays.asList创建的List大小固定，但元素可修改\r\nList.of创建的List完全不可变\r\n\r\n比喻：Arrays.asList就像固定格数的相册，可以替换照片但不能增减格子；List.of就像密封的时间胶囊，一旦封存就不能改变\r\n利用Stream API进行复杂操作\r\n\r\n使用Stream API进行过滤、映射、归约等操作 List&lt;Integer&gt; evenNumbers = numbers.stream()                                  .filter(n -&gt; n % 2 == 0)                                  .collect(Collectors.toList());\r\n\r\n比喻：Stream\r\nAPI就像工厂的生产线，原材料(数据)经过一系列工序(操作)，最终成为成品\r\n避免装箱/拆箱开销\r\n\r\n对于基本类型，考虑使用专门的实现如IntArrayList（第三方库）\r\n或使用数组代替List\r\n\r\n比喻：装箱/拆箱就像每次进出商场都要把东西包装/拆包，很耗时间\r\n注意equals和hashCode\r\n\r\n自定义类作为List元素时，正确实现equals和hashCode方法\r\n这对contains、remove等方法的正确工作至关重要\r\n\r\n比喻：equals就像人脸识别系统，如果设计不当，可能会把双胞胎认成同一个人或把同一个人的不同表情认成不同人\r\n\r\n通过深入理解List集合的内部机制和使用技巧，结合生活化的比喻，我们可以在实际开发中更加高效地使用这一重要的数据结构，编写出更加高效、可靠的代码。\r\n"},{"title":"深入理解Java之多线程","url":"/2025/03/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"深入理解Java之多线程与IO学习笔记\r\n第一部分：Java多线程基础\r\n什么是线程\r\n启动一个java程序实际上是启动了一个JVM进程，然后JVM创建主线程让其执行main方法，在main方法中我们又可以创建启动其他子线程。\r\n进程是计算机资源分配最小单位，线程是计算机计算的最小单位。\r\n比如你在玩游戏，一个游戏就是进程。这个进程用于有渲染的程序A，和有用于AI处理的程序B。A和B经常抢占CPU的时间片就会导致游戏卡顿。如果一个进程中的所有线程在同步计算结果时去访问进程中的全局变量，就会产生竞争条件，需要解决一致性（加锁）。\r\n线程的生命周期\r\n\r\n\r\nimage-20250321161624526\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\nsetPriority(int newPriority)\r\n更改线程的优先级\r\n\r\n\r\nstatic void sleep(long millis)\r\n在指定的毫秒数内让当前正在执行的线程休眠\r\n\r\n\r\nvoid join()\r\n等待该线程终止\r\n\r\n\r\nstatic void yield()\r\n暂停当前正在执行的线程对象，并执行其他线程\r\n\r\n\r\nvoid interrupt()\r\n中断线程，别用这个方式\r\n\r\n\r\nboolean isAlive()\r\n测试线程是否处于活动状态\r\n\r\n\r\n\r\n\r\n新建（New）：线程被创建，但还没有调用start()方法\r\n就绪（Runnable）：线程已经启动，等待CPU分配时间片\r\n运行（Running）：线程正在执行\r\n阻塞（Blocked）：线程因为某些原因暂时停止执行\r\n等待（Waiting）：线程等待其他线程的通知\r\n超时等待（Timed\r\nWaiting）：线程等待一段时间后自动恢复\r\n终止（Terminated）：线程执行完毕\r\n\r\npackage com.luotao.demo;class ThtreadStateDemo&#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread myThread = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 10; i++) &#123;                try &#123;                    Thread.sleep(1000);//TIMED_WAITING                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            System.out.println(&quot;运行中···&quot;);        &#125;,&quot;myThread&quot;);        Thread.State state = myThread.getState();        System.out.println(state); // NEW        myThread.start();        state= myThread.getState();        System.out.println(state);// RUNNABLE:等待cpu调度        while (state != Thread.State.TERMINATED)&#123;            Thread.sleep(1000);            state= myThread.getState();            System.out.println(state); // TERMINATED        &#125;    &#125;&#125;\r\n线程的创建方式\r\nclass ThreadDemo&#123;    public static void main(String[] args) &#123;        new Thread() &#123;            @Override            public void run() &#123;                System.out.println(&quot;继承Thread类并重写run方法&quot;);            &#125;        &#125;.start();        new Thread(new Runnable()&#123;            @Override            public void run() &#123;                System.out.println(&quot;实现Runnable接口并实现抽象方法&quot;);            &#125;        &#125; ).start();    &#125;&#125;\r\n1. 继承Thread类\r\npublic class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程执行中...&quot;);    &#125;        public static void main(String[] args) &#123;        MyThread thread = new MyThread();        thread.start(); // 启动线程    &#125;&#125;\r\n2.\r\n实现Runnable接口（Thread代理一个Runnable接口的实例对象,通过构造函数注入）\r\n线程要执行的任务封装在Runnable子类对象的run方法中。\r\npublic class MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;线程执行中...&quot;);    &#125;        public static void main(String[] args) &#123;        MyRunnable runnable = new MyRunnable();        Thread thread = new Thread(runnable);        thread.start();    &#125;&#125;\r\n3. 实现Callable接口\r\npackage com.luotao.demo;import java.util.concurrent.*;// 实现Callable接口class MyCallable implements Callable&lt;String&gt; &#123;    // 实现call方法，执行异步任务并返回结果    @Override    public String call() &#123;        return &quot;线程执行结果: &quot; + Thread.currentThread().getName();    &#125;&#125;class CallableExample &#123;    public static void main(String[] args) &#123;        // 创建一个单线程的ExecutorService实例        ExecutorService executor = Executors.newSingleThreadExecutor();        MyCallable callable = new MyCallable();        // 提交Callable任务给线程池执行，并获得Future对象        Future&lt;String&gt; future = executor.submit(callable);        try &#123;            // 通过Future对象获取线程执行结果            String result = future.get();            System.out.println(result);        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125; finally &#123;            // 关闭线程池，释放资源            executor.shutdown();        &#125;    &#125;&#125;\r\n4. 使用Lambda表达式（Java 8+）\r\npublic class LambdaThread &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;线程执行中...&quot;);        &#125;);        thread.start();    &#125;&#125;\r\n线程停止\r\npackage com.luotao.demo;class ThreadStopDemo implements Runnable&#123;    // 1.定义线程标志位终止变量，当flag=false时，线程终止    private boolean flag = true;    @Override    public void run() &#123;        int i=0;        while (flag)&#123;            System.out.println(&quot;Thread is running&quot; + i++);        &#125;        if (!flag)&#123;            System.out.println(&quot;Thread is stop&quot;);        &#125;    &#125;    // 2. 对外提供方法改变线程标志位    public void stopThread()&#123;        this.flag = false;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        ThreadStopDemo threadStopDemo = new ThreadStopDemo();        new Thread(threadStopDemo, &quot;线程1&quot;).start(); // 就绪状态        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(Thread.currentThread().getName() + &quot;执行中&quot;);            if (i == 5)&#123;                Thread.sleep(2000);                threadStopDemo.stopThread();            &#125;        &#125;    &#125;&#125;\r\n每一个对象都有锁，sleep不会释放锁\r\npackage com.luotao.demo;import java.text.SimpleDateFormat;import java.util.Date;class sleepDemo&#123;    public static void main(String[] args) throws InterruptedException &#123;        Date startTime = new Date(System.currentTimeMillis());        while (true)&#123;            Thread.sleep(1000);            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));             startTime = new Date(System.currentTimeMillis());        &#125;    &#125;&#125;\r\n线程礼让yield\r\n\r\n让正在执行的线程暂停（不阻塞），运行状态转为就绪状态\r\n让cpu重新调度，yield不一定成功，看抢占时间片\r\n\r\n线程合并Join\r\n待此线程执行完毕后再执行其他线程，其他线程阻塞。想象成插队。\r\npackage com.luotao.demo;class JoinDemo implements Runnable&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(&quot;插队中&quot;);        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        Thread threadVIP = new Thread(new JoinDemo(), &quot;VIP线程&quot;);        threadVIP.start();        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(Thread.currentThread().getName());            if(i==5)&#123;                threadVIP.join();            &#125;            System.out.println(Thread.currentThread().getName());        &#125;    &#125;&#125;\r\n线程的优先级\r\nJava中的线程调度方式是抢占式调度模型，系，优先级高的线程更容易获得CPU的时间片，若优先级相同则会随机选择一个。默认优先级值NORM_PRIORITY=5\r\n优先级低只是意味着获得调度的概率低\r\npublic class ThreadPriority &#123;    public static void main(String[] args) &#123;        Thread thread1 = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 5; i++) &#123;                System.out.println(&quot;高优先级线程: &quot; + i);            &#125;        &#125;);        thread1.setPriority(Thread.MAX_PRIORITY); // 设置最高优先级10                Thread thread2 = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 5; i++) &#123;                System.out.println(&quot;低优先级线程: &quot; + i);            &#125;        &#125;);        thread2.setPriority(Thread.MIN_PRIORITY); // 设置最低优先级1                thread1.start();        thread2.start();    &#125;&#125;\r\n守护线程\r\n守护线程会随着主线程的结束而结束。\r\n当运行的线程都是守护线程时，JVM结束运行。JVM不用等待守护线程执行完毕。后台记录操作日志，可以使用守护线程。\r\npublic class DaemonThread &#123;    public static void main(String[] args) &#123;        Thread daemonThread = new Thread(() -&gt; &#123;            while (true) &#123;                System.out.println(&quot;守护线程正在运行...&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);        daemonThread.setDaemon(true); // 设置为守护线程        daemonThread.start();                // 主线程休眠5秒后结束        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;主线程结束，守护线程也会结束&quot;);    &#125;&#125;\r\n第二部分：线程同步与锁机制\r\n线程安全问题\r\n想象一个银行账户，如果多个线程同时对这个账户进行存取款操作，可能会导致数据不一致。这就是线程安全问题。\r\npackage com.luotao.demo;import java.util.ArrayList;import java.util.concurrent.CopyOnWriteArrayList;class BankAccount &#123;    private int balance = 1000; // 余额     private String name=&quot;结婚基金&quot;;    // 不安全的取款方法    public void withdraw(int amount) &#123;        if (balance &gt;= amount) &#123;            try &#123;                Thread.sleep(100); // 模拟处理时间                balance -= amount;                System.out.println(&quot;取款成功，余额：&quot; + balance);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        BankAccount account = new BankAccount();        // 创建多个线程同时取款        for (int i = 0; i &lt; 5; i++) &#123;            new Thread(() -&gt; &#123;                account.withdraw(100);            &#125;).start();        &#125;        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();// ArrayList是线程不安全的集合        CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;();//JUC安全类型的集合        Thread[] threads = new Thread[10];        for (int i = 0; i &lt; 10; i++) &#123;            threads[i] = new Thread(()-&gt;&#123;                try &#123;                    Thread.sleep(2000);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;//                synchronized (arrayList)&#123;                    arrayList.add(Thread.currentThread().getName());//                &#125;                copyOnWriteArrayList.add(Thread.currentThread().getName());            &#125;);            threads[i].start();//            threads[i].join(); // 不能写在这里，否则会导致线程串行执行，避免了并发问题        &#125;        // 等待所有子线程完成操作后，才打印集合的大小。        for (int i = 0; i &lt; 10; i++) &#123;            threads[i].join();        &#125;        System.out.println(arrayList.size());// !=10        System.out.println(copyOnWriteArrayList.size());// =10    &#125;&#125;\r\nsynchronized关键字\r\nsynchronized方法都必须获得调用该方法的对象的锁才能执行，否则会阻塞，一旦执行就独占该锁，直到方法返回才释放锁，后面被阻塞的线程才能获得锁继续执行。对于需要增删改的对象加锁。\r\npublic class SafeBankAccount &#123;    private int balance = 1000;        // 使用synchronized关键字保护方法    public synchronized void withdraw(int amount) &#123;        if (balance &gt;= amount) &#123;            try &#123;                Thread.sleep(100);                balance -= amount;                System.out.println(&quot;取款成功，余额：&quot; + balance);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;        // 使用synchronized代码块    public void deposit(int amount) &#123;        synchronized (this) &#123;            try &#123;                Thread.sleep(100);                balance += amount;                System.out.println(&quot;存款成功，余额：&quot; + balance);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\r\nvolatile关键字\r\nvolatile就像餐厅的公告板，当一个服务员更新了公告板的内容，其他服务员都能立即看到最新的信息。\r\npublic class VolatileExample &#123;    private volatile boolean flag = false;        public void setFlag() &#123;        flag = true;    &#125;        public void doWork() &#123;        while (!flag) &#123;            // 执行任务        &#125;    &#125;&#125;\r\n原子类\r\n原子类就像自动售货机，它的操作是不可分割的，要么全部成功，要么全部失败。\r\nimport java.util.concurrent.atomic.AtomicInteger;public class AtomicExample &#123;    private AtomicInteger count = new AtomicInteger(0);        public void increment() &#123;        count.incrementAndGet();    &#125;        public int getCount() &#123;        return count.get();    &#125;&#125;\r\nLock接口\r\nLock接口提供了比synchronized更灵活的锁机制，就像银行的自助取款机，可以设置超时时间。\r\n想象一个房间门上的锁，只有持有钥匙（锁对象）的人才能进入，并且如果同一个人再次进入，不需要重新获取钥匙。\r\n锁的定义：ReentrantLock 需要显式创建锁对象，而 synchronized\r\n是隐式的。 锁的获取与释放：ReentrantLock 需要手动调用 lock() 和\r\nunlock()，而 synchronized 自动管理。 功能扩展：ReentrantLock\r\n提供更多功能，如尝试加锁（tryLock()）、设置超时等。\r\npackage com.luotao.job.utils.demo;import java.util.ArrayList;import java.util.Collections;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;// 摇号系统class CarLottery implements Runnable &#123;    private ArrayList&lt;String&gt; serialNumber;// 申请编码池    private int count;// 本期指标数    private final Lock lock = new ReentrantLock();    public CarLottery(ArrayList&lt;String&gt; serialNumber, int count) &#123;        this.serialNumber = serialNumber;        this.count = count;    &#125;    @Override    public void run() &#123;        while (true) &#123;            // 尝试获取锁，最多等待1秒            try &#123;                if (lock.tryLock(1, TimeUnit.SECONDS)) &#123;                    try &#123;                        if (count == 0) &#123;                            break;                        &#125; else &#123;                            Collections.shuffle(serialNumber);// 随机打乱元素顺序                            String selectNumber = serialNumber.remove(0);                            System.out.println(Thread.currentThread().getName() + &quot;抽中&quot; + selectNumber);                            count--;                            try &#123;                                Thread.sleep(200);                            &#125; catch (InterruptedException e) &#123;                                throw new RuntimeException(e);                            &#125;                        &#125;                    &#125; finally &#123;                        // 确保锁被释放                        lock.unlock();                    &#125;                &#125;            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;class App &#123;    public static void main(String[] args) &#123;        ArrayList&lt;String&gt; serialNumber = new ArrayList&lt;&gt;();        // 将编码批量放入集合中        Collections.addAll(serialNumber,                &quot;A001&quot;, &quot;A002&quot;, &quot;A003&quot;, &quot;A004&quot;, &quot;A005&quot;, &quot;A006&quot;, &quot;A007&quot;, &quot;A008&quot;, &quot;A009&quot;, &quot;A010&quot;);        CarLottery carLottery = new CarLottery(serialNumber, 5);        Thread thread1 = new Thread(carLottery);        Thread thread2 = new Thread(carLottery);        thread1.start();        thread2.start();    &#125;&#125;\r\n死锁\r\n\r\n\r\nimage-20250315142643570\r\n\r\npackage com.luotao.job.utils.demo;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class DeadLockDemo &#123;    Object lock1 = new Object();    Object lock2 = new Object();    // 从左侧进入库房的线程类    public class ThreadLeft extends Thread &#123;        @Override        public void run() &#123;            synchronized (lock1) &#123;                System.out.println(&quot;线程Left获得了lock1&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;线程Left尝试获取lock2&quot;);                synchronized (lock2) &#123;                    System.out.println(&quot;线程Left获得了lock2&quot;);                    try &#123;                        Thread.sleep(1000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;            System.out.println(&quot;线程Left执行完毕&quot;);        &#125;    &#125;    // 从右侧侧进入库房的线程类    public class ThreadRight extends Thread &#123;        @Override        public void run() &#123;            synchronized (lock2) &#123;                System.out.println(&quot;线程Right获得了lock2&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;线程Right尝试获取lock1&quot;);                synchronized (lock1) &#123;                    System.out.println(&quot;线程Right获得了lock1&quot;);                    try &#123;                        Thread.sleep(1000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                System.out.println(&quot;线程Right执行完毕&quot;);            &#125;        &#125;    &#125;    // 从右侧侧进入库房的线程类:统一锁获取顺序避免死锁    public class ThreadRight2 extends Thread &#123;        @Override        public void run() &#123;            synchronized (lock1) &#123;                System.out.println(&quot;线程Right获得了lock1&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;线程Right尝试获取lock2&quot;);                synchronized (lock2) &#123;                    System.out.println(&quot;线程Right获得了lock2&quot;);                    try &#123;                        Thread.sleep(1000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                System.out.println(&quot;线程Right执行完毕&quot;);            &#125;        &#125;    &#125;    // 从右侧侧进入库房的线程类:使用ReentrantLock避免死锁    public class ThreadRightLock extends Thread &#123;        @Override        public void run() &#123;            Lock lockA = new ReentrantLock();            Lock lockB = new ReentrantLock();            boolean getLockA = false;            boolean getLockB = false;            try &#123;                // 尝试获取第一把锁，最多等待2秒                getLockA = lockB.tryLock(2, TimeUnit.SECONDS);                if (getLockA) &#123;                    System.out.println(&quot;线程RightLock获得了lockB&quot;);                    // 尝试获取第二把锁，最多等待2秒                    getLockB = lockA.tryLock(2, TimeUnit.SECONDS);                    if (getLockB) &#123;                        System.out.println(&quot;线程RightLock获得了lockA&quot;);                        // 使用两把锁执行业务逻辑                        System.out.println(&quot;线程RightLock成功获取两把锁，执行业务逻辑&quot;);                        try &#123;                            Thread.sleep(1000);                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125; else &#123;                        // 获取第二把锁失败，放弃任务                        System.out.println(&quot;线程RightLock获取lockA超时，放弃任务&quot;);                    &#125;                &#125; else &#123;                    // 获取第一把锁失败，放弃任务                    System.out.println(&quot;线程RightLock获取lockB超时，放弃任务&quot;);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                // 释放已获得的锁                if (getLockB) &#123;                    lockA.unlock();                    System.out.println(&quot;线程RightLock释放了lockA&quot;);                &#125;                if (getLockA) &#123;                    lockB.unlock();                    System.out.println(&quot;线程RightLock释放了lockB&quot;);                &#125;            &#125;            System.out.println(&quot;线程RightLock执行完毕&quot;);        &#125;    &#125;&#125;class App &#123;    public static void main(String[] args) &#123;        DeadLockDemo deadLockDemo = new DeadLockDemo();        DeadLockDemo.ThreadLeft threadLeft = deadLockDemo.new ThreadLeft();        DeadLockDemo.ThreadRight threadRight = deadLockDemo.new ThreadRight();        DeadLockDemo.ThreadRight2 threadRight2 = deadLockDemo.new ThreadRight2();        DeadLockDemo.ThreadRightLock threadRight3 = deadLockDemo.new ThreadRightLock();        threadLeft.start();//        threadRight.start();//        threadRight2.start();        threadRight3.start();    &#125;&#125;\r\n避免死锁的方法\r\n死锁是指两个或多个线程互相等待对方持有的锁，导致这些线程永远处于阻塞状态。避免死锁的方法包括：按固定顺序获取锁、使用tryLock()方法、设置锁超时、使用线程池和并发工具类等。\r\n死锁的四个必要条件是：互斥条件、请求与保持条件、不剥夺条件和循环等待条件。只要破坏其中一个条件，就能避免死锁。\r\n1. 统一锁获取顺序\r\n相同的锁获取顺序：先lock1，再lock2。这样可以避免循环等待条件，从而避免死锁。\r\n2. 使用可重入锁ReentrantLock\r\npackage com.luotao.demo;import java.util.concurrent.locks.ReentrantLock; class ReentrantLockExample &#123;    private final ReentrantLock lock = new ReentrantLock();     /**      ReentrantLock 被称为可重入锁，是因为它支持同一线程对锁的多次获取而不会发生死锁。具体来说：      锁的重入性      当一个线程已经持有了某个锁时，它可以再次获取该锁而不被阻塞。      每次获取锁时，ReentrantLock 会维护一个持有计数器（Hold Count），记录当前线程获取锁的次数。      每次释放锁时，计数器减一，只有当计数器为零时，锁才会真正被释放。*/    public void outerMethod() &#123;        lock.lock();        try &#123;            System.out.println(&quot;Outer method acquired the lock.&quot;);            innerMethod(); // 再次获取锁        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void innerMethod() &#123;        lock.lock();        try &#123;            System.out.println(&quot;Inner method acquired the lock.&quot;);        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        ReentrantLockExample example = new ReentrantLockExample();        example.outerMethod(); // 不会发生死锁    &#125;&#125;\r\npackage com.luotao.demo;import java.util.concurrent.locks.ReentrantLock;class SafeBuyTicket &#123;    public static void main(String[] args) &#123;        BuyTicket station = new BuyTicket();        new Thread(station, &quot;线程1&quot;).start();        new Thread(station, &quot;线程2&quot;).start();        new Thread(station, &quot;线程3&quot;).start();    &#125;&#125;class BuyTicket implements Runnable &#123;    private int ticketNums = 10;    private volatile boolean flag = true; // 线程停止标志位，使用 volatile 确保可见性    private final ReentrantLock lock = new ReentrantLock();    @Override    public void run() &#123;        while (flag) &#123;            lock.lock(); // 正确获取锁            try &#123;                if (!buy()) &#123;                    break; // 如果票已售完，退出循环                &#125;            &#125; finally &#123;                lock.unlock(); // 确保锁总是被释放            &#125;        &#125;    &#125;    private boolean buy() &#123;        if (ticketNums &lt;= 0) &#123;            flag = false; // 设置停止标志            return false; // 表示票已售完        &#125;        // 模拟延时放大问题的发生性        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            Thread.currentThread().interrupt(); // 恢复中断状态            System.out.println(Thread.currentThread().getName() + &quot; 被中断&quot;);            return false; // 中断后退出买票逻辑        &#125;        System.out.println(Thread.currentThread().getName() + &quot;拿到&quot; + ticketNums--);        return true;    &#125;&#125;\r\nsynchronized和ReentrantLock在处理死锁方面有什么区别？\r\nReentrantLock提供了更多避免死锁的机制，如tryLock()方法（支持超时）、可中断的锁获取、公平锁选项等，而synchronized只提供了基本的互斥功能。\r\n线程协作—生产者消费者模型\r\npackage com.luotao.demo;// 生产者消费者模型// 生产者class Producer extends Thread&#123;    private Container container;    public Producer(Container container)&#123;        this.container=container;    &#125;    // 生产10只鸡    @Override    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            container.push(new Chicken(i));            System.out.println(&quot;生产了&quot; + (i+1) + &quot;只鸡&quot;);        &#125;    &#125;&#125;// 消费者class Customer extends Thread&#123;    private Container container;    public Customer(Container container)&#123;        this.container=container;    &#125;    // 消费10只鸡    @Override    public void run() &#123;        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        for (int i = 0; i &lt; 10; i++) &#123;            container.pop();            System.out.println(&quot;消费了&quot; + (i+1)  + &quot;只鸡&quot;);        &#125;    &#125;&#125;// 产品class Chicken &#123;    private Integer id;    public Chicken(Integer id) &#123;        this.id = id;    &#125;&#125;// 缓冲区容器class Container &#123;    Chicken[] chickens = new Chicken[10];// 容器大小    int count = 0;    // 生产者丢产品    public synchronized void push(Chicken chicken) &#123;        // 容器满则等待        if (count == chickens.length) &#123;            try &#123;                this.wait();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        // 容器没满则丢入产品        chickens[count] = chicken;        count++;        // 可以通知消费者了        this.notifyAll();    &#125;    // 消费者消费    public synchronized Chicken pop() &#123;        //没产品了则等待        if (count == 0) &#123;            try &#123;                this.wait();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        // 有产品则消费        count--;        // 吃一个就通知生产        this.notifyAll();        return chickens[count]; // 返回吃的产品    &#125;&#125;class PCDemo &#123;    public static void main(String[] args) &#123;        Container container = new Container();        new Producer(container).start();        new Customer(container).start();    &#125;&#125;\r\n第三部分：线程池\r\n线程池的好吃是减少在创建和销毁线程上所消耗的时间和资源开销，解决资源不足。\r\n线程池不能用Executor执行器去创建，因为它返回的线程池对象允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。\r\n\r\n工作中应该通过new ThreadPoolExecutor来自定义创建，自己指定参数\r\n临时线程+核销线程数量超过最大线程数后会触发拒绝策略\r\n\r\n线程池的工作原理\r\nimport java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolExample &#123;    public static void main(String[] args) &#123;        // 创建固定大小的线程池        ExecutorService executor = Executors.newFixedThreadPool(3);                // 提交任务        for (int i = 0; i &lt; 5; i++) &#123;            final int taskId = i;            executor.submit(() -&gt; &#123;                System.out.println(&quot;任务&quot; + taskId + &quot;正在执行&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;                // 关闭线程池        executor.shutdown();    &#125;&#125;\r\n线程池的创建方式\r\nimport java.util.concurrent.*;public class ThreadPoolCreation &#123;    public static void main(String[] args) &#123;        // 1. 固定大小的线程池        ExecutorService fixedPool = Executors.newFixedThreadPool(3);                // 2. 单线程池        ExecutorService singlePool = Executors.newSingleThreadExecutor();                // 3. 可缓存的线程池        ExecutorService cachedPool = Executors.newCachedThreadPool();                // 4. 定时执行的线程池        ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(3);                // 5. 自定义线程池        ThreadPoolExecutor customPool = new ThreadPoolExecutor(            2,                      // 核心线程数            5,                      // 最大线程数            60L,                    // 空闲线程存活时间            TimeUnit.SECONDS,       // 时间单位            new LinkedBlockingQueue&lt;&gt;(10),  // 工作队列            new ThreadFactory() &#123;   // 线程工厂                @Override                public Thread newThread(Runnable r) &#123;                    Thread t = new Thread(r);                    t.setName(&quot;CustomThread-&quot; + t.getId());                    return t;                &#125;            &#125;,            new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略        );    &#125;&#125;\r\n线程池的拒绝策略\r\npublic class RejectionPolicyExample &#123;    public static void main(String[] args) &#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(            2, 2, 0L, TimeUnit.MILLISECONDS,            new LinkedBlockingQueue&lt;&gt;(2),            new ThreadPoolExecutor.CallerRunsPolicy()  // 使用调用者运行策略        );                // 提交多个任务        for (int i = 0; i &lt; 5; i++) &#123;            final int taskId = i;            executor.submit(() -&gt; &#123;                System.out.println(&quot;任务&quot; + taskId + &quot;正在执行&quot;);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;                executor.shutdown();    &#125;&#125;\r\n第四部分：并发工具类\r\nCountDownLatch\r\nCountDownLatch就像运动会的起跑线，所有运动员都准备好后，才能开始比赛。\r\nimport java.util.concurrent.CountDownLatch;public class CountDownLatchExample &#123;    public static void main(String[] args) &#123;        CountDownLatch latch = new CountDownLatch(3);                // 创建三个线程        for (int i = 0; i &lt; 3; i++) &#123;            new Thread(() -&gt; &#123;                try &#123;                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;准备就绪&quot;);                    Thread.sleep(1000);                    latch.countDown(); // 计数减1                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;).start();        &#125;                try &#123;            latch.await(); // 等待所有线程准备就绪            System.out.println(&quot;所有线程准备就绪，开始执行！&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\nCyclicBarrier\r\nCyclicBarrier就像朋友约好一起出发，所有人都到达集合地点后，才能一起出发。\r\nimport java.util.concurrent.CyclicBarrier;public class CyclicBarrierExample &#123;    public static void main(String[] args) &#123;        CyclicBarrier barrier = new CyclicBarrier(3, () -&gt; &#123;            System.out.println(&quot;所有线程都到达集合点，开始下一轮！&quot;);        &#125;);                // 创建三个线程        for (int i = 0; i &lt; 3; i++) &#123;            new Thread(() -&gt; &#123;                try &#123;                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;到达集合点&quot;);                    barrier.await(); // 等待其他线程                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;).start();        &#125;    &#125;&#125;\r\nSemaphore\r\nSemaphore就像停车场的车位，只有有限数量的车位，当车位满了，其他车需要等待。\r\nimport java.util.concurrent.Semaphore;public class SemaphoreExample &#123;    public static void main(String[] args) &#123;        Semaphore semaphore = new Semaphore(3); // 3个车位                // 创建5辆车        for (int i = 0; i &lt; 5; i++) &#123;            new Thread(() -&gt; &#123;                try &#123;                    semaphore.acquire(); // 获取车位                    System.out.println(&quot;车辆&quot; + Thread.currentThread().getName() + &quot;停车&quot;);                    Thread.sleep(2000); // 停车2秒                    semaphore.release(); // 释放车位                    System.out.println(&quot;车辆&quot; + Thread.currentThread().getName() + &quot;离开&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;).start();        &#125;    &#125;&#125;\r\nExchanger\r\nExchanger就像两个朋友交换礼物，必须双方都准备好礼物才能交换。\r\nimport java.util.concurrent.Exchanger;public class ExchangerExample &#123;    public static void main(String[] args) &#123;        Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();                // 第一个线程        new Thread(() -&gt; &#123;            try &#123;                String gift = &quot;苹果&quot;;                System.out.println(&quot;线程1准备交换礼物：&quot; + gift);                String received = exchanger.exchange(gift);                System.out.println(&quot;线程1收到礼物：&quot; + received);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();                // 第二个线程        new Thread(() -&gt; &#123;            try &#123;                String gift = &quot;香蕉&quot;;                System.out.println(&quot;线程2准备交换礼物：&quot; + gift);                String received = exchanger.exchange(gift);                System.out.println(&quot;线程2收到礼物：&quot; + received);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\r\n第五部分：Java IO基础\r\n文件操作\r\nFile 类\r\njava.io.File\r\n类用于表示文件和目录的信息，但不能直接读写文件内容。\r\npackage com.luotao.job.utils.demo;import java.io.File;import java.io.IOException;class FileDemo&#123;    public static void main(String[] args) &#123;        FileOperatDemo();    &#125;    /**    * @Description: 操作文件的常用方法    **/    static void FileOperatDemo()  &#123;        File directory_root = new File(&quot;Study&quot;);        // 创建File对象：目录或文件对象//        File file = new File(&quot;./Study/README.MD&quot;);        File file = new File(directory_root,&quot;README.MD&quot;);        try &#123;            directory_root.mkdir();// 创建目录//            file.mkdirs(); // 创建目录,包括不存在的上级目录            boolean exists = file.exists();          // 判断文件是否存在            boolean created = file.createNewFile();  // 文件不存在时创建新文件        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;        // 常用方法        System.out.println(file.getAbsoluteFile()); // 获取文件的绝对路径        System.out.println(file.getPath()); // 获取路径名字符串        System.out.println(file.getName()); // 获取文件或目录的名称        System.out.println(file.length()); // 获取文件的长度//        file.delete();// 删除文件或目录//        file.isFile();// 判断是否为文件//        file.isDirectory();// 判断是否为目录        String[] fileList = file.list();         // 获取目录下的文件列表        File[] files = file.listFiles();         // 获取目录下的文件对象数组    &#125;&#125;\r\nIO 基础概念\r\n\r\n\r\nimage-20250315160926669\r\n\r\nJava IO 的核心概念\r\n\r\n流（Stream）：是一个抽象的概念，代表了数据的流动。就像水流一样，数据从一个地方流到另一个地方。\r\n字节（Byte）与字符（Character）：\r\n\r\n字节是计算机存储的基本单位（1字节=8位）\r\n字符是人类可读的符号（在Java中，一个字符通常占用2个字节，使用UTF-16编码）\r\n\r\n阻塞与非阻塞：\r\n\r\n传统IO是阻塞式的，就像排队取水，一个人取完才能轮到下一个\r\nNIO提供了非阻塞式IO，就像多个水龙头同时供水\r\n\r\n\r\n字节流与字符流\r\nJava IO 流主要分为两大类：字节流和字符流。\r\n字节流\r\n字节流适合处理二进制文件（如图片、音频、视频等非文本文件）。\r\n基本类： -\r\nInputStream：所有字节输入流的抽象基类 -\r\nOutputStream：所有字节输出流的抽象基类\r\n常用实现类： -\r\nFileInputStream/FileOutputStream：文件字节流 -\r\nByteArrayInputStream/ByteArrayOutputStream：字节数组流\r\n-\r\nDataInputStream/DataOutputStream：处理基本数据类型\r\n-\r\nObjectInputStream/ObjectOutputStream：对象序列化流\r\n字符流\r\n字符流处理字符数据，适合处理文本文件，如配置文件。字符流内部使用字节流，但会自动进行字符编码和解码。\r\n字符输入流（Reader抽象类）\r\n\r\n\r\n\r\n方法名\r\n返回值\r\n描述\r\n\r\n\r\n\r\n\r\nread()\r\n读完返回-1\r\n从输入流读一个字符\r\n\r\n\r\nread(char[] cbuf)\r\n读完返回-1\r\n读字符到字符数组中\r\n\r\n\r\nclose()\r\nvoid\r\n关闭输入流，释放系统资源\r\n\r\n\r\n\r\n常用实现类：\r\n\r\nFileReader/FileWriter：文件字符流\r\nInputStreamReader/OutputStreamWriter：字节流转字符流的桥梁\r\nBufferedReader/BufferedWriter：带缓冲的字符流\r\nStringReader/StringWriter：字符串流\r\n\r\n字符输入流（FileReader和BufferedReader）\r\n\r\n创建FileReader对象——&gt;read()读——&gt;-1——&gt;关闭流对象（判空）\r\n创建BufferedReader对象——&gt;readLine——&gt;null——&gt;关闭流对象（判空）\r\n\r\npackage com.luotao.job.utils.demo;import java.io.*;import java.util.ArrayList;import java.util.Iterator;class DataRead &#123;    private String fileName;    private FileReader fileReader;    private BufferedReader bufferedReader;    public DataRead(String fileName) &#123;        this.fileName = fileName;    &#125;    public DataRead(FileReader fileReader) &#123;        this.fileReader = fileReader;    &#125;    public DataRead(BufferedReader bufferedReader) &#123;        this.bufferedReader = bufferedReader;    &#125;    /**     * @Description: 字符输入流     **/    public ArrayList&lt;String&gt; read() &#123;        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();// 保存读到的每行        FileReader fileReader = null;        BufferedReader bufferedReader=null;        try &#123;            fileReader = new FileReader(fileName); // 创建输入流对象            while (true) &#123;                // 输入流对象按单个字符读取，返回-1表示读取完毕                int ch = fileReader.read();                if (ch == -1) &#123;                    break;                &#125;                System.out.println((char) ch);            &#125;        &#125; catch (FileNotFoundException e) &#123;            System.out.println(e.getMessage());        &#125; catch (IOException e) &#123;            System.out.println(e.getMessage());        &#125; finally &#123;            try &#123;                if (fileReader != null ) &#123;                    // 先要判空，不然会空指针                    fileReader.close();                &#125;            &#125; catch (IOException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        return arrayList;    &#125;    /**     * @Description: 字符输入流     **/    public ArrayList&lt;String&gt; readByBuf() &#123;        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();// 保存读到的每行        FileReader fileReader = null;        BufferedReader bufferedReader=null;        try &#123;            fileReader = new FileReader(fileName); // 创建输入流对象            bufferedReader = new BufferedReader(fileReader);// 通过输入流对象创建缓冲流对象            while (true) &#123;                // 缓冲流对象按行读取,返回null表示读取完毕                String str = bufferedReader.readLine();                if (str == null) &#123;                    break;                &#125;                if (!str.isEmpty())&#123;                    arrayList.add(str.trim());                &#125;            &#125;        &#125; catch (FileNotFoundException e) &#123;            System.out.println(e.getMessage());        &#125; catch (IOException e) &#123;            System.out.println(e.getMessage());        &#125; finally &#123;            try &#123;                if (fileReader != null &amp;&amp; bufferedReader != null) &#123;                    // 先要判空，不然会空指针                    fileReader.close();                    bufferedReader.close();                &#125;            &#125; catch (IOException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        return arrayList;    &#125;&#125;class App&#123;    public static void main(String[] args) &#123;        DataRead dataRead = new DataRead(&quot;D:\\\\workspace\\\\job\\\\Study\\\\README.MD&quot;);//        ArrayList&lt;String&gt; arrayList = dataRead.read();        ArrayList&lt;String&gt; arrayList = dataRead.readByBuf();        Iterator&lt;String&gt; iterator = arrayList.iterator();        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;\r\n字符输出流（Writer抽象类）\r\n\r\n\r\n\r\n方法名\r\n描述\r\n\r\n\r\n\r\n\r\nwrite()\r\n写入单个字符、字符数组、字符串到内存中\r\n\r\n\r\nflush()\r\n刷新缓冲区，即将数据从内存写到文件中\r\n\r\n\r\nclose()\r\n关闭输出流\r\n\r\n\r\n\r\n字符输出流（FileWriter和BufferedWriter）\r\n\r\n创建目标目录对象\r\n创建目标文件对象\r\n通过目标文件对象构造输出流对象\r\n通过FIleWriter或Buffered输出流对象write到内存\r\nflush刷新内存缓冲区，从内存写到文件\r\n关闭输出流\r\n\r\npackage com.luotao.job.utils.demo;import java.io.*;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;class DataWrite &#123;    private FileWriter fileWriter;    private BufferedWriter bufferedWriter;    public DataWrite(FileWriter fileWriter) &#123;        this.fileWriter = fileWriter;    &#125;    public DataWrite(BufferedWriter bufferedWriter) &#123;        this.bufferedWriter = bufferedWriter;    &#125;    // 字符输出流    public boolean write(String content) &#123;        try &#123;            fileWriter.write(content); // 4.写到内存            return true;        &#125; catch (IOException e) &#123;            System.out.println(e.getMessage());        &#125;        return false;    &#125;    // 字符缓冲输出流    public boolean writeByBuf(String content) &#123;        try &#123;            bufferedWriter.write(content);            bufferedWriter.newLine(); // 换行            return true;        &#125; catch (IOException e) &#123;            System.out.println(e.getMessage());        &#125;        return false;    &#125;&#125;class App &#123;    /**     * @Description 生成文件名：当前日期.md     **/    static String createFilename()&#123;        LocalDateTime now = LocalDateTime.now(); // 当前日期时间对象        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);// 指定日期格式        String dateString = now.format(dateTimeFormatter);        return dateString + &quot;.md&quot;;    &#125;    public static void main(String[] args) &#123;        String pathName = &quot;D:\\\\workspace\\\\job\\\\Study&quot;; //目标目录        String fileName = createFilename(); // 目标文件名称        File directory = new File(pathName);// 1.创建目标目录对象        if (!directory.exists()) &#123;            directory.mkdirs();// 创建目录,包括不存在的上级目录        &#125;        File file = new File(directory, fileName); // 2.创建目标文件对象        FileWriter fileWriter = null;        BufferedWriter bufferedWriter=null;        try &#123;            fileWriter = new FileWriter(file, true); // 3.通过目标文件对象构造输出流对象            bufferedWriter = new BufferedWriter(fileWriter);//            DataWrite dataWrite = new DataWrite(fileWriter);//            System.out.println(dataWrite.write(&quot;DataWrite&quot;));            DataWrite DataWriteByBuf = new DataWrite(bufferedWriter);            System.out.println(DataWriteByBuf.writeByBuf(&quot;DataWriteByBuf&quot;));        &#125; catch (IOException e) &#123;            System.out.println(e.getMessage());        &#125; finally &#123;            try &#123;                // 5.刷新内存缓冲区，从内存写到文件                if ((fileWriter != null &amp;&amp; bufferedWriter != null) || (bufferedWriter !=null) ) &#123;                    bufferedWriter.flush();                    fileWriter.close();                    bufferedWriter.close();                &#125;else if (fileWriter != null)&#123;                    fileWriter.flush();                    fileWriter.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\r\n对象序列化\r\n序列化是将对象转换为字节序列的过程，反序列化则是将字节序列恢复为对象的过程。就像把一个立体物品压扁后通过邮件发送，收件人再将其还原成原来的形状。\r\n实现序列化\r\n\r\n类必须实现 java.io.Serializable 接口\r\n使用 ObjectOutputStream 写入对象\r\n使用 ObjectInputStream 读取对象\r\n\r\n// 定义可序列化的类class Person implements Serializable &#123;    private static final long serialVersionUID = 1L; // 序列化版本号    private String name;    private int age;        // 构造方法、getter和setter省略&#125;// 序列化对象try (ObjectOutputStream oos = new ObjectOutputStream(        new FileOutputStream(&quot;person.dat&quot;))) &#123;    Person person = new Person(&quot;张三&quot;, 25);    oos.writeObject(person);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;// 反序列化对象try (ObjectInputStream ois = new ObjectInputStream(        new FileInputStream(&quot;person.dat&quot;))) &#123;    Person person = (Person) ois.readObject();    System.out.println(person.getName() + &quot;, &quot; + person.getAge());&#125; catch (IOException | ClassNotFoundException e) &#123;    e.printStackTrace();&#125;\r\n注意事项\r\n\r\ntransient 关键字：标记不需要序列化的字段\r\nstatic 字段不会被序列化\r\n序列化版本号 serialVersionUID 用于版本控制\r\n\r\nNIO 基础\r\nNIO (New IO) 是 Java 1.4 引入的 IO API，提供了比传统 IO\r\n更高效的实现。\r\nNIO 的核心组件\r\n\r\nBuffer（缓冲区）：数据的临时存储区域\r\nChannel（通道）：数据传输的通道，类似于流但可以双向传输\r\nSelector（选择器）：用于监控多个通道的IO状态\r\n\r\n基本用法示例\r\n// 使用NIO读取文件try &#123;    RandomAccessFile file = new RandomAccessFile(&quot;nio_test.txt&quot;, &quot;r&quot;);    FileChannel channel = file.getChannel();        // 创建缓冲区    ByteBuffer buffer = ByteBuffer.allocate(1024);        // 读取数据到缓冲区    int bytesRead = channel.read(buffer);    while (bytesRead != -1) &#123;        // 切换到读模式        buffer.flip();                // 读取缓冲区数据        while (buffer.hasRemaining()) &#123;            System.out.print((char) buffer.get());        &#125;                // 清空缓冲区，准备下一次读取        buffer.clear();        bytesRead = channel.read(buffer);    &#125;        file.close();&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\r\n常见应用场景\r\n1. 文件复制\r\npublic static void copyFile(String source, String target) throws IOException &#123;    try (FileInputStream fis = new FileInputStream(source);         FileOutputStream fos = new FileOutputStream(target);         BufferedInputStream bis = new BufferedInputStream(fis);         BufferedOutputStream bos = new BufferedOutputStream(fos)) &#123;                byte[] buffer = new byte[8192]; // 8KB缓冲区        int bytesRead;        while ((bytesRead = bis.read(buffer)) != -1) &#123;            bos.write(buffer, 0, bytesRead);        &#125;    &#125;&#125;\r\n2. 读取配置文件\r\npublic static Properties loadProperties(String filename) throws IOException &#123;    Properties props = new Properties();    try (InputStream input = new FileInputStream(filename)) &#123;        props.load(input);    &#125;    return props;&#125;\r\n3. 网络通信\r\n// 客户端发送数据try (Socket socket = new Socket(&quot;localhost&quot;, 8080);     OutputStream out = socket.getOutputStream();     PrintWriter writer = new PrintWriter(out, true)) &#123;        writer.println(&quot;Hello, Server!&quot;);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;// 服务端接收数据try (ServerSocket serverSocket = new ServerSocket(8080);     Socket clientSocket = serverSocket.accept();     BufferedReader reader = new BufferedReader(             new InputStreamReader(clientSocket.getInputStream()))) &#123;        String line = reader.readLine();    System.out.println(&quot;收到客户端消息: &quot; + line);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\r\n最佳实践\r\n\r\n始终使用 try-with-resources\r\n语句：自动关闭资源，避免资源泄漏 try (InputStream in = new FileInputStream(&quot;file.txt&quot;)) &#123;    // 使用输入流&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\r\n使用缓冲流提高性能：无论是字节流还是字符流，都应该使用对应的缓冲流包装\r\n选择合适的缓冲区大小：通常 8KB (8192字节)\r\n是一个不错的选择\r\n字符流处理文本时指定正确的字符编码：\r\nReader reader = new InputStreamReader(new FileInputStream(&quot;file.txt&quot;), &quot;UTF-8&quot;);\r\n使用 Scanner 简化文本输入处理：\r\ntry (Scanner scanner = new Scanner(new File(&quot;data.txt&quot;))) &#123;    while (scanner.hasNextLine()) &#123;        String line = scanner.nextLine();        // 处理每一行    &#125;&#125;\r\n处理大文件时使用 NIO 的内存映射文件：\r\ntry (RandomAccessFile file = new RandomAccessFile(&quot;bigfile.dat&quot;, &quot;r&quot;);     FileChannel channel = file.getChannel()) &#123;        MappedByteBuffer buffer = channel.map(        FileChannel.MapMode.READ_ONLY, 0, channel.size());        // 直接操作buffer&#125;\r\n\r\n常见面试题\r\n1. Java IO 与 NIO 的区别？\r\n\r\n\r\n\r\n特性\r\nIO\r\nNIO\r\n\r\n\r\n\r\n\r\n数据处理方式\r\n面向流\r\n面向缓冲区\r\n\r\n\r\n处理方式\r\n阻塞IO\r\n支持非阻塞IO\r\n\r\n\r\n选择器\r\n无\r\n有（可监控多个通道）\r\n\r\n\r\n适用场景\r\n连接数少，数据量大\r\n连接数多，数据量少\r\n\r\n\r\n\r\n2. 字节流和字符流的区别？\r\n\r\n字节流直接操作字节，适合处理二进制文件\r\n字符流操作字符，内部进行编码转换，适合处理文本文件\r\n字符流 = 字节流 + 编码/解码\r\n\r\n3. 什么是序列化和反序列化？\r\n\r\n序列化：将对象转换为字节序列的过程\r\n反序列化：将字节序列恢复为对象的过程\r\n用途：对象持久化、网络传输\r\n\r\n4. 如何提高IO性能？\r\n\r\n使用缓冲流\r\n使用NIO的内存映射文件\r\n使用更大的缓冲区\r\n减少IO操作次数\r\n使用并行流处理\r\n\r\n5. transient关键字的作用？\r\n\r\n标记不需要被序列化的字段\r\n通常用于敏感信息（如密码）或可以由其他字段计算得出的冗余字段\r\n\r\nJava 静态代理学习笔记\r\n什么是代理模式\r\n静态代理是一种简单实用的设计模式，它可以在不修改目标对象的前提下，通过代理对象扩展目标对象的功能。代理对象与目标对象实现相同的接口，并持有目标对象的引用，从而可以在调用目标对象的方法前后添加额外的处理逻辑。\r\n静态代理概述\r\n静态代理是代理模式的一种实现方式，其特点是： -\r\n代理类和目标类在编译期间就已经确定 - 代理类和目标类都实现同一个接口 -\r\n代理类持有目标类的引用，并通过构造函数或setter方法注入\r\n静态代理的优缺点\r\n优点\r\n\r\n可以在不修改目标对象的前提下，通过代理对象扩展目标对象的功能\r\n将客户端与目标对象分离，降低系统的耦合度\r\n保护目标对象，控制对目标对象的访问\r\n\r\n缺点\r\n\r\n每个代理类只能为一个接口服务，会导致代理类数量过多\r\n当接口增加方法时，目标类和代理类都需要维护，不易扩展\r\n\r\n静态代理的应用场景\r\n\r\n日志记录：在方法执行前后记录日志\r\n性能监控：统计方法执行时间\r\n权限控制：在方法执行前进行权限检查\r\n事务管理：在方法执行前开启事务，执行后提交或回滚事务\r\n懒加载：延迟加载资源密集型对象\r\n\r\n静态代理实现示例\r\n示例1：基本实现\r\n// 1. 定义共同的接口interface Subject &#123;    void request();&#125;// 2. 实现目标类（被代理类）class RealSubject implements Subject &#123;    @Override    public void request() &#123;        System.out.println(&quot;RealSubject: 处理请求&quot;);    &#125;&#125;// 3. 实现代理类class Proxy implements Subject &#123;    private RealSubject realSubject;        public Proxy(RealSubject realSubject) &#123;        this.realSubject = realSubject;    &#125;        @Override    public void request() &#123;        System.out.println(&quot;Proxy: 请求前的处理&quot;);                // 调用目标对象的方法        realSubject.request();                System.out.println(&quot;Proxy: 请求后的处理&quot;);    &#125;&#125;// 4. 客户端使用public class Client &#123;    public static void main(String[] args) &#123;        // 创建目标对象        RealSubject realSubject = new RealSubject();                // 创建代理对象        Proxy proxy = new Proxy(realSubject);                // 通过代理对象调用方法        proxy.request();    &#125;&#125;\r\n示例2：日志记录代理\r\n\r\n实现代理类和实现目标类都实现了同一个接口。\r\n通过目标类构造出代理类的实例对象，不仅有目标类的方法，还有代理类扩展的方法。\r\n\r\npackage com.luotao.demo;// 1. 定义接口interface UserService &#123;    void addUser(String userId, String userName);    void deleteUser(String userId);    String findUser(String userId);&#125;// 2. 实现目标类class UserServiceImpl implements UserService &#123;    @Override    public void addUser(String userId, String userName) &#123;        System.out.println(&quot;添加用户: &quot; + userId + &quot;, &quot; + userName);    &#125;    @Override    public void deleteUser(String userId) &#123;        System.out.println(&quot;删除用户: &quot; + userId);    &#125;    @Override    public String findUser(String userId) &#123;        System.out.println(&quot;查找用户: &quot; + userId);        return &quot;User: &quot; + userId;    &#125;&#125;// 3. 实现代理类class UserServiceLogProxy implements UserService &#123;    private UserService userService;    public UserServiceLogProxy(UserService userService) &#123;        this.userService = userService;    &#125;    @Override    public void addUser(String userId, String userName) &#123;        System.out.println(&quot;Log: 准备添加用户&quot;);        long startTime = System.currentTimeMillis();        userService.addUser(userId, userName);        long endTime = System.currentTimeMillis();        System.out.println(&quot;Log: 添加用户完成，耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);    &#125;    @Override    public void deleteUser(String userId) &#123;        System.out.println(&quot;Log: 准备删除用户&quot;);        long startTime = System.currentTimeMillis();        userService.deleteUser(userId);        long endTime = System.currentTimeMillis();        System.out.println(&quot;Log: 删除用户完成，耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);    &#125;    @Override    public String findUser(String userId) &#123;        System.out.println(&quot;Log: 准备查找用户&quot;);        long startTime = System.currentTimeMillis();        String result = userService.findUser(userId);        long endTime = System.currentTimeMillis();        System.out.println(&quot;Log: 查找用户完成，耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);        return result;    &#125;&#125;// 4. 客户端使用 class LogProxyDemo &#123;    public static void main(String[] args) &#123;        /*Thread实际上用了静态代理模式        Thread类(代理类)和这个匿名内部类(目标类)都实现了同一个接口(Runnable接口)        代理类持有目标类的引用，并通过构造函数注入        */        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(Thread.currentThread().getName() + &quot;运行中&quot;);            &#125;        &#125;,&quot;线程1&quot;).start();        // 函数式接口：Runnable接口只有一个抽象方法就可以用lamnbda表达式写法        new Thread(()-&gt; System.out.println(Thread.currentThread().getName() + &quot;运行中&quot;),&quot;线程2&quot;).start();        // 创建目标对象        UserService userService = new UserServiceImpl();// 使用接口类型的引用指向其实现类的对象。        // 创建代理对象        UserService proxy = new UserServiceLogProxy(userService);        // 通过代理对象调用方法        proxy.addUser(&quot;1001&quot;, &quot;张三&quot;);        proxy.deleteUser(&quot;1002&quot;);        String user = proxy.findUser(&quot;1003&quot;);        System.out.println(&quot;返回结果: &quot; + user);    &#125;&#125;\r\n示例3：权限控制代理\r\n// 1. 定义接口interface FileOperations &#123;    void read(String filename);    void write(String filename, String content);    void delete(String filename);&#125;// 2. 实现目标类class FileManager implements FileOperations &#123;    @Override    public void read(String filename) &#123;        System.out.println(&quot;读取文件: &quot; + filename);    &#125;        @Override    public void write(String filename, String content) &#123;        System.out.println(&quot;写入文件: &quot; + filename + &quot;, 内容: &quot; + content);    &#125;        @Override    public void delete(String filename) &#123;        System.out.println(&quot;删除文件: &quot; + filename);    &#125;&#125;// 3. 实现代理类class FileSecurityProxy implements FileOperations &#123;    private FileOperations fileManager;    private String userRole;        public FileSecurityProxy(FileOperations fileManager, String userRole) &#123;        this.fileManager = fileManager;        this.userRole = userRole;    &#125;        @Override    public void read(String filename) &#123;        // 所有用户都可以读取文件        fileManager.read(filename);    &#125;        @Override    public void write(String filename, String content) &#123;        // 只有管理员和编辑可以写入文件        if (&quot;admin&quot;.equals(userRole) || &quot;editor&quot;.equals(userRole)) &#123;            fileManager.write(filename, content);        &#125; else &#123;            System.out.println(&quot;权限不足: 只有管理员和编辑可以写入文件&quot;);        &#125;    &#125;        @Override    public void delete(String filename) &#123;        // 只有管理员可以删除文件        if (&quot;admin&quot;.equals(userRole)) &#123;            fileManager.delete(filename);        &#125; else &#123;            System.out.println(&quot;权限不足: 只有管理员可以删除文件&quot;);        &#125;    &#125;&#125;// 4. 客户端使用public class SecurityProxyDemo &#123;    public static void main(String[] args) &#123;        // 创建目标对象        FileOperations fileManager = new FileManager();                // 创建普通用户代理        FileOperations userProxy = new FileSecurityProxy(fileManager, &quot;user&quot;);        System.out.println(&quot;普通用户操作:&quot;);        userProxy.read(&quot;document.txt&quot;);        userProxy.write(&quot;document.txt&quot;, &quot;Hello World&quot;);        userProxy.delete(&quot;document.txt&quot;);                System.out.println(&quot;\\n编辑用户操作:&quot;);        // 创建编辑用户代理        FileOperations editorProxy = new FileSecurityProxy(fileManager, &quot;editor&quot;);        editorProxy.read(&quot;document.txt&quot;);        editorProxy.write(&quot;document.txt&quot;, &quot;Hello World&quot;);        editorProxy.delete(&quot;document.txt&quot;);                System.out.println(&quot;\\n管理员用户操作:&quot;);        // 创建管理员用户代理        FileOperations adminProxy = new FileSecurityProxy(fileManager, &quot;admin&quot;);        adminProxy.read(&quot;document.txt&quot;);        adminProxy.write(&quot;document.txt&quot;, &quot;Hello World&quot;);        adminProxy.delete(&quot;document.txt&quot;);    &#125;&#125;\r\n"},{"title":"深刻理解Java之Map集合","url":"/2025/03/14/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3Java%E4%B9%8BMap%E9%9B%86%E5%90%88/","content":"深刻理解Java之Map集合\r\n什么是Map集合\r\nMap集合是Java集合框架中一个重要的接口，它用于存储键值对（key-value\r\npairs）。想象一个图书馆的书架系统：每本书都有一个唯一的编号（key），通过这个编号可以找到对应的书（value）。这就是Map的基本工作原理。\r\n生活中的例子： - 学生证号 -&gt; 学生信息 - 身份证号 -&gt; 居民信息 -\r\n手机号码 -&gt; 联系人 - 银行卡号 -&gt; 账户信息\r\n在Java中，Map接口位于java.util包中，它的基本定义如下：\r\npublic interface Map&lt;K,V&gt; &#123;    // K 表示键（Key）的类型    // V 表示值（Value）的类型&#125;\r\nMap接口的特点\r\n\r\n键值对映射：每个元素都是键值对，包含一个键和一个值\r\n键的唯一性：键不能重复，但值可以重复\r\n键值对的存储：键和值都可以是任何引用类型的数据，但一般不建议使用可变对象作为键\r\n键和null：大多数Map实现允许使用null键（TreeMap除外），但只能有一个null键\r\n值和null：所有Map实现都允许使用null值，且可以有多个null值\r\n\r\nMap接口的主要实现类\r\nHashMap\r\nHashMap是最常用的Map实现类，就像一个超市的储物柜系统：每个柜子都有一个唯一的号码（key），用来存储顾客的物品（value）。\r\n特点： - 无序存储 - 允许null键和null值 -\r\n非同步（线程不安全） - 查找和插入的时间复杂度为O(1)\r\n内部实现： public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;    // 默认初始容量 - 必须是2的幂    static final int DEFAULT_INITIAL_CAPACITY = 16;        // 默认加载因子    static final float DEFAULT_LOAD_FACTOR = 0.75f;        // 当链表长度大于此值时，转换为红黑树    static final int TREEIFY_THRESHOLD = 8;        // Node数组，用于存储键值对    transient Node&lt;K,V&gt;[] table;&#125;\r\nLinkedHashMap\r\nLinkedHashMap是HashMap的子类，它在HashMap的基础上维护了一个双向链表，用于记录元素的插入顺序或访问顺序。想象一个有序的超市储物柜，不仅能通过柜号找到物品，还能按存入顺序或使用频率排序。\r\n特点： - 维护元素的插入顺序或访问顺序（可选） -\r\n适合实现LRU缓存 - 性能略低于HashMap - 允许null键和null值\r\n示例： // 创建一个记录访问顺序的LinkedHashMap（LRU缓存实现）LinkedHashMap&lt;String, String&gt; lruCache = new LinkedHashMap&lt;&gt;(16, 0.75f, true) &#123;    @Override    protected boolean removeEldestEntry(Map.Entry&lt;String, String&gt; eldest) &#123;        return size() &gt; 3; // 限制缓存大小为3    &#125;&#125;;\r\nTreeMap\r\nTreeMap基于红黑树实现，它的键值对总是按照键的自然顺序或指定的比较器排序。想象一个按字母顺序排列的字典，你可以快速找到特定字母开头的词条。\r\n特点：\r\n\r\n键值对按键排序（自然顺序或自定义顺序）\r\n不允许null键，但允许null值\r\n查找和插入的时间复杂度为O(log n)\r\n适合需要排序的场景\r\n\r\n示例： // 创建一个按键的长度排序的TreeMapTreeMap&lt;String, Integer&gt; lengthSortedMap = new TreeMap&lt;&gt;((s1, s2) -&gt; &#123;    int lenCompare = Integer.compare(s1.length(), s2.length());    return lenCompare != 0 ? lenCompare : s1.compareTo(s2);&#125;);\r\n自然排序\r\npackage com.luotao.job.utils.demo;import java.util.Map;import java.util.TreeMap;// 实现Comparable接口的类class Book implements Comparable&lt;Book&gt; &#123;    private String title;    private double price;    public Book(String title, double price) &#123;        this.title = title;        this.price = price;    &#125;    @Override    public int compareTo(Book other) &#123;        // 按书名字母顺序排序        return this.title.compareTo(other.title);    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;title=&#x27;&quot; + title + &quot;&#x27;, price=&quot; + price + &quot;&#125;&quot;;    &#125;&#125; class ComparableDemo &#123;    public static void main(String[] args) &#123;        TreeMap&lt;Book, Integer&gt; bsMap = new TreeMap&lt;&gt;();        bsMap.put(new Book(&quot;1Java编程&quot;, 59.9),1);        bsMap.put(new Book(&quot;3Python基础&quot;, 45.5),2);        bsMap.put(new Book(&quot;2算法导论&quot;, 88.0),3);        bsMap.put(new Book(&quot;4数据结构&quot;, 55.0),4);        // 遍历（按书名字母顺序）        for (Map.Entry entry: bsMap.entrySet())&#123;            System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());        &#125;    &#125;&#125;\r\n比较器排序\r\npackage com.luotao.job.utils.demo;import java.util.Comparator;import java.util.Map;import java.util.TreeMap;class Book &#123;    private String title;    private double price;    public String getTitle() &#123;        return title;    &#125;    public double getPrice() &#123;        return price;    &#125;    public Book(String title, double price) &#123;        this.title = title;        this.price = price;    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;title=&#x27;&quot; + title + &quot;&#x27;, price=&quot; + price + &quot;&#125;&quot;;    &#125;&#125; class ComparableDemo &#123;    public static void main(String[] args) &#123;        TreeMap&lt;Book, Integer&gt; bsMap = new TreeMap&lt;&gt;(new Comparator&lt;Book&gt;() &#123;            @Override            public int compare(Book o1, Book o2) &#123;                double result = o2.getPrice() - o1.getPrice();                if (result&gt;0)&#123;                    return 1; //交互顺序，降序                &#125;else if(result&lt;0)&#123;                    return -1; //位置不变                &#125;else&#123;                    // 价格一样则按书名字母升序                    return o1.getTitle().compareTo(o2.getTitle());                &#125;            &#125;        &#125;);        bsMap.put(new Book(&quot;1Java编程&quot;, 59.9),1);        bsMap.put(new Book(&quot;3Python基础&quot;, 60),2);        bsMap.put(new Book(&quot;2算法导论&quot;, 60),3);        bsMap.put(new Book(&quot;4数据结构&quot;, 55.0),4);                for (Map.Entry entry: bsMap.entrySet())&#123;            System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());        &#125;    &#125;&#125;\r\nHashtable\r\nHashtable是一个历史悠久的Map实现，现在主要用于遗留代码。它的所有方法都是同步的，类似于一个带锁的储物柜系统。\r\n特点： - 线程安全（所有方法都是同步的） -\r\n不允许null键和null值 - 性能较差（因为同步） -\r\n已被ConcurrentHashMap取代\r\nConcurrentHashMap\r\nConcurrentHashMap是专门为并发设计的Map实现，它像一个分区的储物柜系统，不同的区域可以同时被不同的人使用。\r\n特点： - 线程安全 - 支持高并发访问 -\r\n不允许null键和null值 - 性能优于Hashtable\r\n示例： ConcurrentHashMap&lt;String, Integer&gt; concurrentMap = new ConcurrentHashMap&lt;&gt;();// 线程安全的操作concurrentMap.computeIfAbsent(&quot;count&quot;, k -&gt; 0);concurrentMap.computeIfPresent(&quot;count&quot;, (k, v) -&gt; v + 1);\r\nWeakHashMap\r\nWeakHashMap的特殊之处在于它的键是弱引用，当键对象不再被其他对象引用时，相应的键值对会被自动移除。想象一个会自动清理的储物柜系统。\r\n特点： - 键是弱引用 - 适合实现缓存 -\r\n自动移除无用的键值对 - 需要注意垃圾回收的影响\r\nEnumMap\r\nEnumMap是专门为枚举类型设计的Map实现，非常高效。\r\n特点： - 键必须是同一个枚举类型 - 不允许null键 -\r\n内部使用数组实现，性能极高 - 保持枚举定义的顺序\r\nMap接口的常用方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n描述\r\n返回值\r\n\r\n\r\n\r\n\r\nV put(K key, V value)\r\n添加键值对，若key已经存在则返回旧值，新value会覆盖旧值\r\n如果键存在，返回旧值；否则返回null\r\n\r\n\r\nV get(Object key)\r\n返回指定键所映射的值\r\n如果找到键，返回对应的值；否则返回null\r\n\r\n\r\nV remove(Object key)\r\n删除指定键的映射\r\n如果键存在，返回被删除的值；否则返回null\r\n\r\n\r\nboolean containsKey(Object key)\r\n检查是否包含指定的键\r\n包含返回true，否则返回false\r\n\r\n\r\nboolean containsValue(Object value)\r\n检查是否包含指定的值\r\n包含返回true，否则返回false\r\n\r\n\r\nSet&lt;K&gt; keySet()\r\n返回所有键的Set集合\r\n键的Set集合\r\n\r\n\r\nCollection&lt;V&gt; values()\r\n返回所有值的Collection集合\r\n值的Collection集合\r\n\r\n\r\nSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()\r\n返回所有键值对的Set集合\r\n键值对的Set集合\r\n\r\n\r\nint size()\r\n返回键值对的数量\r\n键值对的数量\r\n\r\n\r\nboolean isEmpty()\r\n检查Map是否为空\r\n为空返回true，否则返回false\r\n\r\n\r\nvoid clear()\r\n清空Map\r\n无返回值\r\n\r\n\r\nV getOrDefault(Object key, V defaultValue)\r\n获取键对应的值，如果键不存在返回默认值\r\n值或默认值\r\n\r\n\r\nvoid putAll(Map&lt;? extends K, ? extends V&gt; m)\r\n将指定Map中的所有映射复制到此Map中\r\n无返回值\r\n\r\n\r\n\r\nMap集合的遍历方式\r\n1. 使用增强for循环遍历键值对\r\nMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;Apple&quot;, 1);map.put(&quot;Banana&quot;, 2);map.put(&quot;Orange&quot;, 3);// 遍历键值对for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());&#125;// 只遍历键for (String key : map.keySet()) &#123;    System.out.println(&quot;Key: &quot; + key);&#125;// 只遍历值for (Integer value : map.values()) &#123;    System.out.println(&quot;Value: &quot; + value);&#125;\r\n2. 使用Lambda表达式遍历\r\nMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;Apple&quot;, 1);map.put(&quot;Banana&quot;, 2);map.put(&quot;Orange&quot;, 3);// 使用forEach方法map.forEach((key, value) -&gt; &#123;    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);&#125;);\r\n3. 使用Stream API遍历\r\nMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;Apple&quot;, 1);map.put(&quot;Banana&quot;, 2);map.put(&quot;Orange&quot;, 3);// 使用Stream API处理键值对map.entrySet().stream()   .filter(entry -&gt; entry.getValue() &gt; 1)   .forEach(entry -&gt; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()));\r\nMap集合的应用场景\r\n\r\n缓存实现：使用Map存储计算结果，避免重复计算。\r\nMap&lt;String, Object&gt; cache = new LinkedHashMap&lt;&gt;(16, 0.75f, true) &#123;    @Override    protected boolean removeEldestEntry(Map.Entry&lt;String, Object&gt; eldest) &#123;        return size() &gt; 100; // 限制缓存大小    &#125;&#125;;\r\n计数器：统计元素出现的次数。\r\nMap&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;();String[] words = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;&#125;;for (String word : words) &#123;    wordCount.merge(word, 1, Integer::sum);&#125;\r\n数据索引：建立快速查找索引。\r\nMap&lt;String, User&gt; userIndex = new HashMap&lt;&gt;();List&lt;User&gt; users = getUserList();users.forEach(user -&gt; userIndex.put(user.getId(), user));\r\n配置管理：存储配置项和对应的值。\r\nMap&lt;String, String&gt; config = new Properties();config.put(&quot;db.url&quot;, &quot;jdbc:mysql://localhost:3306/mydb&quot;);config.put(&quot;db.username&quot;, &quot;root&quot;);\r\n多值映射：一个键对应多个值。\r\nMap&lt;String, List&lt;String&gt;&gt; multiMap = new HashMap&lt;&gt;();multiMap.computeIfAbsent(&quot;fruits&quot;, k -&gt; new ArrayList&lt;&gt;()).add(&quot;apple&quot;);multiMap.computeIfAbsent(&quot;fruits&quot;, k -&gt; new ArrayList&lt;&gt;()).add(&quot;banana&quot;);\r\n\r\nMap集合的性能比较\r\n\r\n\r\n\r\n实现类\r\n插入/删除\r\n查找\r\n有序性\r\n线程安全\r\n允许null键/值\r\n\r\n\r\n\r\n\r\nHashMap\r\nO(1)\r\nO(1)\r\n无序\r\n否\r\n是/是\r\n\r\n\r\nLinkedHashMap\r\nO(1)\r\nO(1)\r\n插入/访问顺序\r\n否\r\n是/是\r\n\r\n\r\nTreeMap\r\nO(log n)\r\nO(log n)\r\n键排序\r\n否\r\n否/是\r\n\r\n\r\nHashtable\r\nO(1)\r\nO(1)\r\n无序\r\n是\r\n否/否\r\n\r\n\r\nConcurrentHashMap\r\nO(1)\r\nO(1)\r\n无序\r\n是\r\n否/否\r\n\r\n\r\nWeakHashMap\r\nO(1)\r\nO(1)\r\n无序\r\n否\r\n是/是\r\n\r\n\r\nEnumMap\r\nO(1)\r\nO(1)\r\n枚举顺序\r\n否\r\n否/是\r\n\r\n\r\n\r\n常见问题与最佳实践\r\n1. 如何选择合适的Map实现？\r\n\r\n一般场景：使用HashMap\r\n需要保持插入顺序：使用LinkedHashMap\r\n需要键排序：使用TreeMap\r\n需要线程安全：使用ConcurrentHashMap\r\n键是枚举类型：使用EnumMap\r\n需要缓存功能：使用WeakHashMap或自定义的LinkedHashMap\r\n\r\n2. 自定义对象作为键的注意事项\r\npublic class CustomKey &#123;    private String id;    private String name;        // 必须正确实现equals和hashCode方法    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        CustomKey customKey = (CustomKey) o;        return Objects.equals(id, customKey.id) &amp;&amp;               Objects.equals(name, customKey.name);    &#125;        @Override    public int hashCode() &#123;        return Objects.hash(id, name);    &#125;&#125;\r\n3. 避免并发修改问题\r\nMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();// 错误的方式for (String key : map.keySet()) &#123;    if (someCondition) &#123;        map.remove(key); // 可能抛出ConcurrentModificationException    &#125;&#125;// 正确的方式Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123;    Map.Entry&lt;String, Integer&gt; entry = iterator.next();    if (someCondition) &#123;        iterator.remove(); // 安全的删除方式    &#125;&#125;\r\n4. 使用Map的现代特性（Java 8+）\r\nMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();// 使用计算方法map.compute(&quot;key&quot;, (k, v) -&gt; (v == null) ? 1 : v + 1);map.computeIfAbsent(&quot;key&quot;, k -&gt; 1);map.computeIfPresent(&quot;key&quot;, (k, v) -&gt; v + 1);// 使用合并方法map.merge(&quot;key&quot;, 1, Integer::sum);// 使用getOrDefaultint value = map.getOrDefault(&quot;key&quot;, 0);\r\n代码示例\r\n示例1：基本操作\r\nimport java.util.*;public class MapDemo &#123;    public static void main(String[] args) &#123;        // 创建HashMap        Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();                // 添加元素        scores.put(&quot;Alice&quot;, 95);        scores.put(&quot;Bob&quot;, 85);        scores.put(&quot;Charlie&quot;, 90);                // 获取元素        System.out.println(&quot;Bob&#x27;s score: &quot; + scores.get(&quot;Bob&quot;));                // 使用getOrDefault        System.out.println(&quot;David&#x27;s score: &quot; + scores.getOrDefault(&quot;David&quot;, 0));                // 检查键是否存在        System.out.println(&quot;Has Alice? &quot; + scores.containsKey(&quot;Alice&quot;));        System.out.println(&quot;Has score 85? &quot; + scores.containsValue(85));                // 更新值        scores.put(&quot;Bob&quot;, 88); // 覆盖原值                // 只在键不存在时添加        scores.putIfAbsent(&quot;Bob&quot;, 100); // 不会改变Bob的分数                // 删除元素        scores.remove(&quot;Charlie&quot;);                // 遍历Map        for (Map.Entry&lt;String, Integer&gt; entry : scores.entrySet()) &#123;            System.out.printf(&quot;%s scored %d%n&quot;, entry.getKey(), entry.getValue());        &#125;                // 清空Map        scores.clear();        System.out.println(&quot;Is empty? &quot; + scores.isEmpty());    &#125;&#125;\r\n示例2：不同Map实现的比较\r\nimport java.util.*;public class MapComparison &#123;    public static void main(String[] args) &#123;        // HashMap - 无序        Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;C&quot;, 3);        hashMap.put(&quot;A&quot;, 1);        hashMap.put(&quot;B&quot;, 2);        System.out.println(&quot;HashMap: &quot; + hashMap);                // LinkedHashMap - 保持插入顺序        Map&lt;String, Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();        linkedHashMap.put(&quot;C&quot;, 3);        linkedHashMap.put(&quot;A&quot;, 1);        linkedHashMap.put(&quot;B&quot;, 2);        System.out.println(&quot;LinkedHashMap: &quot; + linkedHashMap);                // TreeMap - 键排序        Map&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;();        treeMap.put(&quot;C&quot;, 3);        treeMap.put(&quot;A&quot;, 1);        treeMap.put(&quot;B&quot;, 2);        System.out.println(&quot;TreeMap: &quot; + treeMap);                // ConcurrentHashMap - 线程安全        Map&lt;String, Integer&gt; concurrentMap = new ConcurrentHashMap&lt;&gt;();        concurrentMap.put(&quot;C&quot;, 3);        concurrentMap.put(&quot;A&quot;, 1);        concurrentMap.put(&quot;B&quot;, 2);        System.out.println(&quot;ConcurrentHashMap: &quot; + concurrentMap);    &#125;&#125;\r\n示例3：Map的高级操作\r\nimport java.util.*;public class AdvancedMapOperations &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();                // 使用compute方法        map.compute(&quot;A&quot;, (k, v) -&gt; (v == null) ? 1 : v + 1);        map.compute(&quot;A&quot;, (k, v) -&gt; v + 1);        System.out.println(&quot;A count: &quot; + map.get(&quot;A&quot;)); // 输出2                // 使用computeIfAbsent        map.computeIfAbsent(&quot;B&quot;, k -&gt; 1);        map.computeIfAbsent(&quot;B&quot;, k -&gt; 2); // 不会改变B的值        System.out.println(&quot;B count: &quot; + map.get(&quot;B&quot;)); // 输出1                // 使用computeIfPresent        map.computeIfPresent(&quot;B&quot;, (k, v) -&gt; v + 1);        System.out.println(&quot;B count: &quot; + map.get(&quot;B&quot;)); // 输出2                // 使用merge方法        map.merge(&quot;C&quot;, 1, Integer::sum);        map.merge(&quot;C&quot;, 1, Integer::sum);        System.out.println(&quot;C count: &quot; + map.get(&quot;C&quot;)); // 输出2                // 批量操作        map.replaceAll((k, v) -&gt; v * 2);        System.out.println(&quot;After doubling all values: &quot; + map);                // 使用Stream API        int sum = map.values().stream()                    .mapToInt(Integer::intValue)                    .sum();        System.out.println(&quot;Sum of all values: &quot; + sum);                // 按条件过滤        Map&lt;String, Integer&gt; filteredMap = new HashMap&lt;&gt;();        map.forEach((k, v) -&gt; &#123;            if (v &gt; 2) &#123;                filteredMap.put(k, v);            &#125;        &#125;);        System.out.println(&quot;Filtered map: &quot; + filteredMap);    &#125;&#125;\r\n示例4：自定义对象作为键\r\nimport java.util.*;class Person &#123;    private String id;    private String name;        public Person(String id, String name) &#123;        this.id = id;        this.name = name;    &#125;        @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Person person = (Person) o;        return Objects.equals(id, person.id);    &#125;        @Override    public int hashCode() &#123;        return Objects.hash(id);    &#125;        @Override    public String toString() &#123;        return name + &quot;(&quot; + id + &quot;)&quot;;    &#125;&#125;public class CustomKeyMapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;Person, String&gt; personMap = new HashMap&lt;&gt;();                Person p1 = new Person(&quot;1&quot;, &quot;Alice&quot;);        Person p2 = new Person(&quot;2&quot;, &quot;Bob&quot;);        Person p3 = new Person(&quot;1&quot;, &quot;Alice&quot;);                personMap.put(p1, &quot;Developer&quot;);        personMap.put(p2, &quot;Manager&quot;);        personMap.put(p3, &quot;Senior Developer&quot;);                System.out.println(&quot;Map size: &quot; + personMap.size()); // 输出2，因为p1和p3相等        System.out.println(&quot;Person map: &quot; + personMap);    &#125;&#125;\r\n示例5：实现LRU缓存\r\nimport java.util.*;public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;    private final int capacity;        public LRUCache(int capacity) &#123;        super(capacity, 0.75f, true);        this.capacity = capacity;    &#125;        @Override    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;        return size() &gt; capacity;    &#125;        public static void main(String[] args) &#123;        LRUCache&lt;String, Integer&gt; cache = new LRUCache&lt;&gt;(3);                cache.put(&quot;A&quot;, 1);        cache.put(&quot;B&quot;, 2);        cache.put(&quot;C&quot;, 3);        System.out.println(&quot;Cache: &quot; + cache); // &#123;A=1, B=2, C=3&#125;                cache.get(&quot;A&quot;); // 访问A，A移动到最后        cache.put(&quot;D&quot;, 4); // 添加D，B将被移除（最久未使用）        System.out.println(&quot;Cache after adding D: &quot; + cache); // &#123;C=3, A=1, D=4&#125;                cache.put(&quot;E&quot;, 5); // 添加E，C将被移除        System.out.println(&quot;Cache after adding E: &quot; + cache); // &#123;A=1, D=4, E=5&#125;    &#125;&#125;\r\n"},{"title":"详解Java异常处理机制","url":"/2025/03/13/%E8%AF%A6%E8%A7%A3Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","content":"详解Java异常处理机制\r\nJava提供了一种结构化的方式来处理程序运行时可能出现的错误情况。\r\n异常的基本概念\r\n什么是异常\r\n异常是程序运行过程中出现的非正常情况，如： - 程序逻辑错误 -\r\n系统资源不足 - 用户操作错误 - 设备故障等\r\nJava使用异常对象（Exception\r\nObject）来表示这些异常情况，并提供了处理这些异常的机制。\r\n异常的分类\r\nJava中的异常主要分为三大类：\r\n\r\n检查型异常（Checked Exception）\r\n\r\n编译时异常，必须显式处理\r\n继承自Exception类但不是RuntimeException的子类\r\n例如：IOException, SQLException\r\n\r\n非检查型异常（Unchecked Exception）\r\n\r\n运行时异常，不强制处理\r\n继承自RuntimeException\r\n例如：NullPointerException, ArrayIndexOutOfBoundsException\r\n\r\n错误（Error）\r\n\r\n表示严重问题，通常无法恢复\r\n继承自Error类\r\n例如：OutOfMemoryError, StackOverflowError\r\n\r\n\r\nJava异常类层次结构\r\nThrowable (所有异常和错误的父类)├── Error (严重错误，通常无法恢复)│   ├── OutOfMemoryError│   ├── StackOverflowError│   └── ...└── Exception (异常情况，可以处理)    ├── IOException (检查型异常)    ├── SQLException (检查型异常)    ├── ClassNotFoundException (检查型异常)    ├── RuntimeException (非检查型异常)    │   ├── NullPointerException    │   ├── ArrayIndexOutOfBoundsException    │   ├── ArithmeticException    │   ├── IllegalArgumentException    │   └── ...    └── ...\r\n异常处理语法\r\ntry-catch-finally\r\n基本语法：\r\ntry &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType1 e1) &#123;    // 处理ExceptionType1类型的异常&#125; catch (ExceptionType2 e2) &#123;    // 处理ExceptionType2类型的异常&#125; finally &#123;    // 无论是否发生异常，都会执行的代码    // 通常用于释放资源&#125;\r\n示例：\r\npublic void readFile(String filename) &#123;    FileInputStream fis = null;    try &#123;        fis = new FileInputStream(filename);        int data;        while ((data = fis.read()) != -1) &#123;            System.out.print((char) data);        &#125;    &#125; catch (FileNotFoundException e) &#123;        System.err.println(&quot;文件不存在: &quot; + e.getMessage());    &#125; catch (IOException e) &#123;        System.err.println(&quot;读取文件错误: &quot; + e.getMessage());    &#125; finally &#123;        // 关闭资源        if (fis != null) &#123;            try &#123;                fis.close();            &#125; catch (IOException e) &#123;                System.err.println(&quot;关闭文件错误: &quot; + e.getMessage());            &#125;        &#125;    &#125;&#125;\r\ntry-with-resources (Java 7+)\r\n自动资源管理，简化了资源的关闭操作：\r\npublic void readFile(String filename) &#123;    // 实现了AutoCloseable接口的资源会在try块结束后自动关闭    try (FileInputStream fis = new FileInputStream(filename)) &#123;        int data;        while ((data = fis.read()) != -1) &#123;            System.out.print((char) data);        &#125;    &#125; catch (FileNotFoundException e) &#123;        System.err.println(&quot;文件不存在: &quot; + e.getMessage());    &#125; catch (IOException e) &#123;        System.err.println(&quot;读取文件错误: &quot; + e.getMessage());    &#125;    // 不需要finally块来关闭资源&#125;\r\n多个资源的情况：\r\ntry (FileInputStream fis = new FileInputStream(&quot;input.txt&quot;);     FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;)) &#123;    // 使用fis和fos&#125; catch (IOException e) &#123;    // 处理异常&#125;\r\n多重捕获 (Java 7+)\r\n一个catch块可以处理多种类型的异常：\r\ntry &#123;    // 可能抛出异常的代码&#125; catch (FileNotFoundException | SQLException e) &#123;    // 处理FileNotFoundException或SQLException    System.err.println(&quot;发生异常: &quot; + e.getMessage());&#125;\r\nthrows关键字\r\n用于声明方法可能抛出的检查型异常：\r\npublic void readFile(String filename) throws IOException &#123;    FileInputStream fis = new FileInputStream(filename); // 可能抛出FileNotFoundException    int data;    while ((data = fis.read()) != -1) &#123; // 可能抛出IOException        System.out.print((char) data);    &#125;    fis.close(); // 可能抛出IOException&#125;\r\n调用带throws声明的方法：\r\npublic void processFile(String filename) &#123;    try &#123;        readFile(filename);    &#125; catch (IOException e) &#123;        System.err.println(&quot;处理文件错误: &quot; + e.getMessage());    &#125;&#125;\r\nthrow关键字\r\n用于手动抛出异常：\r\npublic void validateAge(int age) &#123;    if (age &lt; 0) &#123;        throw new IllegalArgumentException(&quot;年龄不能为负数&quot;);    &#125;    if (age &gt; 150) &#123;        throw new IllegalArgumentException(&quot;年龄不合理&quot;);    &#125;    System.out.println(&quot;年龄验证通过: &quot; + age);&#125;\r\n自定义异常\r\n当标准异常不能满足需求时，可以创建自定义异常：\r\n// 自定义检查型异常public class InsufficientFundsException extends Exception &#123;    private double amount;        public InsufficientFundsException(double amount) &#123;        super(&quot;余额不足，还差: &quot; + amount);        this.amount = amount;    &#125;        public double getAmount() &#123;        return amount;    &#125;&#125;// 自定义运行时异常public class InvalidUserException extends RuntimeException &#123;    public InvalidUserException(String message) &#123;        super(message);    &#125;&#125;\r\n使用自定义异常：\r\npublic class BankAccount &#123;    private double balance;        public void withdraw(double amount) throws InsufficientFundsException &#123;        if (amount &gt; balance) &#123;            throw new InsufficientFundsException(amount - balance);        &#125;        balance -= amount;    &#125;        public void validateUser(String username) &#123;        if (username == null || username.trim().isEmpty()) &#123;            throw new InvalidUserException(&quot;用户名不能为空&quot;);        &#125;    &#125;&#125;\r\n异常链\r\n异常链允许将一个异常包装在另一个异常中，保留原始异常信息：\r\ntry &#123;    // 数据库操作&#125; catch (SQLException e) &#123;    // 包装原始异常，转换为应用层异常    throw new ServiceException(&quot;数据库操作失败&quot;, e);&#125;\r\n常见异常及其处理方法\r\nNullPointerException\r\n// 避免NullPointerExceptionpublic void processString(String str) &#123;    // 不好的方式    int length = str.length(); // 如果str为null，抛出NullPointerException        // 好的方式    if (str != null) &#123;        int length = str.length();    &#125;        // 更好的方式 (Java 8+)    Optional&lt;String&gt; optStr = Optional.ofNullable(str);    optStr.ifPresent(s -&gt; &#123;        int length = s.length();    &#125;);&#125;\r\nArrayIndexOutOfBoundsException\r\n// 避免ArrayIndexOutOfBoundsExceptionpublic void accessArray(int[] array, int index) &#123;    // 不好的方式    int value = array[index]; // 如果index超出范围，抛出异常        // 好的方式    if (array != null &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; array.length) &#123;        int value = array[index];    &#125;&#125;\r\nNumberFormatException\r\n// 避免NumberFormatExceptionpublic int parseInteger(String str) &#123;    // 不好的方式    return Integer.parseInt(str); // 如果str不是有效的数字，抛出异常        // 好的方式    try &#123;        return Integer.parseInt(str);    &#125; catch (NumberFormatException e) &#123;        System.err.println(&quot;无效的数字格式: &quot; + str);        return 0; // 或其他默认值    &#125;&#125;\r\n异常处理的最佳实践\r\n\r\n只捕获能够处理的异常 // 不好的方式try &#123;    // 代码&#125; catch (Exception e) &#123;    e.printStackTrace(); // 捕获所有异常但没有适当处理&#125;// 好的方式try &#123;    // 代码&#125; catch (IOException e) &#123;    // 针对IO异常的具体处理&#125; catch (SQLException e) &#123;    // 针对SQL异常的具体处理&#125;\r\n不要忽略异常 // 不好的方式try &#123;    // 代码&#125; catch (Exception e) &#123;    // 空的catch块，完全忽略异常&#125;// 好的方式try &#123;    // 代码&#125; catch (Exception e) &#123;    logger.error(&quot;发生错误&quot;, e);    // 适当的错误处理&#125;\r\n释放资源的正确方式 // Java 7之前FileInputStream fis = null;try &#123;    fis = new FileInputStream(&quot;file.txt&quot;);    // 使用fis&#125; catch (IOException e) &#123;    // 处理异常&#125; finally &#123;    if (fis != null) &#123;        try &#123;            fis.close();        &#125; catch (IOException e) &#123;            // 处理关闭异常        &#125;    &#125;&#125;// Java 7及以后try (FileInputStream fis = new FileInputStream(&quot;file.txt&quot;)) &#123;    // 使用fis&#125; catch (IOException e) &#123;    // 处理异常&#125;\r\n异常的粒度 // 粒度太粗try &#123;    // 很多操作&#125; catch (Exception e) &#123;    // 处理异常&#125;// 适当的粒度try &#123;    // 操作1&#125; catch (SpecificException e) &#123;    // 处理特定异常&#125;try &#123;    // 操作2&#125; catch (AnotherException e) &#123;    // 处理另一种异常&#125;\r\n使用标准异常 // 不好的方式throw new Exception(&quot;参数无效&quot;);// 好的方式throw new IllegalArgumentException(&quot;参数无效&quot;);\r\n记录异常信息 try &#123;    // 代码&#125; catch (Exception e) &#123;    logger.error(&quot;操作失败: &quot; + e.getMessage(), e);    // 包含异常堆栈信息&#125;\r\n异常转换 try &#123;    // 底层操作&#125; catch (LowLevelException e) &#123;    // 转换为更有意义的高级异常    throw new BusinessException(&quot;业务操作失败&quot;, e);&#125;\r\n\r\n"},{"title":"个人博客系统","url":"/2025/03/29/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/","content":"个人博客系统\r\n\r\n首先第一步，你要扫描整个项目用到的技术栈，除了已经用到的技术栈以外，其他技术暂时不考虑引入，就利用现有的技术栈去实现代码编写。\r\n你先梳理整个项目的现有文件结构，src\\main\\resources\\application.yaml这个是项目的配置文件，你需要创建一个目录扫描来查看现有的项目结构以便更好地规划代码结构，避免重复创建已有的组件。\r\n\r\n项目简介\r\n这是一个基于Spring\r\nBoot的个人博客系统，提供博客内容管理、用户管理等功能。\r\n技术栈\r\n\r\n核心框架：Spring Boot 2.7.6\r\n数据访问：MyBatis-Plus 3.5.5\r\n数据库：MySQL 8.0.33\r\n接口文档：Knife4j 3.0.3\r\n参数校验：Spring Validation\r\n开发工具：Lombok, DevTools\r\n\r\n1 用户注册登录模块\r\n创建用户表（user表）\r\n\r\n解释一下该表的设计思路。\r\n\r\nCREATE TABLE `user` (    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;使用bigint作为主键，考虑到用户数据的增长性&#x27;,    `username` varchar(50) NOT NULL COMMENT &#x27;用户名作为登录标识，设置唯一索引防止重复&#x27;,    `password` varchar(100) NOT NULL COMMENT &#x27;使用varchar(100)预留足够长度存储加密后的密码&#x27;,    `nickname` varchar(50) DEFAULT NULL COMMENT &#x27;与username分开，用户可以自定义显示名称，默认使用username&#x27;,    `email` varchar(100) NOT NULL COMMENT &#x27;邮箱也设为唯一，可用于找回密码等功能&#x27;,    `avatar` varchar(255) DEFAULT NULL COMMENT &#x27;存储头像URL，便于用户个性化&#x27;,    `status` tinyint(1) DEFAULT 1 COMMENT &#x27;使用tinyint(1)，便于系统管理用户状态（启用/禁用）&#x27;,    `role` varchar(20) DEFAULT &#x27;USER&#x27; COMMENT &#x27;区分普通用户和管理员，为后续权限管理做准备&#x27;,    `last_login` datetime DEFAULT NULL COMMENT &#x27;记录用户最后登录时间，可用于数据分析和安全监控&#x27;,    `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;记录创建时间，自动设置为当前时间&#x27;,    `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;自动更新，用于记录数据变更&#x27;,    PRIMARY KEY (`id`),    UNIQUE KEY `uk_username` (`username`),    UNIQUE KEY `uk_email` (`email`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;\r\n创建实体类（User.java）\r\n基于MyBatis-Plus和Lombok的特性，以及数据库表的设计,开始创建实体类。同时给出实体类设计说明。\r\n\r\n实体类设计说明：\r\n使用注解：\r\n@Data:\r\nLombok注解，自动生成getter、setter、toString等方法\r\n@TableName:\r\nMyBatis-Plus注解，指定对应的数据库表名\r\n@TableId:\r\n指定主键生成策略为自增\r\n字段类型：\r\n使用包装类型 Boolean 而不是 boolean，允许为null\r\n时间类型使用 LocalDateTime，更适合处理日期时间\r\n主键使用 Long 类型，对应数据库的 bigint\r\n字段说明：\r\n每个字段都添加了注释，便于代码维护\r\n字段名称采用驼峰命名，MyBatis-Plus会自动转换为下划线命名\r\n安全性：\r\n密码字段虽然在实体类中可见，但在后续VO转换时会被过滤\r\n接下来，我们要创建视图对象（VO），视图对象会根据不同的业务场景（注册、登录、信息展示）来设计不同的字段。\r\n\r\npackage com.luotao.job.domain;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;import java.time.LocalDateTime;/** * @author luotao * @description 用户实体类 * @date 2024-1-2 */@Data@TableName(&quot;user&quot;)public class User &#123;    /**     * 主键ID     */    @TableId(type = IdType.AUTO)    private Long id;    /**     * 用户名     */    private String username;    /**     * 密码     */    private String password;    /**     * 昵称     */    private String nickname;    /**     * 邮箱     */    private String email;    /**     * 头像URL     */    private String avatar;    /**     * 用户状态(1:正常,0:禁用)     */    private Boolean status;    /**     * 用户角色(USER:普通用户,ADMIN:管理员)     */    private String role;    /**     * 最后登录时间     */    private LocalDateTime lastLogin;    /**     * 创建时间     */    private LocalDateTime createTime;    /**     * 更新时间     */    private LocalDateTime updateTime;&#125;\r\n创建视图对象（UserRegisterVo.java,\r\nUserLoginVo.java, UserInfoVo.java）\r\n\r\n创建三个VO类：注册、登录和信息展示。\r\nVO类设计说明：\r\n\r\n参数校验：\r\n\r\n使用@NotBlank注解确保必填字段不为空\r\n使用@Size注解限制字段长度\r\n使用@Email注解验证邮箱格式\r\n\r\n安全性考虑：\r\n\r\nUserInfoVo不包含密码等敏感信息\r\n注册时要求确认密码\r\n登录只需要用户名和密码\r\n\r\n数据展示：\r\n\r\nUserInfoVo包含了用户的基本信息，用于前端展示\r\n去掉了不需要展示给用户的字段（如status）\r\n\r\n使用Lombok：\r\n\r\n使用@Data注解简化代码\r\n\r\n\r\n\r\npackage com.luotao.job.vo;import lombok.Data;import javax.validation.constraints.Email;import javax.validation.constraints.NotBlank;import javax.validation.constraints.Size;/** * @author luotao * @description 用户注册请求VO */@Datapublic class UserRegisterVo &#123;    /**     * 用户名     */    @NotBlank(message = &quot;用户名不能为空&quot;)    @Size(min = 4, max = 20, message = &quot;用户名长度必须在4-20个字符之间&quot;)    private String username;    /**     * 密码     */    @NotBlank(message = &quot;密码不能为空&quot;)    @Size(min = 6, max = 20, message = &quot;密码长度必须在6-20个字符之间&quot;)    private String password;    /**     * 确认密码     */    @NotBlank(message = &quot;确认密码不能为空&quot;)    private String confirmPassword;    /**     * 邮箱     */    @NotBlank(message = &quot;邮箱不能为空&quot;)    @Email(message = &quot;邮箱格式不正确&quot;)    private String email;    /**     * 昵称（选填）     */    private String nickname;&#125; \r\npackage com.luotao.job.vo;import lombok.Data;import javax.validation.constraints.NotBlank;/** * @author luotao * @description 用户登录请求VO */@Datapublic class UserLoginVo &#123;    /**     * 用户名     */    @NotBlank(message = &quot;用户名不能为空&quot;)    private String username;    /**     * 密码     */    @NotBlank(message = &quot;密码不能为空&quot;)    private String password;&#125; \r\npackage com.luotao.job.vo;import lombok.Data;import java.time.LocalDateTime;/** * @author luotao * @description 用户信息响应VO */@Datapublic class UserInfoVo &#123;    /**     * 用户ID     */    private Long id;    /**     * 用户名     */    private String username;    /**     * 昵称     */    private String nickname;    /**     * 邮箱     */    private String email;    /**     * 头像URL     */    private String avatar;    /**     * 用户角色     */    private String role;    /**     * 最后登录时间     */    private LocalDateTime lastLogin;    /**     * 创建时间     */    private LocalDateTime createTime;&#125; \r\n创建Mapper接口\r\n\r\n这个Mapper接口的设计说明：\r\n\r\n继承关系：\r\n\r\n继承BaseMapper&lt;User&gt;获得基础的CRUD操作方法\r\n泛型参数User指定了操作的实体类\r\n\r\n注解说明：\r\n\r\n@Mapper注解让MyBatis自动扫描到这个接口\r\n\r\n功能特点：\r\n\r\n通过继承BaseMapper，自动获得常用的数据库操作方法\r\n无需编写基础的SQL语句,如果需要自定义复杂查询，可以后续添加自定义方法\r\n\r\n\r\n由于使用了MyBatis-Plus，这个简单的Mapper接口就能满足基本的用户管理需求。如果后续需要特殊的查询方法（比如根据用户名或邮箱查询），我们可以再添加相应的方法。\r\npackage com.luotao.job.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.luotao.job.domain.User;/** * @author luotao * @description 用户Mapper接口 */public interface UserMapper extends BaseMapper&lt;User&gt; &#123;    /**     * BaseMapper提供了基础的CRUD方法:     * - insert: 插入一条记录     * - deleteById: 根据ID删除     * - updateById: 根据ID更新     * - selectById: 根据ID查询     * - selectList: 查询列表     * - selectCount: 查询总记录数     * 等等...     */&#125;\r\n\r\n创建Service接口和实现类\r\n\r\n服务层设计说明：\r\n\r\n接口设计：\r\n定义了三个主要方法：注册、登录和获取用户信息\r\n使用ResponseResult统一返回格式\r\n方法参数和返回值都使用VO对象\r\n实现类特点：\r\n继承ServiceImpl获得MyBatis-Plus的服务能力\r\n使用@Slf4j注解添加日志支持\r\n使用@Service注解标记为服务类\r\n业务逻辑：\r\n注册时进行多重校验（密码一致性、用户名唯一、邮箱唯一）\r\n登录时验证用户状态和密码\r\n密码使用MD5加密存储\r\n使用BeanUtils.copyProperties进行对象属性拷贝\r\n安全性考虑：\r\n密码加密存储\r\n统一的错误信息（不暴露具体原因）\r\n状态检查（如用户是否被禁用）\r\n\r\n\r\npackage com.luotao.job.service;import com.luotao.job.vo.UserLoginVo;import com.luotao.job.vo.UserRegisterVo;import com.luotao.job.vo.UserInfoVo;import com.luotao.job.utils.ResponseResult;/** * @author luotao * @description 用户服务接口 */public interface UserService &#123;    /**     * 用户注册     *     * @param registerVo 注册信息     * @return 注册结果     */    ResponseResult register(UserRegisterVo registerVo);    /**     * 用户登录     *     * @param loginVo 登录信息     * @return 登录结果     */    ResponseResult login(UserLoginVo loginVo);    /**     * 获取用户信息     *     * @param userId 用户ID     * @return 用户信息     */    ResponseResult&lt;UserInfoVo&gt; getUserInfo(Long userId);&#125; \r\npackage com.luotao.job.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.luotao.job.entity.User;import com.luotao.job.mapper.UserMapper;import com.luotao.job.service.UserService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.UserLoginVo;import com.luotao.job.vo.UserRegisterVo;import com.luotao.job.vo.UserInfoVo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.stereotype.Service;import org.springframework.util.DigestUtils;import java.nio.charset.StandardCharsets;import java.time.LocalDateTime;/** * @author luotao * @description 用户服务实现类 */@Slf4j@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;    @Override    public ResponseResult register(UserRegisterVo registerVo) &#123;        // 1. 校验两次密码是否一致        if (!registerVo.getPassword().equals(registerVo.getConfirmPassword())) &#123;            return new ResponseResult(400, &quot;两次密码不一致&quot;);        &#125;        // 2. 校验用户名是否已存在：构建一个查询条件，要求 User 表中的 username 字段等于 registerVo.getUsername() 的值        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(User::getUsername, registerVo.getUsername());        if (this.count(queryWrapper) &gt; 0) &#123;            return new ResponseResult(400, &quot;用户名已存在&quot;);        &#125;        // 3. 校验邮箱是否已存在        queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(User::getEmail, registerVo.getEmail());        if (this.count(queryWrapper) &gt; 0) &#123;            return new ResponseResult(400, &quot;邮箱已被注册&quot;);        &#125;        // 4. 创建用户实体        User user = new User();        BeanUtils.copyProperties(registerVo, user); //根据属性名匹配的方式，将 registerVo 中的非空属性值赋值给 user 对象的对应属性。        // 设置默认昵称        if (user.getNickname() == null) &#123;            user.setNickname(user.getUsername());        &#125;        // 密码加密        /**         调用 registerVo.getPassword() 获取用户输入的明文密码。         使用 StandardCharsets.UTF_8 将密码字符串转换为字节数组。         调用 DigestUtils.md5DigestAsHex 方法对密码字节数组进行 MD5 加密，并返回加密后的十六进制字符串。         将加密后的密码通过 user.setPassword 设置到用户实体对象中。        **/        user.setPassword(DigestUtils.md5DigestAsHex(                registerVo.getPassword().getBytes(StandardCharsets.UTF_8)));        // 设置其他默认值        user.setStatus(true);        user.setRole(&quot;USER&quot;);        user.setCreateTime(LocalDateTime.now());        // 5. 保存用户。        this.save(user);//save 方法会根据传入的实体对象 user，将其插入到对应的数据库表中                return new ResponseResult(200, &quot;注册成功&quot;);    &#125;    @Override    public ResponseResult login(UserLoginVo loginVo) &#123;        // 1. 查询用户        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(User::getUsername, loginVo.getUsername());        User user = this.getOne(queryWrapper);//根据查询条件从数据库中查找一条记录。        // 2. 校验用户是否存在        if (user == null) &#123;            return new ResponseResult(400, &quot;用户名或密码错误&quot;);        &#125;        // 3. 校验密码。对用户登录时输入的密码进行加密后与数据库中存储的密码进行比对。        String encryptedPassword = DigestUtils.md5DigestAsHex(                loginVo.getPassword().getBytes(StandardCharsets.UTF_8));        if (!user.getPassword().equals(encryptedPassword)) &#123;            return new ResponseResult(400, &quot;用户名或密码错误&quot;);        &#125;        // 4. 校验用户状态        if (!user.getStatus()) &#123;            return new ResponseResult(400, &quot;账号已被禁用&quot;);        &#125;        // 5. 更新登录时间        user.setLastLogin(LocalDateTime.now());        this.updateById(user);        // 6. 返回用户信息        UserInfoVo userInfoVo = new UserInfoVo();        BeanUtils.copyProperties(user, userInfoVo);                return new ResponseResult(userInfoVo);    &#125;    @Override    public ResponseResult&lt;UserInfoVo&gt; getUserInfo(Long userId) &#123;        // 1. 查询用户        User user = this.getById(userId);//根据主键 ID 查询单个实体对象        if (user == null) &#123;            return new ResponseResult(400, &quot;用户不存在&quot;);        &#125;        // 2. 转换为VO对象        UserInfoVo userInfoVo = new UserInfoVo();        BeanUtils.copyProperties(user, userInfoVo);                return new ResponseResult(userInfoVo);    &#125;&#125; \r\n创建Controller\r\n\r\nController设计说明：\r\n\r\n注解使用：\r\n@RestController:\r\n标记为REST控制器，返回JSON数据\r\n@RequestMapping(“/api/user”):\r\n统一的URL前缀\r\n@Api(tags =\r\n“用户管理接口”): Swagger文档标签\r\n@Slf4j:\r\n添加日志支持\r\n@Validated:\r\n开启参数校验\r\n接口设计：\r\n注册：POST /api/user/register\r\n登录：POST /api/user/login\r\n获取用户信息：GET /api/user/{userId}\r\n参数处理：\r\n@RequestBody:\r\n处理JSON请求体\r\n@PathVariable: 处理路径参数\r\n@Validated:\r\n启用VO中的参数校验\r\n日志记录：\r\n每个方法都添加了日志记录\r\n记录请求参数，便于问题排查\r\n接口文档：\r\n使用Swagger注解标注接口信息\r\n每个方法都有清晰的注释\r\n\r\n\r\npackage com.luotao.job.controller;import com.luotao.job.service.UserService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.UserLoginVo;import com.luotao.job.vo.UserRegisterVo;import com.luotao.job.vo.UserInfoVo;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.*;/** * @author luotao * @description 用户控制器 */@Slf4j@RestController@RequestMapping(&quot;/api/user&quot;)@Api(tags = &quot;用户管理接口&quot;)public class UserController &#123;    @Autowired    private UserService userService;    /**     * 用户注册     *     * @param registerVo 注册信息     * @return 注册结果     */    @PostMapping(&quot;/register&quot;)    @ApiOperation(&quot;用户注册&quot;)    public ResponseResult register(@Validated @RequestBody UserRegisterVo registerVo) &#123;        log.info(&quot;用户注册，注册信息：&#123;&#125;&quot;, registerVo);        return userService.register(registerVo);    &#125;    /**     * 用户登录     *     * @param loginVo 登录信息     * @return 登录结果     */    @PostMapping(&quot;/login&quot;)    @ApiOperation(&quot;用户登录&quot;)    public ResponseResult login(@Validated @RequestBody UserLoginVo loginVo) &#123;        log.info(&quot;用户登录，登录信息：&#123;&#125;&quot;, loginVo);        return userService.login(loginVo);    &#125;    /**     * 获取用户信息     *     * @param userId 用户ID     * @return 用户信息     */    @GetMapping(&quot;/&#123;userId&#125;&quot;)    @ApiOperation(&quot;获取用户信息&quot;)    public ResponseResult&lt;UserInfoVo&gt; getUserInfo(@PathVariable Long userId) &#123;        log.info(&quot;获取用户信息，用户ID：&#123;&#125;&quot;, userId);        return userService.getUserInfo(userId);    &#125;&#125; \r\n2 修改密码模块\r\n\r\n修改密码功能的设计说明：\r\n\r\n安全性考虑：\r\n需要验证旧密码\r\n新密码需要确认\r\n密码继续使用MD5加密存储\r\n参数校验：\r\n所有密码字段都不能为空\r\n新密码长度限制在6-20个字符\r\n接口设计：\r\n使用PUT方法表示更新操作\r\nURL格式：PUT /api/user/{userId}/password\r\n需要在路径中指定用户ID\r\n业务逻辑：\r\n校验新密码两次输入是否一致\r\n验证用户是否存在\r\n验证旧密码是否正确\r\n加密新密码并更新\r\n\r\n\r\n修改密码的VO类UpdatePasswordVo.java(new)\r\npackage com.luotao.job.vo;import lombok.Data;import javax.validation.constraints.NotBlank;import javax.validation.constraints.Size;/** * @author luotao * @description 修改密码请求VO */@Datapublic class UpdatePasswordVo &#123;    /**     * 旧密码     */    @NotBlank(message = &quot;旧密码不能为空&quot;)    private String oldPassword;    /**     * 新密码     */    @NotBlank(message = &quot;新密码不能为空&quot;)    @Size(min = 6, max = 20, message = &quot;密码长度必须在6-20个字符之间&quot;)    private String newPassword;    /**     * 确认新密码     */    @NotBlank(message = &quot;确认密码不能为空&quot;)    private String confirmPassword;&#125; \r\n在UserService接口中添加修改密码的方法\r\n/** * 修改密码 * * @param userId 用户ID * @param updatePasswordVo 修改密码信息 * @return 修改结果 */ResponseResult updatePassword(Long userId, UpdatePasswordVo updatePasswordVo);\r\n在UserServiceImpl中实现修改密码的方法\r\n@Override    public ResponseResult updatePassword(Long userId, UpdatePasswordVo updatePasswordVo) &#123;        // 1. 校验新密码与确认密码是否一致        if (!updatePasswordVo.getNewPassword().equals(updatePasswordVo.getConfirmPassword())) &#123;            return new ResponseResult(400, &quot;两次输入的新密码不一致&quot;);        &#125;        // 2. 获取用户信息        User user = this.getById(userId);        if (user == null) &#123;            return new ResponseResult(400, &quot;用户不存在&quot;);        &#125;        // 3. 校验旧密码是否正确        String oldEncryptedPassword = DigestUtils.md5DigestAsHex(                updatePasswordVo.getOldPassword().getBytes(StandardCharsets.UTF_8));        if (!user.getPassword().equals(oldEncryptedPassword)) &#123;            return new ResponseResult(400, &quot;旧密码错误&quot;);        &#125;        // 4. 更新密码        String newEncryptedPassword = DigestUtils.md5DigestAsHex(                updatePasswordVo.getNewPassword().getBytes(StandardCharsets.UTF_8));        user.setPassword(newEncryptedPassword);                // 5. 保存更新        this.updateById(user);                return new ResponseResult(200, &quot;密码修改成功&quot;);    &#125;\r\n在UserController中添加修改密码的接口\r\n/** * 修改密码 * * @param userId 用户ID * @param updatePasswordVo 修改密码信息 * @return 修改结果 */@PutMapping(&quot;/&#123;userId&#125;/password&quot;)@ApiOperation(&quot;修改密码&quot;)public ResponseResult updatePassword(        @PathVariable Long userId,        @Validated @RequestBody UpdatePasswordVo updatePasswordVo) &#123;    log.info(&quot;修改密码，用户ID：&#123;&#125;，修改密码信息：&#123;&#125;&quot;, userId, updatePasswordVo);    return userService.updatePassword(userId, updatePasswordVo);&#125;\r\n3 更新用户信息模块\r\n\r\n更新用户信息功能的设计说明：\r\n\r\n字段更新：\r\n支持部分更新，只更新提供的字段\r\n使用needUpdate标记是否需要执行数据库更新\r\n数据校验：\r\n邮箱格式验证\r\n昵称长度限制\r\n邮箱唯一性检查（排除当前用户）\r\n接口设计：\r\n使用PUT方法表示更新操作\r\nURL格式：PUT /api/user/{userId}\r\n返回更新后的完整用户信息\r\n业务逻辑：\r\n验证用户是否存在\r\n校验邮箱唯一性\r\n按需更新字段\r\n返回更新后的用户信息\r\n\r\n\r\n更新用户信息的VO类\r\npackage com.luotao.job.vo;import lombok.Data;import javax.validation.constraints.Email;import javax.validation.constraints.Size;/** * @author luotao * @description 更新用户信息请求VO */@Datapublic class UpdateUserInfoVo &#123;    /**     * 昵称     */    @Size(max = 50, message = &quot;昵称长度不能超过50个字符&quot;)    private String nickname;    /**     * 邮箱     */    @Email(message = &quot;邮箱格式不正确&quot;)    private String email;    /**     * 头像URL     */    private String avatar;&#125; \r\n在UserService接口中添加更新用户信息的方法\r\n/** * 更新用户信息 * * @param userId 用户ID * @param updateUserInfoVo 更新的用户信息 * @return 更新结果 */ResponseResult&lt;UserInfoVo&gt; updateUserInfo(Long userId, UpdateUserInfoVo updateUserInfoVo);\r\n在UserServiceImpl中实现更新用户信息的方法\r\n@Overridepublic ResponseResult&lt;UserInfoVo&gt; updateUserInfo(Long userId, UpdateUserInfoVo updateUserInfoVo) &#123;    // 1. 获取用户信息    User user = this.getById(userId);    if (user == null) &#123;        return new ResponseResult&lt;&gt;(400, &quot;用户不存在&quot;);    &#125;    // 2. 校验邮箱是否被其他用户使用（排除当前用户）    if (updateUserInfoVo.getEmail() != null &amp;&amp; !updateUserInfoVo.getEmail().equals(user.getEmail())) &#123;        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(User::getEmail, updateUserInfoVo.getEmail());        if (this.count(queryWrapper) &gt; 0) &#123;            return new ResponseResult&lt;&gt;(400, &quot;邮箱已被其他用户使用&quot;);        &#125;    &#125;    // 3. 更新用户信息    boolean needUpdate = false;//使用needUpdate标记是否需要执行数据库更新        if (updateUserInfoVo.getNickname() != null) &#123;        user.setNickname(updateUserInfoVo.getNickname());        needUpdate = true;    &#125;        if (updateUserInfoVo.getEmail() != null) &#123;        user.setEmail(updateUserInfoVo.getEmail());        needUpdate = true;    &#125;        if (updateUserInfoVo.getAvatar() != null) &#123;        user.setAvatar(updateUserInfoVo.getAvatar());        needUpdate = true;    &#125;    // 4. 保存更新    if (needUpdate) &#123;        this.updateById(user);    &#125;    // 5. 返回更新后的用户信息    UserInfoVo userInfoVo = new UserInfoVo();    BeanUtils.copyProperties(user, userInfoVo);        return new ResponseResult&lt;&gt;(userInfoVo);&#125;\r\n在UserController中添加更新用户信息的接口\r\n/** * 更新用户信息 * * @param userId 用户ID * @param updateUserInfoVo 更新的用户信息 * @return 更新结果 */@PutMapping(&quot;/&#123;userId&#125;&quot;)@ApiOperation(&quot;更新用户信息&quot;)public ResponseResult&lt;UserInfoVo&gt; updateUserInfo(        @PathVariable Long userId,        @Validated @RequestBody UpdateUserInfoVo updateUserInfoVo) &#123;    log.info(&quot;更新用户信息，用户ID：&#123;&#125;，更新信息：&#123;&#125;&quot;, userId, updateUserInfoVo);    return userService.updateUserInfo(userId, updateUserInfoVo);&#125;\r\n4 用户注销模块\r\n\r\n软删除：将用户状态设置为禁用\r\n硬删除：直接从数据库中删除用户数据\r\n考虑到数据安全和可恢复性，我们采用软删除的方式。\r\n注销功能的设计说明：\r\n\r\n安全性考虑：\r\n需要验证用户密码，防止他人恶意注销\r\n管理员账号不允许注销\r\n使用软删除而不是硬删除\r\n接口设计：\r\n使用DELETE方法表示删除操作\r\nURL格式：DELETE /api/user/{userId}\r\n需要在请求体中提供密码验证\r\n业务逻辑：\r\n验证用户是否存在\r\n验证密码是否正确\r\n检查是否为管理员账号\r\n软删除（设置状态为禁用）\r\n数据处理：\r\n只修改用户状态，保留用户数据\r\n通过status字段控制用户是否可用\r\n\r\n\r\n用户注销的请求VO\r\npackage com.luotao.job.vo;import lombok.Data;import javax.validation.constraints.NotBlank;/** * @author luotao * @description 注销账号请求VO */@Datapublic class DeactivateAccountVo &#123;    /**     * 密码（验证身份）     */    @NotBlank(message = &quot;密码不能为空&quot;)    private String password;&#125; \r\n在UserService接口中添加注销方法\r\n/** * 注销用户 * * @param userId 用户ID * @param password 用户密码（验证身份） * @return 注销结果 */ResponseResult deactivateAccount(Long userId, String password);\r\n在UserServiceImpl中实现注销方法\r\n@Overridepublic ResponseResult deactivateAccount(Long userId, String password) &#123;    // 1. 获取用户信息    User user = this.getById(userId);    if (user == null) &#123;        return new ResponseResult(400, &quot;用户不存在&quot;);    &#125;    // 2. 验证用户密码    String encryptedPassword = DigestUtils.md5DigestAsHex(            password.getBytes(StandardCharsets.UTF_8));    if (!user.getPassword().equals(encryptedPassword)) &#123;        return new ResponseResult(400, &quot;密码错误&quot;);    &#125;    // 3. 检查是否是管理员账号    if (&quot;ADMIN&quot;.equals(user.getRole())) &#123;        return new ResponseResult(400, &quot;管理员账号不能注销&quot;);    &#125;    // 4. 软删除用户（设置状态为禁用）    user.setStatus(false);    this.updateById(user);    return new ResponseResult(200, &quot;账号已注销&quot;);&#125;\r\n在UserController中添加注销接口\r\n/** * 注销账号 * * @param userId 用户ID * @param deactivateAccountVo 注销信息（包含密码验证） * @return 注销结果 */@DeleteMapping(&quot;/&#123;userId&#125;&quot;)@ApiOperation(&quot;注销账号&quot;)public ResponseResult deactivateAccount(        @PathVariable Long userId,        @Validated @RequestBody DeactivateAccountVo deactivateAccountVo) &#123;    log.info(&quot;注销账号，用户ID：&#123;&#125;&quot;, userId);    return userService.deactivateAccount(userId, deactivateAccountVo.getPassword());&#125;\r\n5 文件上传模块\r\n\r\n使用Spring的multipart配置控制文件大小\r\n\r\n配置设计：\r\n使用@ConfigurationProperties自动绑定配置属性\r\n分离Spring默认配置和自定义配置\r\n提供文件大小限制和类型限制的配置选项\r\n支持灵活配置上传目录路径\r\n接口设计：\r\n使用MultipartFile处理文件上传\r\n返回文件的相对访问路径\r\n实现类特点：\r\n使用@Service注解标记为服务类\r\n使用@Slf4j注解添加日志支持\r\n使用@Autowired注入配置类\r\n业务逻辑：\r\n文件空值检查\r\n文件类型验证（白名单机制）\r\n生成基于日期的目录结构\r\n枚举文件冲突策略\r\n保存文件并返回访问路径\r\n控制器设计：\r\n使用@RestController提供REST API\r\n使用@RequestMapping定义基础路径\r\n添加Swagger文档注解\r\n使用@RequestParam接收文件参数\r\n\r\n\r\n图片上传\r\n新建一个blog_image表来存储上传的图片信息\r\n/*idx_post_title: 在post_title字段上建立索引,加速按文章标题查询图片的速度idx_upload_time: 在upload_time字段上建立索引,加速按时间范围查询图片的速度*/CREATE TABLE `blog_image`(    `id`          bigint(20)    NOT NULL AUTO_INCREMENT COMMENT &#x27;主键,自增长&#x27;,    `filename`    varchar(255)  NOT NULL COMMENT &#x27;文件的原始名称&#x27;,    `path`        varchar(1000) NOT NULL COMMENT &#x27;文件在服务器上的存储路径&#x27;,    `post_title`  varchar(255)  NOT NULL COMMENT &#x27;图片所属的博客文章标题,用于按文章组织图片&#x27;,    `url`         varchar(1000) NOT NULL COMMENT &#x27;图片的访问URL,用于在博客正文中引用&#x27;,    `size`        bigint(20)    NOT NULL COMMENT &#x27;文件大小,单位字节,用于展示和限制上传大小&#x27;,    `width`       int(11)                DEFAULT NULL COMMENT &#x27;图片宽度,单位像素,可选,用于展示&#x27;,    `height`      int(11)                DEFAULT NULL COMMENT &#x27;图片高度,单位像素,可选,用于展示&#x27;,    `upload_time` datetime      NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;图片上传时间,默认为当前时间&#x27;,    PRIMARY KEY (`id`),    KEY `idx_post_title` (`post_title`),    KEY `idx_upload_time` (`upload_time`)) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;博客图片表&#x27;;\r\n\r\nBlogImage实体类,与blog_image表对应\r\nBlogImageMapper接口,继承BaseMapper,用于数据库操作\r\nBlogImageService接口,定义图片管理相关的业务方法\r\nBlogImageServiceImpl实现类,实现了图片列表查询、删除、重命名等功能\r\nBlogImageController,提供RESTful风格的图片管理接口\r\n\r\nBlogImageService\r\npackage com.luotao.job.service;import com.baomidou.mybatisplus.extension.service.IService;import com.luotao.job.entity.BlogImage;import com.luotao.job.utils.ResponseResult;/** * 博客图片服务接口 */public interface BlogImageService extends IService&lt;BlogImage&gt; &#123;    /**     * 分页查询图片列表     *     * @param postTitle 博客文章标题     * @param page      页码     * @param size      每页大小     * @return 图片列表     */    ResponseResult listImages(String postTitle, Integer page, Integer size);    /**     * 删除图片     *     * @param imageId 图片ID     * @return 删除结果     */    ResponseResult deleteImage(Long imageId);    /**     * 重命名图片     *     * @param imageId   图片ID     * @param newName 新文件名     * @return 重命名结果     */    ResponseResult renameImage(Long imageId, String newName);&#125;\r\nBlogImageServiceImpl\r\n\r\n构建BlogImage对象,设置文件名、存储路径、所属文章标题、访问URL、文件大小等属性\r\n调用blogImageService.save()方法将图片信息保存到数据库\r\n使用了BlogImageService的save()方法,它是由IService接口提供的,可以直接保存实体对象。\r\n图片的宽度和高度属性暂时没有设置,如果需要的话,可以使用一些图片处理库如Thumbnailator来读取图片尺寸信息。\r\n在FileController的uploadImage接口中添加@Transactional注解,确保文件存储和数据库操作在同一个事务中\r\n\r\npackage com.luotao.job.service.impl;import com.luotao.job.config.FileUploadConfig;import com.luotao.job.service.FileService;import com.luotao.job.service.BlogImageService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.FileConflictStrategy;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.Map;/** * @author luotao * @description 文件服务实现类 */@Slf4j@Servicepublic class FileServiceImpl implements FileService &#123;    @Autowired    private FileUploadConfig fileUploadConfig;    @Autowired    private BlogImageService blogImageService;    @Override    public ResponseResult uploadMarkdown(MultipartFile file, FileConflictStrategy strategy) &#123;        // 1. 校验文件是否为空        if (file.isEmpty()) &#123;            return new ResponseResult(400, &quot;文件不能为空&quot;);        &#125;        // 2. 校验文件类型        String originalFilename = file.getOriginalFilename();        String fileExtension = StringUtils.getFilenameExtension(originalFilename);        if (!isAllowedFileType(fileExtension)) &#123;            return new ResponseResult(400, &quot;不支持的文件类型&quot;);        &#125;        try &#123;            // 3. 生成文件保存路径            String savePath = generateSavePath(originalFilename);            Path path = Paths.get(savePath);            // 4. 处理文件冲突            if (Files.exists(path)) &#123;                switch (strategy) &#123;                    case REJECT:                        return new ResponseResult(400, &quot;文件已存在&quot;);                    case RENAME:                        path = generateUniqueFilePath(path);                        break;                    case OVERWRITE:                        // 默认覆盖，无需特殊处理                        break;                &#125;            &#125;            // 5. 确保目录存在            Files.createDirectories(path.getParent());            // 6. 保存文件            file.transferTo(path);            // 7. 返回文件访问路径            String accessPath = path.toString().replace(fileUploadConfig.getPath(), &quot;&quot;);            return new ResponseResult(200, &quot;上传成功&quot;, accessPath);        &#125; catch (IOException e) &#123;            log.error(&quot;文件上传失败：&quot;, e);            return new ResponseResult(500, &quot;文件上传失败：&quot; + e.getMessage());        &#125;    &#125;    @Override    public ResponseResult readMarkdownContent(String filePath) &#123;        try &#123;            // 1. 构建完整的文件路径//            Path fullPath = Paths.get(fileUploadConfig.getPath(), filePath);            Path fullPath = Paths.get(filePath);            // 2. 检查文件是否存在            if (!Files.exists(fullPath)) &#123;                return new ResponseResult(404, &quot;文件不存在&quot;);            &#125;                        // 3. 检查文件类型            String fileExtension = StringUtils.getFilenameExtension(fullPath.toString());            if (!isAllowedFileType(fileExtension)) &#123;                return new ResponseResult(400, &quot;不支持的文件类型&quot;);            &#125;                        // 4. 读取文件内容            String content = new String(Files.readAllBytes(fullPath), StandardCharsets.UTF_8);                        // 5. 返回文件内容            return new ResponseResult(200, &quot;读取成功&quot;, content);        &#125; catch (IOException e) &#123;            log.error(&quot;读取文件失败：&quot;, e);            return new ResponseResult(500, &quot;读取文件失败：&quot; + e.getMessage());        &#125;    &#125;    @Override    public ResponseResult uploadImage(MultipartFile file, String postTitle, FileConflictStrategy strategy) &#123;        // 1. 校验文件是否为空        if (file.isEmpty()) &#123;            return new ResponseResult(400, &quot;文件不能为空&quot;);        &#125;        // 2. 校验文件类型        String originalFilename = file.getOriginalFilename();        String fileExtension = StringUtils.getFilenameExtension(originalFilename);        if (!isAllowedImageType(fileExtension)) &#123;            return new ResponseResult(400, &quot;不支持的图片类型&quot;);        &#125;        try &#123;            // 3. 生成图片存储目录和文件名            String storageDir = generateStorageDir(postTitle);            String newFilename = handleFileConflict(storageDir, originalFilename, strategy);            // 4. 保存文件            Path filePath = Paths.get(storageDir, newFilename);            Files.createDirectories(filePath.getParent());            file.transferTo(filePath);                        // 5. 保存图片信息到数据库            BlogImage blogImage = new BlogImage();            blogImage.setFilename(newFilename);            blogImage.setPath(filePath.toString());            blogImage.setPostTitle(postTitle);            blogImage.setUrl(generateAccessUrl(postTitle, newFilename));            blogImage.setSize(file.getSize());            blogImageService.save(blogImage);            // 6. 生成访问URL和Markdown引用路径            String accessUrl = generateAccessUrl(postTitle, newFilename);            String markdownPath = generateMarkdownPath(postTitle, newFilename);            // 7. 返回结果            Map&lt;String, String&gt; data = new HashMap&lt;&gt;();            data.put(&quot;url&quot;, accessUrl);            data.put(&quot;markdownPath&quot;, markdownPath);            return new ResponseResult(200, &quot;上传成功&quot;, data);        &#125; catch (IOException e) &#123;            log.error(&quot;图片上传失败：&quot;, e);            return new ResponseResult(500, &quot;图片上传失败：&quot; + e.getMessage());        &#125;    &#125;    /**     * 检查文件类型是否允许     */    private boolean isAllowedFileType(String fileExtension) &#123;        if (fileExtension == null) &#123;            return false;        &#125;        return fileUploadConfig.getAllowedTypes().contains(&quot;.&quot; + fileExtension.toLowerCase());    &#125;    /**     * 检查图片类型是否允许     */    private boolean isAllowedImageType(String fileExtension) &#123;        if (fileExtension == null) &#123;            return false;        &#125;//        return fileUploadConfig.getAllowedImageTypes().contains(&quot;.&quot; + fileExtension.toLowerCase());        return fileUploadConfig.getAllowedTypes().contains(&quot;.&quot; + fileExtension.toLowerCase());    &#125;    /**     * 生成文件保存路径     */    private String generateSavePath(String originalFilename) &#123;        // 1. 生成日期目录//        String dateDir = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));                // 2. 组合完整路径//        return fileUploadConfig.getPath() + dateDir + File.separator + originalFilename;        return fileUploadConfig.getPath()  + File.separator + originalFilename;    &#125;    /**     * 根据原始文件路径生成一个唯一的文件路径     * 如果文件已存在，则在文件名后添加递增的数字以确保路径唯一     *     * @param original 原始文件路径     * @return 生成唯一的文件路径（通过添加序号）     */    private Path generateUniqueFilePath(Path original) &#123;        // 获取原始路径的父目录        Path parent = original.getParent();        // 获取原始文件名        String filename = original.getFileName().toString();        // 移除文件名中的扩展名        String nameWithoutExt = StringUtils.stripFilenameExtension(filename);        // 获取文件名的扩展名        String extension = StringUtils.getFilenameExtension(filename);        // 初始化计数器用于生成唯一的文件名        int counter = 1;        // 初始化新路径为原始路径        Path newPath = original;        // 循环直到找到一个不存在的文件名        while (Files.exists(newPath)) &#123;            // 根据计数器生成新的文件名            String newName = String.format(&quot;%s(%d).%s&quot;, nameWithoutExt, counter++, extension);            // 在父目录下解析新的文件路径            newPath = parent.resolve(newName);        &#125;        // 返回唯一的文件路径        return newPath;    &#125;    /**     * 生成图片存储目录     */    private String generateStorageDir(String postTitle) &#123;        // 实现生成图片存储目录的逻辑        return fileUploadConfig.getPath() + File.separator + &quot;images&quot; + File.separator + postTitle;    &#125;    /**     * 处理文件冲突     */    private String handleFileConflict(String storageDir, String originalFilename, FileConflictStrategy strategy) &#123;        // 实现处理文件冲突的逻辑        return originalFilename;    &#125;    /**     * 生成访问URL     */    private String generateAccessUrl(String postTitle, String filename) &#123;        // 实现生成访问URL的逻辑        return fileUploadConfig.getPath() + &quot;images&quot; + File.separator + postTitle + File.separator + filename;    &#125;    /**     * 生成Markdown引用路径     */    private String generateMarkdownPath(String postTitle, String filename) &#123;        // 实现生成Markdown引用路径的逻辑        return &quot;images&quot; + File.separator + postTitle + File.separator + filename;    &#125;&#125; \r\nBlogImageController\r\npackage com.luotao.job.controller;import com.luotao.job.service.BlogImageService;import com.luotao.job.utils.ResponseResult;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;/** * 博客图片控制器 */@RestController@RequestMapping(&quot;/blog/images&quot;)@Api(tags = &quot;博客图片管理&quot;)public class BlogImageController &#123;    @Autowired    private BlogImageService blogImageService;    /**     * 分页查询图片列表     */    @GetMapping    @ApiOperation(&quot;分页查询图片列表&quot;)    public ResponseResult listImages(            @RequestParam(required = false) String postTitle,            @RequestParam(defaultValue = &quot;1&quot;) Integer page,            @RequestParam(defaultValue = &quot;10&quot;) Integer size) &#123;        return blogImageService.listImages(postTitle, page, size);    &#125;    /**     * 删除图片     */    @DeleteMapping(&quot;/&#123;imageId&#125;&quot;)    @ApiOperation(&quot;删除图片&quot;)    public ResponseResult deleteImage(@PathVariable Long imageId) &#123;        return blogImageService.deleteImage(imageId);    &#125;    /**     * 重命名图片     */    @PutMapping(&quot;/&#123;imageId&#125;&quot;)    @ApiOperation(&quot;重命名图片&quot;)    public ResponseResult renameImage(            @PathVariable Long imageId,            @RequestParam String newName) &#123;        return blogImageService.renameImage(imageId, newName);    &#125;&#125; \r\n\r\n\r\n图片存储目录调整为与博客文章Markdown文件同级,并按博客文章名称命名:\r\n\r\n博客文章Markdown文件路径形如: /uploads/markdown/post-title.md\r\n对应的图片存储目录为: /uploads/markdown/post-title/\r\n图片文件存储在 post-title 目录下\r\n\r\n图片文件名允许重复,并在前端提供冲突处理策略选择。\r\n\r\n下面我详细说明一下每一步的设计思路:\r\n第一步:调整FileService的uploadImage方法\r\n添加参数postTitle,表示博客文章标题,用于生成图片存储目录\r\n添加参数strategy,表示文件冲突处理策略,在前端上传时指定\r\n图片存储路径逻辑调整为:\r\n根路径为 /uploads/markdown/\r\n子目录为博客文章标题 postTitle\r\n最终的图片存储路径为 /uploads/markdown/postTitle/image.jpg\r\n根据strategy参数处理文件重名冲突:\r\nRENAME: 重命名新文件,如image(1).jpg\r\nREPLACE: 覆盖已有文件\r\nKEEP_BOTH: 保留两个文件\r\n返回结果中包含访问URL和图片在Markdown中的引用路径\r\n第二步:更新FileController的uploadImage接口\r\n请求参数中添加postTitle和strategy\r\n调用FileService的uploadImage方法,传入postTitle和strategy参数\r\n返回结果中新增markdownPath字段,表示图片在Markdown中的引用路径\r\n第三步:更新BlogPostEdit组件的图片上传处理逻辑\r\n上传前,根据当前博客标题生成postTitle参数\r\n上传前,获取用户选择的冲突处理策略,生成strategy参数\r\n上传成功后,使用服务端返回的markdownPath,在编辑器中插入图片引用\r\n第四步:更新图片管理功能\r\n根据postTitle参数,获取对应目录下的图片列表\r\n图片重命名时,只更新图片文件名,不修改所在目录\r\n\r\n图片删除时,如果目录为空,将目录一并删除\r\n\r\n数据库表结构新增postTitle字段,记录图片所属的博客文章标题\r\n以上就是按照你的要求,对图片上传和存储设计的调整思路。这样可以实现:\r\n图片按博客文章名称分目录存储,方便管理\r\n图片文件与博客文章Markdown文件同级,方便迁移和备份\r\n允许图片文件名重复,并由用户决定冲突处理策略\r\n上传成功后,直接返回图片在Markdown中的引用路径,方便写作\r\n\r\n在FileService接口中添加uploadImage方法\r\npackage com.luotao.job.service;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.FileConflictStrategy;import org.springframework.web.multipart.MultipartFile;/** * @author luotao * @description 文件服务接口 */public interface FileService &#123;    /**     * 上传Markdown文件     *     * @param file 文件     * @param strategy 文件冲突处理策略     * @return 上传结果     */    ResponseResult uploadMarkdown(MultipartFile file, FileConflictStrategy strategy);        /**     * 读取Markdown文件内容     *     * @param filePath 文件相对路径     * @return 文件内容     */    ResponseResult readMarkdownContent(String filePath);        /**     * 上传图片文件     *     * @param file 图片文件     * @param postTitle 博客文章标题     * @param strategy 文件冲突处理策略     * @return 上传结果,包含访问URL和Markdown引用路径     */    ResponseResult uploadImage(MultipartFile file, String postTitle, FileConflictStrategy strategy);&#125; \r\n在FileServiceImpl中实现图片上传\r\npackage com.luotao.job.service.impl;import com.luotao.job.config.FileUploadConfig;import com.luotao.job.service.FileService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.FileConflictStrategy;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.Map;/** * @author luotao * @description 文件服务实现类 */@Slf4j@Servicepublic class FileServiceImpl implements FileService &#123;    @Autowired    private FileUploadConfig fileUploadConfig;    @Override    public ResponseResult uploadMarkdown(MultipartFile file, FileConflictStrategy strategy) &#123;        // 1. 校验文件是否为空        if (file.isEmpty()) &#123;            return new ResponseResult(400, &quot;文件不能为空&quot;);        &#125;        // 2. 校验文件类型        String originalFilename = file.getOriginalFilename();        String fileExtension = StringUtils.getFilenameExtension(originalFilename);        if (!isAllowedFileType(fileExtension)) &#123;            return new ResponseResult(400, &quot;不支持的文件类型&quot;);        &#125;        try &#123;            // 3. 生成文件保存路径            String savePath = generateSavePath(originalFilename);            Path path = Paths.get(savePath);            // 4. 处理文件冲突            if (Files.exists(path)) &#123;                switch (strategy) &#123;                    case REJECT:                        return new ResponseResult(400, &quot;文件已存在&quot;);                    case RENAME:                        path = generateUniqueFilePath(path);                        break;                    case OVERWRITE:                        // 默认覆盖，无需特殊处理                        break;                &#125;            &#125;            // 5. 确保目录存在            Files.createDirectories(path.getParent());            // 6. 保存文件            file.transferTo(path);            // 7. 返回文件访问路径            String accessPath = path.toString().replace(fileUploadConfig.getPath(), &quot;&quot;);            return new ResponseResult(200, &quot;上传成功&quot;, accessPath);        &#125; catch (IOException e) &#123;            log.error(&quot;文件上传失败：&quot;, e);            return new ResponseResult(500, &quot;文件上传失败：&quot; + e.getMessage());        &#125;    &#125;    @Override    public ResponseResult readMarkdownContent(String filePath) &#123;        try &#123;            // 1. 构建完整的文件路径//            Path fullPath = Paths.get(fileUploadConfig.getPath(), filePath);            Path fullPath = Paths.get(filePath);            // 2. 检查文件是否存在            if (!Files.exists(fullPath)) &#123;                return new ResponseResult(404, &quot;文件不存在&quot;);            &#125;                        // 3. 检查文件类型            String fileExtension = StringUtils.getFilenameExtension(fullPath.toString());            if (!isAllowedFileType(fileExtension)) &#123;                return new ResponseResult(400, &quot;不支持的文件类型&quot;);            &#125;                        // 4. 读取文件内容            String content = new String(Files.readAllBytes(fullPath), StandardCharsets.UTF_8);                        // 5. 返回文件内容            return new ResponseResult(200, &quot;读取成功&quot;, content);        &#125; catch (IOException e) &#123;            log.error(&quot;读取文件失败：&quot;, e);            return new ResponseResult(500, &quot;读取文件失败：&quot; + e.getMessage());        &#125;    &#125;    @Override    public ResponseResult uploadImage(MultipartFile file, String postTitle, FileConflictStrategy strategy) &#123;        // 1. 校验文件是否为空        if (file.isEmpty()) &#123;            return new ResponseResult(400, &quot;文件不能为空&quot;);        &#125;        // 2. 校验文件类型        String originalFilename = file.getOriginalFilename();        String fileExtension = StringUtils.getFilenameExtension(originalFilename);        if (!isAllowedImageType(fileExtension)) &#123;            return new ResponseResult(400, &quot;不支持的图片类型&quot;);        &#125;        try &#123;            // 3. 生成图片存储目录和文件名            String storageDir = generateStorageDir(postTitle);            String newFilename = handleFileConflict(storageDir, originalFilename, strategy);            // 4. 保存文件            Path filePath = Paths.get(storageDir, newFilename);            Files.createDirectories(filePath.getParent());            file.transferTo(filePath);            // 5. 生成访问URL和Markdown引用路径            String accessUrl = generateAccessUrl(postTitle, newFilename);            String markdownPath = generateMarkdownPath(postTitle, newFilename);            // 6. 返回结果            Map&lt;String, String&gt; data = new HashMap&lt;&gt;();            data.put(&quot;url&quot;, accessUrl);            data.put(&quot;markdownPath&quot;, markdownPath);            return new ResponseResult(200, &quot;上传成功&quot;, data);        &#125; catch (IOException e) &#123;            log.error(&quot;图片上传失败：&quot;, e);            return new ResponseResult(500, &quot;图片上传失败：&quot; + e.getMessage());        &#125;    &#125;    /**     * 检查文件类型是否允许     */    private boolean isAllowedFileType(String fileExtension) &#123;        if (fileExtension == null) &#123;            return false;        &#125;        return fileUploadConfig.getAllowedTypes().contains(&quot;.&quot; + fileExtension.toLowerCase());    &#125;    /**     * 检查图片类型是否允许     */    private boolean isAllowedImageType(String fileExtension) &#123;        if (fileExtension == null) &#123;            return false;        &#125;        return fileUploadConfig.getAllowedImageTypes().contains(&quot;.&quot; + fileExtension.toLowerCase());    &#125;    /**     * 生成文件保存路径     */    private String generateSavePath(String originalFilename) &#123;        // 1. 生成日期目录//        String dateDir = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));                // 2. 组合完整路径//        return fileUploadConfig.getPath() + dateDir + File.separator + originalFilename;        return fileUploadConfig.getPath()  + File.separator + originalFilename;    &#125;    /**     * 根据原始文件路径生成一个唯一的文件路径     * 如果文件已存在，则在文件名后添加递增的数字以确保路径唯一     *     * @param original 原始文件路径     * @return 生成唯一的文件路径（通过添加序号）     */    private Path generateUniqueFilePath(Path original) &#123;        // 获取原始路径的父目录        Path parent = original.getParent();        // 获取原始文件名        String filename = original.getFileName().toString();        // 移除文件名中的扩展名        String nameWithoutExt = StringUtils.stripFilenameExtension(filename);        // 获取文件名的扩展名        String extension = StringUtils.getFilenameExtension(filename);        // 初始化计数器用于生成唯一的文件名        int counter = 1;        // 初始化新路径为原始路径        Path newPath = original;        // 循环直到找到一个不存在的文件名        while (Files.exists(newPath)) &#123;            // 根据计数器生成新的文件名            String newName = String.format(&quot;%s(%d).%s&quot;, nameWithoutExt, counter++, extension);            // 在父目录下解析新的文件路径            newPath = parent.resolve(newName);        &#125;        // 返回唯一的文件路径        return newPath;    &#125;    /**     * 生成图片存储目录     */    private String generateStorageDir(String postTitle) &#123;        // 实现生成图片存储目录的逻辑        return fileUploadConfig.getPath() + File.separator + &quot;images&quot; + File.separator + postTitle;    &#125;    /**     * 处理文件冲突     */    private String handleFileConflict(String storageDir, String originalFilename, FileConflictStrategy strategy) &#123;        // 实现处理文件冲突的逻辑        return originalFilename;    &#125;    /**     * 生成访问URL     */    private String generateAccessUrl(String postTitle, String filename) &#123;        // 实现生成访问URL的逻辑        return fileUploadConfig.getPath() + &quot;images&quot; + File.separator + postTitle + File.separator + filename;    &#125;    /**     * 生成Markdown引用路径     */    private String generateMarkdownPath(String postTitle, String filename) &#123;        // 实现生成Markdown引用路径的逻辑        return &quot;images&quot; + File.separator + postTitle + File.separator + filename;    &#125;&#125; \r\n在FileController中添加对应的Restful接口\r\npackage com.luotao.job.controller;import com.luotao.job.service.FileService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.FileConflictStrategy;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;/** * @author luotao * @description 文件上传控制器 */@Slf4j@RestController@RequestMapping(&quot;/file&quot;)@Api(tags = &quot;文件上传接口&quot;)public class FileController &#123;    @Autowired    private FileService fileService;    /**     * 上传Markdown文件     *     * @param file 文件     * @param strategy 冲突处理策略     * @return 上传结果     */    @PostMapping(&quot;/markdown&quot;)    @ApiOperation(&quot;上传Markdown文件&quot;)    public ResponseResult uploadMarkdown(            @RequestPart(&quot;file&quot;) MultipartFile file,            @RequestParam(defaultValue = &quot;RENAME&quot;) FileConflictStrategy strategy) &#123;        log.info(&quot;上传Markdown文件，文件名：&#123;&#125;，冲突处理策略：&#123;&#125;&quot;, file.getOriginalFilename(), strategy);        return fileService.uploadMarkdown(file, strategy);    &#125;    /**     * 读取Markdown文件内容     *     * @param filePath 文件相对路径     * @return 文件内容     */    @GetMapping(&quot;/markdown&quot;)    @ApiOperation(&quot;读取Markdown文件内容&quot;)    public ResponseResult readMarkdownContent(@RequestParam String filePath) &#123;        log.info(&quot;读取Markdown文件内容，文件路径：&#123;&#125;&quot;, filePath);        return fileService.readMarkdownContent(filePath);    &#125;    /**     * 上传图片文件     *     * @param file 图片文件     * @param postTitle 博客文章标题     * @param strategy 冲突处理策略     * @return 上传结果,包含访问URL和Markdown引用路径     */    @PostMapping(&quot;/image&quot;)    @ApiOperation(&quot;上传图片文件&quot;)    public ResponseResult uploadImage(            @RequestPart(&quot;file&quot;) MultipartFile file,            @RequestParam(&quot;postTitle&quot;) String postTitle,            @RequestParam(defaultValue = &quot;RENAME&quot;) FileConflictStrategy strategy) &#123;        log.info(&quot;上传图片文件,文章标题: &#123;&#125;, 文件名: &#123;&#125;, 冲突处理策略: &#123;&#125;&quot;, postTitle, file.getOriginalFilename(), strategy);        return fileService.uploadImage(file, postTitle, strategy);    &#125;&#125; \r\n添加文件上传相关配置\r\n# 数据库spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/job?serverTimezone=Asia/Shanghai    username: xxx    password: xxx  mvc:    # Spring MVC 的路径匹配策略    pathmatch:      matching-strategy: ant_path_matcher  servlet:    multipart:      max-file-size: 10MB        # 单个文件大小限制      max-request-size: 100MB    # 总请求大小限制      enabled: true              # 开启文件上传      # 自定义文件上传配置file:  upload:    path: ./uploads/markdown/    # 文件上传根路径    allowed-types:              # 允许上传的文件类型      - .md      - .markdown\r\n文件重复处理的枚举类(FileConflictStrategy)\r\npackage com.luotao.job.utils.enums;/** * @author luotao * @description 文件冲突处理策略 */public enum FileConflictStrategy &#123;    OVERWRITE,   // 覆盖已存在的文件    RENAME,      // 重命名新文件    REJECT       // 拒绝上传&#125; \r\n创建文件上传配置类(FileUploadConfig)\r\npackage com.luotao.job.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import java.util.List;/** * @author luotao * @description 文件上传配置类 */@Data@Configuration@ConfigurationProperties(prefix = &quot;file.upload&quot;)public class FileUploadConfig &#123;    /**     * 文件上传根路径     */    private String path;    /**     * 允许上传的文件类型     */    private List&lt;String&gt; allowedTypes;&#125; \r\n创建文件上传服务接口(\r\nFileService )和实现( FileServiceImpl)\r\npackage com.luotao.job.service;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.FileConflictStrategy;import org.springframework.web.multipart.MultipartFile;/** * @author luotao * @description 文件服务接口 */public interface FileService &#123;    /**     * 上传Markdown文件     *     * @param file 文件     * @param strategy 文件冲突处理策略     * @return 上传结果     */    ResponseResult uploadMarkdown(MultipartFile file, FileConflictStrategy strategy);&#125; \r\npackage com.luotao.job.service.impl;import com.luotao.job.config.FileUploadConfig;import com.luotao.job.service.FileService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.FileConflictStrategy;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;/** * @author luotao * @description 文件服务实现类 */@Slf4j@Servicepublic class FileServiceImpl implements FileService &#123;    @Autowired    private FileUploadConfig fileUploadConfig;    @Override    public ResponseResult uploadMarkdown(MultipartFile file, FileConflictStrategy strategy) &#123;        // 1. 校验文件是否为空        if (file.isEmpty()) &#123;            return new ResponseResult(400, &quot;文件不能为空&quot;);        &#125;        // 2. 校验文件类型        String originalFilename = file.getOriginalFilename();        String fileExtension = StringUtils.getFilenameExtension(originalFilename);        if (!isAllowedFileType(fileExtension)) &#123;            return new ResponseResult(400, &quot;不支持的文件类型&quot;);        &#125;        try &#123;            // 3. 生成文件保存路径            String savePath = generateSavePath(originalFilename);            Path path = Paths.get(savePath);            // 4. 处理文件冲突            if (Files.exists(path)) &#123;                switch (strategy) &#123;                    case REJECT:                        return new ResponseResult(400, &quot;文件已存在&quot;);                    case RENAME:                        path = generateUniqueFilePath(path);                        break;                    case OVERWRITE:                        // 默认覆盖，无需特殊处理                        break;                &#125;            &#125;            // 5. 确保目录存在            Files.createDirectories(path.getParent());            // 6. 保存文件            file.transferTo(path);            // 7. 返回文件访问路径            String accessPath = path.toString().replace(fileUploadConfig.getPath(), &quot;&quot;);            return new ResponseResult(200, &quot;上传成功&quot;, accessPath);        &#125; catch (IOException e) &#123;            log.error(&quot;文件上传失败：&quot;, e);            return new ResponseResult(500, &quot;文件上传失败：&quot; + e.getMessage());        &#125;    &#125;    /**     * 检查文件类型是否允许     */    private boolean isAllowedFileType(String fileExtension) &#123;        if (fileExtension == null) &#123;            return false;        &#125;        return fileUploadConfig.getAllowedTypes().contains(&quot;.&quot; + fileExtension.toLowerCase());    &#125;    /**     * 生成文件保存路径     */    private String generateSavePath(String originalFilename) &#123;        // 1. 生成日期目录//        String dateDir = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));                // 2. 组合完整路径//        return fileUploadConfig.getPath() + dateDir + File.separator + originalFilename;        return fileUploadConfig.getPath()  + File.separator + originalFilename;    &#125;    /**     * 根据原始文件路径生成一个唯一的文件路径     * 如果文件已存在，则在文件名后添加递增的数字以确保路径唯一     *     * @param original 原始文件路径     * @return 生成唯一的文件路径（通过添加序号）     */    private Path generateUniqueFilePath(Path original) &#123;        // 获取原始路径的父目录        Path parent = original.getParent();        // 获取原始文件名        String filename = original.getFileName().toString();        // 移除文件名中的扩展名        String nameWithoutExt = StringUtils.stripFilenameExtension(filename);        // 获取文件名的扩展名        String extension = StringUtils.getFilenameExtension(filename);        // 初始化计数器用于生成唯一的文件名        int counter = 1;        // 初始化新路径为原始路径        Path newPath = original;        // 循环直到找到一个不存在的文件名        while (Files.exists(newPath)) &#123;            // 根据计数器生成新的文件名            String newName = String.format(&quot;%s(%d).%s&quot;, nameWithoutExt, counter++, extension);            // 在父目录下解析新的文件路径            newPath = parent.resolve(newName);        &#125;        // 返回唯一的文件路径        return newPath;    &#125;&#125; \r\n创建文件上传控制器(FileController)\r\npackage com.luotao.job.controller;import com.luotao.job.service.FileService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.utils.enums.FileConflictStrategy;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;/** * @author luotao * @description 文件上传控制器 */@Slf4j@RestController@RequestMapping(&quot;/api/file&quot;)@Api(tags = &quot;文件上传接口&quot;)public class FileController &#123;    @Autowired    private FileService fileService;    /**     * 上传Markdown文件     *     * @param file 文件     * @param strategy 冲突处理策略     * @return 上传结果     */    @PostMapping(&quot;/markdown&quot;)    @ApiOperation(&quot;上传Markdown文件&quot;)    public ResponseResult uploadMarkdown(            @RequestPart(&quot;file&quot;) MultipartFile file,            @RequestParam(defaultValue = &quot;RENAME&quot;) FileConflictStrategy strategy) &#123;        log.info(&quot;上传Markdown文件，文件名：&#123;&#125;，冲突处理策略：&#123;&#125;&quot;, file.getOriginalFilename(), strategy);        return fileService.uploadMarkdown(file, strategy);    &#125;&#125; \r\n在FileService接口中添加读取文件的方法\r\n\r\n设计说明：\r\n\r\n接口设计：\r\n使用GET方法获取文件内容\r\n通过请求参数传递文件路径\r\n返回文件的文本内容\r\n实现类特点：\r\n完整的路径构建和安全检查\r\n文件类型验证\r\n使用UTF-8编码读取文件内容\r\n业务逻辑：\r\n文件存在性检查\r\n文件类型验证\r\n文件内容读取\r\n异常处理\r\n安全特性：\r\n路径合法性验证\r\n文件类型限制\r\n异常捕获和日志记录\r\n\r\n\r\n/** * 读取Markdown文件内容 * * @param filePath 文件相对路径 * @return 文件内容 */ResponseResult readMarkdownContent(String filePath);\r\n在FileServiceImpl中实现读取Markdown文件内容的方法\r\n@Override    public ResponseResult readMarkdownContent(String filePath) &#123;        try &#123;            // 1. 构建完整的文件路径            Path fullPath = Paths.get(fileUploadConfig.getPath(), filePath);                        // 2. 检查文件是否存在            if (!Files.exists(fullPath)) &#123;                return new ResponseResult(404, &quot;文件不存在&quot;);            &#125;                        // 3. 检查文件类型            String fileExtension = StringUtils.getFilenameExtension(fullPath.toString());            if (!isAllowedFileType(fileExtension)) &#123;                return new ResponseResult(400, &quot;不支持的文件类型&quot;);            &#125;                        // 4. 读取文件内容            String content = new String(Files.readAllBytes(fullPath), StandardCharsets.UTF_8);                        // 5. 返回文件内容            return new ResponseResult(200, &quot;读取成功&quot;, content);        &#125; catch (IOException e) &#123;            log.error(&quot;读取文件失败：&quot;, e);            return new ResponseResult(500, &quot;读取文件失败：&quot; + e.getMessage());        &#125;    &#125;\r\n在FileController中添加读取Markdown文件内容的接口\r\n/** * 读取Markdown文件内容 * * @param filePath 文件相对路径 * @return 文件内容 */@GetMapping(&quot;/markdown&quot;)@ApiOperation(&quot;读取Markdown文件内容&quot;)public ResponseResult readMarkdownContent(@RequestParam String filePath) &#123;    log.info(&quot;读取Markdown文件内容，文件路径：&#123;&#125;&quot;, filePath);    return fileService.readMarkdownContent(filePath);&#125;\r\n博客内容管理数据库设计\r\n\r\n一对多关系：\r\n\r\n用户(author_id) → 博客文章：一个用户可以发表多篇文章\r\n分类 → 博客文章：一个分类可以包含多篇文章\r\n\r\n多对多关系：\r\n\r\n博客文章 ↔︎ 标签：通过blog_post_tag关联表实现\r\n博客文章表 (blog_post)\r\nCREATE TABLE `blog_post` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,  `title` varchar(200) NOT NULL COMMENT &#x27;文章标题，必填，限制200字符&#x27;,  `content` LONGTEXT COMMENT &#x27; 文章内容，使用longtext类型存储Markdown格式内容&#x27;,  `summary` varchar(500) DEFAULT NULL COMMENT &#x27;文章摘要，可选，限制500字符，便于列表展示&#x27;,  `cover_image` TEXT DEFAULT NULL COMMENT &#x27;封面图片URL，可选，增强文章视觉&#x27;,  `category_id` bigint(20) DEFAULT NULL COMMENT &#x27;外键关联博客分类表&#x27;,  `author_id` bigint(20) NOT NULL COMMENT &#x27;外键关联用户表，记录作者信息&#x27;,  `status` tinyint(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;文章状态(0:草稿,1:已发布,2:回收站)&#x27;,  `view_count` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;浏览量统计&#x27;,  `comment_count` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;评论数统计&#x27;,  `like_count` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;点赞数统计&#x27;,  `is_top` tinyint(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否置顶，用于首页或分类页置顶显示(0:否,1:是)&#x27;,  `is_original` tinyint(1) DEFAULT &#x27;1&#x27; COMMENT &#x27;是否原创，区分原创和转载内容(0:否,1:是)&#x27;,  `source_url` varchar(1000) DEFAULT NULL COMMENT &#x27;原文链接(非原创时)&#x27;,  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27; 创建时间，自动记录&#x27;,  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间，自动更新&#x27;,  PRIMARY KEY (`id`),  KEY `idx_category` (`category_id`),  KEY `idx_author` (`author_id`),  KEY `idx_status` (`status`),  KEY `idx_create_time` (`create_time`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;博客文章表&#x27;;\r\n博客分类表 (blog_category)\r\n\r\n分类名称唯一\r\n一篇文章只能属于一个分类\r\n分类有层级关系（通过sort字段排序）\r\n\r\nCREATE TABLE `blog_category` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,  `name` varchar(50) NOT NULL COMMENT &#x27;分类名称&#x27;,  `description` varchar(200) DEFAULT NULL COMMENT &#x27;分类描述&#x27;,  `sort` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;,  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;博客分类表&#x27;;\r\n博客标签表 (blog_tag)\r\n\r\n标签名称唯一\r\n一篇文章可以有多个标签\r\n标签无层级关系\r\n\r\nCREATE TABLE `blog_tag` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,  `name` varchar(50) NOT NULL COMMENT &#x27;标签名称&#x27;,  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;博客标签表&#x27;;\r\n博客文章标签关联表\r\n(blog_post_tag)\r\n\r\n博客文章 ↔︎ 标签:使用中间表实现多对多关系\r\n联合唯一索引确保一篇文章不会重复关联同一标签\r\n双向索引优化查询性能\r\n\r\nCREATE TABLE `blog_post_tag` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,  `post_id` bigint(20) NOT NULL COMMENT &#x27;文章ID&#x27;,  `tag_id` bigint(20) NOT NULL COMMENT &#x27;标签ID&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_post_tag` (`post_id`,`tag_id`),  KEY `idx_tag_id` (`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;博客文章标签关联表&#x27;;\r\n请求VO\r\n\r\n数据校验：\r\n使用@NotBlank、@Size等注解进行输入验证\r\n为必填字段添加非空校验\r\n为长度受限字段添加长度校验\r\n创建与更新区别：\r\n创建VO：必填字段使用@NotBlank强制校验\r\n更新VO：所有字段可选，支持部分更新\r\n数据类型：\r\n使用包装类型而非基本类型，避免默认值问题\r\n使用List表示多对多关系（如标签）\r\n\r\n博客文章创建请求VO\r\npackage com.luotao.job.vo;import lombok.Data;import javax.validation.constraints.NotBlank;import javax.validation.constraints.Size;import java.util.List;/** * @author luotao * @description 创建博客文章请求VO */@Datapublic class BlogPostCreateVo &#123;    /**     * 文章标题     */    @NotBlank(message = &quot;文章标题不能为空&quot;)    @Size(max = 200, message = &quot;文章标题不能超过200个字符&quot;)    private String title;    /**     * 文章内容(Markdown格式)     */    @NotBlank(message = &quot;文章内容不能为空&quot;)    private String content;    /**     * 文章摘要     */    @Size(max = 500, message = &quot;文章摘要不能超过500个字符&quot;)    private String summary;    /**     * 封面图片URL     */    private String coverImage;    /**     * 分类ID     */    private Long categoryId;    /**     * 标签ID列表     */    private List&lt;Long&gt; tagIds;    /**     * 状态(0:草稿,1:已发布)     */    private Integer status;    /**     * 是否置顶(0:否,1:是)     */    private Boolean isTop;    /**     * 是否原创(0:否,1:是)     */    private Boolean isOriginal;    /**     * 原文链接(非原创时)     */    private String sourceUrl;&#125; \r\n博客文章更新请求VO\r\npackage com.luotao.job.vo;import lombok.Data;import javax.validation.constraints.Size;import java.util.List;/** * @author luotao * @description 更新博客文章请求VO */@Datapublic class BlogPostUpdateVo &#123;    /**     * 文章标题     */    @Size(max = 200, message = &quot;文章标题不能超过200个字符&quot;)    private String title;    /**     * 文章内容(Markdown格式)     */    private String content;    /**     * 文章摘要     */    @Size(max = 500, message = &quot;文章摘要不能超过500个字符&quot;)    private String summary;    /**     * 封面图片URL     */    private String coverImage;    /**     * 分类ID     */    private Long categoryId;    /**     * 标签ID列表     */    private List&lt;Long&gt; tagIds;    /**     * 状态(0:草稿,1:已发布,2:回收站)     */    private Integer status;    /**     * 是否置顶(0:否,1:是)     */    private Boolean isTop;    /**     * 是否原创(0:否,1:是)     */    private Boolean isOriginal;    /**     * 原文链接(非原创时)     */    private String sourceUrl;&#125; \r\n博客分类请求VO\r\npackage com.luotao.job.vo;import lombok.Data;/** * @author luotao * @description 创建博客分类请求VO */@Datapublic class BlogCategoryCreateVo &#123;    /**     * 分类名称     */    private String name;    /**     * 分类描述     */    private String description;    /**     * 排序     */    private Integer sort = 0;&#125; \r\n创建博客标签请求VO\r\npackage com.luotao.job.vo;import lombok.Data;/** * @author luotao * @description 创建博客标签请求VO */@Datapublic class BlogTagCreateVo &#123;    /**     * 标签名称     */    private String name;&#125; \r\n响应VO\r\n\r\n列表与详情区分：\r\n列表VO：包含摘要信息，不包含完整内容\r\n详情VO：包含完整内容和关联数据\r\n数据冗余：\r\n包含关联对象的名称（如分类名、作者名）\r\n减少前端二次查询的需求\r\n数据转换：\r\n将数据库实体转换为前端友好的格式\r\n隐藏不必要的实现细节\r\n\r\n博客文章列表响应VO\r\npackage com.luotao.job.vo;import lombok.Data;import java.time.LocalDateTime;/** * @author luotao * @description 博客文章列表响应VO */@Datapublic class BlogPostListVo &#123;    /**     * 文章ID     */    private Long id;    /**     * 文章标题     */    private String title;    /**     * 文章摘要     */    private String summary;    /**     * 封面图片URL     */    private String coverImage;    /**     * 分类ID     */    private Long categoryId;    /**     * 分类名称     */    private String categoryName;    /**     * 作者ID     */    private Long authorId;    /**     * 作者名称     */    private String authorName;    /**     * 作者头像     */    private String authorAvatar;    /**     * 浏览量     */    private Integer viewCount;    /**     * 评论数     */    private Integer commentCount;    /**     * 点赞数     */    private Integer likeCount;    /**     * 是否置顶(0:否,1:是)     */    private Boolean isTop;    /**     * 是否原创(0:否,1:是)     */    private Boolean isOriginal;    /**     * 创建时间     */    private LocalDateTime createTime;    /**     * 更新时间     */    private LocalDateTime updateTime;&#125; \r\n博客文章详情响应VO\r\npackage com.luotao.job.vo;import lombok.Data;import java.time.LocalDateTime;import java.util.List;/** * @author luotao * @description 博客文章详情响应VO */@Datapublic class BlogPostDetailVo &#123;    /**     * 文章ID     */    private Long id;    /**     * 文章标题     */    private String title;    /**     * 文章内容(Markdown格式)     */    private String content;    /**     * 文章摘要     */    private String summary;    /**     * 封面图片URL     */    private String coverImage;    /**     * 分类ID     */    private Long categoryId;    /**     * 分类名称     */    private String categoryName;    /**     * 标签列表     */    private List&lt;BlogTagVo&gt; tags;    /**     * 作者ID     */    private Long authorId;    /**     * 作者名称     */    private String authorName;    /**     * 作者头像     */    private String authorAvatar;    /**     * 状态(0:草稿,1:已发布,2:回收站)     */    private Integer status;    /**     * 浏览量     */    private Integer viewCount;    /**     * 评论数     */    private Integer commentCount;    /**     * 点赞数     */    private Integer likeCount;    /**     * 是否置顶(0:否,1:是)     */    private Boolean isTop;    /**     * 是否原创(0:否,1:是)     */    private Boolean isOriginal;    /**     * 原文链接(非原创时)     */    private String sourceUrl;    /**     * 创建时间     */    private LocalDateTime createTime;    /**     * 更新时间     */    private LocalDateTime updateTime;&#125; \r\n博客分类VO\r\npackage com.luotao.job.vo;import lombok.Data;/** * @author luotao * @description 博客分类VO */@Datapublic class BlogCategoryVo &#123;    /**     * 分类ID     */    private Long id;    /**     * 分类名称     */    private String name;    /**     * 分类描述     */    private String description;    /**     * 文章数量     */    private Integer postCount;&#125; \r\n博客标签VO\r\npackage com.luotao.job.vo;import lombok.Data;/** * @author luotao * @description 博客标签VO */@Datapublic class BlogTagVo &#123;    /**     * 标签ID     */    private Long id;    /**     * 标签名称     */    private String name;    /**     * 文章数量     */    private Integer postCount;&#125; \r\n查询参数VO\r\n\r\n分页参数：\r\n默认值设置：页码默认为1，每页大小默认为10\r\n支持自定义分页大小\r\n过滤条件：\r\n支持多维度过滤：分类、标签、关键词、状态\r\n所有过滤条件均为可选\r\n灵活查询：\r\n支持组合查询条件\r\n便于构建复杂的查询场景\r\n\r\npackage com.luotao.job.vo;import lombok.Data;/** * @author luotao * @description 博客文章查询参数VO */@Datapublic class BlogPostQueryVo &#123;    /**     * 页码     */    private Integer page = 1;    /**     * 每页大小     */    private Integer size = 10;    /**     * 分类ID     */    private Long categoryId;    /**     * 标签ID     */    private Long tagId;    /**     * 关键词     */    private String keyword;    /**     * 状态(0:草稿,1:已发布,2:回收站)     */    private Integer status;    /**     * 作者ID     */    private Long authorId;&#125; \r\n实体类和Mapper接口设计\r\n\r\n注解使用：\r\n@TableName:\r\n指定对应的数据库表名\r\n@TableId:\r\n指定主键字段，并设置自增策略\r\n@Data:\r\nLombok注解，自动生成getter/setter等方法\r\n字段映射：\r\n实体类字段名采用驼峰命名\r\n数据库字段名采用下划线命名\r\n通过MyBatis-Plus的配置自动转换\r\n类型选择：\r\n使用包装类型而非基本类型，避免默认值问题\r\n使用LocalDateTime表示时间\r\n自定义方法：\r\n使用注解SQL：简单的查询和更新操作\r\n使用XML映射：复杂的多表关联查询\r\n性能优化：\r\n增量更新：如浏览量、点赞数等统计字段\r\n关联查询：按需加载关联数据\r\n功能设计：\r\n分页查询：支持多条件组合过滤\r\n统计查询：分类和标签的文章数量统计\r\n关联查询：文章与标签的多对多关系处理\r\n\r\n\r\n\r\nimage-20250330160209402\r\n\r\n\r\n\r\nimage-20250330160224181\r\n\r\n博客文章Mapper接口\r\n(BlogPostMapper)\r\npackage com.luotao.job.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.luotao.job.domain.BlogPost;import com.luotao.job.vo.BlogPostListVo;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Update;/** * @author luotao * @description 博客文章Mapper接口 */public interface BlogPostMapper extends BaseMapper&lt;BlogPost&gt; &#123;    /**     * 分页查询文章列表     *     * @param page 分页参数     * @param categoryId 分类ID     * @param tagId 标签ID     * @param keyword 关键词     * @param status 状态     * @return 分页结果     */    IPage&lt;BlogPostListVo&gt; selectPostList(Page&lt;BlogPostListVo&gt; page,                                          @Param(&quot;categoryId&quot;) Long categoryId,                                         @Param(&quot;tagId&quot;) Long tagId,                                         @Param(&quot;keyword&quot;) String keyword,                                         @Param(&quot;status&quot;) Integer status);        /**     * 增加文章浏览量     *     * @param postId 文章ID     * @return 影响行数     */    @Update(&quot;UPDATE blog_post SET view_count = view_count + 1 WHERE id = #&#123;postId&#125;&quot;)    int incrementViewCount(@Param(&quot;postId&quot;) Long postId);        /**     * 增加文章点赞数     *     * @param postId 文章ID     * @return 影响行数     */    @Update(&quot;UPDATE blog_post SET like_count = like_count + 1 WHERE id = #&#123;postId&#125;&quot;)    int incrementLikeCount(@Param(&quot;postId&quot;) Long postId);        /**     * 增加文章评论数     *     * @param postId 文章ID     * @return 影响行数     */    @Update(&quot;UPDATE blog_post SET comment_count = comment_count + 1 WHERE id = #&#123;postId&#125;&quot;)    int incrementCommentCount(@Param(&quot;postId&quot;) Long postId);&#125; \r\n博客分类Mapper接口\r\n(BlogCategoryMapper)\r\npackage com.luotao.job.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.luotao.job.domain.BlogCategory;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @author luotao * @description 博客分类Mapper接口 */public interface BlogCategoryMapper extends BaseMapper&lt;BlogCategory&gt; &#123;    /**     * 查询所有分类及其文章数量     *     * @return 分类列表     */    @Select(&quot;SELECT c.*, COUNT(p.id) as post_count &quot; +            &quot;FROM blog_category c &quot; +            &quot;LEFT JOIN blog_post p ON c.id = p.category_id AND p.status = 1 &quot; +            &quot;GROUP BY c.id &quot; +            &quot;ORDER BY c.sort ASC, c.create_time DESC&quot;)    List&lt;BlogCategory&gt; selectCategoryWithCount();&#125; \r\n博客标签Mapper接口\r\n(BlogTagMapper)\r\npackage com.luotao.job.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.luotao.job.domain.BlogTag;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import java.util.List;/** * @author luotao * @description 博客标签Mapper接口 */public interface BlogTagMapper extends BaseMapper&lt;BlogTag&gt; &#123;    /**     * 查询文章的所有标签     *     * @param postId 文章ID     * @return 标签列表     */    @Select(&quot;SELECT t.* FROM blog_tag t &quot; +            &quot;INNER JOIN blog_post_tag pt ON t.id = pt.tag_id &quot; +            &quot;WHERE pt.post_id = #&#123;postId&#125;&quot;)    List&lt;BlogTag&gt; selectTagsByPostId(@Param(&quot;postId&quot;) Long postId);        /**     * 查询所有标签及其文章数量     *     * @return 标签列表     */    @Select(&quot;SELECT t.*, COUNT(pt.post_id) as post_count &quot; +            &quot;FROM blog_tag t &quot; +            &quot;LEFT JOIN blog_post_tag pt ON t.id = pt.tag_id &quot; +            &quot;LEFT JOIN blog_post p ON pt.post_id = p.id AND p.status = 1 &quot; +            &quot;GROUP BY t.id &quot; +            &quot;ORDER BY post_count DESC, t.create_time DESC&quot;)    List&lt;BlogTag&gt; selectTagWithCount();&#125; \r\n博客文章标签关联Mapper接口\r\n(BlogPostTagMapper)\r\npackage com.luotao.job.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.luotao.job.domain.BlogPostTag;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Param;/** * @author luotao * @description 博客文章标签关联Mapper接口 */public interface BlogPostTagMapper extends BaseMapper&lt;BlogPostTag&gt; &#123;    /**     * 删除文章的所有标签关联     *     * @param postId 文章ID     * @return 影响行数     */    @Delete(&quot;DELETE FROM blog_post_tag WHERE post_id = #&#123;postId&#125;&quot;)    int deleteByPostId(@Param(&quot;postId&quot;) Long postId);&#125; \r\nBlogPostMapper.xml实现复杂的查询\r\n\r\n动态SQL：\r\n使用&lt;if&gt;标签实现条件查询\r\n支持多条件组合过滤\r\n多表关联：\r\n左连接(LEFT JOIN)：获取分类和作者信息\r\n内连接(INNER JOIN)：按标签筛选文章\r\n排序策略：\r\n置顶文章优先显示\r\n按创建时间倒序排列\r\n结果映射：\r\n直接映射到VO对象，减少代码转换工作\r\n\r\n&lt;!-- 分页查询文章列表 --&gt;  &lt;select id=&quot;selectPostList&quot; resultType=&quot;com.luotao.job.vo.BlogPostListVo&quot;&gt;      SELECT      p.id,      p.title,      p.summary,      p.cover_image,      p.category_id,      c.name as category_name,      p.author_id,      u.username as author_name,      u.avatar as author_avatar,      p.view_count,      p.comment_count,      p.like_count,      p.is_top,      p.is_original,      p.create_time,      p.update_time      FROM      blog_post p      LEFT JOIN      blog_category c ON p.category_id = c.id      LEFT JOIN      user u ON p.author_id = u.id      &lt;if test=&quot;tagId != null&quot;&gt;          INNER JOIN          blog_post_tag pt ON p.id = pt.post_id AND pt.tag_id = #&#123;tagId&#125;      &lt;/if&gt;      WHERE      1 = 1      &lt;if test=&quot;status != null&quot;&gt;          AND p.status = #&#123;status&#125;      &lt;/if&gt;      &lt;if test=&quot;categoryId != null&quot;&gt;          AND p.category_id = #&#123;categoryId&#125;      &lt;/if&gt;      &lt;if test=&quot;keyword != null and keyword != &#x27;&#x27;&quot;&gt;          AND (          p.title LIKE CONCAT(&#x27;%&#x27;, #&#123;keyword&#125;, &#x27;%&#x27;)          OR p.summary LIKE CONCAT(&#x27;%&#x27;, #&#123;keyword&#125;, &#x27;%&#x27;)          OR p.content LIKE CONCAT(&#x27;%&#x27;, #&#123;keyword&#125;, &#x27;%&#x27;)          )      &lt;/if&gt;      ORDER BY      p.is_top DESC,      p.create_time DESC  &lt;/select&gt;\r\n\r\nService层设计:\r\n在涉及多表操作的方法上添加@Transactional注解\r\n设置rollbackFor = Exception.class确保任何异常都会触发回滚\r\nController层设计：\r\n\r\nBlogPostController\r\npackage com.luotao.job.controller;import com.luotao.job.service.BlogTagService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.BlogTagVo;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import lombok.extern.slf4j.Slf4j;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * @author luotao * @description 博客标签控制器 */@Slf4j@RestController@RequestMapping(&quot;/blog/tags&quot;)@Api(tags = &quot;博客标签管理接口&quot;)public class BlogTagController &#123;    @Resource    private BlogTagService blogTagService;    /**     * 获取所有标签列表     */    @GetMapping    @ApiOperation(&quot;获取所有标签列表&quot;)    public ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getAllTags() &#123;        return blogTagService.getAllTags();    &#125;    /**     * 创建标签     */    @PostMapping    @ApiOperation(&quot;创建标签&quot;)    public ResponseResult&lt;Long&gt; createTag(            @ApiParam(&quot;标签名称&quot;) @RequestParam String name) &#123;        // 检查标签名称是否为空        if (!StringUtils.hasText(name)) &#123;            return new ResponseResult&lt;&gt;(400, &quot;标签名称不能为空&quot;);        &#125;                return blogTagService.createTag(name);    &#125;    /**     * 更新标签     */    @PutMapping(&quot;/&#123;tagId&#125;&quot;)    @ApiOperation(&quot;更新标签&quot;)    public ResponseResult&lt;Void&gt; updateTag(            @ApiParam(&quot;标签ID&quot;) @PathVariable Long tagId,            @ApiParam(&quot;标签名称&quot;) @RequestParam String name) &#123;        return blogTagService.updateTag(tagId, name);    &#125;    /**     * 删除标签     */    @DeleteMapping(&quot;/&#123;tagId&#125;&quot;)    @ApiOperation(&quot;删除标签&quot;)    public ResponseResult&lt;Void&gt; deleteTag(            @ApiParam(&quot;标签ID&quot;) @PathVariable Long tagId) &#123;        return blogTagService.deleteTag(tagId);    &#125;    /**     * 获取文章的标签列表     */    @GetMapping(&quot;/post/&#123;postId&#125;&quot;)    @ApiOperation(&quot;获取文章的标签列表&quot;)    public ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getPostTags(            @ApiParam(&quot;文章ID&quot;) @PathVariable Long postId) &#123;        return blogTagService.getPostTags(postId);    &#125;&#125; \r\nBlogPostService\r\npackage com.luotao.job.service;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.baomidou.mybatisplus.extension.service.IService;import com.luotao.job.domain.BlogPost;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.*;import java.util.List;/*** @author T* @description 针对表【blog_post(博客文章表)】的数据库操作Service* @createDate 2025-03-30 16:02:34*/public interface BlogPostService extends IService&lt;BlogPost&gt; &#123;    /**     * 创建博客文章     *     * @param userId 用户ID     * @param createVo 创建文章请求     * @return 创建结果     */    ResponseResult&lt;Long&gt; createPost(Long userId, BlogPostCreateVo createVo);    /**     * 更新博客文章     *     * @param userId 用户ID     * @param postId 文章ID     * @param updateVo 更新文章请求     * @return 更新结果     */    ResponseResult&lt;Void&gt; updatePost(Long userId, Long postId, BlogPostUpdateVo updateVo);    /**     * 获取博客文章详情     *     * @param postId 文章ID     * @param increaseViewCount 是否增加浏览量     * @return 文章详情     */    ResponseResult&lt;BlogPostDetailVo&gt; getPostDetail(Long postId, boolean increaseViewCount);    /**     * 分页查询博客文章列表     *     * @param queryVo 查询参数     * @return 分页结果     */    ResponseResult&lt;Page&lt;BlogPostListVo&gt;&gt; getPostList(BlogPostQueryVo queryVo);    /**     * 删除博客文章     *     * @param userId 用户ID     * @param postId 文章ID     * @return 删除结果     */    ResponseResult&lt;Void&gt; deletePost(Long userId, Long postId);    /**     * 将文章移至回收站     *     * @param userId 用户ID     * @param postId 文章ID     * @return 操作结果     */    ResponseResult&lt;Void&gt; moveToRecycleBin(Long userId, Long postId);    /**     * 从回收站恢复文章     *     * @param userId 用户ID     * @param postId 文章ID     * @return 操作结果     */    ResponseResult&lt;Void&gt; restoreFromRecycleBin(Long userId, Long postId);        /**     * 点赞文章     *     * @param postId 文章ID     * @return 操作结果     */    ResponseResult&lt;Void&gt; likePost(Long postId);        /**     * 获取用户的文章列表     *     * @param userId 用户ID     * @param status 状态     * @return 文章列表     */    ResponseResult&lt;List&lt;BlogPostListVo&gt;&gt; getUserPosts(Long userId, Integer status);&#125;\r\nBlogPostServiceImpl\r\n\r\n数据校验：\r\n创建和更新分类时，检查名称是否为空\r\n检查分类名称是否已存在，避免重复\r\n删除分类前，检查是否有文章使用该分类\r\n业务逻辑：\r\n获取分类列表时，同时查询每个分类下的文章数量\r\n更新分类时，只更新有变化的字段\r\n删除分类时，如果有关联文章则拒绝删除\r\n性能优化：\r\n使用自定义SQL查询分类及其文章数量\r\n使用Lambda表达式构建查询条件\r\n\r\npackage com.luotao.job.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.luotao.job.domain.BlogPost;import com.luotao.job.domain.BlogPostTag;import com.luotao.job.domain.BlogTag;import com.luotao.job.domain.User;import com.luotao.job.mapper.BlogPostMapper;import com.luotao.job.mapper.BlogPostTagMapper;import com.luotao.job.mapper.BlogTagMapper;import com.luotao.job.mapper.UserMapper;import com.luotao.job.service.BlogPostService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.*;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.util.StringUtils;import javax.annotation.Resource;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;/** * @author luotao * @description 博客文章服务实现类 */@Slf4j@Servicepublic class BlogPostServiceImpl extends ServiceImpl&lt;BlogPostMapper, BlogPost&gt; implements BlogPostService &#123;    @Resource    private BlogPostTagMapper blogPostTagMapper;    @Resource    private BlogTagMapper blogTagMapper;    @Resource    private UserMapper userMapper;    /**     * 创建博客文章     *     * @param userId   用户ID     * @param createVo 创建文章请求     * @return 创建结果     */    @Override    @Transactional(rollbackFor = Exception.class)    public ResponseResult&lt;Long&gt; createPost(Long userId, BlogPostCreateVo createVo) &#123;        // 1. 检查用户是否存在        User user = userMapper.selectById(userId);        if (user == null) &#123;            return new ResponseResult&lt;&gt;(400, &quot;用户不存在&quot;);        &#125;        // 2. 构建博客文章对象        BlogPost blogPost = new BlogPost();        BeanUtils.copyProperties(createVo, blogPost);                // 3. 设置作者ID和默认值        blogPost.setAuthorId(userId);        blogPost.setViewCount(0);        blogPost.setCommentCount(0);        blogPost.setLikeCount(0);                // 4. 如果摘要为空，自动生成摘要        if (!StringUtils.hasText(blogPost.getSummary()) &amp;&amp; StringUtils.hasText(blogPost.getContent())) &#123;            // 从内容中提取前100个字符作为摘要            String content = blogPost.getContent();            // 去除Markdown标记            content = content.replaceAll(&quot;#+\\\\s*&quot;, &quot;&quot;)  // 标题                    .replaceAll(&quot;!?\\\\[.*?\\\\]\\\\(.*?\\\\)&quot;, &quot;&quot;) // 链接和图片                    .replaceAll(&quot;\\\\*\\\\*|__&quot;, &quot;&quot;) // 粗体                    .replaceAll(&quot;\\\\*|_&quot;, &quot;&quot;)     // 斜体                    .replaceAll(&quot;`.*?`&quot;, &quot;&quot;)     // 行内代码                    .replaceAll(&quot;```[\\\\s\\\\S]*?```&quot;, &quot;&quot;) // 代码块                    .replaceAll(&quot;\\\\n&quot;, &quot; &quot;);     // 换行                        blogPost.setSummary(content.length() &gt; 100 ? content.substring(0, 100) + &quot;...&quot; : content);        &#125;                // 5. 保存文章        save(blogPost);        Long postId = blogPost.getId();                // 6. 处理标签关联        if (createVo.getTagIds() != null &amp;&amp; !createVo.getTagIds().isEmpty()) &#123;            List&lt;BlogPostTag&gt; postTags = createVo.getTagIds().stream()                    .map(tagId -&gt; &#123;                        BlogPostTag postTag = new BlogPostTag();                        postTag.setPostId(postId);                        postTag.setTagId(tagId);                        return postTag;                    &#125;)                    .collect(Collectors.toList());                        // 批量插入标签关联            for (BlogPostTag postTag : postTags) &#123;                blogPostTagMapper.insert(postTag);            &#125;        &#125;                return new ResponseResult&lt;&gt;(200, &quot;创建成功&quot;, postId);    &#125;    /**     * 更新博客文章     *     * @param userId   用户ID     * @param postId   文章ID     * @param updateVo 更新文章请求     * @return 更新结果     */    @Override    @Transactional(rollbackFor = Exception.class)    public ResponseResult&lt;Void&gt; updatePost(Long userId, Long postId, BlogPostUpdateVo updateVo) &#123;        // 1. 检查文章是否存在        BlogPost blogPost = getById(postId);        if (blogPost == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;文章不存在&quot;);        &#125;                // 2. 检查权限（只有作者或管理员可以修改）        User user = userMapper.selectById(userId);        if (user == null) &#123;            return new ResponseResult&lt;&gt;(400, &quot;用户不存在&quot;);        &#125;                if (!blogPost.getAuthorId().equals(userId) &amp;&amp; !&quot;ADMIN&quot;.equals(user.getRole())) &#123;            return new ResponseResult&lt;&gt;(403, &quot;无权限修改此文章&quot;);        &#125;                // 3. 更新文章基本信息        boolean needUpdate = false;                if (StringUtils.hasText(updateVo.getTitle())) &#123;            blogPost.setTitle(updateVo.getTitle());            needUpdate = true;        &#125;                if (updateVo.getContent() != null) &#123;            blogPost.setContent(updateVo.getContent());            needUpdate = true;                        // 如果内容更新了，且摘要为空或也要更新，则重新生成摘要            if ((!StringUtils.hasText(blogPost.getSummary()) || StringUtils.hasText(updateVo.getSummary()))                     &amp;&amp; StringUtils.hasText(updateVo.getContent())) &#123;                // 从内容中提取前100个字符作为摘要                String content = updateVo.getContent();                // 去除Markdown标记                content = content.replaceAll(&quot;#+\\\\s*&quot;, &quot;&quot;)  // 标题                        .replaceAll(&quot;!?\\\\[.*?\\\\]\\\\(.*?\\\\)&quot;, &quot;&quot;) // 链接和图片                        .replaceAll(&quot;\\\\*\\\\*|__&quot;, &quot;&quot;) // 粗体                        .replaceAll(&quot;\\\\*|_&quot;, &quot;&quot;)     // 斜体                        .replaceAll(&quot;`.*?`&quot;, &quot;&quot;)     // 行内代码                        .replaceAll(&quot;```[\\\\s\\\\S]*?```&quot;, &quot;&quot;) // 代码块                        .replaceAll(&quot;\\\\n&quot;, &quot; &quot;);     // 换行                                blogPost.setSummary(content.length() &gt; 100 ? content.substring(0, 100) + &quot;...&quot; : content);            &#125;        &#125;                if (StringUtils.hasText(updateVo.getSummary())) &#123;            blogPost.setSummary(updateVo.getSummary());            needUpdate = true;        &#125;                if (updateVo.getCoverImage() != null) &#123;            blogPost.setCoverImage(updateVo.getCoverImage());            needUpdate = true;        &#125;                if (updateVo.getCategoryId() != null) &#123;            blogPost.setCategoryId(updateVo.getCategoryId());            needUpdate = true;        &#125;                if (updateVo.getStatus() != null) &#123;            blogPost.setStatus(updateVo.getStatus());            needUpdate = true;        &#125;                if (updateVo.getIsTop() != null) &#123;            blogPost.setIsTop(updateVo.getIsTop());            needUpdate = true;        &#125;                if (updateVo.getIsOriginal() != null) &#123;            blogPost.setIsOriginal(updateVo.getIsOriginal());            needUpdate = true;        &#125;                if (updateVo.getSourceUrl() != null) &#123;            blogPost.setSourceUrl(updateVo.getSourceUrl());            needUpdate = true;        &#125;                // 4. 更新文章        if (needUpdate) &#123;            updateById(blogPost);        &#125;                // 5. 处理标签关联        if (updateVo.getTagIds() != null) &#123;            // 先删除原有标签关联            blogPostTagMapper.deleteByPostId(postId);                        // 添加新的标签关联            if (!updateVo.getTagIds().isEmpty()) &#123;                List&lt;BlogPostTag&gt; postTags = updateVo.getTagIds().stream()                        .map(tagId -&gt; &#123;                            BlogPostTag postTag = new BlogPostTag();                            postTag.setPostId(postId);                            postTag.setTagId(tagId);                            return postTag;                        &#125;)                        .collect(Collectors.toList());                                // 批量插入标签关联                for (BlogPostTag postTag : postTags) &#123;                    blogPostTagMapper.insert(postTag);                &#125;            &#125;        &#125;                return new ResponseResult&lt;&gt;(200, &quot;更新成功&quot;);    &#125;    /**     * 获取博客文章详情     *     * @param postId           文章ID     * @param increaseViewCount 是否增加浏览量     * @return 文章详情     */    @Override    public ResponseResult&lt;BlogPostDetailVo&gt; getPostDetail(Long postId, boolean increaseViewCount) &#123;        // 1. 查询文章        BlogPost blogPost = getById(postId);        if (blogPost == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;文章不存在&quot;);        &#125;                // 2. 增加浏览量        if (increaseViewCount) &#123;            baseMapper.incrementViewCount(postId);            blogPost.setViewCount(blogPost.getViewCount() + 1);        &#125;                // 3. 查询作者信息        User author = userMapper.selectById(blogPost.getAuthorId());                // 4. 查询标签信息        List&lt;BlogTag&gt; tags = blogTagMapper.selectTagsByPostId(postId);        List&lt;BlogTagVo&gt; tagVos = tags.stream().map(tag -&gt; &#123;            BlogTagVo tagVo = new BlogTagVo();            tagVo.setId(tag.getId());            tagVo.setName(tag.getName());            return tagVo;        &#125;).collect(Collectors.toList());                // 5. 构建详情VO        BlogPostDetailVo detailVo = new BlogPostDetailVo();        BeanUtils.copyProperties(blogPost, detailVo);                // 设置作者信息        if (author != null) &#123;            detailVo.setAuthorName(author.getUsername());            detailVo.setAuthorAvatar(author.getAvatar());        &#125;                // 设置标签信息        detailVo.setTags(tagVos);                return new ResponseResult&lt;&gt;(200, &quot;获取成功&quot;, detailVo);    &#125;    /**     * 分页查询博客文章列表     *     * @param queryVo 查询参数     * @return 分页结果     */    @Override    public ResponseResult&lt;Page&lt;BlogPostListVo&gt;&gt; getPostList(BlogPostQueryVo queryVo) &#123;        // 1. 创建分页对象        Page&lt;BlogPostListVo&gt; page = new Page&lt;&gt;(queryVo.getPage(), queryVo.getSize());                // 2. 调用Mapper查询        IPage&lt;BlogPostListVo&gt; postPage = baseMapper.selectPostList(                page,                queryVo.getCategoryId(),                queryVo.getTagId(),                queryVo.getKeyword(),                queryVo.getStatus()        );                return new ResponseResult&lt;&gt;(200, &quot;获取成功&quot;, (Page&lt;BlogPostListVo&gt;) postPage);    &#125;    /**     * 删除博客文章     *     * @param userId 用户ID     * @param postId 文章ID     * @return 删除结果     */    @Override    @Transactional(rollbackFor = Exception.class)    public ResponseResult&lt;Void&gt; deletePost(Long userId, Long postId) &#123;        // 1. 检查文章是否存在        BlogPost blogPost = getById(postId);        if (blogPost == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;文章不存在&quot;);        &#125;                // 2. 检查权限（只有作者或管理员可以删除）        User user = userMapper.selectById(userId);        if (user == null) &#123;            return new ResponseResult&lt;&gt;(400, &quot;用户不存在&quot;);        &#125;                if (!blogPost.getAuthorId().equals(userId) &amp;&amp; !&quot;ADMIN&quot;.equals(user.getRole())) &#123;            return new ResponseResult&lt;&gt;(403, &quot;无权限删除此文章&quot;);        &#125;                // 3. 删除标签关联        blogPostTagMapper.deleteByPostId(postId);                // 4. 删除文章        removeById(postId);                return new ResponseResult&lt;&gt;(200, &quot;删除成功&quot;);    &#125;    /**     * 将文章移至回收站     *     * @param userId 用户ID     * @param postId 文章ID     * @return 操作结果     */    @Override    public ResponseResult&lt;Void&gt; moveToRecycleBin(Long userId, Long postId) &#123;        // 1. 检查文章是否存在        BlogPost blogPost = getById(postId);        if (blogPost == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;文章不存在&quot;);        &#125;                // 2. 检查权限（只有作者或管理员可以操作）        User user = userMapper.selectById(userId);        if (user == null) &#123;            return new ResponseResult&lt;&gt;(400, &quot;用户不存在&quot;);        &#125;                if (!blogPost.getAuthorId().equals(userId) &amp;&amp; !&quot;ADMIN&quot;.equals(user.getRole())) &#123;            return new ResponseResult&lt;&gt;(403, &quot;无权限操作此文章&quot;);        &#125;                // 3. 更新状态为回收站(2)        blogPost.setStatus(2);        updateById(blogPost);                return new ResponseResult&lt;&gt;(200, &quot;已移至回收站&quot;);    &#125;    /**     * 从回收站恢复文章     *     * @param userId 用户ID     * @param postId 文章ID     * @return 操作结果     */    @Override    public ResponseResult&lt;Void&gt; restoreFromRecycleBin(Long userId, Long postId) &#123;        // 1. 检查文章是否存在        BlogPost blogPost = getById(postId);        if (blogPost == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;文章不存在&quot;);        &#125;                // 2. 检查文章是否在回收站        if (blogPost.getStatus() != 2) &#123;            return new ResponseResult&lt;&gt;(400, &quot;文章不在回收站&quot;);        &#125;                // 3. 检查权限（只有作者或管理员可以操作）        User user = userMapper.selectById(userId);        if (user == null) &#123;            return new ResponseResult&lt;&gt;(400, &quot;用户不存在&quot;);        &#125;                if (!blogPost.getAuthorId().equals(userId) &amp;&amp; !&quot;ADMIN&quot;.equals(user.getRole())) &#123;            return new ResponseResult&lt;&gt;(403, &quot;无权限操作此文章&quot;);        &#125;                // 4. 恢复为草稿状态(0)        blogPost.setStatus(0);        updateById(blogPost);                return new ResponseResult&lt;&gt;(200, &quot;已从回收站恢复&quot;);    &#125;    /**     * 点赞文章     *     * @param postId 文章ID     * @return 操作结果     */    @Override    public ResponseResult&lt;Void&gt; likePost(Long postId) &#123;        // 1. 检查文章是否存在        BlogPost blogPost = getById(postId);        if (blogPost == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;文章不存在&quot;);        &#125;                // 2. 增加点赞数        baseMapper.incrementLikeCount(postId);                return new ResponseResult&lt;&gt;(200, &quot;点赞成功&quot;);    &#125;    /**     * 获取用户的文章列表     *     * @param userId 用户ID     * @param status 状态     * @return 文章列表     */    @Override    public ResponseResult&lt;List&lt;BlogPostListVo&gt;&gt; getUserPosts(Long userId, Integer status) &#123;        // 1. 检查用户是否存在        User user = userMapper.selectById(userId);        if (user == null) &#123;            return new ResponseResult&lt;&gt;(400, &quot;用户不存在&quot;);        &#125;                // 2. 创建查询对象        BlogPostQueryVo queryVo = new BlogPostQueryVo();        queryVo.setAuthorId(userId);        queryVo.setStatus(status);        queryVo.setPage(1);        queryVo.setSize(Integer.MAX_VALUE); // 获取所有文章                // 3. 查询文章列表        ResponseResult&lt;Page&lt;BlogPostListVo&gt;&gt; result = getPostList(queryVo);                if (result.getCode() != 200) &#123;            return new ResponseResult&lt;&gt;(result.getCode(), result.getMsg());        &#125;        //        return new ResponseResult&lt;&gt;(200, &quot;获取成功&quot;, result.getData().getRecords());        return new ResponseResult(200, &quot;获取成功&quot;, result.getData());    &#125;&#125;\r\nBlogCategoryController\r\npackage com.luotao.job.controller;import com.luotao.job.service.BlogCategoryService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.BlogCategoryVo;import com.luotao.job.vo.BlogCategoryCreateVo;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import lombok.extern.slf4j.Slf4j;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * @author luotao * @description 博客分类控制器 */@Slf4j@RestController@RequestMapping(&quot;/blog/categories&quot;)@Api(tags = &quot;博客分类管理接口&quot;)public class BlogCategoryController &#123;    @Resource    private BlogCategoryService blogCategoryService;    /**     * 获取所有分类列表     */    @GetMapping    @ApiOperation(&quot;获取所有分类列表&quot;)    public ResponseResult&lt;List&lt;BlogCategoryVo&gt;&gt; getAllCategories() &#123;        return blogCategoryService.getAllCategories();    &#125;    /**     * 创建分类     */    @PostMapping    @ApiOperation(&quot;创建分类&quot;)    public ResponseResult&lt;Long&gt; createCategory(@RequestBody BlogCategoryCreateVo categoryVo) &#123;        try &#123;            log.info(&quot;创建分类，参数：&#123;&#125;&quot;, categoryVo);                        if (!StringUtils.hasText(categoryVo.getName())) &#123;                return new ResponseResult&lt;&gt;(400, &quot;分类名称不能为空&quot;);            &#125;                        return blogCategoryService.createCategory(                categoryVo.getName(),                 categoryVo.getDescription(),                 categoryVo.getSort()            );        &#125; catch (Exception e) &#123;            log.error(&quot;创建分类失败: &quot;, e);            return new ResponseResult&lt;&gt;(500, &quot;创建分类失败&quot;);        &#125;    &#125;    /**     * 更新分类     */    @PutMapping(&quot;/&#123;categoryId&#125;&quot;)    @ApiOperation(&quot;更新分类&quot;)    public ResponseResult&lt;Void&gt; updateCategory(            @ApiParam(&quot;分类ID&quot;) @PathVariable Long categoryId,            @ApiParam(&quot;分类名称&quot;) @RequestParam(required = false) String name,            @ApiParam(&quot;分类描述&quot;) @RequestParam(required = false) String description,            @ApiParam(&quot;排序&quot;) @RequestParam(required = false) Integer sort) &#123;        System.out.println(categoryId );        System.out.println(name );        System.out.println(description );        System.out.println(sort );        return blogCategoryService.updateCategory(categoryId, name, description, sort);    &#125;    /**     * 删除分类     */    @DeleteMapping(&quot;/&#123;categoryId&#125;&quot;)    @ApiOperation(&quot;删除分类&quot;)    public ResponseResult&lt;Void&gt; deleteCategory(            @ApiParam(&quot;分类ID&quot;) @PathVariable Long categoryId) &#123;        return blogCategoryService.deleteCategory(categoryId);    &#125;&#125; \r\nBlogCategoryService\r\npackage com.luotao.job.service;import com.baomidou.mybatisplus.extension.service.IService;import com.luotao.job.domain.BlogCategory;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.BlogCategoryVo;import java.util.List;/** * @author luotao * @description 博客分类服务接口 */public interface BlogCategoryService extends IService&lt;BlogCategory&gt; &#123;    /**     * 获取所有分类列表     *     * @return 分类列表     */    ResponseResult&lt;List&lt;BlogCategoryVo&gt;&gt; getAllCategories();        /**     * 创建分类     *     * @param name 分类名称     * @param description 分类描述     * @param sort 排序     * @return 创建结果     */    ResponseResult&lt;Long&gt; createCategory(String name, String description, Integer sort);        /**     * 更新分类     *     * @param categoryId 分类ID     * @param name 分类名称     * @param description 分类描述     * @param sort 排序     * @return 更新结果     */    ResponseResult&lt;Void&gt; updateCategory(Long categoryId, String name, String description, Integer sort);        /**     * 删除分类     *     * @param categoryId 分类ID     * @return 删除结果     */    ResponseResult&lt;Void&gt; deleteCategory(Long categoryId);&#125;\r\nBlogCategoryServiceImpl\r\npackage com.luotao.job.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.luotao.job.domain.BlogCategory;import com.luotao.job.domain.BlogPost;import com.luotao.job.mapper.BlogCategoryMapper;import com.luotao.job.mapper.BlogPostMapper;import com.luotao.job.service.BlogCategoryService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.BlogCategoryVo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import javax.annotation.Resource;import java.time.LocalDateTime;import java.util.List;import java.util.stream.Collectors;/** * @author luotao * @description 博客分类服务实现类 */@Slf4j@Servicepublic class BlogCategoryServiceImpl extends ServiceImpl&lt;BlogCategoryMapper, BlogCategory&gt; implements BlogCategoryService &#123;    @Resource    private BlogPostMapper blogPostMapper;    /**     * 获取所有分类列表     *     * @return 分类列表     */    @Override    public ResponseResult&lt;List&lt;BlogCategoryVo&gt;&gt; getAllCategories() &#123;        // 1. 查询所有分类及其文章数量        List&lt;BlogCategory&gt; categories = baseMapper.selectCategoryWithCount();                // 2. 转换为VO对象        List&lt;BlogCategoryVo&gt; categoryVos = categories.stream().map(category -&gt; &#123;            BlogCategoryVo categoryVo = new BlogCategoryVo();            categoryVo.setId(category.getId());            categoryVo.setName(category.getName());            categoryVo.setDescription(category.getDescription());                        // 查询该分类下的文章数量            LambdaQueryWrapper&lt;BlogPost&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(BlogPost::getCategoryId, category.getId())                    .eq(BlogPost::getStatus, 1); // 只统计已发布的文章//            int count = blogPostMapper.selectCount(queryWrapper);            Long countLong = blogPostMapper.selectCount(queryWrapper);            int count = (countLong == null) ? 0 : countLong.intValue(); // 显式转换并处理 null 情            categoryVo.setPostCount(count);                        return categoryVo;        &#125;).collect(Collectors.toList());                return new ResponseResult&lt;&gt;(200, &quot;获取成功&quot;, categoryVos);    &#125;    /**     * 创建分类     *     * @param name        分类名称     * @param description 分类描述     * @param sort        排序     * @return 创建结果     */    @Override    public ResponseResult&lt;Long&gt; createCategory(String name, String description, Integer sort) &#123;        try &#123;            // 1. 检查分类名称是否已存在            LambdaQueryWrapper&lt;BlogCategory&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(BlogCategory::getName, name);            if (this.count(queryWrapper) &gt; 0) &#123;                return new ResponseResult&lt;&gt;(400, &quot;分类名称已存在&quot;);            &#125;            // 2. 创建分类            BlogCategory category = new BlogCategory();            category.setName(name);            category.setDescription(description);            category.setSort(sort != null ? sort : 0);            category.setCreateTime(LocalDateTime.now());            category.setUpdateTime(LocalDateTime.now());            // 3. 保存分类            this.save(category);            return new ResponseResult&lt;&gt;(200, &quot;创建成功&quot;, category.getId());        &#125; catch (Exception e) &#123;            log.error(&quot;创建分类失败: &quot;, e);            return new ResponseResult&lt;&gt;(500, &quot;创建分类失败&quot;);        &#125;    &#125;    /**     * 更新分类     *     * @param categoryId  分类ID     * @param name        分类名称     * @param description 分类描述     * @param sort        排序     * @return 更新结果     */    @Override    public ResponseResult&lt;Void&gt; updateCategory(Long categoryId, String name, String description, Integer sort) &#123;        // 1. 检查分类是否存在        BlogCategory category = getById(categoryId);        if (category == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;分类不存在&quot;);        &#125;                // 2. 如果修改了名称，检查名称是否已存在        if (StringUtils.hasText(name) &amp;&amp; !name.equals(category.getName())) &#123;            LambdaQueryWrapper&lt;BlogCategory&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(BlogCategory::getName, name);            if (baseMapper.selectCount(queryWrapper) &gt; 0) &#123;                return new ResponseResult&lt;&gt;(400, &quot;分类名称已存在&quot;);            &#125;            category.setName(name);        &#125;                // 3. 更新其他字段        if (StringUtils.hasText(description)) &#123;            category.setDescription(description);        &#125;                if (sort != null) &#123;            category.setSort(sort);        &#125;                category.setUpdateTime(LocalDateTime.now());        updateById(category);                return new ResponseResult&lt;&gt;(200, &quot;更新成功&quot;);    &#125;    /**     * 删除分类     *     * @param categoryId 分类ID     * @return 删除结果     */    @Override    public ResponseResult&lt;Void&gt; deleteCategory(Long categoryId) &#123;        // 1. 检查分类是否存在        BlogCategory category = getById(categoryId);        if (category == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;分类不存在&quot;);        &#125;                // 2. 检查是否有文章使用该分类        LambdaQueryWrapper&lt;BlogPost&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(BlogPost::getCategoryId, categoryId);        long count = blogPostMapper.selectCount(queryWrapper);                if (count &gt; 0) &#123;            return new ResponseResult&lt;&gt;(400, &quot;该分类下有&quot; + count + &quot;篇文章，无法删除&quot;);        &#125;                // 3. 删除分类        removeById(categoryId);                return new ResponseResult&lt;&gt;(200, &quot;删除成功&quot;);    &#125;&#125;\r\nBlogTagController\r\npackage com.luotao.job.controller;import com.luotao.job.service.BlogTagService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.BlogTagCreateVo;import com.luotao.job.vo.BlogTagVo;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import lombok.extern.slf4j.Slf4j;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * @author luotao * @description 博客标签控制器 */@Slf4j@RestController@RequestMapping(&quot;/blog/tags&quot;)@Api(tags = &quot;博客标签管理接口&quot;)public class BlogTagController &#123;    @Resource    private BlogTagService blogTagService;    /**     * 获取所有标签列表     */    @GetMapping    @ApiOperation(&quot;获取所有标签列表&quot;)    public ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getAllTags() &#123;        return blogTagService.getAllTags();    &#125;    /**     * 创建标签     */    @PostMapping    @ApiOperation(&quot;创建标签&quot;)    public ResponseResult&lt;Long&gt; createTag(@RequestBody BlogTagCreateVo tagVo) &#123;        try &#123;            log.info(&quot;创建标签，参数：&#123;&#125;&quot;, tagVo);                        if (!StringUtils.hasText(tagVo.getName())) &#123;                return new ResponseResult&lt;&gt;(400, &quot;标签名称不能为空&quot;);            &#125;                        return blogTagService.createTag(tagVo.getName());        &#125; catch (Exception e) &#123;            log.error(&quot;创建标签失败: &quot;, e);            return new ResponseResult&lt;&gt;(500, &quot;创建标签失败&quot;);        &#125;    &#125;    /**     * 更新标签     */    @PutMapping(&quot;/&#123;tagId&#125;&quot;)    @ApiOperation(&quot;更新标签&quot;)    public ResponseResult&lt;Void&gt; updateTag(            @ApiParam(&quot;标签ID&quot;) @PathVariable Long tagId,            @ApiParam(&quot;标签名称&quot;) @RequestParam String name) &#123;        return blogTagService.updateTag(tagId, name);    &#125;    /**     * 删除标签     */    @DeleteMapping(&quot;/&#123;tagId&#125;&quot;)    @ApiOperation(&quot;删除标签&quot;)    public ResponseResult&lt;Void&gt; deleteTag(            @ApiParam(&quot;标签ID&quot;) @PathVariable Long tagId) &#123;        return blogTagService.deleteTag(tagId);    &#125;    /**     * 获取文章的标签列表     */    @GetMapping(&quot;/post/&#123;postId&#125;&quot;)    @ApiOperation(&quot;获取文章的标签列表&quot;)    public ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getPostTags(            @ApiParam(&quot;文章ID&quot;) @PathVariable Long postId) &#123;        return blogTagService.getPostTags(postId);    &#125;&#125; \r\nBlogTagService\r\npackage com.luotao.job.service;import com.baomidou.mybatisplus.extension.service.IService;import com.luotao.job.domain.BlogTag;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.BlogTagVo;import java.util.List;/** * @author luotao * @description 博客标签服务接口 */public interface BlogTagService extends IService&lt;BlogTag&gt; &#123;    /**     * 获取所有标签列表     *     * @return 标签列表     */    ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getAllTags();        /**     * 创建标签     *     * @param name 标签名称     * @return 创建结果     */    ResponseResult&lt;Long&gt; createTag(String name);        /**     * 更新标签     *     * @param tagId 标签ID     * @param name 标签名称     * @return 更新结果     */    ResponseResult&lt;Void&gt; updateTag(Long tagId, String name);        /**     * 删除标签     *     * @param tagId 标签ID     * @return 删除结果     */    ResponseResult&lt;Void&gt; deleteTag(Long tagId);        /**     * 获取文章的标签列表     *     * @param postId 文章ID     * @return 标签列表     */    ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getPostTags(Long postId);&#125;\r\nBlogTagServiceImpl\r\n\r\n数据校验：\r\n创建和更新标签时，检查名称是否为空\r\n检查标签名称是否已存在，避免重复\r\n删除标签前，检查是否有文章使用该标签\r\n业务逻辑：\r\n获取标签列表时，同时查询每个标签关联的文章数量\r\n获取文章标签时，使用自定义SQL直接查询关联标签\r\n删除标签时，如果有关联文章则拒绝删除\r\n性能优化：\r\n使用自定义SQL查询标签及其文章数量\r\n使用Stream API进行数据转换\r\n\r\npackage com.luotao.job.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.luotao.job.domain.BlogPostTag;import com.luotao.job.domain.BlogTag;import com.luotao.job.mapper.BlogPostTagMapper;import com.luotao.job.mapper.BlogTagMapper;import com.luotao.job.service.BlogTagService;import com.luotao.job.utils.ResponseResult;import com.luotao.job.vo.BlogTagVo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import javax.annotation.Resource;import java.time.LocalDateTime;import java.util.List;import java.util.stream.Collectors;/** * @author luotao * @description 博客标签服务实现类 */@Slf4j@Servicepublic class BlogTagServiceImpl extends ServiceImpl&lt;BlogTagMapper, BlogTag&gt; implements BlogTagService &#123;    @Resource    private BlogPostTagMapper blogPostTagMapper;    /**     * 获取所有标签列表     *     * @return 标签列表     */    @Override    public ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getAllTags() &#123;        // 1. 查询所有标签及其文章数量        List&lt;BlogTag&gt; tags = baseMapper.selectTagWithCount();                // 2. 转换为VO对象        List&lt;BlogTagVo&gt; tagVos = tags.stream().map(tag -&gt; &#123;            BlogTagVo tagVo = new BlogTagVo();            tagVo.setId(tag.getId());            tagVo.setName(tag.getName());                        // 查询使用该标签的文章数量            LambdaQueryWrapper&lt;BlogPostTag&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(BlogPostTag::getTagId, tag.getId());//            int count = blogPostTagMapper.selectCount(queryWrapper);            Long countLong = blogPostTagMapper.selectCount(queryWrapper);            int count = (countLong == null) ? 0 : countLong.intValue();            tagVo.setPostCount(count);                        return tagVo;        &#125;).collect(Collectors.toList());                return new ResponseResult&lt;&gt;(200, &quot;获取成功&quot;, tagVos);    &#125;    /**     * 创建标签     *     * @param name 标签名称     * @return 创建结果     */    @Override    public ResponseResult&lt;Long&gt; createTag(String name) &#123;        try &#123;            // 1. 检查标签名称是否已存在            LambdaQueryWrapper&lt;BlogTag&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(BlogTag::getName, name);            if (this.count(queryWrapper) &gt; 0) &#123;                return new ResponseResult&lt;&gt;(400, &quot;标签名称已存在&quot;);            &#125;            // 2. 创建标签            BlogTag tag = new BlogTag();            tag.setName(name);            tag.setCreateTime(LocalDateTime.now());            tag.setUpdateTime(LocalDateTime.now());            // 3. 保存标签            this.save(tag);            return new ResponseResult&lt;&gt;(200, &quot;创建成功&quot;, tag.getId());        &#125; catch (Exception e) &#123;            log.error(&quot;创建标签失败: &quot;, e);            return new ResponseResult&lt;&gt;(500, &quot;创建标签失败&quot;);        &#125;    &#125;    /**     * 更新标签     *     * @param tagId 标签ID     * @param name  标签名称     * @return 更新结果     */    @Override    public ResponseResult&lt;Void&gt; updateTag(Long tagId, String name) &#123;        // 1. 检查标签是否存在        BlogTag tag = getById(tagId);        if (tag == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;标签不存在&quot;);        &#125;                // 2. 检查标签名称是否为空        if (!StringUtils.hasText(name)) &#123;            return new ResponseResult&lt;&gt;(400, &quot;标签名称不能为空&quot;);        &#125;                // 3. 如果修改了名称，检查名称是否已存在        if (!name.equals(tag.getName())) &#123;            LambdaQueryWrapper&lt;BlogTag&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();            queryWrapper.eq(BlogTag::getName, name);            if (baseMapper.selectCount(queryWrapper) &gt; 0) &#123;                return new ResponseResult&lt;&gt;(400, &quot;标签名称已存在&quot;);            &#125;        &#125;                // 4. 更新标签        tag.setName(name);        updateById(tag);                return new ResponseResult&lt;&gt;(200, &quot;更新成功&quot;);    &#125;    /**     * 删除标签     *     * @param tagId 标签ID     * @return 删除结果     */    @Override    public ResponseResult&lt;Void&gt; deleteTag(Long tagId) &#123;        // 1. 检查标签是否存在        BlogTag tag = getById(tagId);        if (tag == null) &#123;            return new ResponseResult&lt;&gt;(404, &quot;标签不存在&quot;);        &#125;                // 2. 检查是否有文章使用该标签        LambdaQueryWrapper&lt;BlogPostTag&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();        queryWrapper.eq(BlogPostTag::getTagId, tagId);//        int count = blogPostTagMapper.selectCount(queryWrapper);        Long countLong = blogPostTagMapper.selectCount(queryWrapper);        int count = (countLong == null) ? 0 : countLong.intValue();                if (count &gt; 0) &#123;            return new ResponseResult&lt;&gt;(400, &quot;该标签下有&quot; + count + &quot;篇文章，无法删除&quot;);        &#125;                // 3. 删除标签        removeById(tagId);                return new ResponseResult&lt;&gt;(200, &quot;删除成功&quot;);    &#125;    /**     * 获取文章的标签列表     *     * @param postId 文章ID     * @return 标签列表     */    @Override    public ResponseResult&lt;List&lt;BlogTagVo&gt;&gt; getPostTags(Long postId) &#123;        // 1. 查询文章的所有标签        List&lt;BlogTag&gt; tags = baseMapper.selectTagsByPostId(postId);                // 2. 转换为VO对象        List&lt;BlogTagVo&gt; tagVos = tags.stream().map(tag -&gt; &#123;            BlogTagVo tagVo = new BlogTagVo();            tagVo.setId(tag.getId());            tagVo.setName(tag.getName());            return tagVo;        &#125;).collect(Collectors.toList());                return new ResponseResult&lt;&gt;(200, &quot;获取成功&quot;, tagVos);    &#125;&#125;\r\n博客文章CRUD\r\n分类管理\r\n标签管理\r\nMarkdown导入导出\r\n文章统计\r\n评论管理模块\r\n用户权限管理\r\n搜索功能\r\n前端\r\n安装\r\n| v-md-editor\r\nVue3 + Element Plus + Vue Router + Vuex\r\n步骤1：更新左侧菜单\r\n首先，我们需要更新LeftMenu.vue，添加博客管理相关菜单项。\r\n步骤2：添加API封装\r\n在apis.js中添加博客相关API封装。\r\n步骤3：创建博客管理视图组件\r\n创建以下视图组件：\r\nBlogLayout.vue - 博客管理布局\r\nBlogPosts.vue - 文章列表\r\nBlogPostEdit.vue - 文章编辑（创建/修改）\r\nBlogCategories.vue - 分类管理\r\nBlogTags.vue - 标签管理\r\nBlogRecycle.vue - 回收站\r\n步骤4：更新路由配置\r\n在router/index.js中添加博客管理相关路由。\r\n步骤5：实现各功能模块\r\n逐步实现各功能模块的具体功能\r\nv-md-editor\r\nnpm i @kangc/v-md-editor@next -S\r\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;// 引入element-plus组件库import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;import VueMarkdownEditor from &#x27;@kangc/v-md-editor&#x27;;import &#x27;@kangc/v-md-editor/lib/style/base-editor.css&#x27;;import vuepressTheme from &#x27;@kangc/v-md-editor/lib/theme/vuepress.js&#x27;;import &#x27;@kangc/v-md-editor/lib/theme/style/vuepress.css&#x27;;import Prism from &#x27;prismjs&#x27;;VueMarkdownEditor.use(vuepressTheme, &#123;  Prism,&#125;);// 定义特性标志解决控制台警告：在生产环境中，为了获得更好的树摇优化，Vue 需要特定的特性标志，以减小生成的生产包的大小。window.__VUE_PROD_DEVTOOLS__ = false;window.__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;const app = createApp(App)// 注册所有 Element Plus 图标for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123;  app.component(key, component)&#125;app.use(store) // vuex状态管理app.use(router)app.use(ElementPlus)app.use(VueMarkdownEditor)app.mount(&#x27;#app&#x27;) // 绑定到id为app的元素上\r\n博客管理菜单项\r\n&lt;template&gt;    &lt;div&gt;        &lt;el-menu        :default-active=&quot;activeIndex&quot;        class=&quot;el-menu-vertical&quot;        :collapse=&quot;isCollapse&quot;        background-color=&quot;#545c64&quot;        text-color=&quot;#fff&quot;        active-text-color=&quot;#ffd04b&quot;        router        &gt;            &lt;el-menu-item index=&quot;/&quot;&gt;                &lt;el-icon&gt;&lt;Odometer /&gt;&lt;/el-icon&gt;                &lt;span&gt;数据分析&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;/dataList&quot;&gt;                &lt;el-icon&gt;&lt;Document /&gt;&lt;/el-icon&gt;                &lt;span&gt;数据列表&lt;/span&gt;            &lt;/el-menu-item&gt;                        &lt;el-menu-item index=&quot;/statistics&quot;&gt;                &lt;el-icon&gt;&lt;PieChart /&gt;&lt;/el-icon&gt;                &lt;span&gt;数据统计&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;!-- 博客管理菜单 --&gt;            &lt;el-sub-menu index=&quot;/blog&quot;&gt;                &lt;template #title&gt;                    &lt;el-icon&gt;&lt;Edit /&gt;&lt;/el-icon&gt;                    &lt;span&gt;博客管理&lt;/span&gt;                &lt;/template&gt;                &lt;el-menu-item index=&quot;/blog/posts&quot;&gt;                    &lt;el-icon&gt;&lt;Document /&gt;&lt;/el-icon&gt;                    &lt;span&gt;文章管理&lt;/span&gt;                &lt;/el-menu-item&gt;                &lt;el-menu-item index=&quot;/blog/categories&quot;&gt;                    &lt;el-icon&gt;&lt;Folder /&gt;&lt;/el-icon&gt;                    &lt;span&gt;分类管理&lt;/span&gt;                &lt;/el-menu-item&gt;                &lt;el-menu-item index=&quot;/blog/tags&quot;&gt;                    &lt;el-icon&gt;&lt;Collection /&gt;&lt;/el-icon&gt;                    &lt;span&gt;标签管理&lt;/span&gt;                &lt;/el-menu-item&gt;                &lt;el-menu-item index=&quot;/blog/recycle&quot;&gt;                    &lt;el-icon&gt;&lt;Delete /&gt;&lt;/el-icon&gt;                    &lt;span&gt;回收站&lt;/span&gt;                &lt;/el-menu-item&gt;            &lt;/el-sub-menu&gt;        &lt;/el-menu&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, onMounted, watch &#125; from &#x27;vue&#x27;import &#123; useRoute &#125; from &#x27;vue-router&#x27;import &#123;     Document,     Odometer,     PieChart,     Edit,     Folder,     Collection,     Delete &#125; from &#x27;@element-plus/icons-vue&#x27;// 控制菜单是否折叠const isCollapse = ref(false)// 当前激活的菜单项const activeIndex = ref(&#x27;/&#x27;)// 获取当前路由const route = useRoute()// 监听路由变化，更新激活的菜单项watch(() =&gt; route.path, (newPath) =&gt; &#123;    activeIndex.value = newPath&#125;)// 组件挂载时，根据当前路由设置激活的菜单项onMounted(() =&gt; &#123;    activeIndex.value = route.path&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.el-menu-vertical &#123;    height: 100%;    border-right: none;&#125;.el-menu-vertical:not(.el-menu--collapse) &#123;    width: 200px;&#125;&lt;/style&gt;\r\n博客管理路由\r\nimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import DataList from &#x27;@/views/DataList.vue&#x27;import Statistics from &#x27;@/views/Statistics.vue&#x27;import Analysis from &#x27;@/views/Analysis.vue&#x27;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;Analysis&#x27;,    component: Analysis,    meta:&#123;      title: &#x27;数据分析&#x27;    &#125;  &#125;,  &#123;    path: &#x27;/dataList&#x27;,    name: &#x27;DataList&#x27;,    component: DataList,    meta: &#123;      title: &#x27;数据列表&#x27;    &#125;  &#125;,  &#123;    path: &#x27;/statistics&#x27;,    name: &#x27;Statistics&#x27;,    component: Statistics,    meta:&#123;      title: &#x27;数据统计&#x27;    &#125;  &#125;,  // 博客管理路由  &#123;    path: &#x27;/blog&#x27;,    name: &#x27;Blog&#x27;,    redirect: &#x27;/blog/posts&#x27;,    meta: &#123;      title: &#x27;博客管理&#x27;    &#125;,    children: [      &#123;        path: &#x27;posts&#x27;,        name: &#x27;BlogPosts&#x27;,        component: () =&gt; import(&#x27;@/views/blog/BlogPosts.vue&#x27;),        meta: &#123;          title: &#x27;文章管理&#x27;        &#125;      &#125;,      &#123;        path: &#x27;post/create&#x27;,        name: &#x27;BlogPostCreate&#x27;,        component: () =&gt; import(&#x27;@/views/blog/BlogPostEdit.vue&#x27;),        meta: &#123;          title: &#x27;创建文章&#x27;        &#125;      &#125;,      &#123;        path: &#x27;post/edit/:id&#x27;,        name: &#x27;BlogPostEdit&#x27;,        component: () =&gt; import(&#x27;@/views/blog/BlogPostEdit.vue&#x27;),        meta: &#123;          title: &#x27;编辑文章&#x27;        &#125;      &#125;,      &#123;        path: &#x27;categories&#x27;,        name: &#x27;BlogCategories&#x27;,        component: () =&gt; import(&#x27;@/views/blog/BlogCategories.vue&#x27;),        meta: &#123;          title: &#x27;分类管理&#x27;        &#125;      &#125;,      &#123;        path: &#x27;tags&#x27;,        name: &#x27;BlogTags&#x27;,        component: () =&gt; import(&#x27;@/views/blog/BlogTags.vue&#x27;),        meta: &#123;          title: &#x27;标签管理&#x27;        &#125;      &#125;,      &#123;        path: &#x27;recycle&#x27;,        name: &#x27;BlogRecycle&#x27;,        component: () =&gt; import(&#x27;@/views/blog/BlogRecycle.vue&#x27;),        meta: &#123;          title: &#x27;回收站&#x27;        &#125;      &#125;    ]  &#125;]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)// 遍历路由以设置titlerouter.beforeEach((to, from, next) =&gt; &#123;  document.title = to.meta.title  next()&#125;)export default router\r\n在 apis.js\r\n中添加博客相关的API封装\r\n// 业务请求import&#123;request&#125; from &#x27;./axiosConfig&#x27;;// `vue.config.js`中配置了代理解决跨域。前端请求时url带该前缀时走代理请求到target指定的后端服务器上，并且请求路径中的该前缀被去掉，还原成后端接口原来的路径。const prefix =&#x27;/api&#x27;// 请求分页查询岗位数据的接口,参数page是想要获取第几页，即当前选中页码export function getJobListData(page)&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/page/&#x27; + page,        method:&#x27;get&#x27;    &#125;)&#125;// 封装按类别统计的业务请求export function getJobByCategory()&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/category/statistics&#x27;,        method:&#x27;get&#x27;    &#125;)&#125;// 封装按城市统计的业务请求export function getJobByCity()&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/city/statistics&#x27;,        method:&#x27;get&#x27;    &#125;)&#125;// 封装按城市统计的业务请求export function getJobByProvince()&#123;    return request(&#123;        url:prefix + &#x27;/job/v1/province/statistics&#x27;,        method:&#x27;get&#x27;    &#125;)&#125;// =================== 博客管理相关API ===================// 博客文章相关API// 获取文章列表export function getBlogPosts(queryParams) &#123;    return request(&#123;        url: prefix + &#x27;/blog/posts&#x27;,        method: &#x27;get&#x27;,        params: queryParams    &#125;)&#125;// 获取文章详情export function getBlogPostDetail(postId, increaseViewCount = true) &#123;    return request(&#123;        url: prefix + `/blog/posts/$&#123;postId&#125;`,        method: &#x27;get&#x27;,        params: &#123; increaseViewCount &#125;    &#125;)&#125;// 创建文章export function createBlogPost(userId, postData) &#123;    return request(&#123;        url: prefix + &#x27;/blog/posts&#x27;,        method: &#x27;post&#x27;,        params: &#123; userId &#125;,// 查询参数 如/api/blog/posts?userId=1。        data: postData    &#125;)&#125;// 更新文章export function updateBlogPost(userId, postId, postData) &#123;    return request(&#123;        url: prefix + `/blog/posts/$&#123;postId&#125;`,        method: &#x27;put&#x27;,        params: &#123; userId &#125;,        data: postData    &#125;)&#125;// 删除文章export function deleteBlogPost(userId, postId) &#123;    return request(&#123;        url: prefix + `/blog/posts/$&#123;postId&#125;`,        method: &#x27;delete&#x27;,        params: &#123; userId &#125;    &#125;)&#125;// 将文章移至回收站export function moveBlogPostToRecycleBin(userId, postId) &#123;    return request(&#123;        url: prefix + `/blog/posts/$&#123;postId&#125;/recycle`,        method: &#x27;put&#x27;,        params: &#123; userId &#125;    &#125;)&#125;// 从回收站恢复文章export function restoreBlogPostFromRecycleBin(userId, postId) &#123;    return request(&#123;        url: prefix + `/blog/posts/$&#123;postId&#125;/restore`,        method: &#x27;put&#x27;,        params: &#123; userId &#125;    &#125;)&#125;// 获取用户的文章列表export function getUserBlogPosts(userId, status) &#123;    return request(&#123;        url: prefix + `/blog/posts/user/$&#123;userId&#125;`,        method: &#x27;get&#x27;,        params: &#123; status &#125;    &#125;)&#125;// 博客分类相关API// 获取所有分类export function getBlogCategories() &#123;    return request(&#123;        url: prefix + &#x27;/blog/categories&#x27;,        method: &#x27;get&#x27;    &#125;)&#125;// 创建分类export function createBlogCategory(name, description, sort) &#123;    return request(&#123;        url: prefix + &#x27;/blog/categories&#x27;,        method: &#x27;post&#x27;,        params: &#123;             name: name,            description: description,            sort: sort        &#125;    &#125;)&#125;// 更新分类export function updateBlogCategory(categoryId, name, description, sort) &#123;    // 确保 categoryId 是数值类型    categoryId = Number(categoryId);        // 只传递非空参数    const params = &#123;&#125;;    if (name !== undefined &amp;&amp; name !== null) params.name = name;    if (description !== undefined &amp;&amp; description !== null) params.description = description;    if (sort !== undefined &amp;&amp; sort !== null) params.sort = sort;        return request(&#123;        url: prefix + `/blog/categories/$&#123;categoryId&#125;`,        method: &#x27;put&#x27;,        params: params    &#125;)&#125;// 删除分类export function deleteBlogCategory(categoryId) &#123;    return request(&#123;        url: prefix + `/blog/categories/$&#123;categoryId&#125;`,        method: &#x27;delete&#x27;    &#125;)&#125;// 博客标签相关API// 获取所有标签export function getBlogTags() &#123;    return request(&#123;        url: prefix + &#x27;/blog/tags&#x27;,        method: &#x27;get&#x27;    &#125;)&#125;// 创建标签export function createBlogTag(name) &#123;    return request(&#123;        url: prefix + &#x27;/blog/tags&#x27;,        // url: prefix + &#x27;/api/blog/tags&#x27;,         method: &#x27;post&#x27;,        params: &#123; name &#125;    &#125;)&#125;// 更新标签export function updateBlogTag(tagId, name) &#123;    return request(&#123;        url: prefix + `/blog/tags/$&#123;tagId&#125;`,        method: &#x27;put&#x27;,        params: &#123; name &#125;    &#125;)&#125;// 删除标签export function deleteBlogTag(tagId) &#123;    return request(&#123;        url: prefix + `/blog/tags/$&#123;tagId&#125;`,        method: &#x27;delete&#x27;    &#125;)&#125;// 获取文章的标签export function getBlogPostTags(postId) &#123;    return request(&#123;        url: prefix + `/blog/tags/post/$&#123;postId&#125;`,        method: &#x27;get&#x27;    &#125;)&#125;\r\n在\r\naxiosConfig.js 中添加请求和响应拦截器来记录详细信息\r\nimport axios from &#x27;axios&#x27;;/*Axios 的核心设计允许通过传递配置对象来动态定义请求行为。当你调用 instance(config) 时，Axios 会将 config 合并到实例的默认配置中（如 baseURL 和 timeout），然后发起请求。调用 request(config) 发起 HTTP 请求。如果请求成功，进入 .then 回调，response 是 Axios 返回的响应对象。如果请求失败（如网络错误或服务器返回错误状态码），进入 .catch 回调.*/// 声明函数并将其导出，以便在其他模块中使用。config 参数是一个对象，包含请求的配置信息。export function request(config)&#123;    // 创建Axios的实例本质上是一个函数，可以直接接收一个配置对象（config）作为参数，并根据该配置发起 HTTP 请求。    const instance = axios.create(&#123;        baseURL:&quot;&quot;, // 请求的基础 URL        timeout:8000,// 请求超时时间    &#125;)        // 添加请求拦截器    instance.interceptors.request.use(        config =&gt; &#123;            console.log(&#x27;请求配置:&#x27;, config);            return config;        &#125;,        error =&gt; &#123;            console.error(&#x27;请求错误:&#x27;, error);            return Promise.reject(error);        &#125;    );        // 添加响应拦截器    instance.interceptors.response.use(        response =&gt; &#123;            console.log(&#x27;响应数据:&#x27;, response);            return response;        &#125;,        error =&gt; &#123;            console.error(&#x27;响应错误:&#x27;, error);            return Promise.reject(error);        &#125;    );        return instance(config); //使用刚刚创建的 Axios 实例发送请求。Axios 实例会根据这些配置发送请求，并返回一个 Promise，该 Promise 解析为响应数据。&#125;\r\n创建博客文章列表组件（BlogPosts.vue）\r\n&lt;template&gt;  &lt;div class=&quot;blog-posts-container&quot;&gt;    &lt;div class=&quot;page-header&quot;&gt;      &lt;h2&gt;文章管理&lt;/h2&gt;      &lt;el-button type=&quot;primary&quot; @click=&quot;goToCreatePost&quot;&gt;        &lt;el-icon&gt;&lt;Plus /&gt;&lt;/el-icon&gt;新建文章      &lt;/el-button&gt;    &lt;/div&gt;    &lt;!-- 搜索区域 --&gt;    &lt;div class=&quot;search-container&quot;&gt;      &lt;el-form :inline=&quot;true&quot; :model=&quot;searchForm&quot; class=&quot;search-form&quot;&gt;        &lt;el-form-item label=&quot;标题&quot;&gt;          &lt;el-input v-model=&quot;searchForm.title&quot; placeholder=&quot;请输入文章标题&quot; clearable /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;分类&quot;&gt;          &lt;el-select v-model=&quot;searchForm.categoryId&quot; placeholder=&quot;请选择分类&quot; clearable&gt;            &lt;el-option v-for=&quot;item in categories&quot; :key=&quot;item.id&quot; :label=&quot;item.name&quot; :value=&quot;item.id&quot; /&gt;          &lt;/el-select&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;状态&quot;&gt;          &lt;el-select v-model=&quot;searchForm.status&quot; placeholder=&quot;请选择状态&quot; clearable&gt;            &lt;el-option :label=&quot;&#x27;草稿&#x27;&quot; :value=&quot;0&quot; /&gt;            &lt;el-option :label=&quot;&#x27;已发布&#x27;&quot; :value=&quot;1&quot; /&gt;          &lt;/el-select&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-button type=&quot;primary&quot; @click=&quot;handleSearch&quot;&gt;            &lt;el-icon&gt;&lt;Search /&gt;&lt;/el-icon&gt;搜索          &lt;/el-button&gt;          &lt;el-button @click=&quot;resetSearch&quot;&gt;            &lt;el-icon&gt;&lt;Refresh /&gt;&lt;/el-icon&gt;重置          &lt;/el-button&gt;        &lt;/el-form-item&gt;      &lt;/el-form&gt;    &lt;/div&gt;    &lt;!-- 文章列表 --&gt;    &lt;el-table      v-loading=&quot;loading&quot;      :data=&quot;postList&quot;      border      style=&quot;width: 100%&quot;      @selection-change=&quot;handleSelectionChange&quot;    &gt;      &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; /&gt;      &lt;el-table-column prop=&quot;title&quot; label=&quot;标题&quot; min-width=&quot;200&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-tooltip :content=&quot;scope.row.title&quot; placement=&quot;top&quot; :show-after=&quot;1000&quot;&gt;            &lt;span class=&quot;post-title&quot;&gt;&#123;&#123; scope.row.title &#125;&#125;&lt;/span&gt;          &lt;/el-tooltip&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column prop=&quot;categoryName&quot; label=&quot;分类&quot; width=&quot;120&quot; /&gt;      &lt;el-table-column prop=&quot;viewCount&quot; label=&quot;浏览量&quot; width=&quot;100&quot; sortable /&gt;      &lt;el-table-column prop=&quot;commentCount&quot; label=&quot;评论数&quot; width=&quot;100&quot; sortable /&gt;      &lt;el-table-column prop=&quot;likeCount&quot; label=&quot;点赞数&quot; width=&quot;100&quot; sortable /&gt;      &lt;el-table-column label=&quot;状态&quot; width=&quot;100&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-tag :type=&quot;scope.row.status === 1 ? &#x27;success&#x27; : &#x27;info&#x27;&quot;&gt;            &#123;&#123; scope.row.status === 1 ? &#x27;已发布&#x27; : &#x27;草稿&#x27; &#125;&#125;          &lt;/el-tag&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column prop=&quot;createTime&quot; label=&quot;创建时间&quot; width=&quot;180&quot; sortable /&gt;      &lt;el-table-column label=&quot;操作&quot; width=&quot;220&quot; fixed=&quot;right&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-button size=&quot;small&quot; @click=&quot;viewPost(scope.row)&quot;&gt;查看&lt;/el-button&gt;          &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;editPost(scope.row)&quot;&gt;编辑&lt;/el-button&gt;          &lt;el-button             size=&quot;small&quot;             type=&quot;danger&quot;             @click=&quot;moveToRecycleBin(scope.row)&quot;            v-if=&quot;scope.row.status !== 2&quot;          &gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;!-- 分页 --&gt;    &lt;div class=&quot;pagination-container&quot;&gt;      &lt;el-pagination        v-model:current-page=&quot;currentPage&quot;        v-model:page-size=&quot;pageSize&quot;        :page-sizes=&quot;[10, 20, 50, 100]&quot;        layout=&quot;total, sizes, prev, pager, next, jumper&quot;        :total=&quot;total&quot;        @size-change=&quot;handleSizeChange&quot;        @current-change=&quot;handleCurrentChange&quot;      /&gt;    &lt;/div&gt;    &lt;!-- 批量操作 --&gt;    &lt;div class=&quot;batch-actions&quot; v-if=&quot;selectedPosts.length &gt; 0&quot;&gt;      &lt;el-button type=&quot;danger&quot; @click=&quot;batchMoveToRecycleBin&quot;&gt;        批量删除 (&#123;&#123; selectedPosts.length &#125;&#125;)      &lt;/el-button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive, onMounted &#125; from &#x27;vue&#x27;import &#123; useRouter &#125; from &#x27;vue-router&#x27;import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;import &#123; Plus, Search, Refresh &#125; from &#x27;@element-plus/icons-vue&#x27;import &#123; getBlogPosts, getBlogCategories, moveBlogPostToRecycleBin &#125; from &#x27;@/utils/apis&#x27;const router = useRouter()const loading = ref(false)const postList = ref([])const categories = ref([])const selectedPosts = ref([])const total = ref(0)const currentPage = ref(1)const pageSize = ref(10)// 搜索表单const searchForm = reactive(&#123;  title: &#x27;&#x27;,  categoryId: &#x27;&#x27;,  status: &#x27;&#x27;&#125;)// 获取文章列表const fetchPosts = async () =&gt; &#123;  loading.value = true  try &#123;    const params = &#123;      page: currentPage.value,      size: pageSize.value,      title: searchForm.title || undefined,      categoryId: searchForm.categoryId || undefined,      status: searchForm.status !== &#x27;&#x27; ? searchForm.status : undefined    &#125;        const res = await getBlogPosts(params)    if (res.data &amp;&amp; res.data.code === 200) &#123;      postList.value = res.data.data.records      total.value = res.data.data.total    &#125; else &#123;      ElMessage.error(res.data.msg || &#x27;获取文章列表失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取文章列表出错:&#x27;, error)    ElMessage.error(&#x27;获取文章列表失败&#x27;)  &#125; finally &#123;    loading.value = false  &#125;&#125;// 获取分类列表const fetchCategories = async () =&gt; &#123;  try &#123;    const res = await getBlogCategories()    if (res.data &amp;&amp; res.data.code === 200) &#123;      categories.value = res.data.data    &#125; else &#123;      ElMessage.error(res.data.msg || &#x27;获取分类列表失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取分类列表出错:&#x27;, error)    ElMessage.error(&#x27;获取分类列表失败&#x27;)  &#125;&#125;// 搜索const handleSearch = () =&gt; &#123;  currentPage.value = 1  fetchPosts()&#125;// 重置搜索const resetSearch = () =&gt; &#123;  searchForm.title = &#x27;&#x27;  searchForm.categoryId = &#x27;&#x27;  searchForm.status = &#x27;&#x27;  currentPage.value = 1  fetchPosts()&#125;// 页码变化const handleCurrentChange = (val) =&gt; &#123;  currentPage.value = val  fetchPosts()&#125;// 每页条数变化const handleSizeChange = (val) =&gt; &#123;  pageSize.value = val  currentPage.value = 1  fetchPosts()&#125;// 选择变化const handleSelectionChange = (selection) =&gt; &#123;  selectedPosts.value = selection&#125;// 查看文章const viewPost = (row) =&gt; &#123;  // 这里可以跳转到文章详情页或者打开预览弹窗  ElMessage.info(&#x27;查看文章: &#x27; + row.title)&#125;// 编辑文章const editPost = (row) =&gt; &#123;  router.push(`/blog/post/edit/$&#123;row.id&#125;`)&#125;// 新建文章const goToCreatePost = () =&gt; &#123;  router.push(&#x27;/blog/post/create&#x27;)&#125;// 移动到回收站const moveToRecycleBin = (row) =&gt; &#123;  ElMessageBox.confirm(    `确定要将文章 &quot;$&#123;row.title&#125;&quot; 移至回收站吗？`,    &#x27;提示&#x27;,    &#123;      confirmButtonText: &#x27;确定&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;warning&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      // 这里使用一个固定的用户ID，实际应用中应该从登录用户信息中获取      const userId = 1      const res = await moveBlogPostToRecycleBin(userId, row.id)      if (res.data &amp;&amp; res.data.code === 200) &#123;        ElMessage.success(&#x27;已将文章移至回收站&#x27;)        fetchPosts()      &#125; else &#123;        ElMessage.error(res.data.msg || &#x27;操作失败&#x27;)      &#125;    &#125; catch (error) &#123;      console.error(&#x27;移动到回收站出错:&#x27;, error)      ElMessage.error(&#x27;操作失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 批量移动到回收站const batchMoveToRecycleBin = () =&gt; &#123;  if (selectedPosts.value.length === 0) &#123;    ElMessage.warning(&#x27;请选择要删除的文章&#x27;)    return  &#125;  ElMessageBox.confirm(    `确定要将选中的 $&#123;selectedPosts.value.length&#125; 篇文章移至回收站吗？`,    &#x27;提示&#x27;,    &#123;      confirmButtonText: &#x27;确定&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;warning&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      const userId = 1 // 固定用户ID，实际应用中应该从登录用户信息中获取      const promises = selectedPosts.value.map(post =&gt;         moveBlogPostToRecycleBin(userId, post.id)      )            await Promise.all(promises)      ElMessage.success(&#x27;已将选中文章移至回收站&#x27;)      fetchPosts()    &#125; catch (error) &#123;      console.error(&#x27;批量移动到回收站出错:&#x27;, error)      ElMessage.error(&#x27;操作失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 组件挂载时获取数据onMounted(() =&gt; &#123;  fetchCategories()  fetchPosts()&#125;)&lt;/script&gt;&lt;style scoped&gt;.blog-posts-container &#123;  padding: 20px;&#125;.page-header &#123;  display: flex;  justify-content: space-between;  align-items: center;  margin-bottom: 20px;&#125;.search-container &#123;  margin-bottom: 20px;  background-color: #f5f7fa;  padding: 15px;  border-radius: 4px;&#125;.post-title &#123;  display: inline-block;  max-width: 300px;  overflow: hidden;  text-overflow: ellipsis;  white-space: nowrap;&#125;.pagination-container &#123;  margin-top: 20px;  display: flex;  justify-content: flex-end;&#125;.batch-actions &#123;  margin-top: 20px;  padding: 10px;  background-color: #f5f7fa;  border-radius: 4px;&#125;&lt;/style&gt; \r\n博客文章编辑组件(BlogPostEdit.vue)\r\n&lt;template&gt;  &lt;div class=&quot;blog-post-edit-container&quot;&gt;    &lt;div class=&quot;page-header&quot;&gt;      &lt;h2&gt;&#123;&#123; isEdit ? &#x27;编辑文章&#x27; : &#x27;创建文章&#x27; &#125;&#125;&lt;/h2&gt;      &lt;div class=&quot;header-actions&quot;&gt;        &lt;el-button @click=&quot;goBack&quot;&gt;返回&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;saveAsDraft&quot;&gt;保存草稿&lt;/el-button&gt;        &lt;el-button type=&quot;success&quot; @click=&quot;publishPost&quot;&gt;发布文章&lt;/el-button&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;el-form :model=&quot;postForm&quot; :rules=&quot;rules&quot; ref=&quot;postFormRef&quot; label-width=&quot;100px&quot; class=&quot;post-form&quot;&gt;      &lt;el-form-item label=&quot;文章标题&quot; prop=&quot;title&quot;&gt;        &lt;el-input v-model=&quot;postForm.title&quot; placeholder=&quot;请输入文章标题&quot; maxlength=&quot;200&quot; show-word-limit /&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章分类&quot; prop=&quot;categoryId&quot;&gt;        &lt;el-select v-model=&quot;postForm.categoryId&quot; placeholder=&quot;请选择分类&quot;&gt;          &lt;el-option v-for=&quot;item in categories&quot; :key=&quot;item.id&quot; :label=&quot;item.name&quot; :value=&quot;item.id&quot; /&gt;        &lt;/el-select&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章标签&quot;&gt;        &lt;el-select          v-model=&quot;postForm.tagIds&quot;          multiple          filterable          :allow-create=&quot;false&quot;          placeholder=&quot;请选择标签&quot;          @change=&quot;handleTagSelect&quot;        &gt;          &lt;el-option            v-for=&quot;item in tagOptions&quot;            :key=&quot;item.value&quot;            :label=&quot;item.label&quot;            :value=&quot;item.value&quot;          /&gt;        &lt;/el-select&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章摘要&quot;&gt;        &lt;el-input          v-model=&quot;postForm.summary&quot;          type=&quot;textarea&quot;          :rows=&quot;3&quot;          placeholder=&quot;请输入文章摘要（选填）&quot;          maxlength=&quot;500&quot;          show-word-limit        /&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;封面图片&quot;&gt;        &lt;el-upload          class=&quot;cover-uploader&quot;          action=&quot;#&quot;          :http-request=&quot;uploadCover&quot;          :show-file-list=&quot;false&quot;          :before-upload=&quot;beforeCoverUpload&quot;        &gt;          &lt;img v-if=&quot;postForm.coverImage&quot; :src=&quot;postForm.coverImage&quot; class=&quot;cover-image&quot; /&gt;          &lt;el-icon v-else class=&quot;cover-uploader-icon&quot;&gt;&lt;Plus /&gt;&lt;/el-icon&gt;        &lt;/el-upload&gt;        &lt;div class=&quot;upload-tip&quot;&gt;建议尺寸: 1200 x 675 像素&lt;/div&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章内容&quot; prop=&quot;content&quot;&gt;        &lt;div class=&quot;editor-container&quot;&gt;          &lt;v-md-editor v-model=&quot;postForm.content&quot; height=&quot;500px&quot; @change=&quot;handleEditorChange&quot;&gt;&lt;/v-md-editor&gt;        &lt;/div&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;文章设置&quot;&gt;        &lt;el-checkbox v-model=&quot;postForm.isTop&quot;&gt;置顶文章&lt;/el-checkbox&gt;        &lt;el-checkbox v-model=&quot;postForm.isOriginal&quot;&gt;原创文章&lt;/el-checkbox&gt;      &lt;/el-form-item&gt;      &lt;el-form-item v-if=&quot;!postForm.isOriginal&quot; label=&quot;原文链接&quot;&gt;        &lt;el-input v-model=&quot;postForm.sourceUrl&quot; placeholder=&quot;请输入原文链接&quot; /&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive, computed, onMounted &#125; from &#x27;vue&#x27;import &#123; useRoute, useRouter &#125; from &#x27;vue-router&#x27;import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;import &#123; Plus &#125; from &#x27;@element-plus/icons-vue&#x27;import &#123;   getBlogPostDetail,   createBlogPost,   updateBlogPost,   getBlogCategories,   getBlogTags,  getBlogPostTags&#125; from &#x27;@/utils/apis&#x27;const route = useRoute()//当前路由对象const router = useRouter()const postFormRef = ref(null)const categories = ref([])const tags = ref([])// 判断是编辑还是创建const isEdit = computed(() =&gt; route.params.id !== undefined) //通过 useRoute().params 获取在路由定义中使用占位符（如 :id）来表示可以变化的部分。const postId = computed(() =&gt; route.params.id)// 表单数据const postForm = reactive(&#123;  title: &#x27;&#x27;,  content: &#x27;&#x27;,  summary: &#x27;&#x27;,  coverImage: &#x27;&#x27;,  categoryId: &#x27;&#x27;,  tagIds: [],  isTop: false,  isOriginal: true,  sourceUrl: &#x27;&#x27;,  status: 0 // 0: 草稿, 1: 已发布&#125;)// 表单验证规则const rules = &#123;  title: [    &#123; required: true, message: &#x27;请输入文章标题&#x27;, trigger: &#x27;blur&#x27; &#125;,    &#123; min: 2, max: 200, message: &#x27;标题长度在 2 到 200 个字符&#x27;, trigger: &#x27;blur&#x27; &#125;  ],  categoryId: [    &#123; required: true, message: &#x27;请选择文章分类&#x27;, trigger: &#x27;change&#x27; &#125;  ],  content: [    &#123; required: true, message: &#x27;请输入文章内容&#x27;, trigger: &#x27;blur&#x27; &#125;  ]&#125;// 获取文章详情const fetchPostDetail = async () =&gt; &#123;  if (!isEdit.value) return    try &#123;    const res = await getBlogPostDetail(postId.value, false)    if (res.data &amp;&amp; res.data.code === 200) &#123;      const postDetail = res.data.data            // 填充表单数据      postForm.title = postDetail.title      postForm.content = postDetail.content      postForm.summary = postDetail.summary      postForm.coverImage = postDetail.coverImage      postForm.categoryId = postDetail.categoryId      postForm.isTop = postDetail.isTop      postForm.isOriginal = postDetail.isOriginal      postForm.sourceUrl = postDetail.sourceUrl      postForm.status = postDetail.status            // 获取文章标签      fetchPostTags()    &#125; else &#123;      ElMessage.error(res.data.msg || &#x27;获取文章详情失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取文章详情出错:&#x27;, error)    ElMessage.error(&#x27;获取文章详情失败&#x27;)  &#125;&#125;// 获取文章标签const fetchPostTags = async () =&gt; &#123;  try &#123;    const res = await getBlogPostTags(postId.value)    if (res.data &amp;&amp; res.data.code === 200) &#123;      postForm.tagIds = res.data.data.map(tag =&gt; tag.id)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取文章标签出错:&#x27;, error)  &#125;&#125;// 获取分类列表const fetchCategories = async () =&gt; &#123;  try &#123;    const res = await getBlogCategories()    if (res.data &amp;&amp; res.data.code === 200) &#123;      categories.value = res.data.data    &#125; else &#123;      ElMessage.error(res.data.msg || &#x27;获取分类列表失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取分类列表出错:&#x27;, error)    ElMessage.error(&#x27;获取分类列表失败&#x27;)  &#125;&#125;// 获取标签列表const fetchTags = async () =&gt; &#123;  try &#123;    const res = await getBlogTags()    if (res.data &amp;&amp; res.data.code === 200) &#123;      tags.value = res.data.data    &#125; else &#123;      ElMessage.error(res.data.msg || &#x27;获取标签列表失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取标签列表出错:&#x27;, error)    ElMessage.error(&#x27;获取标签列表失败&#x27;)  &#125;&#125;// 上传封面图片前的验证const beforeCoverUpload = (file) =&gt; &#123;  const isImage = file.type.startsWith(&#x27;image/&#x27;)  const isLt2M = file.size / 1024 / 1024 &lt; 2  if (!isImage) &#123;    ElMessage.error(&#x27;封面图片只能是图片格式!&#x27;)  &#125;  if (!isLt2M) &#123;    ElMessage.error(&#x27;封面图片大小不能超过 2MB!&#x27;)  &#125;    return isImage &amp;&amp; isLt2M&#125;// 上传封面图片const uploadCover = (options) =&gt; &#123;  // 这里应该调用实际的上传API，这里仅做演示  // 实际项目中，应该将文件上传到服务器，然后获取返回的URL  const file = options.file  const reader = new FileReader()  reader.readAsDataURL(file)  reader.onload = () =&gt; &#123;    postForm.coverImage = reader.result    ElMessage.success(&#x27;封面上传成功&#x27;)  &#125;&#125;// 编辑器内容变化const handleEditorChange = (text) =&gt; &#123;  postForm.content = text&#125;// 保存草稿const saveAsDraft = () =&gt; &#123;  postForm.status = 0  savePost()&#125;// 发布文章const publishPost = () =&gt; &#123;  postForm.status = 1  savePost()&#125;// 保存文章const savePost = () =&gt; &#123;  postFormRef.value.validate(async (valid) =&gt; &#123;    /*  valid 是 el-form 组件的 validate 方法回调函数中的参数，表示表单验证的结果。它是由框架自动生成并传递给回调函数的布尔值*/    if (!valid) &#123;      ElMessage.error(&#x27;请完善表单信息&#x27;)      return    &#125;    try &#123;      // 构建请求数据      const postData = &#123;        title: postForm.title,        content: postForm.content,        summary: postForm.summary,        coverImage: postForm.coverImage,        categoryId: postForm.categoryId,        tagIds: postForm.tagIds,        isTop: postForm.isTop,        isOriginal: postForm.isOriginal,        sourceUrl: postForm.sourceUrl,        status: postForm.status      &#125;      // 确保标签ID是数值类型      if (postData.tagIds &amp;&amp; postData.tagIds.length &gt; 0) &#123;        postData.tagIds = postData.tagIds.map(id =&gt; &#123;          // 尝试将ID转换为数值          const numId = Number(id);          // 检查转换结果是否是有效数字          if (isNaN(numId)) &#123;            throw new Error(`标签ID &quot;$&#123;id&#125;&quot; 不是有效的数字`);          &#125;          return numId;        &#125;);      &#125;            // 固定用户ID，实际应用中应该从登录用户信息中获取      const userId = 1      let res      if (isEdit.value) &#123;        // 更新文章        res = await updateBlogPost(userId, postId.value, postData)      &#125; else &#123;        // 创建文章        res = await createBlogPost(userId, postData)      &#125;      if (res.data &amp;&amp; res.data.code === 200) &#123;        ElMessage.success(postForm.status === 1 ? &#x27;文章发布成功&#x27; : &#x27;草稿保存成功&#x27;)        router.push(&#x27;/blog/posts&#x27;) // 路由到文章管理      &#125; else &#123;        ElMessage.error(res.data.msg || &#x27;操作失败&#x27;)      &#125;    &#125; catch (error) &#123;      console.error(&#x27;保存文章出错:&#x27;, error)      ElMessage.error(&#x27;操作失败&#x27;)    &#125;  &#125;)&#125;// 返回列表const goBack = () =&gt; &#123;  ElMessageBox.confirm(    &#x27;确定要离开吗？未保存的内容将会丢失&#x27;,    &#x27;提示&#x27;,    &#123;      confirmButtonText: &#x27;确定&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;warning&#x27;    &#125;  ).then(() =&gt; &#123;    router.push(&#x27;/blog/posts&#x27;)  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 标签选择器配置const handleTagSelect = (value) =&gt; &#123;  // 确保所有选中的标签ID都是数值  postForm.tagIds = value.map(id =&gt; Number(id));&#125;// 加载标签列表const loadTags = async () =&gt; &#123;  try &#123;    const res = await getBlogTags();    if (res.data &amp;&amp; res.data.code === 200) &#123;      // 确保标签选项的值是数值类型      tagOptions.value = (res.data.data || []).map(tag =&gt; (&#123;        value: Number(tag.id),  // 确保ID是数值        label: tag.name      &#125;));    &#125;  &#125; catch (error) &#123;    console.error(&#x27;加载标签失败:&#x27;, error);  &#125;&#125;// 组件挂载时获取数据onMounted(() =&gt; &#123;  fetchCategories()  fetchTags()  if (isEdit.value) &#123;    fetchPostDetail()  &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;.blog-post-edit-container &#123;  padding: 20px;&#125;.page-header &#123;  display: flex;  justify-content: space-between;  align-items: center;  margin-bottom: 20px;&#125;.post-form &#123;  background-color: #fff;  padding: 20px;  border-radius: 4px;  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);&#125;.editor-container &#123;  border: 1px solid #dcdfe6;  border-radius: 4px;&#125;.cover-uploader &#123;  width: 300px;  height: 169px;  border: 1px dashed #d9d9d9;  border-radius: 6px;  cursor: pointer;  position: relative;  overflow: hidden;  display: flex;  justify-content: center;  align-items: center;&#125;.cover-uploader:hover &#123;  border-color: #409eff;&#125;.cover-uploader-icon &#123;  font-size: 28px;  color: #8c939d;  width: 300px;  height: 169px;  line-height: 169px;  text-align: center;&#125;.cover-image &#123;  width: 100%;  height: 100%;  object-fit: cover;&#125;.upload-tip &#123;  font-size: 12px;  color: #606266;  margin-top: 5px;&#125;&lt;/style&gt; \r\n\r\n博客分类管理组件(BlogCategories.vue)\r\n&lt;template&gt;  &lt;div class=&quot;blog-categories-container&quot;&gt;    &lt;div class=&quot;page-header&quot;&gt;      &lt;h2&gt;分类管理&lt;/h2&gt;      &lt;el-button type=&quot;primary&quot; @click=&quot;showAddCategoryDialog&quot;&gt;        &lt;el-icon&gt;&lt;Plus /&gt;&lt;/el-icon&gt;新建分类      &lt;/el-button&gt;    &lt;/div&gt;    &lt;!-- 分类列表 --&gt;    &lt;el-table      v-loading=&quot;loading&quot;      :data=&quot;categories&quot;      border      style=&quot;width: 100%&quot;    &gt;      &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;80&quot; /&gt;      &lt;el-table-column prop=&quot;name&quot; label=&quot;分类名称&quot; min-width=&quot;150&quot; /&gt;      &lt;el-table-column prop=&quot;description&quot; label=&quot;描述&quot; min-width=&quot;200&quot; /&gt;      &lt;el-table-column prop=&quot;postCount&quot; label=&quot;文章数量&quot; width=&quot;100&quot; sortable /&gt;      &lt;el-table-column prop=&quot;sort&quot; label=&quot;排序&quot; width=&quot;80&quot; sortable /&gt;      &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot; fixed=&quot;right&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;showEditCategoryDialog(scope.row)&quot;&gt;编辑&lt;/el-button&gt;          &lt;el-button             size=&quot;small&quot;             type=&quot;danger&quot;             @click=&quot;deleteCategory(scope.row)&quot;            :disabled=&quot;scope.row.postCount &gt; 0&quot;          &gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;!-- 新增/编辑分类对话框 --&gt;    &lt;el-dialog      :title=&quot;dialogType === &#x27;add&#x27; ? &#x27;新建分类&#x27; : &#x27;编辑分类&#x27;&quot;      v-model=&quot;dialogVisible&quot;      width=&quot;500px&quot;    &gt;      &lt;el-form :model=&quot;categoryForm&quot; :rules=&quot;rules&quot; ref=&quot;categoryFormRef&quot; label-width=&quot;80px&quot;&gt;        &lt;el-form-item label=&quot;分类名称&quot; prop=&quot;name&quot;&gt;          &lt;el-input v-model=&quot;categoryForm.name&quot; placeholder=&quot;请输入分类名称&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;描述&quot; prop=&quot;description&quot;&gt;          &lt;el-input             v-model=&quot;categoryForm.description&quot;             type=&quot;textarea&quot;             :rows=&quot;3&quot;             placeholder=&quot;请输入分类描述&quot;           /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;排序&quot; prop=&quot;sort&quot;&gt;          &lt;el-input-number v-model=&quot;categoryForm.sort&quot; :min=&quot;0&quot; :max=&quot;999&quot; /&gt;        &lt;/el-form-item&gt;      &lt;/el-form&gt;      &lt;template #footer&gt;        &lt;span class=&quot;dialog-footer&quot;&gt;          &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt;          &lt;el-button type=&quot;primary&quot; @click=&quot;submitCategoryForm&quot;&gt;确定&lt;/el-button&gt;        &lt;/span&gt;      &lt;/template&gt;    &lt;/el-dialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive, onMounted &#125; from &#x27;vue&#x27;import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;import &#123;   getBlogCategories,   createBlogCategory,   updateBlogCategory,   deleteBlogCategory &#125; from &#x27;@/utils/apis&#x27;// 分类列表数据const categories = ref([])// 加载状态const loading = ref(false)// 对话框可见性const dialogVisible = ref(false)// 对话框类型：add-新增，edit-编辑const dialogType = ref(&#x27;add&#x27;)// 分类表单引用const categoryFormRef = ref(null)// 当前编辑的分类IDconst currentCategoryId = ref(null)// 分类表单数据const categoryForm = reactive(&#123;  name: &#x27;&#x27;,  description: &#x27;&#x27;,  sort: 0&#125;)// 表单验证规则const rules = &#123;  name: [    &#123; required: true, message: &#x27;请输入分类名称&#x27;, trigger: &#x27;blur&#x27; &#125;,    &#123; max: 50, message: &#x27;分类名称不能超过50个字符&#x27;, trigger: &#x27;blur&#x27; &#125;  ],  description: [    &#123; max: 200, message: &#x27;描述不能超过200个字符&#x27;, trigger: &#x27;blur&#x27; &#125;  ]&#125;// 获取分类列表const fetchCategories = async () =&gt; &#123;  loading.value = true  try &#123;    const res = await getBlogCategories()    if (res.data &amp;&amp; res.data.code === 200) &#123;      categories.value = res.data.data || []    &#125; else &#123;      ElMessage.error(res.data?.msg || &#x27;获取分类列表失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取分类列表出错:&#x27;, error)    ElMessage.error(&#x27;获取分类列表失败&#x27;)  &#125; finally &#123;    loading.value = false  &#125;&#125;// 显示新增分类对话框const showAddCategoryDialog = () =&gt; &#123;  dialogType.value = &#x27;add&#x27;  resetCategoryForm()  dialogVisible.value = true&#125;// 显示编辑分类对话框const showEditCategoryDialog = (category) =&gt; &#123;  dialogType.value = &#x27;edit&#x27;    // 确保 category.id 是有效的数值  currentCategoryId.value = Number(category.id)    // 填充表单数据  categoryForm.name = category.name  categoryForm.description = category.description || &#x27;&#x27;  categoryForm.sort = category.sort || 0    dialogVisible.value = true&#125;// 重置分类表单const resetCategoryForm = () =&gt; &#123;  if (categoryFormRef.value) &#123;    categoryFormRef.value.resetFields()  &#125;  categoryForm.name = &#x27;&#x27;  categoryForm.description = &#x27;&#x27;  categoryForm.sort = 0  currentCategoryId.value = null&#125;// 提交分类表单const submitCategoryForm = async () =&gt; &#123;  if (!categoryFormRef.value) return    await categoryFormRef.value.validate(async (valid) =&gt; &#123;    if (!valid) return        try &#123;      if (dialogType.value === &#x27;add&#x27;) &#123;        // 新增分类        const res = await createBlogCategory(          categoryForm.name,          categoryForm.description,          categoryForm.sort        )                if (res.data &amp;&amp; res.data.code === 200) &#123;          ElMessage.success(&#x27;分类创建成功&#x27;)          dialogVisible.value = false          fetchCategories()        &#125; else &#123;          ElMessage.error(res.data?.msg || &#x27;创建分类失败&#x27;)        &#125;      &#125; else &#123;        // 编辑分类 - 确保 currentCategoryId.value 是有效的数值        if (!currentCategoryId.value) &#123;          ElMessage.error(&#x27;分类ID无效&#x27;)          return        &#125;                // 打印调试信息        console.log(&#x27;更新分类ID:&#x27;, currentCategoryId.value, typeof currentCategoryId.value)        console.log(&#x27;更新分类参数:&#x27;, &#123;          name: categoryForm.name,          description: categoryForm.description,          sort: categoryForm.sort        &#125;)                const res = await updateBlogCategory(          currentCategoryId.value,          categoryForm.name,          categoryForm.description,          categoryForm.sort        )                if (res.data &amp;&amp; res.data.code === 200) &#123;          ElMessage.success(&#x27;分类更新成功&#x27;)          dialogVisible.value = false          fetchCategories()        &#125; else &#123;          ElMessage.error(res.data?.msg || &#x27;更新分类失败&#x27;)        &#125;      &#125;    &#125; catch (error) &#123;      console.error(&#x27;提交分类表单出错:&#x27;, error)      ElMessage.error(&#x27;操作失败&#x27;)    &#125;  &#125;)&#125;// 删除分类const deleteCategory = (category) =&gt; &#123;  if (category.postCount &gt; 0) &#123;    ElMessage.warning(`该分类下有$&#123;category.postCount&#125;篇文章，无法删除`)    return  &#125;    ElMessageBox.confirm(    `确定要删除分类&quot;$&#123;category.name&#125;&quot;吗？`,    &#x27;提示&#x27;,    &#123;      confirmButtonText: &#x27;确定&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;warning&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      const res = await deleteBlogCategory(category.id)            if (res.data &amp;&amp; res.data.code === 200) &#123;        ElMessage.success(&#x27;分类删除成功&#x27;)        fetchCategories()      &#125; else &#123;        ElMessage.error(res.data?.msg || &#x27;删除分类失败&#x27;)      &#125;    &#125; catch (error) &#123;      console.error(&#x27;删除分类出错:&#x27;, error)      ElMessage.error(&#x27;删除失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 组件挂载时获取数据onMounted(() =&gt; &#123;  fetchCategories()&#125;)&lt;/script&gt;&lt;style scoped&gt;.blog-categories-container &#123;  padding: 20px;&#125;.page-header &#123;  display: flex;  justify-content: space-between;  align-items: center;  margin-bottom: 20px;&#125;.dialog-footer &#123;  display: flex;  justify-content: flex-end;&#125;&lt;/style&gt; \r\n博客标签管理组件(BlogTags.vue)\r\n&lt;template&gt;  &lt;div class=&quot;blog-tags-container&quot;&gt;    &lt;div class=&quot;page-header&quot;&gt;      &lt;h2&gt;标签管理&lt;/h2&gt;      &lt;el-button type=&quot;primary&quot; @click=&quot;showAddTagDialog&quot;&gt;        &lt;el-icon&gt;&lt;Plus /&gt;&lt;/el-icon&gt;新建标签      &lt;/el-button&gt;    &lt;/div&gt;    &lt;!-- 标签列表 --&gt;    &lt;el-table      v-loading=&quot;loading&quot;      :data=&quot;tags&quot;      border      style=&quot;width: 100%&quot;    &gt;      &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;80&quot; /&gt;      &lt;el-table-column prop=&quot;name&quot; label=&quot;标签名称&quot; min-width=&quot;150&quot; /&gt;      &lt;el-table-column prop=&quot;postCount&quot; label=&quot;文章数量&quot; width=&quot;100&quot; sortable /&gt;      &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot; fixed=&quot;right&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;showEditTagDialog(scope.row)&quot;&gt;编辑&lt;/el-button&gt;          &lt;el-button             size=&quot;small&quot;             type=&quot;danger&quot;             @click=&quot;deleteTag(scope.row)&quot;            :disabled=&quot;scope.row.postCount &gt; 0&quot;          &gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;!-- 新增/编辑标签对话框 --&gt;    &lt;el-dialog      :title=&quot;dialogType === &#x27;add&#x27; ? &#x27;新建标签&#x27; : &#x27;编辑标签&#x27;&quot;      v-model=&quot;dialogVisible&quot;      width=&quot;400px&quot;    &gt;      &lt;el-form :model=&quot;tagForm&quot; :rules=&quot;rules&quot; ref=&quot;tagFormRef&quot; label-width=&quot;80px&quot;&gt;        &lt;el-form-item label=&quot;标签名称&quot; prop=&quot;name&quot;&gt;          &lt;el-input v-model=&quot;tagForm.name&quot; placeholder=&quot;请输入标签名称&quot; /&gt;        &lt;/el-form-item&gt;      &lt;/el-form&gt;      &lt;template #footer&gt;        &lt;span class=&quot;dialog-footer&quot;&gt;          &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt;          &lt;el-button type=&quot;primary&quot; @click=&quot;submitTagForm&quot;&gt;确定&lt;/el-button&gt;        &lt;/span&gt;      &lt;/template&gt;    &lt;/el-dialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive, onMounted &#125; from &#x27;vue&#x27;import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;import &#123;   getBlogTags,   createBlogTag,   updateBlogTag,   deleteBlogTag &#125; from &#x27;@/utils/apis&#x27;// 标签列表数据const tags = ref([])// 加载状态const loading = ref(false)// 对话框可见性const dialogVisible = ref(false)// 对话框类型：add-新增，edit-编辑const dialogType = ref(&#x27;add&#x27;)// 标签表单引用const tagFormRef = ref(null)// 当前编辑的标签IDconst currentTagId = ref(null)// 标签表单数据const tagForm = reactive(&#123;  name: &#x27;&#x27;&#125;)// 表单验证规则const rules = &#123;  name: [    &#123; required: true, message: &#x27;请输入标签名称&#x27;, trigger: &#x27;blur&#x27; &#125;,    &#123; max: 50, message: &#x27;标签名称不能超过50个字符&#x27;, trigger: &#x27;blur&#x27; &#125;  ]&#125;// 获取标签列表const fetchTags = async () =&gt; &#123;  loading.value = true  try &#123;    const res = await getBlogTags()    if (res.data &amp;&amp; res.data.code === 200) &#123;      tags.value = res.data.data || []    &#125; else &#123;      ElMessage.error(res.data?.msg || &#x27;获取标签列表失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取标签列表出错:&#x27;, error)    ElMessage.error(&#x27;获取标签列表失败&#x27;)  &#125; finally &#123;    loading.value = false  &#125;&#125;// 显示新增标签对话框const showAddTagDialog = () =&gt; &#123;  dialogType.value = &#x27;add&#x27;  resetTagForm()  dialogVisible.value = true&#125;// 显示编辑标签对话框const showEditTagDialog = (tag) =&gt; &#123;  dialogType.value = &#x27;edit&#x27;  currentTagId.value = tag.id  resetTagForm()    // 填充表单数据  tagForm.name = tag.name    dialogVisible.value = true&#125;// 重置标签表单const resetTagForm = () =&gt; &#123;  if (tagFormRef.value) &#123;    tagFormRef.value.resetFields()  &#125;  tagForm.name = &#x27;&#x27;  currentTagId.value = null&#125;// 提交标签表单const submitTagForm = async () =&gt; &#123;  if (!tagFormRef.value) return    await tagFormRef.value.validate(async (valid) =&gt; &#123;    if (!valid) return        try &#123;      if (dialogType.value === &#x27;add&#x27;) &#123;        // 新增标签        const res = await createBlogTag(tagForm.name)        console.log(&#x27;@&#x27;,res);                if (res.data &amp;&amp; res.data.code === 200) &#123;          ElMessage.success(&#x27;标签创建成功&#x27;)          dialogVisible.value = false          fetchTags()        &#125; else &#123;          ElMessage.error(res.data?.msg || &#x27;创建标签失败&#x27;)        &#125;      &#125; else &#123;        // 编辑标签        const res = await updateBlogTag(currentTagId.value, tagForm.name)                if (res.data &amp;&amp; res.data.code === 200) &#123;          ElMessage.success(&#x27;标签更新成功&#x27;)          dialogVisible.value = false          fetchTags()        &#125; else &#123;          ElMessage.error(res.data?.msg || &#x27;更新标签失败&#x27;)        &#125;      &#125;    &#125; catch (error) &#123;      console.error(&#x27;提交标签表单出错:&#x27;, error)      ElMessage.error(&#x27;操作失败&#x27;)    &#125;  &#125;)&#125;// 删除标签const deleteTag = (tag) =&gt; &#123;  if (tag.postCount &gt; 0) &#123;    ElMessage.warning(`该标签下有$&#123;tag.postCount&#125;篇文章，无法删除`)    return  &#125;    ElMessageBox.confirm(    `确定要删除标签&quot;$&#123;tag.name&#125;&quot;吗？`,    &#x27;提示&#x27;,    &#123;      confirmButtonText: &#x27;确定&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;warning&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      const res = await deleteBlogTag(tag.id)            if (res.data &amp;&amp; res.data.code === 200) &#123;        ElMessage.success(&#x27;标签删除成功&#x27;)        fetchTags()      &#125; else &#123;        ElMessage.error(res.data?.msg || &#x27;删除标签失败&#x27;)      &#125;    &#125; catch (error) &#123;      console.error(&#x27;删除标签出错:&#x27;, error)      ElMessage.error(&#x27;删除失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 组件挂载时获取数据onMounted(() =&gt; &#123;  fetchTags()&#125;)&lt;/script&gt;&lt;style scoped&gt;.blog-tags-container &#123;  padding: 20px;&#125;.page-header &#123;  display: flex;  justify-content: space-between;  align-items: center;  margin-bottom: 20px;&#125;.dialog-footer &#123;  display: flex;  justify-content: flex-end;&#125;&lt;/style&gt; \r\n博客回收站组件(BlogRecycle.vue)\r\n&lt;template&gt;  &lt;div class=&quot;blog-recycle-container&quot;&gt;    &lt;div class=&quot;page-header&quot;&gt;      &lt;h2&gt;回收站&lt;/h2&gt;      &lt;div class=&quot;header-actions&quot;&gt;        &lt;el-button type=&quot;danger&quot; @click=&quot;batchDeletePosts&quot; :disabled=&quot;selectedPosts.length === 0&quot;&gt;          &lt;el-icon&gt;&lt;Delete /&gt;&lt;/el-icon&gt;永久删除        &lt;/el-button&gt;        &lt;el-button type=&quot;success&quot; @click=&quot;batchRestorePosts&quot; :disabled=&quot;selectedPosts.length === 0&quot;&gt;          &lt;el-icon&gt;&lt;RefreshRight /&gt;&lt;/el-icon&gt;恢复文章        &lt;/el-button&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- 文章列表 --&gt;    &lt;el-table      v-loading=&quot;loading&quot;      :data=&quot;postList&quot;      border      style=&quot;width: 100%&quot;      @selection-change=&quot;handleSelectionChange&quot;    &gt;      &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; /&gt;      &lt;el-table-column prop=&quot;title&quot; label=&quot;标题&quot; min-width=&quot;200&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-tooltip :content=&quot;scope.row.title&quot; placement=&quot;top&quot; :show-after=&quot;1000&quot;&gt;            &lt;span class=&quot;post-title&quot;&gt;&#123;&#123; scope.row.title &#125;&#125;&lt;/span&gt;          &lt;/el-tooltip&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column prop=&quot;categoryName&quot; label=&quot;分类&quot; width=&quot;120&quot; /&gt;      &lt;el-table-column prop=&quot;authorName&quot; label=&quot;作者&quot; width=&quot;120&quot; /&gt;      &lt;el-table-column prop=&quot;createTime&quot; label=&quot;创建时间&quot; width=&quot;180&quot; sortable /&gt;      &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot; fixed=&quot;right&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-button size=&quot;small&quot; type=&quot;success&quot; @click=&quot;restorePost(scope.row)&quot;&gt;恢复&lt;/el-button&gt;          &lt;el-button size=&quot;small&quot; type=&quot;danger&quot; @click=&quot;deletePost(scope.row)&quot;&gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;!-- 分页 --&gt;    &lt;div class=&quot;pagination-container&quot;&gt;      &lt;el-pagination        v-model:current-page=&quot;currentPage&quot;        v-model:page-size=&quot;pageSize&quot;        :page-sizes=&quot;[10, 20, 50, 100]&quot;        layout=&quot;total, sizes, prev, pager, next, jumper&quot;        :total=&quot;total&quot;        @size-change=&quot;handleSizeChange&quot;        @current-change=&quot;handleCurrentChange&quot;      /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive, onMounted &#125; from &#x27;vue&#x27;import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;import &#123;   getBlogPosts,   deleteBlogPost,   restoreBlogPostFromRecycleBin &#125; from &#x27;@/utils/apis&#x27;// 文章列表数据const postList = ref([])// 加载状态const loading = ref(false)// 选中的文章const selectedPosts = ref([])// 分页相关const currentPage = ref(1)const pageSize = ref(10)const total = ref(0)// 获取回收站文章列表const fetchPosts = async () =&gt; &#123;  loading.value = true  try &#123;    const res = await getBlogPosts(&#123;      page: currentPage.value,      size: pageSize.value,      status: 2 // 回收站状态    &#125;)        if (res.data &amp;&amp; res.data.code === 200) &#123;      const data = res.data.data      postList.value = data.records || []      total.value = data.total || 0    &#125; else &#123;      ElMessage.error(res.data?.msg || &#x27;获取回收站文章失败&#x27;)    &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取回收站文章出错:&#x27;, error)    ElMessage.error(&#x27;获取回收站文章失败&#x27;)  &#125; finally &#123;    loading.value = false  &#125;&#125;// 处理选择变化const handleSelectionChange = (selection) =&gt; &#123;  selectedPosts.value = selection&#125;// 处理每页显示数量变化const handleSizeChange = (size) =&gt; &#123;  pageSize.value = size  fetchPosts()&#125;// 处理页码变化const handleCurrentChange = (page) =&gt; &#123;  currentPage.value = page  fetchPosts()&#125;// 恢复单篇文章const restorePost = (post) =&gt; &#123;  ElMessageBox.confirm(    `确定要恢复文章&quot;$&#123;post.title&#125;&quot;吗？`,    &#x27;提示&#x27;,    &#123;      confirmButtonText: &#x27;确定&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;info&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      const userId = 1 // 固定用户ID，实际应用中应该从登录用户信息中获取      const res = await restoreBlogPostFromRecycleBin(userId, post.id)            if (res.data &amp;&amp; res.data.code === 200) &#123;        ElMessage.success(&#x27;文章已恢复&#x27;)        fetchPosts()      &#125; else &#123;        ElMessage.error(res.data?.msg || &#x27;恢复文章失败&#x27;)      &#125;    &#125; catch (error) &#123;      console.error(&#x27;恢复文章出错:&#x27;, error)      ElMessage.error(&#x27;恢复失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 永久删除单篇文章const deletePost = (post) =&gt; &#123;  ElMessageBox.confirm(    `确定要永久删除文章&quot;$&#123;post.title&#125;&quot;吗？此操作不可恢复！`,    &#x27;警告&#x27;,    &#123;      confirmButtonText: &#x27;确定删除&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;warning&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      const userId = 1 // 固定用户ID，实际应用中应该从登录用户信息中获取      const res = await deleteBlogPost(userId, post.id)            if (res.data &amp;&amp; res.data.code === 200) &#123;        ElMessage.success(&#x27;文章已永久删除&#x27;)        fetchPosts()      &#125; else &#123;        ElMessage.error(res.data?.msg || &#x27;删除文章失败&#x27;)      &#125;    &#125; catch (error) &#123;      console.error(&#x27;删除文章出错:&#x27;, error)      ElMessage.error(&#x27;删除失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 批量恢复文章const batchRestorePosts = () =&gt; &#123;  if (selectedPosts.value.length === 0) &#123;    return  &#125;  ElMessageBox.confirm(    `确定要恢复选中的 $&#123;selectedPosts.value.length&#125; 篇文章吗？`,    &#x27;提示&#x27;,    &#123;      confirmButtonText: &#x27;确定&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;info&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      const userId = 1 // 固定用户ID，实际应用中应该从登录用户信息中获取      const promises = selectedPosts.value.map(post =&gt;         restoreBlogPostFromRecycleBin(userId, post.id)      )            await Promise.all(promises)      ElMessage.success(&#x27;已恢复选中文章&#x27;)      fetchPosts()    &#125; catch (error) &#123;      console.error(&#x27;批量恢复文章出错:&#x27;, error)      ElMessage.error(&#x27;操作失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 批量永久删除文章const batchDeletePosts = () =&gt; &#123;  if (selectedPosts.value.length === 0) &#123;    return  &#125;  ElMessageBox.confirm(    `确定要永久删除选中的 $&#123;selectedPosts.value.length&#125; 篇文章吗？此操作不可恢复！`,    &#x27;警告&#x27;,    &#123;      confirmButtonText: &#x27;确定删除&#x27;,      cancelButtonText: &#x27;取消&#x27;,      type: &#x27;warning&#x27;    &#125;  ).then(async () =&gt; &#123;    try &#123;      const userId = 1 // 固定用户ID，实际应用中应该从登录用户信息中获取      const promises = selectedPosts.value.map(post =&gt;         deleteBlogPost(userId, post.id)      )            await Promise.all(promises)      ElMessage.success(&#x27;已永久删除选中文章&#x27;)      fetchPosts()    &#125; catch (error) &#123;      console.error(&#x27;批量删除文章出错:&#x27;, error)      ElMessage.error(&#x27;操作失败&#x27;)    &#125;  &#125;).catch(() =&gt; &#123;    // 取消操作  &#125;)&#125;// 组件挂载时获取数据onMounted(() =&gt; &#123;  fetchPosts()&#125;)&lt;/script&gt;&lt;style scoped&gt;.blog-recycle-container &#123;  padding: 20px;&#125;.page-header &#123;  display: flex;  justify-content: space-between;  align-items: center;  margin-bottom: 20px;&#125;.header-actions &#123;  display: flex;  gap: 10px;&#125;.post-title &#123;  display: inline-block;  max-width: 300px;  overflow: hidden;  text-overflow: ellipsis;  white-space: nowrap;&#125;.pagination-container &#123;  margin-top: 20px;  display: flex;  justify-content: flex-end;&#125;&lt;/style&gt; \r\n用户登录\r\n\r\n状态管理设计 ：\r\n使用Vuex集中管理用户状态（user）、登录状态（isAuthenticated）和token\r\n通过getters提供状态访问接口\r\n通过mutations提供状态修改方法\r\n通过actions封装业务逻辑（登录、注销、检查登录状态）\r\nAPI设计 ：\r\n在apis.js中统一管理所有用户相关API\r\n接口路径与后端保持一致（/user/login, /user/info等）\r\n使用统一的request方法发送请求\r\nAxios拦截器设计 ：\r\n请求拦截器：自动添加token到请求头\r\n响应拦截器：统一处理错误（特别是401未授权错误）\r\n自动保存响应中的token到store\r\n登录组件设计 ：\r\n使用Element Plus表单组件\r\n表单验证规则与后端一致\r\n通过Vuex action处理登录逻辑\r\n提供友好的用户反馈（加载状态、成功/失败提示）\r\n安全性考虑 ：\r\n密码在传输前应该加密（可以在前端做MD5加密）\r\ntoken存储在Vuex中，不推荐长期存储在localStorage\r\n401错误自动注销并清理用户信息\r\n\r\n轮播图数据库设计\r\nCREATE TABLE `blog_carousel` (    `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,    `title` VARCHAR(100) NOT NULL COMMENT &#x27;轮播图标题&#x27;,    `description` VARCHAR(255) DEFAULT NULL COMMENT &#x27;轮播图描述&#x27;,    `image_url` VARCHAR(1000) NOT NULL COMMENT &#x27;轮播图图片URL&#x27;,    `link_url` VARCHAR(1000) DEFAULT NULL COMMENT &#x27;轮播图跳转链接&#x27;,    `sort` INT(11) NOT NULL DEFAULT 0 COMMENT &#x27;轮播图排序（数字越小越靠前）&#x27;,    `status` TINYINT(1) NOT NULL DEFAULT 1 COMMENT &#x27;轮播图状态（0:禁用, 1:启用）&#x27;,    `target_type` VARCHAR(20) DEFAULT NULL COMMENT &#x27;跳转目标类型（如：文章、活动、外部链接等）&#x27;,    `target_id` BIGINT(20) DEFAULT NULL COMMENT &#x27;跳转目标ID（如文章ID、活动ID等）&#x27;,    `language` VARCHAR(10) DEFAULT &#x27;zh-CN&#x27; COMMENT &#x27;语言（如：zh-CN, en-US等）&#x27;,    `start_time` DATETIME DEFAULT NULL COMMENT &#x27;轮播图开始展示时间&#x27;,    `end_time` DATETIME DEFAULT NULL COMMENT &#x27;轮播图结束展示时间&#x27;,    `width` INT(11) DEFAULT NULL COMMENT &#x27;图片宽度（单位：像素）&#x27;,    `height` INT(11) DEFAULT NULL COMMENT &#x27;图片高度（单位：像素）&#x27;,    `click_count` INT(11) NOT NULL DEFAULT 0 COMMENT &#x27;点击次数&#x27;,    `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,    `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,    PRIMARY KEY (`id`),    KEY `idx_sort` (`sort`),    KEY `idx_status` (`status`),    KEY `idx_create_time` (`create_time`),    KEY `idx_language` (`language`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;轮播图表&#x27;;\r\n"},{"title":"网络协议","url":"/2024/05/03/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/","content":"环境搭建\r\n\r\nCisco Packet Tracer\r\n\r\n\r\n\r\ntomcat\r\n\r\n\r\n\r\nimage-20240504012420439\r\n\r\n客户端-服务器\r\n\r\n\r\ncs\r\n\r\n网络互连模型\r\n\r\n\r\n网络互连模型\r\n\r\n\r\n1985年ISO（国际标准化组织）制定网络互连模型OSI（openSystemInterconnectReferenceModel）\r\n\r\n请求过程\r\n\r\n\r\n请求过程\r\n\r\n计算机通信基础\r\n\r\n需要得知目标IP\r\n最终根据MAC地址(网卡地址)输送到网卡\r\n网卡发现数据的目标MAC地址是自己则将数据传递给上一层处理，否则丢弃\r\n网线直连、同轴电缆、集线器、网桥、交换机连接的设备必须在同一广播域才能通信。\r\n\r\n网桥\r\n\r\n\r\nimage-20240504151605518\r\n\r\n交换机\r\n\r\n\r\n交换机\r\n\r\n\r\n相当于接口更多的网桥\r\n每一个接口都记录目标MAC地址\r\n\r\n路由器\r\n\r\n可在不同网段间转发数据\r\n隔绝广播域\r\n计算机通信前会先判断目标主机和自己是否在同一网段，不同网段交由路由器转发\r\n网段计算：子网掩码&amp;IP地址\r\n\r\n\r\n\r\nrouter\r\n\r\nMac地址\r\n\r\n\r\nmediaAccessControlAdress\r\n\r\n\r\nMAC地址MediaAccessControlAddress有6字节\r\n全球唯一，固化在网卡ROM中，有IEEE802标准规定\r\n前3字节为组织唯一标识符OUI(Organizationally Unique Identifier)，有IEEE的注册管理机构分配给厂商\r\n后3个字节为网络接口标识符，有厂商自行分配\r\n\r\n修改MAC地址\r\n\r\n\r\n修改MAC地址\r\n\r\nARP广播\r\n\r\n\r\nimage-20240504205617208\r\n\r\nIP地址\r\n\r\n\r\nIP地址\r\n\r\n\r\nInternetProtocolAddress:互联网上每一个主机都有一个IP地址\r\n\r\nIP地址组成\r\n\r\n\r\nimage-20240504212044130\r\n\r\nIP地址分类\r\n\r\n\r\nimage-20240504213206081\r\n\r\nA类IP\r\n\r\n\r\nA类\r\n\r\nB类IP\r\n\r\n\r\nimage-20240504214907025\r\n\r\n\r\n\r\nimage-20240504214939330\r\n\r\n子网掩码的CIDR表示方法\r\n\r\n\r\nimage-20240504215519174\r\n\r\n参考\r\n\r\nOUI查询\r\nMAC地址查询\r\n子网掩码计算工具\r\n\r\n"},{"title":"深刻理解Java之Set集合","url":"/2025/03/14/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3Java%E4%B9%8BSet%E9%9B%86%E5%90%88/","content":"深刻理解Java之Set集合\r\n什么是Set集合\r\nSet集合是Java集合框架中的一个接口，它继承自Collection接口。Set集合就像现实生活中的”集合”概念一样，比如一个班级里的学生集合，每个学生只能出现一次。\r\n想象一下，你有一个装水果的篮子，但这个篮子有个特点：每种水果只能放一个。你不能在篮子里同时放两个苹果或两个橙子。这就是Set集合的核心特性——不允许重复元素。\r\n在Java中，Set接口位于java.util包中，是Collection接口的子接口。它的定义如下：\r\npublic interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;    // 集合框架中的方法&#125;\r\nSet接口的特点\r\n\r\n不允许重复元素：Set集合中的元素都是唯一的，不会出现重复的元素。\r\n无序集合：大多数Set实现类不保证元素的顺序（LinkedHashSet和TreeSet除外）。\r\n不支持索引访问：不能通过索引来访问Set中的元素。\r\n最多只允许一个null元素：大多数Set实现允许存储null元素（TreeSet除外）。\r\n\r\nSet接口的主要实现类\r\nHashSet\r\n\r\n\r\nimage-20250314152859425\r\n\r\nHashSet是Set接口最常用的实现类，它基于HashMap实现。就像一个没有特定顺序的抽奖箱，你放入的元素可能以任意顺序排列。\r\n特点：\r\n\r\n不保证元素的顺序\r\n允许使用null元素\r\n非同步（线程不安全）\r\n查找、添加和删除操作的时间复杂度为O(1)\r\n\r\n内部实现：\r\nHashSet内部使用HashMap来存储元素。实际上，HashSet是通过将元素作为HashMap的键来实现的，而HashMap的值则是一个固定的Object对象。\r\n// HashSet的部分源码简化版public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt; &#123;    private transient HashMap&lt;E,Object&gt; map;    private static final Object PRESENT = new Object();        public HashSet() &#123;        map = new HashMap&lt;&gt;();    &#125;        public boolean add(E e) &#123;        return map.put(e, PRESENT) == null;    &#125;&#125;\r\nLinkedHashSet\r\nLinkedHashSet是HashSet的子类，它在HashSet的基础上增加了元素的有序性。想象一个有序的抽奖箱，你按照放入的顺序取出元素。\r\n特点： - 维护元素的插入顺序 - 允许使用null元素 -\r\n非同步（线程不安全） - 性能略低于HashSet，但迭代访问更快\r\n内部实现：\r\nLinkedHashSet内部使用LinkedHashMap来存储元素，这使得它能够记住元素的插入顺序。\r\nTreeSet\r\nTreeSet是Java集合框架中的一个实现类，它是基于TreeMap实现的有序集合。想象一下图书馆的书架，所有书籍都按照特定的规则（如书名字母顺序）排列整齐，这就像TreeSet中的元素一样。它通过红黑树数据结构提供了高效的排序和查找功能。\r\n特点： - 元素按照自然顺序或指定的比较器排序 -\r\n不允许使用null元素 - 非同步（线程不安全） -\r\n查找、添加和删除操作的时间复杂度为O(log n)\r\n内部实现：\r\nTreeSet内部使用TreeMap来存储元素，这使得它能够保持元素的有序性。\r\nTreeSet的基本用法\r\nimport java.util.TreeSet;public class TreeSetDemo &#123;    public static void main(String[] args) &#123;        // 创建TreeSet        TreeSet&lt;Integer&gt; numbers = new TreeSet&lt;&gt;();                // 添加元素        numbers.add(10);        numbers.add(5);        numbers.add(20);        numbers.add(15);        numbers.add(5);  // 重复元素不会被添加                // 遍历TreeSet（已排序）        System.out.println(&quot;TreeSet元素（升序）：&quot;);        for (Integer number : numbers) &#123;            System.out.println(number);        &#125;                // 输出：5, 10, 15, 20    &#125;&#125;\r\nTreeSet的自然排序\r\n\r\n\r\nimage-20250314153954152\r\n\r\nComparable接口\r\nTreeSet默认使用元素的自然排序规则，这要求元素实现Comparable接口。就像图书馆里的书籍可能按照ISBN编号自然排序一样。\r\nimport java.util.TreeSet;// 实现Comparable接口的类class Book implements Comparable&lt;Book&gt; &#123;    private String title;    private double price;        public Book(String title, double price) &#123;        this.title = title;        this.price = price;    &#125;        @Override    public int compareTo(Book other) &#123;        // 按书名字母顺序排序        return this.title.compareTo(other.title);    &#125;        @Override    public String toString() &#123;        return &quot;Book&#123;title=&#x27;&quot; + title + &quot;&#x27;, price=&quot; + price + &quot;&#125;&quot;;    &#125;&#125;public class ComparableDemo &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Book&gt; bookSet = new TreeSet&lt;&gt;();                bookSet.add(new Book(&quot;Java编程&quot;, 59.9));        bookSet.add(new Book(&quot;Python基础&quot;, 45.5));        bookSet.add(new Book(&quot;算法导论&quot;, 88.0));        bookSet.add(new Book(&quot;数据结构&quot;, 55.0));                // 遍历（按书名字母顺序）        for (Book book : bookSet) &#123;            System.out.println(book);        &#125;    &#125;&#125;\r\ncompareTo方法的返回值含义\r\n\r\n\r\nimage-20250314175851482\r\n\r\ncompareTo方法返回一个整数，其含义如下： -\r\n返回正数：表示第一个对象（e1）应该排在第二个对象（e2）之后，交互顺序。 -\r\n返回负数：表示第一个对象（e1）应该排在第二个对象（e2）之前。 -\r\n返回零：表示两个对象相等，在排序中它们的顺序可以是任意的。\r\n这就像我们比较两本书的ISBN号，如果当前书的ISBN小于另一本，返回负数；相等返回零；大于则返回正数。\r\nTreeSet的定制排序\r\n\r\n\r\nimage-20250314154215312\r\n\r\nComparator接口\r\n如果我们想要使用不同于自然排序的规则，或者元素类没有实现Comparable接口，我们可以使用Comparator接口提供定制排序规则。这就像图书馆可以根据需要改变书籍的排序方式，有时按书名，有时按出版日期。\r\nimport java.util.Comparator;import java.util.TreeSet;class Student &#123;    private String name;    private int age;    private double score;        public Student(String name, int age, double score) &#123;        this.name = name;        this.age = age;        this.score = score;    &#125;        public String getName() &#123; return name; &#125;    public int getAge() &#123; return age; &#125;    public double getScore() &#123; return score; &#125;        @Override    public String toString() &#123;        return &quot;Student&#123;name=&#x27;&quot; + name + &quot;&#x27;, age=&quot; + age + &quot;, score=&quot; + score + &quot;&#125;&quot;;    &#125;&#125;public class ComparatorDemo &#123;    public static void main(String[] args) &#123;        // 子类（这里是匿名内部类）实现Comparator接口，重写compare方法，作为参数传给TreeSet        // 按年龄排序        TreeSet&lt;Student&gt; studentsByAge = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student s1, Student s2) &#123;                return s1.getAge() - s2.getAge();            &#125;        &#125;);                // 使用Lambda表达式按分数排序（降序）        TreeSet&lt;Student&gt; studentsByScore = new TreeSet&lt;&gt;((s1, s2) -&gt;             Double.compare(s2.getScore(), s1.getScore()));                // 添加学生        Student s1 = new Student(&quot;张三&quot;, 20, 85.5);        Student s2 = new Student(&quot;李四&quot;, 18, 92.0);        Student s3 = new Student(&quot;王五&quot;, 22, 78.5);        Student s4 = new Student(&quot;赵六&quot;, 19, 88.0);                studentsByAge.add(s1);        studentsByAge.add(s2);        studentsByAge.add(s3);        studentsByAge.add(s4);                studentsByScore.add(s1);        studentsByScore.add(s2);        studentsByScore.add(s3);        studentsByScore.add(s4);                System.out.println(&quot;按年龄排序（升序）：&quot;);        for (Student s : studentsByAge) &#123;            System.out.println(s);        &#125;                System.out.println(&quot;\\n按分数排序（降序）：&quot;);        for (Student s : studentsByScore) &#123;            System.out.println(s);        &#125;    &#125;&#125;\r\n多字段排序\r\n在实际应用中，我们经常需要按多个字段排序，就像图书馆可能先按类别，再按作者姓名排序。\r\npackage com.luotao.job.utils.demo;import java.util.Comparator;import java.util.TreeSet;class Employee &#123;    private String department;    private String name;    private int salary;    public Employee(String department, String name, int salary) &#123;        this.department = department;        this.name = name;        this.salary = salary;    &#125;    public String getDepartment() &#123; return department; &#125;    public String getName() &#123; return name; &#125;    public int getSalary() &#123; return salary; &#125;    @Override    public String toString() &#123;        return &quot;Employee&#123;department=&#x27;&quot; + department + &quot;&#x27;, name=&#x27;&quot; + name + &quot;&#x27;, salary=&quot; + salary + &quot;&#125;&quot;;    &#125;&#125; class MultiFieldSortDemo &#123;    public static void main(String[] args) &#123;        // 先按部门，再按薪资（降序）排序        /*        TreeSet&lt;Employee&gt; employees = new TreeSet&lt;&gt;(                Comparator.comparing(Employee::getDepartment)                        .thenComparing(Employee::getSalary, Comparator.reverseOrder())        );*/        TreeSet&lt;Employee&gt; employees = new TreeSet&lt;&gt;(new Comparator&lt;Employee&gt;() &#123;            @Override            public int compare(Employee e1, Employee e2) &#123;                int departmentComparison = e1.getDepartment().compareTo(e2.getDepartment());                if (departmentComparison != 0) &#123;                    return departmentComparison;                &#125;                // 按薪资降序排序                return Integer.compare(e2.getSalary(), e1.getSalary());            &#125;        &#125;);        employees.add(new Employee(&quot;IT&quot;, &quot;张三&quot;, 12000));        employees.add(new Employee(&quot;IT&quot;, &quot;李四&quot;, 15000));        employees.add(new Employee(&quot;HR&quot;, &quot;王五&quot;, 10000));        employees.add(new Employee(&quot;HR&quot;, &quot;赵六&quot;, 11000));        employees.add(new Employee(&quot;IT&quot;, &quot;钱七&quot;, 13000));        for (Employee emp : employees) &#123;            System.out.println(emp);        &#125;    &#125;&#125;\r\nTreeSet排序的内部原理\r\n红黑树实现\r\nTreeSet内部使用红黑树（Red-Black\r\nTree）数据结构来存储元素。红黑树是一种自平衡的二叉搜索树，它通过一系列的规则保证树的高度平衡，从而保证基本操作的时间复杂度为O(log\r\nn)。\r\n想象一下一棵树，每个节点都有两个子节点（左子节点和右子节点）。对于树中的任意节点：\r\n- 左子树上的所有节点都小于当前节点 -\r\n右子树上的所有节点都大于当前节点\r\n这种结构使得查找、插入和删除操作非常高效。\r\n元素添加过程\r\n当向TreeSet添加元素时，会发生以下步骤：\r\n\r\n使用比较器（或元素的自然顺序）确定新元素的位置\r\n如果集合为空，新元素成为根节点\r\n否则，从根节点开始，与树中的节点进行比较\r\n如果新元素小于当前节点，向左子树移动\r\n如果新元素大于当前节点，向右子树移动\r\n如果新元素等于当前节点，根据TreeSet的实现，可能替换现有元素或忽略新元素\r\n找到合适的位置后，插入新元素\r\n插入后，可能需要进行树的再平衡操作\r\n\r\n// 简化的添加过程伪代码void add(E element) &#123;    if (root == null) &#123;        root = new Node(element);        return;    &#125;        Node current = root;    while (true) &#123;        int cmp = compare(element, current.element);                if (cmp &lt; 0) &#123;            if (current.left == null) &#123;                current.left = new Node(element);                rebalance();                return;            &#125;            current = current.left;        &#125; else if (cmp &gt; 0) &#123;            if (current.right == null) &#123;                current.right = new Node(element);                rebalance();                return;            &#125;            current = current.right;        &#125; else &#123;            // 元素已存在，根据实现可能替换或忽略            return;        &#125;    &#125;&#125;\r\nTreeSet排序的常见问题\r\n1. 元素未实现Comparable接口\r\n如果元素没有实现Comparable接口，并且没有提供Comparator，将抛出ClassCastException。\r\nclass Person &#123;    private String name;        public Person(String name) &#123;        this.name = name;    &#125;        @Override    public String toString() &#123;        return &quot;Person&#123;name=&#x27;&quot; + name + &quot;&#x27;&#125;&quot;;    &#125;&#125;public class NoComparableDemo &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Person&gt; personSet = new TreeSet&lt;&gt;();                // 将抛出ClassCastException        personSet.add(new Person(&quot;张三&quot;));    &#125;&#125;\r\n2. 不一致的比较逻辑\r\n如果compareTo方法或compare方法的实现与equals方法不一致，可能导致TreeSet行为异常。\r\nclass InconsistentPerson implements Comparable&lt;InconsistentPerson&gt; &#123;    private String name;    private int id;        public InconsistentPerson(String name, int id) &#123;        this.name = name;        this.id = id;    &#125;        @Override    public int compareTo(InconsistentPerson other) &#123;        // 只按id比较        return this.id - other.id;    &#125;        @Override    public boolean equals(Object obj) &#123;        if (this == obj) return true;        if (obj == null || getClass() != obj.getClass()) return false;                InconsistentPerson that = (InconsistentPerson) obj;                // 按id和name比较        return id == that.id &amp;&amp; name.equals(that.name);    &#125;        @Override    public int hashCode() &#123;        return 31 * name.hashCode() + id;    &#125;        @Override    public String toString() &#123;        return &quot;Person&#123;name=&#x27;&quot; + name + &quot;&#x27;, id=&quot; + id + &quot;&#125;&quot;;    &#125;&#125;\r\n3. 修改已添加元素的关键属性\r\n如果在将元素添加到TreeSet后修改了影响排序的属性，TreeSet的顺序将不再正确。\r\nclass MutablePerson implements Comparable&lt;MutablePerson&gt; &#123;    private String name;    private int age;        public MutablePerson(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public void setAge(int age) &#123;        this.age = age;    &#125;        @Override    public int compareTo(MutablePerson other) &#123;        return this.age - other.age;    &#125;        @Override    public String toString() &#123;        return &quot;MutablePerson&#123;name=&#x27;&quot; + name + &quot;&#x27;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class MutableElementDemo &#123;    public static void main(String[] args) &#123;        TreeSet&lt;MutablePerson&gt; personSet = new TreeSet&lt;&gt;();                MutablePerson p1 = new MutablePerson(&quot;张三&quot;, 20);        MutablePerson p2 = new MutablePerson(&quot;李四&quot;, 25);        MutablePerson p3 = new MutablePerson(&quot;王五&quot;, 30);                personSet.add(p1);        personSet.add(p2);        personSet.add(p3);                System.out.println(&quot;修改前：&quot; + personSet);                // 修改p1的年龄，使其大于p3        p1.setAge(35);                System.out.println(&quot;修改后：&quot; + personSet);        // 顺序不会自动调整！                // 验证顺序错误        System.out.println(&quot;p1是否大于p3: &quot; + (p1.compareTo(p3) &gt; 0));        System.out.println(&quot;但在TreeSet中p1仍在p3之前！&quot;);    &#125;&#125;\r\nTreeSet与其他集合的对比\r\nTreeSet vs HashSet\r\n\r\n\r\n\r\n特性\r\nTreeSet\r\nHashSet\r\n\r\n\r\n\r\n\r\n排序\r\n有序\r\n无序\r\n\r\n\r\n性能(添加/删除/包含)\r\nO(log n)\r\nO(1)\r\n\r\n\r\n内部实现\r\n红黑树\r\n哈希表\r\n\r\n\r\nnull元素\r\n不允许\r\n允许一个\r\n\r\n\r\n使用场景\r\n需要排序的场景\r\n不关心顺序，追求性能\r\n\r\n\r\n\r\n就像图书馆（TreeSet）和仓库（HashSet）的区别：图书馆中的书籍按特定顺序排列，方便查找特定范围的书籍；而仓库中的物品可能没有特定顺序，但可以通过编号快速找到特定物品。\r\nTreeSet vs LinkedHashSet\r\n\r\n\r\n\r\n特性\r\nTreeSet\r\nLinkedHashSet\r\n\r\n\r\n\r\n\r\n排序\r\n按比较规则排序\r\n按插入顺序排序\r\n\r\n\r\n性能(添加/删除/包含)\r\nO(log n)\r\nO(1)\r\n\r\n\r\n内部实现\r\n红黑树\r\n哈希表+双向链表\r\n\r\n\r\n使用场景\r\n需要按特定规则排序\r\n需要保持插入顺序\r\n\r\n\r\n\r\n这就像图书馆（TreeSet）和博物馆的展览（LinkedHashSet）：图书馆的书籍按分类和编号排序，而博物馆的展品按参观路线（插入顺序）排列。\r\nTreeSet的性能分析\r\n时间复杂度\r\n\r\n\r\n\r\n操作\r\n时间复杂度\r\n\r\n\r\n\r\n\r\nadd()\r\nO(log n)\r\n\r\n\r\nremove()\r\nO(log n)\r\n\r\n\r\ncontains()\r\nO(log n)\r\n\r\n\r\nsize()\r\nO(1)\r\n\r\n\r\niterator()\r\nO(log n)\r\n\r\n\r\n\r\n空间复杂度\r\nTreeSet的空间复杂度为O(n)，其中n是元素数量。\r\n性能测试示例\r\nimport java.util.*;public class PerformanceTest &#123;    public static void main(String[] args) &#123;        int size = 1000000;                // 测试TreeSet        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();        long startTime = System.currentTimeMillis();                for (int i = 0; i &lt; size; i++) &#123;            treeSet.add(i);        &#125;                long endTime = System.currentTimeMillis();        System.out.println(&quot;TreeSet添加&quot; + size + &quot;个元素耗时：&quot; + (endTime - startTime) + &quot;ms&quot;);                // 测试HashSet        HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();        startTime = System.currentTimeMillis();                for (int i = 0; i &lt; size; i++) &#123;            hashSet.add(i);        &#125;                endTime = System.currentTimeMillis();        System.out.println(&quot;HashSet添加&quot; + size + &quot;个元素耗时：&quot; + (endTime - startTime) + &quot;ms&quot;);                // 测试查找        startTime = System.currentTimeMillis();        for (int i = 0; i &lt; size; i += 100) &#123;            treeSet.contains(i);        &#125;        endTime = System.currentTimeMillis();        System.out.println(&quot;TreeSet查找耗时：&quot; + (endTime - startTime) + &quot;ms&quot;);                startTime = System.currentTimeMillis();        for (int i = 0; i &lt; size; i += 100) &#123;            hashSet.contains(i);        &#125;        endTime = System.currentTimeMillis();        System.out.println(&quot;HashSet查找耗时：&quot; + (endTime - startTime) + &quot;ms&quot;);    &#125;&#125;\r\nTreeSet的最佳实践\r\n1. 选择合适的排序方式\r\n根据业务需求选择自然排序（Comparable）或定制排序（Comparator）： -\r\n如果类有明确的自然顺序，实现Comparable接口 -\r\n如果需要多种排序方式，或者无法修改类的源代码，使用Comparator\r\n2. 确保比较逻辑与equals一致\r\n为避免意外行为，确保compareTo或compare方法的逻辑与equals方法一致。如果两个对象通过equals方法比较相等，它们的compareTo方法应该返回0。\r\n3. 避免修改影响排序的属性\r\n将TreeSet中的元素视为不可变对象，不要修改影响排序的属性。如果必须修改，考虑：\r\n- 先从TreeSet中移除元素 - 修改属性 - 重新添加到TreeSet中\r\nTreeSet&lt;MutablePerson&gt; personSet = new TreeSet&lt;&gt;();MutablePerson person = new MutablePerson(&quot;张三&quot;, 20);personSet.add(person);// 需要修改年龄时personSet.remove(person);person.setAge(25);personSet.add(person);\r\n4. 利用TreeSet的导航方法\r\nTreeSet提供了丰富的导航方法，可以高效地查找特定范围的元素：\r\nTreeSet&lt;Integer&gt; numbers = new TreeSet&lt;&gt;();for (int i = 1; i &lt;= 100; i++) &#123;    numbers.add(i);&#125;// 获取小于或等于指定元素的最大元素System.out.println(numbers.floor(50));  // 50// 获取大于或等于指定元素的最小元素System.out.println(numbers.ceiling(50.5));  // 51// 获取严格小于指定元素的最大元素System.out.println(numbers.lower(50));  // 49// 获取严格大于指定元素的最小元素System.out.println(numbers.higher(50));  // 51// 获取指定范围的子集SortedSet&lt;Integer&gt; subset = numbers.subSet(20, 30);System.out.println(subset);  // [20, 21, ..., 29]\r\n5. 考虑线程安全\r\nTreeSet不是线程安全的。在多线程环境中，可以使用以下方式确保线程安全：\r\n// 使用Collections.synchronizedSortedSet包装SortedSet&lt;String&gt; sortedSet = Collections.synchronizedSortedSet(new TreeSet&lt;&gt;());// 或使用并发集合类import java.util.concurrent.ConcurrentSkipListSet;ConcurrentSkipListSet&lt;String&gt; concurrentSet = new ConcurrentSkipListSet&lt;&gt;();\r\n6. 性能考虑\r\n\r\n对于频繁查找操作但不关心顺序的场景，考虑使用HashSet\r\n对于需要按插入顺序访问的场景，考虑使用LinkedHashSet\r\n只有在需要元素有序或需要范围查询时，才使用TreeSet\r\n\r\nEnumSet\r\nEnumSet是专门为枚举类型设计的Set实现。如果你的集合只包含枚举类型的元素，EnumSet是最佳选择。\r\n特点： - 所有元素必须来自同一个枚举类型 -\r\n内部使用位向量实现，非常高效 - 不允许使用null元素 -\r\n元素按照枚举常量的声明顺序排序\r\n使用示例： enum Day &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;EnumSet&lt;Day&gt; weekdays = EnumSet.range(Day.MONDAY, Day.FRIDAY);EnumSet&lt;Day&gt; weekend = EnumSet.complementOf(weekdays); // 包含SATURDAY和SUNDAY\r\nCopyOnWriteArraySet\r\nCopyOnWriteArraySet是线程安全的Set实现，适用于读多写少的并发场景。\r\n特点： - 线程安全，无需额外同步 -\r\n在修改时复制整个底层数组，适合读多写少的场景 - 迭代器不支持修改操作 -\r\n允许使用null元素\r\n内部实现：\r\nCopyOnWriteArraySet内部使用CopyOnWriteArrayList来存储元素。\r\nSet接口的常用方法\r\nSet接口继承自Collection接口，因此拥有Collection接口的所有方法。以下是一些常用方法：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n描述\r\n返回值\r\n\r\n\r\n\r\n\r\nboolean add(E e)\r\n将指定元素添加到集合中\r\n如果集合因此调用而改变，则返回true\r\n\r\n\r\nboolean remove(Object o)\r\n从集合中移除指定元素\r\n如果集合包含指定元素，则返回true\r\n\r\n\r\nboolean contains(Object o)\r\n判断集合是否包含指定元素\r\n如果集合包含指定元素，则返回true\r\n\r\n\r\nboolean isEmpty()\r\n判断集合是否为空\r\n如果集合不包含元素，则返回true\r\n\r\n\r\nint size()\r\n返回集合中的元素数量\r\n集合中的元素数量\r\n\r\n\r\nvoid clear()\r\n移除集合中的所有元素\r\n无返回值\r\n\r\n\r\nIterator&lt;E&gt; iterator()\r\n返回集合中元素的迭代器\r\n集合中元素的迭代器\r\n\r\n\r\nboolean containsAll(Collection&lt;?&gt; c)\r\n判断集合是否包含指定集合中的所有元素\r\n如果包含所有元素，则返回true\r\n\r\n\r\nboolean addAll(Collection&lt;? extends E&gt; c)\r\n将指定集合中的所有元素添加到集合中\r\n如果集合因此调用而改变，则返回true\r\n\r\n\r\nboolean removeAll(Collection&lt;?&gt; c)\r\n移除集合中与指定集合相同的所有元素\r\n如果集合因此调用而改变，则返回true\r\n\r\n\r\nboolean retainAll(Collection&lt;?&gt; c)\r\n仅保留集合中与指定集合相同的元素\r\n如果集合因此调用而改变，则返回true\r\n\r\n\r\nObject[] toArray()\r\n返回包含集合中所有元素的数组\r\n包含集合中所有元素的数组\r\n\r\n\r\n\r\nSet集合的遍历方式\r\nSet集合有多种遍历方式，以下是常用的几种：\r\n1. 使用增强for循环（for-each）\r\nSet&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;Apple&quot;);set.add(&quot;Banana&quot;);set.add(&quot;Orange&quot;);for (String fruit : set) &#123;    System.out.println(fruit);&#125;\r\n2. 使用迭代器（Iterator）\r\nSet&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;Apple&quot;);set.add(&quot;Banana&quot;);set.add(&quot;Orange&quot;);Iterator&lt;String&gt; iterator = set.iterator();while (iterator.hasNext()) &#123;    String fruit = iterator.next();    System.out.println(fruit);        // 如果需要在遍历过程中安全地删除元素，可以使用迭代器的remove方法    // if (&quot;Banana&quot;.equals(fruit)) &#123;    //     iterator.remove();    // &#125;&#125;\r\n3. 使用Stream API（Java\r\n8及以上）\r\nSet&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;Apple&quot;);set.add(&quot;Banana&quot;);set.add(&quot;Orange&quot;);// 普通遍历set.stream().forEach(System.out::println);// 过滤元素set.stream()   .filter(fruit -&gt; fruit.startsWith(&quot;A&quot;))   .forEach(System.out::println);\r\nSet集合的应用场景\r\nSet集合在实际开发中有很多应用场景，以下是一些常见的：\r\n\r\n去重：当需要去除重复元素时，可以使用Set集合。\r\nList&lt;Integer&gt; numbersList = Arrays.asList(1, 2, 3, 2, 1, 4, 5, 4);Set&lt;Integer&gt; numbersSet = new HashSet&lt;&gt;(numbersList); // 结果为 [1, 2, 3, 4, 5]\r\n检查元素是否存在：Set的contains方法时间复杂度为O(1)（对于HashSet），比List的contains方法更高效。\r\nSet&lt;String&gt; dictionary = new HashSet&lt;&gt;();dictionary.add(&quot;apple&quot;);dictionary.add(&quot;banana&quot;);boolean exists = dictionary.contains(&quot;apple&quot;); // true\r\n集合运算：可以使用Set的方法实现并集、交集、差集等集合运算。\r\nSet&lt;Integer&gt; set1 = new HashSet&lt;&gt;(Arrays.asList(1, 2, 3, 4));Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(Arrays.asList(3, 4, 5, 6));// 并集Set&lt;Integer&gt; union = new HashSet&lt;&gt;(set1);union.addAll(set2); // [1, 2, 3, 4, 5, 6]// 交集Set&lt;Integer&gt; intersection = new HashSet&lt;&gt;(set1);intersection.retainAll(set2); // [3, 4]// 差集Set&lt;Integer&gt; difference = new HashSet&lt;&gt;(set1);difference.removeAll(set2); // [1, 2]\r\n有序集合：当需要元素保持特定顺序时，可以使用TreeSet或LinkedHashSet。\r\n// 按照自然顺序排序Set&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();sortedSet.add(&quot;banana&quot;);sortedSet.add(&quot;apple&quot;);sortedSet.add(&quot;orange&quot;);// 结果为 [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]// 按照插入顺序排序Set&lt;String&gt; orderedSet = new LinkedHashSet&lt;&gt;();orderedSet.add(&quot;banana&quot;);orderedSet.add(&quot;apple&quot;);orderedSet.add(&quot;orange&quot;);// 结果为 [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;]\r\n缓存实现：可以使用LinkedHashSet实现LRU（最近最少使用）缓存。\r\n线程安全的集合：在多线程环境下，可以使用CopyOnWriteArraySet或Collections.synchronizedSet()方法包装的Set。\r\n\r\nSet集合的性能比较\r\n不同的Set实现类在性能上有所差异，选择合适的实现类可以提高程序的效率。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n实现类\r\n添加/删除/包含\r\n有序性\r\n线程安全\r\n允许null\r\n\r\n\r\n\r\n\r\nHashSet\r\nO(1)\r\n无序\r\n否\r\n是\r\n\r\n\r\nLinkedHashSet\r\nO(1)\r\n插入顺序\r\n否\r\n是\r\n\r\n\r\nTreeSet\r\nO(log n)\r\n自然顺序或比较器顺序\r\n否\r\n否\r\n\r\n\r\nEnumSet\r\nO(1)\r\n枚举声明顺序\r\n否\r\n否\r\n\r\n\r\nCopyOnWriteArraySet\r\nO(n)\r\n插入顺序\r\n是\r\n是\r\n\r\n\r\n\r\n常见问题与最佳实践\r\n1.\r\n如何正确地在Set中存储自定义对象？\r\n当在Set中存储自定义对象时，需要正确地重写equals()和hashCode()方法，否则Set无法正确地判断元素是否重复。\r\npublic class Person &#123;    private String name;    private int age;        // 构造函数、getter和setter省略        @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Person person = (Person) o;        return age == person.age &amp;&amp; Objects.equals(name, person.name);    &#125;        @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;&#125;\r\n2. 如何选择合适的Set实现类？\r\n\r\n如果不需要有序性，且需要最高效率，选择HashSet\r\n如果需要保持插入顺序，选择LinkedHashSet\r\n如果需要元素自动排序，选择TreeSet\r\n如果只存储枚举类型，选择EnumSet\r\n如果在多线程环境下使用，选择CopyOnWriteArraySet或使用Collections.synchronizedSet()包装其他Set实现\r\n\r\n3. 避免在遍历Set时修改集合\r\n在使用for-each循环或迭代器遍历Set时，不应该直接调用Set的remove()方法来删除元素，这会导致ConcurrentModificationException异常。正确的做法是使用迭代器的remove()方法：\r\nSet&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;Apple&quot;);set.add(&quot;Banana&quot;);set.add(&quot;Orange&quot;);// 错误的做法// for (String fruit : set) &#123;//     if (&quot;Banana&quot;.equals(fruit)) &#123;//         set.remove(fruit); // 会抛出ConcurrentModificationException异常//     &#125;// &#125;// 正确的做法Iterator&lt;String&gt; iterator = set.iterator();while (iterator.hasNext()) &#123;    String fruit = iterator.next();    if (&quot;Banana&quot;.equals(fruit)) &#123;        iterator.remove(); // 使用迭代器的remove方法    &#125;&#125;\r\n4. 使用Stream API简化Set操作\r\nJava 8引入的Stream API可以大大简化Set的操作：\r\nSet&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Grape&quot;));// 过滤元素Set&lt;String&gt; filteredSet = set.stream()                             .filter(fruit -&gt; fruit.length() &gt; 5)                             .collect(Collectors.toSet());// 结果为 [&quot;Banana&quot;, &quot;Orange&quot;]// 转换元素Set&lt;String&gt; upperCaseSet = set.stream()                             .map(String::toUpperCase)                             .collect(Collectors.toSet());// 结果为 [&quot;APPLE&quot;, &quot;BANANA&quot;, &quot;ORANGE&quot;, &quot;GRAPE&quot;]\r\n代码示例\r\n以下是一些使用Set集合的完整示例：\r\n示例1：基本操作\r\nimport java.util.*;public class SetDemo &#123;    public static void main(String[] args) &#123;        // 创建HashSet        Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();                // 添加元素        hashSet.add(&quot;Apple&quot;);        hashSet.add(&quot;Banana&quot;);        hashSet.add(&quot;Orange&quot;);        hashSet.add(&quot;Apple&quot;); // 重复元素不会被添加                // 打印集合        System.out.println(&quot;HashSet: &quot; + hashSet);                // 检查元素是否存在        System.out.println(&quot;Contains Apple? &quot; + hashSet.contains(&quot;Apple&quot;));        System.out.println(&quot;Contains Grape? &quot; + hashSet.contains(&quot;Grape&quot;));                // 删除元素        hashSet.remove(&quot;Banana&quot;);        System.out.println(&quot;After removing Banana: &quot; + hashSet);                // 集合大小        System.out.println(&quot;Size: &quot; + hashSet.size());                // 遍历集合        System.out.println(&quot;Iterating over HashSet:&quot;);        for (String fruit : hashSet) &#123;            System.out.println(fruit);        &#125;                // 清空集合        hashSet.clear();        System.out.println(&quot;After clearing: &quot; + hashSet);        System.out.println(&quot;Is empty? &quot; + hashSet.isEmpty());    &#125;&#125;\r\n示例2：不同Set实现的比较\r\nimport java.util.*;public class SetComparison &#123;    public static void main(String[] args) &#123;        // HashSet - 无序        Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();        hashSet.add(&quot;Banana&quot;);        hashSet.add(&quot;Apple&quot;);        hashSet.add(&quot;Orange&quot;);        System.out.println(&quot;HashSet: &quot; + hashSet);                // LinkedHashSet - 保持插入顺序        Set&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();        linkedHashSet.add(&quot;Banana&quot;);        linkedHashSet.add(&quot;Apple&quot;);        linkedHashSet.add(&quot;Orange&quot;);        System.out.println(&quot;LinkedHashSet: &quot; + linkedHashSet);                // TreeSet - 自然排序        Set&lt;String&gt; treeSet = new TreeSet&lt;&gt;();        treeSet.add(&quot;Banana&quot;);        treeSet.add(&quot;Apple&quot;);        treeSet.add(&quot;Orange&quot;);        System.out.println(&quot;TreeSet: &quot; + treeSet);                // TreeSet - 自定义排序（按长度排序）        Set&lt;String&gt; customTreeSet = new TreeSet&lt;&gt;(Comparator.comparingInt(String::length));        customTreeSet.add(&quot;Banana&quot;);        customTreeSet.add(&quot;Apple&quot;);        customTreeSet.add(&quot;Orange&quot;);        customTreeSet.add(&quot;Kiwi&quot;);        System.out.println(&quot;Custom TreeSet (sorted by length): &quot; + customTreeSet);                // EnumSet        enum Day &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;        Set&lt;Day&gt; weekdays = EnumSet.range(Day.MONDAY, Day.FRIDAY);        Set&lt;Day&gt; weekend = EnumSet.complementOf(weekdays);        System.out.println(&quot;Weekdays: &quot; + weekdays);        System.out.println(&quot;Weekend: &quot; + weekend);    &#125;&#125;\r\n示例3：集合运算\r\nimport java.util.*;public class SetOperations &#123;    public static void main(String[] args) &#123;        Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));        Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(Arrays.asList(4, 5, 6, 7, 8));                // 打印原始集合        System.out.println(&quot;Set1: &quot; + set1);        System.out.println(&quot;Set2: &quot; + set2);                // 并集        Set&lt;Integer&gt; union = new HashSet&lt;&gt;(set1);        union.addAll(set2);        System.out.println(&quot;Union: &quot; + union);                // 交集        Set&lt;Integer&gt; intersection = new HashSet&lt;&gt;(set1);        intersection.retainAll(set2);        System.out.println(&quot;Intersection: &quot; + intersection);                // 差集 (set1 - set2)        Set&lt;Integer&gt; difference1 = new HashSet&lt;&gt;(set1);        difference1.removeAll(set2);        System.out.println(&quot;Difference (set1 - set2): &quot; + difference1);                // 差集 (set2 - set1)        Set&lt;Integer&gt; difference2 = new HashSet&lt;&gt;(set2);        difference2.removeAll(set1);        System.out.println(&quot;Difference (set2 - set1): &quot; + difference2);                // 对称差集 (set1 ∆ set2)        Set&lt;Integer&gt; symmetricDifference = new HashSet&lt;&gt;(set1);        symmetricDifference.addAll(set2); // 并集        Set&lt;Integer&gt; temp = new HashSet&lt;&gt;(set1);        temp.retainAll(set2); // 交集        symmetricDifference.removeAll(temp); // 并集 - 交集 = 对称差集        System.out.println(&quot;Symmetric Difference: &quot; + symmetricDifference);    &#125;&#125;\r\n示例4：自定义对象在Set中的使用\r\nimport java.util.*;class Person &#123;    private String name;    private int age;        public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public String getName() &#123;        return name;    &#125;        public int getAge() &#123;        return age;    &#125;        @Override    public String toString() &#123;        return name + &quot; (&quot; + age + &quot;)&quot;;    &#125;        @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Person person = (Person) o;        return age == person.age &amp;&amp; Objects.equals(name, person.name);    &#125;        @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;&#125;public class CustomObjectSetDemo &#123;    public static void main(String[] args) &#123;        Set&lt;Person&gt; personSet = new HashSet&lt;&gt;();                personSet.add(new Person(&quot;Alice&quot;, 25));        personSet.add(new Person(&quot;Bob&quot;, 30));        personSet.add(new Person(&quot;Charlie&quot;, 35));        personSet.add(new Person(&quot;Alice&quot;, 25)); // 重复元素，不会被添加                System.out.println(&quot;Person Set size: &quot; + personSet.size()); // 输出3，而不是4        System.out.println(&quot;Person Set: &quot; + personSet);                // 使用TreeSet按年龄排序        Set&lt;Person&gt; sortedPersonSet = new TreeSet&lt;&gt;(Comparator.comparingInt(Person::getAge));        sortedPersonSet.addAll(personSet);                System.out.println(&quot;Sorted Person Set: &quot; + sortedPersonSet);    &#125;&#125;\r\n示例5：使用Stream API操作Set\r\nimport java.util.*;import java.util.stream.Collectors;public class SetStreamDemo &#123;    public static void main(String[] args) &#123;        Set&lt;String&gt; fruits = new HashSet&lt;&gt;(Arrays.asList(            &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;, &quot;Kiwi&quot;        ));                System.out.println(&quot;Original Set: &quot; + fruits);                // 过滤长度大于5的水果        Set&lt;String&gt; longNameFruits = fruits.stream()                                          .filter(fruit -&gt; fruit.length() &gt; 5)                                          .collect(Collectors.toSet());        System.out.println(&quot;Fruits with name length &gt; 5: &quot; + longNameFruits);                // 转换为大写        Set&lt;String&gt; upperCaseFruits = fruits.stream()                                           .map(String::toUpperCase)                                           .collect(Collectors.toSet());        System.out.println(&quot;Uppercase fruits: &quot; + upperCaseFruits);                // 按长度分组        Map&lt;Integer, List&lt;String&gt;&gt; fruitsByLength = fruits.stream()                                                         .collect(Collectors.groupingBy(String::length));        System.out.println(&quot;Fruits grouped by length: &quot; + fruitsByLength);                // 检查是否所有水果名称都以&#x27;A&#x27;开头        boolean allStartWithA = fruits.stream().allMatch(fruit -&gt; fruit.startsWith(&quot;A&quot;));        System.out.println(&quot;All fruits start with &#x27;A&#x27;: &quot; + allStartWithA);                // 检查是否有水果名称以&#x27;A&#x27;开头        boolean anyStartWithA = fruits.stream().anyMatch(fruit -&gt; fruit.startsWith(&quot;A&quot;));        System.out.println(&quot;Any fruit starts with &#x27;A&#x27;: &quot; + anyStartWithA);                // 获取名称最长的水果        Optional&lt;String&gt; longestFruit = fruits.stream()                                             .max(Comparator.comparingInt(String::length));        longestFruit.ifPresent(fruit -&gt; System.out.println(&quot;Longest fruit name: &quot; + fruit));    &#125;&#125;\r\n"},{"title":"软考笔记-软考中级-软件设计师","url":"/2025/06/14/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0-%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","content":"2025年5月真题\r\nLinux外部设备，以文件形式存储，存放在哪个路径？\r\ngraph TD\r\n    A[\"/ (根目录)Root - 整个文件系统的起点\"] --> B[\"bin (用户二进制文件)User Binaries - 基本用户命令 (如 ls, cp)\"]\r\n    A --> C[\"sbin (系统二进制文件)System Binaries - 基本系统管理命令 (如 ifconfig, fdisk)\"]\r\n    A --> D[\"etc (配置文件)Etcetera / Editable Text Configurations - 系统配置文件 (如 passwd, fstab)\"]\r\n    A --> E[\"dev (设备文件)Device files - 设备文件 (如 /dev/null, /dev/sda)\"]\r\n    A --> F[\"proc (进程信息)Process information - 内核与进程信息的虚拟文件系统\"]\r\n    A --> G[\"var (可变文件)Variable files - 经常变化的文件 (如日志 /var/log, 邮件 /var/mail)\"]\r\n    A --> H[\"tmp (临时文件)Temporary files - 临时文件 (通常重启后清空)\"]\r\n    A --> I[\"usr (用户程序)Unix System Resources / User Shared Resources - 用户安装的程序和数据 (最大的目录之一)\"]\r\n    I --> I1[\"/usr/bin (非必要用户命令)User Binaries - 大部分用户命令\"]\r\n    I --> I2[\"/usr/sbin (非必要系统命令)System Binaries - 非必要的系统管理命令\"]\r\n    I --> I3[\"/usr/local (本地安装)Local - 本地管理员安装的软件 (通常有 bin, lib, share 子目录)\"]\r\n    I --> I4[\"/usr/share (共享数据)Share - 体系结构无关的共享数据 (如文档、图标)\"]\r\n    I --> I5[\"/usr/lib (用户库文件)Libraries - /usr/bin 和 /usr/sbin 中程序所需的共享库\"]\r\n    A --> J[\"home (家目录)Home - 用户个人目录 (如 /home/username)\"]\r\n    A --> K[\"boot (启动文件)Boot loader files - 系统启动相关文件 (如内核 vmlinuz, GRUB)\"]\r\n    A --> L[\"lib (核心共享库)Libraries - /bin和/sbin中程序所需的共享库 (如 ld.so, libc.so.*)\"]\r\n    A --> M[\"opt (可选应用)Optional - 第三方可选应用程序包 (如 Google Chrome)\"]\r\n    A --> N[\"mnt (挂载点)Mount - 临时文件系统挂载点 (管理员手动挂载)\"]\r\n    A --> O[\"media (可移动媒体)Media - 可移动设备挂载点 (如U盘, CD-ROM)\"]\r\n    A --> P[\"srv (服务数据)Service - 系统提供的服务数据 (如 /srv/ftp, /srv/www)\"]\r\n\r\n    %% Styling for better readability\r\n    classDef default fill:#f9f,stroke:#333,stroke-width:2px,font-size:16px,color:#333;\r\n    classDef root fill:#add8e6,stroke:#333,stroke-width:2px,font-size:18px,font-weight:bold,color:#000;\r\n    class A root;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n目录路径\r\n中文名称\r\n英文全称/含义\r\n主要作用\r\n\r\n\r\n\r\n\r\n/\r\n根目录\r\n/\r\n整个文件系统的起点\r\n\r\n\r\n/root\r\n系统管理员目录\r\nRoot\r\n系统管理员目录\r\n\r\n\r\n/bin\r\n用户二进制文件\r\nUser Binaries\r\n基本用户命令 (如 ls, cp)\r\n\r\n\r\n/sbin\r\n系统二进制文件\r\nSystem Binaries\r\n基本系统管理命令 (如 ifconfig, fdisk)\r\n\r\n\r\n/etc\r\n配置文件\r\nEtcetera / Editable Text Configurations\r\n系统配置文件 (如 passwd, fstab)\r\n\r\n\r\n/dev\r\n设备文件\r\nDevice files\r\n外部设备（硬盘、u盘、USB、光驱等）会被抽象为设备文件,这些设备文件提供与硬件交互的接口\r\n\r\n\r\n/proc\r\n进程信息\r\nProcess information\r\n内核与进程信息的虚拟文件系统\r\n\r\n\r\n/var\r\n可变文件\r\nVariable files\r\n经常变化扩充的文件 (如日志 /var/log, 邮件 /var/mail)\r\n\r\n\r\n/tmp\r\n临时文件\r\nTemporary files\r\n临时文件 (通常重启后清空)\r\n\r\n\r\n/usr\r\n用户程序\r\nUnix System Resources / User Shared Resources\r\n用户安装的程序和数据 (最大的目录之一)\r\n\r\n\r\n/usr/bin\r\n非必要用户命令\r\nUser Binaries\r\n大部分用户命令\r\n\r\n\r\n/usr/sbin\r\n非必要系统命令\r\nSystem Binaries\r\n非必要的系统管理命令\r\n\r\n\r\n/usr/local\r\n本地安装\r\nLocal\r\n本地管理员安装的软件 (通常有 bin, lib, share 子目录)\r\n\r\n\r\n/usr/share\r\n共享数据\r\nShare\r\n体系结构无关的共享数据 (如文档、图标)\r\n\r\n\r\n/usr/lib\r\n用户库文件\r\nLibraries\r\n/usr/bin 和 /usr/sbin 中程序所需的共享库\r\n\r\n\r\n/home\r\n用户目录\r\nHome\r\n用户个人目录 (如 /home/username)\r\n\r\n\r\n/boot\r\n启动文件\r\nBoot loader files\r\n系统启动相关文件 (如内核 vmlinuz, GRUB)\r\n\r\n\r\n/lib\r\n核心共享库\r\nLibraries\r\n/bin和/sbin中程序所需的共享库 (如 ld.so, libc.so.*)\r\n\r\n\r\n/opt\r\n可选应用\r\nOptional\r\n第三方可选应用程序包 (如 Google Chrome)\r\n\r\n\r\n/mnt\r\n挂载点\r\nMount\r\n临时文件系统挂载点 (管理员手动挂载)\r\n\r\n\r\n/media\r\n可移动媒体\r\nMedia\r\n可移动设备挂载点 (如U盘, CD-ROM)\r\n\r\n\r\n/srv\r\n服务数据\r\nService\r\n系统提供的服务数据 (如 /srv/ftp, /srv/www)\r\n\r\n\r\n\r\n某系统有6个并发进程竞争资源R，每个进程都需要3个R，保证系统不会发生死锁，R的最小值为？\r\n$$\r\n\\begin{array}{l}\r\n\\text{为了保证系统不发生死锁，最坏的情况是每个进程都已经获得了 k-1\r\n个资源，} \\\\\r\n\\text{并且都在等待最后一个资源。此时，只要再多一个资源，就能满足至少一个进程，}\r\n\\\\\r\n\\text{使其执行完毕并释放资源，从而避免死锁。} \\\\\r\n\\\\\r\n\\textbf{符号定义：} \\\\\r\n\\quad \\begin{array}{ll}\r\nN &amp; \\text{：并发进程的数量} \\\\\r\nK &amp; \\text{：每个进程需要某种资源的最大数量} \\\\\r\nR_{\\text{min}} &amp; \\text{：保证不发生死锁的最小资源数} \\\\\r\n\\end{array} \\\\\r\n\\\\\r\n\\textbf{计算公式：} \\\\\r\n\\quad R_{\\text{min}} = N \\times (K - 1) + 1 \\\\\r\n\\\\\r\n\\hline \\\\\r\n\\textbf{例题：} \\\\\r\n\\text{某系统有6个并发进程竞争资源R，每个进程都需要3个R，} \\\\\r\n\\text{保证系统不会发生死锁，R的最小值为？} \\\\\r\n\\\\\r\n\\textbf{解：} \\\\\r\n\\quad \\begin{array}{lcl}\r\nN &amp;=&amp; 6 \\\\\r\nK &amp;=&amp; 3 \\\\\r\nR_{\\text{min}} &amp;=&amp; N \\times (K - 1) + 1 \\\\\r\n        &amp;=&amp; 6 \\times (3 - 1) + 1 \\\\\r\n        &amp;=&amp; 6 \\times 2 + 1 \\\\\r\n        &amp;=&amp; 12 + 1 \\\\\r\n        &amp;=&amp; 13 \\\\\r\n\\end{array} \\\\\r\n\\\\\r\n\\textbf{解释：} \\\\\r\n\\text{如果只有12个资源R，可能出现6个进程各获得2个资源（共用12个），} \\\\\r\n\\text{此时每个进程都还需1个资源才能执行。由于无剩余资源，将发生死锁。}\r\n\\\\\r\n\\text{若有13个资源R，在每个进程获得2个资源后（共用12个），还剩1个资源。}\r\n\\\\\r\n\\text{此资源可分配给任一进程，使其完成并释放资源，} \\\\\r\n\\text{从而其他进程也能相继完成。} \\\\\r\n\\end{array}\r\n$$\r\n数据库事务特性ACID\r\ngraph TD\r\n    T_def[\"事务 (Transaction)访问并可能操作各种数据项的一组数据库操作序列\"] --> A\r\n    A[\"数据库事务特性 (ACID)\"] --> B(原子性 Atomicity)\r\n    A --> C(一致性 Consistency)\r\n    A --> D(隔离性 Isolation)\r\n    A --> E(持久性 Durability)\r\n\r\n    B --> B_desc[\"事务中的全部操作要么整体提交 (commit) 成功要么整体回滚 (rollback) 失败\"]\r\n    C --> C_desc[\"事务执行前后数据库 (DB) 从一个一致状态转变到另一个一致状态始终符合完整性约束\"]\r\n    D --> D_desc[\"并发执行的多个事务之间应相互独立，互不干扰一个事务的中间结果对其他事务不可见\"]\r\n    E --> E_desc[\"事务一旦成功提交 (commit)其对数据库的修改就是永久性的即使发生系统故障也不会丢失\"]\r\n\r\n    %% 样式定义\r\n    style T_def fill:#FFFACD,stroke:#BDB76B,stroke-width:2px,color:#556B2F\r\n    style A fill:#FFDAB9,stroke:#A0522D,stroke-width:2px,color:#A0522D\r\n    style B fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style C fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style D fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style E fill:#ADD8E6,stroke:#4682B4,stroke-width:2px,color:#000080\r\n    style B_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style C_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style D_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n    style E_desc fill:#F0F8FF,stroke:#B0C4DE,stroke-width:1px,color:#2F4F4F\r\n软考笔记-软考中级-软件设计师\r\n\r\n\r\nimage-20250604131919824\r\n\r\n计算机系统基础知识\r\n\r\n\r\nimage-20250603152044787\r\n\r\n\r\n计算机的基本硬件系统（冯诺依曼结构）的五大部件：运算器、控制器、存储器、输入设备和输出设备。\r\n中央处理单元(CPU)：运算器 + 控制器 + 寄存器 +\r\n内部总线（CPU内部连接各寄存器及运算器之间的总线，而非系统总线）\r\n存储器：计算机系统中的记忆设备，分为内部存储器（速快容小，临时存储）和外部存储器（长期存储）。\r\n外部设备（外设):\r\n输入设备（输入原始数据和各种命令）和输出设备（输出处理结果）\r\n运算器：执行算数运算（加减乘除）和执行逻辑运算并逻辑测试（与或非）：\r\n\r\n算数逻辑单元ALU：对数据的算数和逻辑运算\r\n累加寄存器AC：为ALU提供工作区，暂存运算结果\r\n数据缓冲寄存器DR：CPU和内存、外设间数据传送的中转站，用于缓冲速度上的差异性，如对内存读写时，用DR暂存有内存读写的指令或数据字\r\n状态条件寄存器PSW：保存算数/逻辑运算结果的状态，分状态标志和控制标志，如运算结果进位标志、溢出标志、中断标志\r\n\r\n控制器：\r\n\r\n指令寄存器IR：保存当前执行指令的代码\r\n程序计数器PC：指向下一条指令的地址\r\n地址寄存器AR: 存放CPU访问的内存单元地址\r\n指令译码器：对指令译码\r\n\r\n\r\n\r\nimage-20250603151703495\r\n\r\n\r\n\r\nimage-20250603151959224\r\n\r\n\r\n二进制按位权展开表示\r\n二进制的10.00 = 1 × 21 + 0 × 20 + 0 × 2−1 + 0 × 2−2\r\n十进制转R进制使用除基取余法\r\ngraph TD\r\n    A[\"十进制数: 10\"] --> B[\"10 ÷ 2 = 5 ... 0(最低位)\"];\r\n    B --> C[\"5 ÷ 2 = 2 ... 1\"];\r\n    C --> D[\"2 ÷ 2 = 1 ... 0\"];\r\n    D --> E[\"1 ÷ 2 = 0 ... 1 (最高位)\"];\r\n    E --> F[\"商为0，停止计算\"];\r\n    F --> G[\"余数从下往上排列 (1010)₂\"];\r\n十进制转二进制使用减法\r\n$$\r\n$$\r\n二进制与八进制互转\r\n二进制转八进制 (三位分组，421法)：\r\n1位八进制数可以表示从 0 到 7 的数字，而 3位二进制数正好也能表示从 0 到 7\r\n的值（共8种组合），所以我们可以将每 3位二进制数转换为\r\n1位八进制数。位权是 22, 21,\r\n20，也就是 4, 2,\r\n1。所以，每一组3位二进制数转换为八进制数码时，是基于”4-2-1”的位权相加得到的。\r\n八进制数码与二进制对应关系：\r\n\r\n\r\n\r\n八进制\r\n3位二进制 (421)\r\n\r\n\r\n\r\n\r\n0\r\n000\r\n\r\n\r\n1\r\n001\r\n\r\n\r\n2\r\n010\r\n\r\n\r\n3\r\n011\r\n\r\n\r\n4\r\n100\r\n\r\n\r\n5\r\n101\r\n\r\n\r\n6\r\n110\r\n\r\n\r\n7\r\n111\r\n\r\n\r\n\r\n$$\r\n\\begin{array}{lll}\r\n{\\text{示例：将二进制数 } (1101011.1011)_2 \\text{ 转换为八进制数。}} \\\\\r\n\\hline\r\n\\text{1. 整数部分处理:} &amp; (1101011)_2 \\\\\r\n&amp; \\text{从右向左分组:} &amp; 1 \\quad 101 \\quad 011 \\\\\r\n&amp; \\text{补0后分组:} &amp; \\mathbf{001} \\quad \\mathbf{101} \\quad\r\n\\mathbf{011} \\\\\r\n&amp; \\text{对应八进制:} &amp; \\downarrow \\quad \\downarrow \\quad\r\n\\downarrow \\\\\r\n&amp; &amp; {(0×4 + 0×2 + 1×1) = 1₈} \\quad { (1×4 + 0×2 + 1×1) = 5₈}\r\n\\quad {(0×4 + 1×2 + 1×1) = 3₈} \\\\\r\n&amp; \\text{整数部分结果:} &amp; (153)_8 \\\\\r\n\\hline\r\n\\text{2. 小数部分处理:} &amp; (.1011)_2 \\\\\r\n&amp; \\text{从左向右分组:} &amp; 101 \\quad 1 \\\\\r\n&amp; \\text{补0后分组:} &amp; \\mathbf{101} \\quad \\mathbf{100} \\\\\r\n&amp; \\text{对应八进制:} &amp; \\downarrow \\quad \\downarrow \\\\\r\n&amp; &amp; 5 \\quad 4 \\\\\r\n&amp; \\text{小数部分结果:} &amp; (.54)_8 \\\\\r\n\\hline\r\n\\text{3. 合并结果:} &amp; (153.54)_8\r\n\\end{array}\r\n$$\r\n八进制转二进制 (一位拆三位)：\r\n规则：将八进制数的每一位直接用其对应的3位二进制数替换。整数部分高位的0通常可以省略（除非单独一位0），小数部分末尾的0也可以省略。\r\n$$\r\n\\begin{array}{lll}\r\n{\\text{示例：将八进制数 } (153.54)_8 \\text{ 转换为二进制数。}} \\\\\r\n\\hline\r\n\\text{1. 整数部分处理:} &amp; (153)_8 \\\\\r\n   &amp; \\text{每位八进制转3位二进制:} &amp; 1 &amp; 5 &amp; 3 \\\\\r\n   &amp; &amp; \\downarrow &amp; \\downarrow &amp; \\downarrow \\\\\r\n   &amp; &amp; 001 &amp; 101 &amp; 011 \\\\\r\n   &amp; \\text{合并并去除前导0:} &amp; (001101011)_2 \\rightarrow\r\n(1101011)_2 \\\\\r\n\\hline\r\n\\text{2. 小数部分处理:} &amp; (.54)_8 \\\\\r\n   &amp; \\text{每位八进制转3位二进制:} &amp; 5 &amp; 4 \\\\\r\n   &amp; &amp; \\downarrow &amp; \\downarrow \\\\\r\n   &amp; &amp; 101 &amp; 100 \\\\\r\n   &amp; \\text{合并并去除末尾0 (如有必要):} &amp; (.101100)_2\r\n\\rightarrow (.1011)_2 \\\\\r\n\\hline\r\n\\text{3. 最终合并结果:} &amp; (1101011.1011)_2\r\n\\end{array}\r\n$$\r\n二进制与十六进制互转\r\n二进制转十六进制 (四位分组，8421法)：\r\n1位十六进制数可以表示从 0 到 15 的数字（0-9, A-F），而\r\n4位二进制数正好也能表示从 0 到 15 的值（共16种组合），所以我们可以将每\r\n4位二进制数转换为 1位十六进制数。位权是 23,\r\n22, 21, 20，也就是 8, 4, 2,\r\n1。所以，每一组4位二进制数转换为十六进制数码时，是基于”8-4-2-1”的位权相加得到的。\r\n十六进制数码与二进制对应关系：\r\n\r\n\r\n\r\n十六进制\r\n等效十进制\r\n4位二进制 (8421)\r\n\r\n\r\n\r\n\r\n0\r\n0\r\n0000\r\n\r\n\r\n1\r\n1\r\n0001\r\n\r\n\r\n2\r\n2\r\n0010\r\n\r\n\r\n3\r\n3\r\n0011\r\n\r\n\r\n4\r\n4\r\n0100\r\n\r\n\r\n5\r\n5\r\n0101\r\n\r\n\r\n6\r\n6\r\n0110\r\n\r\n\r\n7\r\n7\r\n0111\r\n\r\n\r\n8\r\n8\r\n1000\r\n\r\n\r\n9\r\n9\r\n1001\r\n\r\n\r\nA\r\n10\r\n1010\r\n\r\n\r\nB\r\n11\r\n1011\r\n\r\n\r\nC\r\n12\r\n1100\r\n\r\n\r\nD\r\n13\r\n1101\r\n\r\n\r\nE\r\n14\r\n1110\r\n\r\n\r\nF\r\n15\r\n1111\r\n\r\n\r\n\r\n$$\r\n\\begin{array}{lll}\r\n{\\text{示例：将二进制数 } (1101011.101101)_2 \\text{ 转换为十六进制数。}}\r\n\\\\\r\n\\hline\r\n\\text{1. 整数部分处理:} &amp; (1101011)_2 \\\\\r\n   &amp; \\text{从右向左分组 (每4位):} &amp; 110 \\quad 1011 \\\\\r\n   &amp; \\text{补0后分组:} &amp; \\mathbf{0110} \\quad \\mathbf{1011} \\\\\r\n   &amp; \\text{对应十六进制:} &amp; \\downarrow \\qquad \\downarrow \\\\\r\n   &amp; &amp; (0\\cdot8+1\\cdot4+1\\cdot2+0\\cdot1)=6_{16} \\quad\r\n(1\\cdot8+0\\cdot4+1\\cdot2+1\\cdot1)=B_{16} \\\\\r\n   &amp; \\text{整数部分结果:} &amp; (6B)_{16} \\\\\r\n\\hline\r\n\\text{2. 小数部分处理:} &amp; (.101101)_2 \\\\\r\n   &amp; \\text{从左向右分组 (每4位):} &amp; 1011 \\quad 01 \\\\\r\n   &amp; \\text{补0后分组:} &amp; \\mathbf{1011} \\quad \\mathbf{0100} \\\\\r\n   &amp; \\text{对应十六进制:} &amp; \\downarrow \\qquad \\downarrow \\\\\r\n   &amp; &amp; (1\\cdot8+0\\cdot4+1\\cdot2+1\\cdot1)=B_{16} \\quad\r\n(0\\cdot8+1\\cdot4+0\\cdot2+0\\cdot1)=4_{16} \\\\\r\n   &amp; \\text{小数部分结果:} &amp; (.B4)_{16} \\\\\r\n\\hline\r\n\\text{3. 合并结果:} &amp; (6B.B4)_{16}\r\n\\end{array}\r\n$$\r\n十六进制转二进制 (一位拆四位)：\r\n规则：将十六进制数的每一位直接用其对应的4位二进制数替换。整数部分高位的0通常可以省略（除非单独一位0），小数部分末尾的0也可以省略。\r\n$$\r\n\\begin{array}{lll}\r\n{\\text{示例：将十六进制数 } (6B.B4)_{16} \\text{ 转换为二进制数。}} \\\\\r\n\\hline\r\n\\text{1. 整数部分处理:} &amp; (6B)_{16} \\\\\r\n   &amp; \\text{每位十六进制转4位二进制:} &amp; 6 &amp; B \\\\\r\n   &amp; &amp; \\downarrow &amp; \\downarrow \\\\\r\n   &amp; &amp; 0110 &amp; 1011 \\\\\r\n   &amp; \\text{合并并去除前导0:} &amp; (01101011)_2 \\rightarrow\r\n(1101011)_2 \\\\\r\n\\hline\r\n\\text{2. 小数部分处理:} &amp; (.B4)_{16} \\\\\r\n   &amp; \\text{每位十六进制转4位二进制:} &amp; B &amp; 4 \\\\\r\n   &amp; &amp; \\downarrow &amp; \\downarrow \\\\\r\n   &amp; &amp; 1011 &amp; 0100 \\\\\r\n   &amp; \\text{合并并去除末尾0 (如有必要):} &amp; (.101100)_2\r\n\\rightarrow (.1011)_2 \\\\\r\n\\hline\r\n\\text{3. 最终合并结果:} &amp; (1101011.1011)_2\r\n\\end{array}\r\n$$\r\n八进制与十六进制互转\r\n(以二进制为桥梁)\r\n八进制转十六进制：\r\n规则：先将每一位八进制数转换为3位二进制数，然后将得到的完整二进制串重新按4位一组进行划分（从小数点开始，分别向左、向右，不足4位则补0），最后将每4位二进制数转换为对应的十六进制数。\r\n$$\r\n\\begin{array}{lll}\r\n{\\text{示例：将八进制数 } (153.54)_8 \\text{ 转换为十六进制数。}} \\\\\r\n\\hline\r\n\\text{1. 八进制转二进制 (一位拆三位):} \\\\\r\n   &amp; (153.54)_8 \\\\\r\n   &amp; \\text{整数部分: } 1 \\rightarrow 001, \\quad 5 \\rightarrow 101,\r\n\\quad 3 \\rightarrow 011 &amp; \\Rightarrow (001101011)_2 \\\\\r\n   &amp; \\text{小数部分: } 5 \\rightarrow 101, \\quad 4 \\rightarrow 100\r\n&amp; \\Rightarrow (.101100)_2 \\\\\r\n   &amp; \\text{合并二进制: } (001101011.101100)_2 \\\\\r\n\\hline\r\n\\text{2. 二进制重新分组 (四位一组):} \\\\\r\n   &amp; \\text{整数部分 (从右向左): } 001101011 \\rightarrow 0110 \\quad\r\n1011 &amp; \\text{(补前导0后为 0110 1011)} \\\\\r\n   &amp; \\text{小数部分 (从左向右): } 101100 \\rightarrow 1011 \\quad 00\r\n&amp; \\text{(补末尾0后为 1011 0000)} \\\\\r\n   &amp; \\text{分组后二进制: } (\\mathbf{0110} \\quad \\mathbf{1011} .\r\n\\mathbf{1011} \\quad \\mathbf{0000})_2 \\\\\r\n\\hline\r\n\\text{3. 二进制转十六进制 (四位转一位):} \\\\\r\n   &amp; 0110_2 \\rightarrow 6_{16} \\\\\r\n   &amp; 1011_2 \\rightarrow B_{16} \\\\\r\n   &amp; 1011_2 \\rightarrow B_{16} \\\\\r\n   &amp; 0000_2 \\rightarrow 0_{16} \\\\\r\n   &amp; \\text{合并结果 (去除小数末尾的0): } (6B.B0)_{16} \\rightarrow\r\n(6B.B)_{16} \\\\\r\n\\hline\r\n\\text{最终结果:} &amp; (153.54)_8 = (6B.B)_{16}\r\n\\end{array}\r\n$$\r\n十六进制转八进制：\r\n规则：先将每一位十六进制数转换为4位二进制数，然后将得到的完整二进制串重新按3位一组进行划分（从小数点开始，分别向左、向右，不足3位则补0），最后将每3位二进制数转换为对应的八进制数。\r\n$$\r\n\\begin{array}{lll}\r\n{\\text{示例：将十六进制数 } (6B.B)_{16} \\text{ 转换为八进制数。}} \\\\\r\n\\hline\r\n\\text{1. 十六进制转二进制 (一位拆四位):} \\\\\r\n   &amp; (6B.B)_{16} \\\\\r\n   &amp; \\text{整数部分: } 6 \\rightarrow 0110, \\quad B \\rightarrow 1011\r\n&amp; \\Rightarrow (01101011)_2 \\\\\r\n   &amp; \\text{小数部分: } B \\rightarrow 1011 &amp; \\Rightarrow\r\n(.1011)_2 \\\\\r\n   &amp; \\text{合并二进制: } (01101011.1011)_2 \\\\\r\n\\hline\r\n\\text{2. 二进制重新分组 (三位一组):} \\\\\r\n   &amp; \\text{整数部分 (从右向左): } 01101011 \\rightarrow 001 \\quad 101\r\n\\quad 011 &amp; \\text{(补前导0后为 001 101 011)} \\\\\r\n   &amp; \\text{小数部分 (从左向右): } 1011 \\rightarrow 101 \\quad 1 &amp;\r\n\\text{(补末尾0后为 101 100)} \\\\\r\n   &amp; \\text{分组后二进制: } (\\mathbf{001} \\quad \\mathbf{101} \\quad\r\n\\mathbf{011} . \\mathbf{101} \\quad \\mathbf{100})_2 \\\\\r\n\\hline\r\n\\text{3. 二进制转八进制 (三位转一位):} \\\\\r\n   &amp; 001_2 \\rightarrow 1_8 \\\\\r\n   &amp; 101_2 \\rightarrow 5_8 \\\\\r\n   &amp; 011_2 \\rightarrow 3_8 \\\\\r\n   &amp; 101_2 \\rightarrow 5_8 \\\\\r\n   &amp; 100_2 \\rightarrow 4_8 \\\\\r\n   &amp; \\text{合并结果: } (153.54)_8 \\\\\r\n\\hline\r\n\\text{最终结果:} &amp; (6B.B)_{16} = (153.54)_8\r\n\\end{array}\r\n$$\r\n计算机中的运算采用的是补码\r\ngraph TD\r\n    A[\"原码(负数: 1 | 数值位)\"] -->|符号位不变, 数值位取反| B(\"反码(负数: 1 | 数值位取反)\");\r\n    B -->|\"末位加1\"| C(\"补码(负数: 反码+1)\");\r\n    C -->|\"符号位取反\"| D(移码);\r\n\r\n    C -->|\"减1再按位取反（数值位）或各位取反（包括符号位）再加1特殊定义：对于无法用原码表示的最小负数（如8位中的-128，补码10000000）\"| A_rev(原码);\r\n    B -->|\"符号位不变, 数值位取反\"| A_rev2(原码);\r\n    D -->|\"符号位取反\"| C_rev(补码);\r\n\r\n    style A fill:#FFDAB9,stroke:#A0522D\r\n    style B fill:#ADD8E6,stroke:#4682B4\r\n    style C fill:#90EE90,stroke:#3CB371\r\n    style D fill:#FFFFE0,stroke:#BDB76B\r\n    style A_rev fill:#FFDAB9,stroke:#A0522D\r\n    style A_rev2 fill:#FFDAB9,stroke:#A0522D\r\n    style C_rev fill:#90EE90,stroke:#3CB371\r\n\r\n\r\n原码、反码：+0 和 −0 两种表示。\r\n补码、移码：0 只有一种表示。\r\n原码和反码由于存在 +0 和 −0，实际能表示的数值个数比 2N 少一个。\r\n补码通过”人为规定”，将 −0 的编码\r\n(100...0 在原码中是 −0) 用来表示多一个负数 (−2N − 1)，从而实现了\r\n2N\r\n个唯一数值的表示。\r\n移码的范围取决于偏置值的选择，但其能表示的真值数量和补码一致。\r\n\r\n\r\n计算机取值是固定8位字长：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n码制 (详细说明)\r\n整数范围\r\n定点小数范围\r\n数值个数\r\n零的表示\r\n+1 (示例, n=8)\r\n-1 (示例, n=8)\r\n1 + (-1)  (二进制,\r\nn=8)\r\n1 + (-1)  (真值,\r\nn=8)\r\n\r\n\r\n\r\n\r\n原码\r\n(Sign-Magnitude)符号位加上数值的绝对值的二进制表示。零的表示不唯一：有\r\n+0 (00000000) 和 -0\r\n(10000000)。\r\n[−(2N − 1 − 1), 2N − 1 − 1]\r\n[−(1 − 2−(N − 1)), 1 − 2−(N − 1)]\r\n2N − 1\r\n+0, -0\r\n00000001\r\n10000001\r\n10000010\r\n-2\r\n\r\n\r\n反码 (One’s\r\nComplement)正数: 同原码负数: 原码数值位取反+0:\r\n00000000-0: 11111111\r\n[−(2N − 1 − 1), 2N − 1 − 1]\r\n[−(1 − 2−(N − 1)), 1 − 2−(N − 1)]\r\n2N − 1\r\n+0, -0\r\n00000001\r\n11111110\r\n11111111\r\n-0\r\n\r\n\r\n补码 (Two’s\r\nComplement)定义:正数:\r\n同原反码负数: 反码末位+1零表示:唯一\r\n00000000简化了硬件设计。加法和减法可以用相同的电路实现（减法通过加负数的补码）补码比原码/反码能多表示一个最小负数\r\n[−2N − 1, 2N − 1 − 1]假设字长为3，则最小负数：100最大负数：111最大正数：011\r\n[−1, 1 − 2−(N − 1)]\r\n2N\r\n+0 (唯一)\r\n00000001\r\n11111111\r\n00000000\r\n0\r\n\r\n\r\n移码\r\n(Excess/Biased)补码符号位取反,\r\n其余不变零的表示通常不唯一，取决于偏置值\r\n[−2N − 1, 2N − 1 − 1]\r\n[−1, 1 − 2−(N − 1)]\r\n2N\r\n唯一 (取决于偏置)\r\n10000001\r\n01111111\r\n00000000\r\n-128 (偏置值 2N − 1)\r\n\r\n\r\n\r\n\r\n原码不使用负权重的计算方式，是因为它的定义就是将符号和数值分开表示，追求的是表示上的直观性。而负权重计算是补码为了实现算术运算的便捷性而采用的特定编码规则。\r\n\r\n原码的定义：直接和直观\r\n“符号-数值”分离：原码的设计思路非常直观，它将一个数的符号和其绝对值（大小）分开处理。\r\n符号位：最高位专门用来表示正负（0为正，1为负）。它就是一个纯粹的”标志”，告诉我们这个数是正还是负。\r\n数值位：剩下的 n-1\r\n位表示这个数的绝对值，按照标准的无符号二进制数来解读。\r\n计算方式：因此，解读一个原码表示的数，就是先看符号位确定正负，然后将数值位直接转换为十进制得到其绝对值。例如，3位原码\r\n111，符号位 1 表示负，数值位 11 表示 21 + 20 = 3，所以整个数是\r\n-3。\r\n补码的定义：为算术运算优化\r\n统一的加法规则：补码的设计目标之一是让加法和减法（通过加负数的补码）可以用一套相同的硬件逻辑来实现，并且符号位也参与运算。\r\n负权重的引入：为了实现这个目标，补码采用了一种特殊的编码方式。其中，最高位（符号位）被赋予了一个负的权重（即\r\n−2n − 1），而其余各位仍然是正权重。\r\n结果：这种负权重的计算方式使得补码可以直接进行二进制加法，得到正确的结果，无需像原码那样先判断符号再决定是做加法还是减法。例如，3位补码\r\n111，其值为 −1 × 22 + 1 × 21 + 1 × 20 = −4 + 2 + 1 = −1。\r\n\r\n\r\n$$\r\n等比求和公式:S_k = \\frac{a_1(q^k - 1)}{q - 1}\r\n$$\r\n\r\n\r\nimage-20250609181939351\r\n\r\n\r\n\r\nimage-20250609182050301\r\n\r\n例题：采用n位补码（包含一个符号位）表示数据，可以直接表示的数值？\r\n核心概念与推导：\r\n补码（Two’s\r\nComplement）是一种在计算机中表示有符号整数的常用方法。对于一个n位的二进制数，如果采用补码表示：\r\n\r\n符号位： 最高位（最左边的一位）为符号位。\r\n\r\n0 代表正数或零。\r\n1 代表负数。\r\n\r\n数值位： 剩下的 n-1\r\n位用于表示数值的大小。\r\n正数及零的表示：\r\n\r\n当符号位为 0\r\n时，其表示的数值与原码和反码相同。\r\n最小值为 0，表示为 000...0\r\n(n个0)。\r\n最大值为当 n-1 个数值位全为 1 时，即\r\n011...1。其值为 2n − 1 − 1。\r\n\r\n二进制转十进制： 一个由 k 个 1 组成的二进制数，其值为： 1 ⋅ 2k − 1 + 1 ⋅ 2k − 2 + … + 1 ⋅ 21 + 1 ⋅ 20\r\n这是一个等比数列求和，首项 a1 = 20 = 1，公比\r\nq = 2，项数 k。 根据等比数列求和公式 $S_k = \\frac{a_1(q^k - 1)}{q - 1}$： $S_k = \\frac{1 \\cdot (2^k - 1)}{2 - 1} = 2^k -\r\n1$ 数值位有 n-1 位，并且这 n-1 位全为 1。 所以，这里的 k 相当于\r\nn-1。 将 k = n − 1\r\n代入上面的公式 2k − 1，我们得到这些数值位所代表的值为：\r\n2(n − 1) − 1\r\n因此，当n位补码的符号位为 0，且剩下的 n-1 个数值位全为 1\r\n时（即二进制形式为 011…1），其表示的十进制值为 2n − 1 − 1。这就是n位补码能表示的最大正数。\r\n\r\n例如，对于8位补码 (n=8)，最大正数为 01111111，即\r\n28 − 1 − 1 = 27 − 1 = 128 − 1 = 127。\r\n\r\n负数的表示：\r\n\r\n当符号位为 1 时，表示负数。\r\n负数的补码定义为其绝对值的原码各位取反（得到反码），然后在末位加1。\r\n最小负数（绝对值最大）： 其补码表示为\r\n100...0 (一个1后跟n-1个0)。这个值是 −2n − 1。\r\n\r\n例如，对于8位补码 (n=8)，最小负数是 −128，表示为 10000000。\r\n常见误区与辨析：为什么最小负数不是\r\n111...1？\r\n初学者可能会直观地认为，既然符号位为1表示负数，那么数值位全为1（如\r\n111...1）应该代表绝对值最大的负数，即最小负数。这种想法更符合原码的逻辑。\r\n但在补码中，情况不同。我们以3位字长为例来说明：\r\n\r\n补码计算规则 (n=3)： 值 = −b2 ⋅ 22 + b1 ⋅ 21 + b0 ⋅ 20 = −4b2 + 2b1 + b0\r\n对于 111 (3位补码)： 值 = −1 ⋅ 4 + 1 ⋅ 2 + 1 ⋅ 1 = −4 + 2 + 1 = −1。\r\n对于 100 (3位补码)： 值 = −1 ⋅ 4 + 0 ⋅ 2 + 0 ⋅ 1 = −4 + 0 + 0 = −4。\r\n显然，-4 比 -1 更小，所以 100 (其值为 −23 − 1) 才是3位补码的最小负数。\r\n核心原因： 在补码中，最高位（符号位）具有负权 (−2n − 1)，其余位具有正权。要得到最小的负数（即绝对值最大的负数），我们需要这个大的负权起作用（最高位为1），并让其余位的正权贡献最小化（即其余所有数值位为0）。如果其余数值位也为1（如\r\n111...1\r\n的情况），它们贡献的正值会”抵消”一部分最高位的负值，使得最终结果更接近0（例如得到-1），而不是变得更小（更负）。\r\n\r\n\r\n\r\n\r\n推导过程：\r\n方法一：通过补码的定义（针对负数）\r\n对于一个负数 X，其 n\r\n位补码的定义是 2n − |X|（在模\r\n2n 的意义下）。\r\n我们给定的补码是\r\n100...0。如果我们将这个二进制串看作一个无符号整数，它的值是\r\n1 × 2n − 1 + 0 × 2n − 2 + … + 0 × 20 = 2n − 1。\r\n设 100...0 所代表的负数值为 V. 根据定义，这个补码表示 2n − |V|。\r\n所以，我们有： 2n − 1 = 2n − |V|\r\n现在解出 |V|： |V| = 2n − 2n − 1\r\n|V| = (2 × 2n − 1) − 2n − 1\r\n|V| = (2 − 1) × 2n − 1\r\n|V| = 2n − 1\r\n因为符号位（最高位）是 1，所以 V 是一个负数。 因此，V = −|V| = −2n − 1。\r\n方法二：通过补码的加权求和规则\r\n一个 n 位的二进制补码 bn − 1bn − 2...b1b0（其中\r\nbn − 1\r\n是符号位）可以直接按权展开求和，其值为： 数值 = (−bn − 1 × 2n − 1) + (bn − 2 × 2n − 2) + … + (b1 × 21) + (b0 × 20)\r\n对于补码 100...0：\r\n\r\nbn − 1 = 1\r\n(符号位)\r\nbn − 2 = 0\r\n…\r\nb0 = 0\r\n\r\n将这些值代入加权求和公式： 数值 = (−1 × 2n − 1) + (0 × 2n − 2) + (0 × 2n − 3) + … + (0 × 21) + (0 × 20)\r\n数值 = −2n − 1 + 0 + 0 + … + 0 + 0\r\n数值 = −2n − 1\r\n结论： 两种方法都表明，n 位补码 100...0\r\n表示的十进制数值是 −2n − 1。这是 n\r\n位补码能够表示的最小负数（即绝对值最大的负数）。\r\n\r\n这是补码表示的一个特点，负数范围比正数范围多一个最小负数−2n − 1。\r\n例如，对于8位补码 (n=8)，最小负数为 10000000，即 −28 − 1 = −27 = −128。\r\n\r\n\r\n\r\n最大负数（绝对值最小）： 其补码表示为\r\n111...1 (n个1)。这个值是 −1。\r\n\r\n\r\n推导过程：\r\n方法一：通过补码的定义（针对负数）\r\n对于一个负数 X，其 n\r\n位补码的定义是 2n − |X|（在模\r\n2n 的意义下）。\r\n我们给定的补码是 111...1\r\n(n个1)。如果我们将这个二进制串看作一个无符号整数，它的值是 20 + 21 + … + 2n − 1 = 2n − 1。\r\n设 111...1 所代表的负数值为 V. 根据定义，这个补码表示 2n − |V|。\r\n所以，我们将无符号整数的值与补码的定义式等同起来： 2n − 1 = 2n − |V|\r\n现在解出 |V|：\r\n从上式两边同时减去 2n： −1 = −|V| 所以， |V| = 1。\r\n因为符号位（最高位 bn − 1）是\r\n1，所以 V\r\n是一个负数。 因此，V = −|V| = −1。\r\n方法二：通过补码的加权求和规则\r\n一个 n 位的二进制补码 bn − 1bn − 2...b1b0（其中\r\nbn − 1\r\n是符号位）可以直接按权展开求和，其值为： 数值 = (−bn − 1 × 2n − 1) + (bn − 2 × 2n − 2) + … + (b1 × 21) + (b0 × 20)\r\n对于补码 111...1：\r\n\r\nbn − 1 = 1\r\n(符号位)\r\nbn − 2 = 1\r\n…\r\nb0 = 1\r\n\r\n将这些值代入加权求和公式： 数值 = (−1 × 2n − 1) + (1 × 2n − 2) + (1 × 2n − 3) + … + (1 × 21) + (1 × 20)\r\n数值 = −2n − 1 + (2n − 2 + 2n − 3 + … + 21 + 20)\r\n我们知道括号中的部分 (2n − 2 + 2n − 3 + … + 21 + 20)\r\n是一个等比数列的和，其项数为 n − 1 (从 20到 2n − 2)，首项为 20 = 1，公比为 2。 这个和等于 2(n − 1) − 1。\r\n所以，代入回去： 数值 = −2n − 1 + (2n − 1 − 1)\r\n数值 = −2n − 1 + 2n − 1 − 1\r\n数值 = −1\r\n结论： 两种方法都表明，n 位补码 111...1\r\n表示的十进制数值是 −1。这是 n\r\n位补码能够表示的最大负数（即绝对值最小的负数）。\r\n\r\n例如，对于8位补码 (n=8)，-1 表示为\r\n11111111。\r\n\r\n\r\n总体表示范围：\r\n综合正数、零和负数的表示，n位补码（包含一个符号位）可以直接表示的数值范围是：\r\n[−2n − 1, 2n − 1 − 1]\r\n\r\n示例（以 n=4 位补码为例）： * n = 4, n − 1 = 3 * 最小负数：−24 − 1 = −23 = −8\r\n(补码 1000) * 最大正数：24 − 1 − 1 = 23 − 1 = 8 − 1 = 7\r\n(补码 0111) * 零：0 (补码 0000) *\r\n范围：[−8, 7]\r\n记忆要点：\r\n\r\nn位补码比n位原码和反码能多表示一个最小的负数 (−2n − 1)。\r\n\r\n详细解释：\r\n核心原因：零的表示方式不同\r\n\r\n原码 (Sign-Magnitude) 和 反码 (One’s Complement)：\r\n\r\n在这两种表示法中，零都有两种表示形式：\r\n\r\n原码： +0 表示为\r\n000...0，-0 表示为 100...0。\r\n反码： +0 表示为\r\n000...0，-0 表示为 111...1\r\n(全1)。\r\n\r\n因为零有两种表示，这实际上”浪费”了一个编码。对于n位二进制数，总共有\r\n2n\r\n种不同的编码组合。如果零占用了两种，那么能表示的非零数值就会少一个。\r\n表示范围：\r\n因此，它们能表示的数值范围都是对称的，通常是 [−(2n − 1 − 1), 2n − 1 − 1]。\r\n\r\n例如，对于8位原码/反码，范围是 [−127, 127]。\r\n最小的负数（绝对值最大的）是 −(2n − 1 − 1)。\r\n\r\n\r\n补码 (Two’s Complement)：\r\n\r\n在 补码 表示法中，由于零的表示是唯一的 (000…0)，原先用于表示 -0\r\n的那个编码 100…0\r\n被赋予了一个全新的、非零的数值含义。这个新的含义就是：表示数值 −2n − 1\r\n扩展了负数范围： 通过将 100…0 这个编码模式从表示 -0 转变为表示 −2n − 1，补码能够比原码和反码多表示一个负数。原码和反码的最小负数是\r\n−(2n − 1 − 1)，而补码的最小负数是\r\n−2n − 1，后者比前者更小（更负）。\r\n因此它能表示的最小负数比原码和反码更小（例如，8位补码能表示-128，而8位原码/反码只能表示到-127）。\r\n因此它表示的不同整数的总个数比原码和反码多一个\r\n−2n − 1最小的负数（2n 个 vs 2n − 1 个）。\r\n\r\n\r\n总结与对比：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\n原码 (Sign-Magnitude)\r\n反码 (One’s Complement)\r\n补码 (Two’s Complement)\r\n\r\n\r\n\r\n\r\n零的表示\r\n00...0\r\n(+0)10...0 (-0)\r\n00...0\r\n(+0)11...1 (-0)\r\n00...0 (唯一)\r\n\r\n\r\n编码\r\n10...0\r\n-0\r\n−(2n − 1 − 1)\r\n−2n − 1\r\n\r\n\r\n最小负数\r\n−(2n − 1 − 1)\r\n−(2n − 1 − 1)\r\n−2n − 1\r\n\r\n\r\n最大正数\r\n2n − 1 − 1\r\n2n − 1 − 1\r\n2n − 1 − 1\r\n\r\n\r\n总范围\r\n[−(2n − 1 − 1), 2n − 1 − 1]\r\n[−(2n − 1 − 1), 2n − 1 − 1]\r\n[−2n − 1, 2n − 1 − 1]\r\n\r\n\r\n\r\n\r\n零的表示是唯一的 (00...0)。\r\n正数范围：[0, 2n − 1 − 1]\r\n负数范围：[−2n − 1, −1]\r\n\r\n例题：如果2X的补码是90H，那么X的真值是？\r\n\r\n\r\nimage-20250609183747331\r\n\r\n如题目中 2X 的补码是 90H：\r\n\r\n90H → 二进制 100100002 (这是 2X 的补码)。\r\n判断符号：最高位为1，是负数。\r\n求 2X 的原码：\r\n\r\n补码 100100002\r\n减1 (得到反码)：100100002 − 1 = 100011112\r\n(这是 2X 的反码)\r\n符号位不变，数值位取反 (得到原码)：1 (符号) 11100002 (数值位 00011112 取反) → 111100002 (这是 2X 的原码)。\r\n\r\n2X 的原码 1(符号)11100002\r\n表示十进制 −(64 + 32 + 16) = −112。\r\n所以 X = −112/2 = −56。\r\n\r\n浮点数\r\n\r\n\r\n浮点数\r\n\r\n逻辑运算 (Logical Operations)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n逻辑运算符\r\n符号 (Symbol)\r\n含义 (Meaning)\r\n场景 (Scenario)\r\n\r\n\r\n\r\n\r\n逻辑与\r\nAND /\r\n&amp;&amp;/*\r\n连接的两个条件同时为真时，结果才为真；只要有一个为假，结果就为假。\r\n类似于电路中的串联，任何一处断开（为假），整个电路就不通（为假）。\r\n\r\n\r\n逻辑或\r\nOR / ||/+\r\n连接的两个条件只要有一个为真，结果就为真；只有两者同时为假时，结果才为假。\r\n类似于电路中的并联，只要有一条线路是通路（为真），整个系统就是通路（为真）。\r\n\r\n\r\n逻辑非\r\nNOT / !\r\n取反操作，真变假，假变真。\r\n对单一条件的否定判断。\r\n\r\n\r\n逻辑异或\r\nXOR / ^/ ⊕\r\n当两个输入不同时输出为真，否则为假。\r\n密码学、错误检测、数字电路设计。\r\n\r\n\r\n\r\n\r\n括号\r\n()：优先级最高，任何在括号内的表达式会优先计算。\r\n逻辑非 !：高于所有算术运算符。\r\n算术运算符：先乘除取模 * / %，后加减\r\n+ -。\r\n关系运算符：先大于小于\r\n&gt; &lt; &gt;= &lt;=，后等于不等于\r\n== !=。\r\n逻辑运算符：先逻辑与\r\n&amp;&amp;、+，后逻辑或 ||、*。\r\n赋值运算符\r\n=：优先级最低，最后执行。\r\n\r\n例题：判断字长为16位的整数\r\nA，第四位（从右向左数）是否全为零？\r\n\r\n背景知识：16进制数 F 转换为二进制是\r\n1111。位操作通常从右向左计数，最低位为第0位。\r\n分析：我们需要判断 A\r\n的第4位（从右数，假设从0开始编号，即第3位）是否为0。一个常用的方法是使用逻辑与操作符，将\r\nA\r\n与一个只有目标位为1，其余位为0的掩码进行逻辑与操作。如果结果为0，则说明\r\nA 的目标位为0。\r\n选项分析： $$\r\n\\begin{array}{|c|l|l|}\r\n\\hline\r\n\\textbf{选项} &amp; \\textbf{表达式} &amp; \\textbf{分析与结论} \\\\\r\n\\hline\r\n\\text{A} &amp; A \\&amp; \\text{0x000F} == 0 &amp;\r\n\\begin{array}{l}\r\n\\text{检查 A 的最低四位 (Mask: } (000F)_{16} = (1111)_2 \\text{) 是否全为\r\n0。} \\\\\r\n\\text{若低四位为 } (0000)_2 \\text{, 则 } (0000)_2 \\&amp; (1111)_2 =\r\n(0000)_2 \\rightarrow 0 \\text{。} \\\\\r\n\\textbf{结论：正确}\r\n\\end{array} \\\\\r\n\\hline\r\n\\text{B} &amp; A \\| \\text{0x000F} == \\text{0x000F} &amp;\r\n\\begin{array}{l}\r\n\\text{无论 A 的低四位是 } (0000)_2 \\text{ 还是 } (0010)_2 \\text{, 与 }\r\n(1111)_2 \\text{ 或运算结果均为 } (1111)_2 \\text{。} \\\\\r\n\\text{无法判断低四位是否全为 0。} \\\\\r\n\\textbf{结论：错误}\r\n\\end{array} \\\\\r\n\\hline\r\n\\text{C} &amp; A \\oplus \\text{0x000F} == 0 &amp;\r\n\\begin{array}{l}\r\n\\text{异或 (XOR) 操作。仅当 A 的低四位为 } (1111)_2 \\text{ 时, 结果才为\r\n0。} \\\\\r\n\\text{此为判断低四位是否全为 1。} \\\\\r\n\\textbf{结论：错误}\r\n\\end{array} \\\\\r\n\\hline\r\n\\text{D} &amp; A \\&amp; \\text{0x000F} == \\text{0x000F} &amp;\r\n\\begin{array}{l}\r\n\\text{与 (AND) 操作。仅当 A 的低四位为 } (1111)_2 \\text{ 时, 结果才为 }\r\n(1111)_2 \\text{。} \\\\\r\n\\text{此为判断低四位是否全为 1。} \\\\\r\n\\textbf{结论：错误}\r\n\\end{array} \\\\\r\n\\hline\r\n\\end{array}\r\n$$\r\n\r\n例题：布尔表达式的短路求值\r\n题目：对布尔表达式进行短路求值是指，无须对表达式中所有操作数或运算符进行计算就可确定表达式的值。对于表达式\r\na or ((c &lt; d) and b)，当（ ）时可进行短路计算。\r\n核心概念：短路求值 (Short-circuit Evaluation)\r\n\r\n逻辑或 (OR / ||)：在表达式\r\nX or Y 中，如果 X 为\r\ntrue，则整个表达式的结果必定为\r\ntrue，无需再计算 Y。\r\n逻辑与 (AND / &amp;&amp;)：在表达式\r\nX and Y 中，如果 X 为\r\nfalse，则整个表达式的结果必定为\r\nfalse，无需再计算 Y。\r\n\r\n题目分析：\r\n给定的表达式为 a or ((c &lt; d) and b)，其顶层是一个逻辑\r\nor 运算。根据 or\r\n的短路规则，只要左侧的操作数 a 为\r\ntrue，整个表达式的值就确定为\r\ntrue，右侧的复杂表达式 ((c &lt; d) and b)\r\n将被完全跳过，不进行任何计算。这就实现了短路求值。\r\n选项分析：\r\n$$\r\n\\begin{array}{|c|l|l|}\r\n\\hline\r\n\\textbf{选项} &amp; \\textbf{条件} &amp; \\textbf{分析与结论} \\\\\r\n\\hline\r\n\\text{A} &amp; d \\text{ 为 true} &amp; \\text{d\r\n在表达式右侧深层嵌套，其值无法直接决定是否短路。} \\\\\r\n\\hline\r\n\\text{B} &amp; a \\text{ 为 true} &amp;\r\n    \\begin{array}{l}\r\n    \\text{当 a 为 true 时，根据 or 运算的短路规则，} \\\\\r\n    \\text{整个表达式结果直接为 true，右侧部分被跳过。} \\\\\r\n    \\textbf{结论：正确}\r\n    \\end{array} \\\\\r\n\\hline\r\n\\text{C} &amp; b \\text{ 为 true} &amp; \\text{b 在表达式右侧，只有当 a 为\r\nfalse 时才会被求值。} \\\\\r\n\\hline\r\n\\text{D} &amp; c \\text{ 为 true} &amp; \\text{c\r\n在表达式右侧深层嵌套，其值无法直接决定是否短路。} \\\\\r\n\\hline\r\n\\end{array}\r\n$$\r\n校验码：奇偶校验 (Parity\r\nCheck)\r\n\r\n校验码 (Check Code):\r\n在原始数据（信息位）的基础上，通过特定算法增加一些冗余信息（校验位），用于在数据传输或存储后检测内容是否发生错误。其核心思想是增加冗余度。\r\n码距 (Hamming Distance):\r\n指在一个编码系统中，任意两个合法“码字”之间，对应位上二进制数值不同的最小位数。\r\n用4位二进制表示$2^4=16$种状态，则有16个不同的码字：00000001=&gt;码距为10010...1111\r\n码距越大，检错和纠错能力越强。奇偶校验通过增加1位校验位，将码距从1提升到2。\r\n\r\n奇偶校验是一种简单、易于实现的检错码。它通过添加一个校验位，使得整个码字（信息位\r\n+ 校验位）中“1”的个数满足特定的奇偶性要求。\r\n\r\n奇校验 (Odd Parity):\r\n确保整个码字中“1”的个数为奇数。\r\n偶校验 (Even Parity):\r\n确保整个码字中“1”的个数为偶数。\r\n\r\n假设原始信息位为\r\n1011001，我们来计算其奇校验和偶校验的校验位。\r\n$$\r\n\\begin{array}{|l|l|l|}\r\n\\hline\r\n\\textbf{校验类型} &amp; \\textbf{计算过程} &amp; \\textbf{最终码字\r\n(校验位在后)} \\\\\r\n\\hline\r\n\\textbf{奇校验} &amp;\r\n    \\begin{array}{l}\r\n    \\text{信息位: } 1011001 \\\\\r\n    \\text{“1”的个数: 4 (偶数)} \\\\\r\n    \\text{为使总数为奇数，需添加校验位: } \\textbf{1}\r\n    \\end{array} &amp;\r\n    1011001\\textbf{1} \\\\\r\n\\hline\r\n\\textbf{偶校验} &amp;\r\n    \\begin{array}{l}\r\n    \\text{信息位: } 1011001 \\\\\r\n    \\text{“1”的个数: 4 (偶数)} \\\\\r\n    \\text{为使总数为偶数，需添加校验位: } \\textbf{0}\r\n    \\end{array} &amp;\r\n    1011001\\textbf{0} \\\\\r\n\\hline\r\n\\end{array}\r\n$$\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\n描述\r\n\r\n\r\n\r\n\r\n检错能力\r\n能够检测出任意奇数位（如1、3、5位）的错误。\r\n\r\n\r\n检错盲区\r\n无法检测出任意偶数位（如2、4、6位）的错误。这是因为偶数个位的翻转不会改变码字中“1”的整体奇偶性。\r\n\r\n\r\n纠错能力\r\n完全不具备纠错能力。它只能发现“出错了”，但无法确定是哪一位错了。\r\n\r\n\r\n\r\n例题：奇数个数据位出错，则可检测出该错误但无法纠错\r\nA. 若所有奇数位出错 B. 若所有偶数位出错 C.\r\n奇数个数据位出错，则可检测出该错误但无法纠错 D.\r\n若有偶数个数据位出错\r\n分析：\r\n$$\r\n\\begin{array}{|c|l|l|}\r\n\\hline\r\n\\textbf{选项} &amp; \\textbf{内容} &amp; \\textbf{分析与结论} \\\\\r\n\\hline\r\n\\text{A, B} &amp; \\text{奇数/偶数位出错} &amp;\r\n    \\begin{array}{l}\r\n    \\text{奇偶校验关心的是出错位的【个数】，而非出错位的【位置】。} \\\\\r\n    \\text{无论是奇数位还是偶数位出错，都无法直接判断检错结果。} \\\\\r\n    \\textbf{结论：错误}\r\n    \\end{array} \\\\\r\n\\hline\r\n\\text{C} &amp; \\text{奇数个数据位出错} &amp;\r\n    \\begin{array}{l}\r\n    \\text{当有奇数个位发生翻转（0变1或1变0）时，} \\\\\r\n    \\text{码字中“1”的个数的奇偶性必然会改变，从而破坏原有的校验规则。}\r\n\\\\\r\n    \\text{因此，奇偶校验能够可靠地检测出奇数个位的错误。无法检测出任意偶数位（如2、4、6位）的错误。这是因为偶数个位的翻转不会改变码字中“1”的整体奇偶性。}\r\n\\\\\r\n    \\textbf{结论：正确}\r\n    \\end{array} \\\\\r\n\\hline\r\n\\text{D} &amp; \\text{偶数个数据位出错} &amp;\r\n    \\begin{array}{l}\r\n    \\text{当有偶数个位发生翻转时，变化的“1”和“0”会相互抵消，} \\\\\r\n    \\text{导致码字整体的奇偶性不变，校验机制失效，无法发现错误。} \\\\\r\n    \\textbf{结论：错误}\r\n    \\end{array} \\\\\r\n\\hline\r\n\\end{array}\r\n$$\r\n奇偶校验的有效性，完全依赖于整个码字中“1”的个数是奇数还是偶数。如果这个奇偶性被破坏，我们就能发现错误。\r\n我们以偶校验为例，并使用一个7位的信息 1011001\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n步骤\r\n正常情况 (无错误)\r\n奇数位错误 (1位出错)\r\n偶数位错误 (2位出错)\r\n\r\n\r\n\r\n\r\n1. 发送端编码\r\n信息: 1011001“1”的个数: 4\r\n(偶数)为满足偶校验，校验位为 0发送码字:\r\n1011001**0**\r\n(同左)\r\n(同左)\r\n\r\n\r\n2. 传输中发生错误\r\n-\r\n第1位 1 翻转为\r\n0错误码字: **0**0110010\r\n第1、2位翻转 (10 -&gt;\r\n01)错误码字: **01**110010\r\n\r\n\r\n3. 接收端校验\r\n接收码字: 10110010“1”的个数:\r\n4 (偶数)\r\n接收码字: 00110010“1”的个数:\r\n3 (奇数)\r\n接收码字: 01110010“1”的个数:\r\n4 (偶数)\r\n\r\n\r\n4. 结论\r\n奇偶性符合约定 (偶数)✅\r\n数据正确\r\n奇偶性不符合约定\r\n(应为偶数)❌ 成功检测到错误\r\n奇偶性符合约定 (偶数)⚠️\r\n未能检测到错误\r\n\r\n\r\n\r\n\r\n奇数个错误：每翻转1位，码字中“1”的个数要么+1，要么-1，这必然会改变原有的奇偶性（奇数变偶数，偶数变奇数）。所以，校验机制总能发现它\r\n偶数个错误：当发生2位错误时，有三种可能：\r\n\r\n两个 0 变成 1：1 的总数 +2。\r\n两个 1 变成 0：1 的总数 -2。\r\n一个 0 变 1，一个 1 变 0：1 的总数不变 (+1 再 -1)。\r\n无论哪种情况，1 的总数变化量都是一个偶数（+2, -2,\r\n0）。一个数（无论奇偶）加上或减去一个偶数，其本身的奇偶性是不会改变的。\r\n\r\n\r\n因此，在上面的例子中，当2位出错后，接收端计算后发现“1”的个数仍然是偶数，就错误地认为数据是正确的，这就是奇偶校验无法检测出偶数位错误的原因。\r\n因此，在上面的例子中，当2位出错后，接收端计算后发现”1”的个数仍然是偶数，就错误地认为数据是正确的，这就是奇偶校验无法检测出偶数位错误的原因。\r\nCRC循环冗余校验码\r\n使用模二除法进行计算\r\ngraph TD\r\n    A[\"Cyclic Redundancy Check，循环冗余校验\"] --> B[\"特点\"]\r\n    A --> C[\"校验方式\"]\r\n    A --> D[\"工作原理\"]\r\n    A --> E[\"应用场景\"]\r\n    \r\n    B --> B1[\"可检错不可纠错\"]\r\n    B --> B2[\"无奇偶位限制\"]\r\n    B --> B3[\"使用模二除法\"]\r\n    \r\n    C --> C1[\"信息位后拼接校验位\"]\r\n    C --> C2[\"校验位位数由生成多项式决定\"]\r\n    \r\n    D --> D1[\"发送方：用生成多项式进行模二除，得到余数作为校验位\"]\r\n    D --> D2[\"接收方：用相同生成多项式除完整信息，余数为0则正确\"]\r\n    \r\n    E --> E1[\"数据通信\"]\r\n    E --> E2[\"存储系统\"]\r\n    E --> E3[\"网络传输\"]\r\n海明校验码 (Hamming Code)\r\ngraph TD\r\n    A[\"海明校验码 (Hamming Code)\"] --> B[\"特点\"]\r\n    A --> C[\"校验位计算\"]\r\n    A --> D[\"编码原理\"]\r\n    A --> E[\"应用场景\"]\r\n    \r\n    B --> B1[\"唯一既可检错也可纠错\"]\r\n    B --> B2[\"多组分组交叉校验\"]\r\n    B --> B3[\"通过码距检测与纠错\"]\r\n    \r\n    C --> C1[\"公式: 2^R ≥ M + R + 1\"]\r\n    C --> C2[\"R: 校验位个数\"]\r\n    C --> C3[\"M: 信息位个数\"]\r\n    C --> C4[\"求取满足条件的最小R值\"]\r\n    \r\n    D --> D1[\"校验位放置在2的幂次位置 (1, 2, 4, 8...)\"]\r\n    D --> D2[\"信息位放置在其他位置\"]\r\n    D --> D3[\"通过分组奇偶校验实现检错纠错\"]\r\n    \r\n    E --> E1[\"内存错误检测与纠正\"]\r\n    E --> E2[\"数据通信可靠性增强\"]\r\n\r\n可检错可纠错\r\n利用奇偶性检错和纠错\r\n通过扩大码距实现检错纠错，所以通常码距大于1。\r\n\r\n海明校验位 (R)的求取\r\n2R ≥ M + R + 1\r\n\r\nR：海明校验位的个数（即需要增加的冗余位数）。\r\nM：信息位的个数（即原始数据的位数）。\r\n通过代入 M 的值，找到满足不等式的最小 R\r\n值。\r\n通过”分组奇偶校验”实现检错纠错。\r\n校验位和信息位是相互掺杂在一起的，而不是简单地拼接在末尾。\r\n海明校验位通常放置在 (2^R) （即 (20, 21, 22, …)的位置上，也就是第\r\n1、2、4、8、16… 位。\r\n其他非 (2^R) 的位置则放置信息位。\r\n\r\n$$\r\n\\textbf{示例}：\r\n\\begin{array}{l}\r\n\\textbf{当信息位 } M = 16 \\textbf{ 时：} \\\\\r\n\\quad \\text{公式: } 2^R \\ge M + R + 1 \\\\\r\n\\quad \\text{若 } R = 4 \\text{: } 2^4 = 16 \\\\\r\n\\quad \\quad M + R + 1 = 16 + 4 + 1 = 21 \\\\\r\n\\quad \\quad 16 &lt; 21 \\quad (\\text{不满足}) \\\\\r\n\\quad \\text{若 } R = 5 \\text{: } 2^5 = 32 \\\\\r\n\\quad \\quad M + R + 1 = 16 + 5 + 1 = 22 \\\\\r\n\\quad \\quad 32 \\ge 22 \\quad (\\text{满足}) \\\\\r\n\\quad \\text{结论：当信息位为16位时，至少需要增加 } 5 \\text{\r\n个海明校验位。} \\\\\r\n\\end{array}\r\n$$\r\n例题：海明码校验\r\n$$\r\n\\begin{array}{l}\r\n\\text{海明码是一种纠错码，其方法是为需要校验的数据位增加若干校验位，} \\\\\r\n\\text{使得校验位的值决定于某些被校验位的数据，当被校验数据出错时，} \\\\\r\n\\text{可根据校验位的变化找到出错位，从而纠正错误。} \\\\\r\n\\\\\r\n\\textbf{1. 对于 } 32 \\textbf{ 位的数据，至少需要增加（ } 6 \\textbf{\r\n）个校验位才能构成海明码。}\\\\\r\n\\textbf{当信息位 } M = 32 \\textbf{ 时：} \\\\\r\n\\quad \\text{公式: } 2^R \\ge M + R + 1 \\\\\r\n\\quad \\text{若 } R = 5 \\text{: } 2^5 = 32 \\\\\r\n\\quad \\quad M + R + 1 = 32 + 5 + 1 = 38 \\\\\r\n\\quad \\quad 32 &lt; 38 \\quad (\\text{不满足}) \\\\\r\n\\quad \\text{若 } R = 6 \\text{: } 2^6 = 64 \\\\\r\n\\quad \\quad M + R + 1 = 32 + 6 + 1 = 39 \\\\\r\n\\quad \\quad 64 \\ge 39 \\quad (\\text{满足}) \\\\\r\n\\quad \\text{结论：当信息位为32位时，至少需要增加 } 6 \\text{\r\n个海明校验位。}\r\n\\\\\r\n\\textbf{2. 以10位数据为例，其海明码表示为：}\\\\\r\n\\quad D_9D_8D_7D_6D_5D_4P_4D_3D_2D_1P_3D_0P_2P_1 \\\\\r\n\\quad \\text{其中 } D_i \\text{ (} 0 \\le i \\le 9 \\text{) 表示数据位，} P_j\r\n\\text{ (} 1 \\le j \\le 4 \\text{) 表示校验位。} \\\\\r\n\\quad \\text{数据位 } D_9 \\text{ （从右至左 } D_9 \\text{ 的位序为 } 14\r\n\\text{，即等于 } 8+4+2 \\text{）由第8位的 } P_4 \\text{、第4位的 } P_3\r\n\\text{ 和第2位的 } P_2 \\text{ 进行校验。}\\\\\r\n\\quad \\text{数据位 } D_5 \\text{ 由（ } P_4 \\text{、} P_2 \\text{\r\n）进行校验。}\\\\\r\n\\quad \\quad \\textbf{解析：找规律} \\\\\r\n\\quad \\quad \\text{首先确定 } D_5 \\text{ 的位序。根据给出的码字序列，}\r\nD_5 \\text{ 从右向左的位序是 } 10 \\text{。} \\\\\r\n\\quad \\quad \\text{将 } 10 \\text{ 分解为 } 2 \\text{ 的幂次之和：} \\\\\r\n\\quad \\quad 10 = 8 + 2 \\\\\r\n\\quad \\quad \\text{这意味着 } D_5 \\text{ 将由位序为 } 8 \\text{ 的校验位 }\r\nP_4 \\text{ 和位序为 } 2 \\text{ 的校验位 } P_2 \\text{ 进行校验。}\r\n\\end{array}\r\n$$\r\n校验码对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n校验方式\r\n检错能力\r\n纠错能力\r\n校验位数量\r\n放置方式\r\n特点\r\n\r\n\r\n\r\n\r\n奇偶校验\r\n只能检测奇数位错误\r\n不可纠错\r\n1位\r\n拼接在头部或尾部\r\n奇校验 (Odd Parity):\r\n确保整个码字中“1”的个数为奇数。 偶校验 (Even Parity):\r\n确保整个码字中“1”的个数为偶数。\r\n\r\n\r\nCRC校验\r\n可检测多种错误\r\n不可纠错\r\n由生成多项式决定\r\n拼接在信息位尾部\r\n模二除法求余数，拼接作为校验位\r\n\r\n\r\n海明校验码\r\n可检错\r\n可纠错\r\n2R ≥ M + R + 1\r\n相互掺杂\r\n分组奇偶校验\r\n\r\n\r\n\r\nCPU组成（运算器与控制器）\r\ngraph TD\r\n    subgraph A [\"计算机硬件系统Computer Hardware System\"]\r\n        direction LR\r\n        H(\"主机Host\") --> M[\"主存 (内存)Main Memory\"]\r\n        H --> CPU\r\n        \r\n        P(\"外设Peripheral Devices\") --> I[\"输入设备(键盘, 鼠标)\"]\r\n        P --> O[\"输出设备Output Devices(显示器)\"]\r\n        P --> E[\"外存 (辅存)Secondary Storage(硬盘, U盘)\"]\r\n    end\r\n\r\n    CPU  B(\"总线Bus\")\r\n    M  B\r\n    P  B\r\n\r\n    subgraph CPU [\"Central Processing Unit\"]\r\n        direction LR\r\n        ARU(\"运算器Arithmetic Unit\")\r\n        CU(\"控制器Control Unit\")\r\n    end\r\n    \r\n    %% 样式定义\r\n    style H fill:#FFFACD,stroke:#BDB76B\r\n    style P fill:#F0F8FF,stroke:#B0C4DE\r\n    style CPU fill:#FFDAB9,stroke:#A0522D\r\n    style M fill:#E6E6FA,stroke:#9370DB\r\n    style I fill:#D4EDDA,stroke:#28A745\r\n    style O fill:#D4EDDA,stroke:#28A745\r\n    style E fill:#D4EDDA,stroke:#28A745\r\ngraph TD\r\n    CPU[\"中央处理器Central Processing Unit (CPU)\"] --> ARU[\"运算器Arithmetic Unit工厂流水线的加工区\"]\r\n    CPU --> CU[\"控制器Control Unit工厂流水线的控制中心\"]\r\n\r\n    subgraph ARU_COMP [\"运算器内部Arithmetic Unit Components\"]\r\n        ALU[\"算术逻辑单元Arithmetic Logic Unit (ALU)加工机器，执行具体操作\"]\r\n        AC[\"累加寄存器Accumulator Register (AC)临时工作台，存放加工零件\"]\r\n        DR[\"数据缓冲寄存器Data Register (DR)传送带，传输加工材料\"]\r\n        PSW[\"程序状态字寄存器Program Status Word (PSW)质量检查员，记录加工状态\"]\r\n    end\r\n    \r\n    subgraph CU_COMP [\"控制器内部Control Unit Components\"]\r\n        PC[\"程序计数器Program Counter (PC)传送带控制器，决定下个工件位置\"]\r\n        IR[\"指令寄存器Instruction Register (IR)当前加工的工件\"]\r\n        ID[\"指令译码器Instruction Decoder (ID)操作说明书，翻译加工步骤\"]\r\n        TIMING[\"时序控制电路Timing and Control Unit生产调度，协调工作流程\"]\r\n    end\r\n\r\n    ARU --> ARU_COMP\r\n    CU --> CU_COMP\r\n    \r\n    PSW -.->|\"分类存在争议:因为它既存储运算状态（属于运算器范畴），也存储控制标志（可用于控制器决策）\"| CU\r\n\r\n    %% 样式定义\r\n    style CPU fill:#FFDAB9,stroke:#A0522D,stroke-width:2px\r\n    style ARU fill:#ADD8E6,stroke:#4682B4\r\n    style CU fill:#ADD8E6,stroke:#4682B4\r\n    style ARU_COMP fill:#F0F8FF,stroke:#B0C4DE\r\n    style CU_COMP fill:#F0F8FF,stroke:#B0C4DE\r\nflowchart TD\r\n    A(\"开始CPU执行程序的过程本质上是不断重复“取指令 -> 分析指令 -> 执行指令”的循环就像厨师做菜，不断重复“看菜谱 -> 理解步骤 -> 执行烹饪”的过程\") --> B{\"PC 提供下一条指令地址就像厨师看菜谱的页码指示器\"}\r\n    B --> C[\"通过地址总线从主存中取出指令就像厨师翻到指定的菜谱页\"]\r\n    C --> D{\"指令存入 IR就像厨师阅读当前的菜谱内容\"}\r\n    D --> E[\"PC 指向下一条指令 (PC++)就像厨师标记下一道菜的页码\"]\r\n    E --> F{\"ID 译码分析 IR 中的指令就像厨师翻译菜谱步骤\"}\r\n    F --> G[\"根据指令操作ALU、寄存器等完成计算或数据转移就像厨师执行具体的烹饪操作\"]\r\n    G --> H{\"循环或结束就像厨师完成一道菜后决定是否继续下一道\"}\r\n    H --> B\r\n寻址方式（Addressing Modes）\r\ngraph TD\r\n    subgraph A [\"指令格式Instruction Format\"]\r\n        OP(\"操作码Operation Code\") -->|\"给出具体操作\"| OPCODE\r\n        ADDR[\"地址码Address Field\"] -->|\"指向数据位置\"| ADDRESS\r\n    end\r\n\r\n    subgraph B [\"寻址方式分类Addressing Modes Classification\"]\r\n        direction LR\r\n        IMM(\"立即寻址Immediate Addressing信封上直接写钱数\") -->|\"操作数直接在指令中\"| IMM_EX\r\n        DIR(\"直接寻址Direct Addressing信封上写银行账户号\") -->|\"地址在指令中\"| DIR_EX\r\n        IND(\"间接寻址Indirect Addressing信封上写账户号，再去地址\") -->|\"间接地址在指令中\"| IND_EX\r\n        REG(\"寄存器寻址Register Addressing信封上写钱包\") -->|\"寄存器中放操作数\"| REG_EX\r\n        REG_IND(\"寄存器间接寻址Register Indirect Addressing信封上写钱包，再去地址\") -->|\"寄存器中放地址\"| REG_IND_EX\r\n        IMPL(\"隐含寻址Implicit Addressing默认从钱包取钱\") -->|\"默认使用累加寄存器AC\"| IMPL_EX\r\n    end\r\n\r\n    %% 样式定义\r\n    style A fill:#FFDAB9,stroke:#A0522D\r\n    style B fill:#ADD8E6,stroke:#4682B4\r\n    style IMM fill:#D4EDDA,stroke:#28A745\r\n    style DIR fill:#D4EDDA,stroke:#28A745\r\n    style IND fill:#D4EDDA,stroke:#28A745\r\n    style REG fill:#D4EDDA,stroke:#28A745\r\n    style REG_IND fill:#D4EDDA,stroke:#28A745\r\n    style IMPL fill:#D4EDDA,stroke:#28A745\r\nCISC与RISC指令集体系\r\ngraph TD\r\n    A[计算机指令集体系发展Evolution of Computer Instruction Set Architectures] --> B(指令集设计哲学Instruction Set Design Philosophy);\r\n\r\n    B --> C(CISCComplex Instruction Set Computer);\r\n    B --> D(RISCReduced Instruction Set Computer);\r\n\r\n    C --> C1[指令数量多，功能强大More instructions, powerful functions];\r\n    C --> C2[变长格式，使用频率差异大Variable length, large frequency difference];\r\n    C --> C3[多种寻址方式Multiple addressing modes];\r\n    C --> C4[微程序控制Microprogram Control];\r\n    C --> C5[研制周期长Longer Development Cycle];\r\n\r\n    D --> D1[指令数量少，功能精简Fewer instructions, simple functions];\r\n    D --> D2[定长格式，使用频率接近Fixed length, similar frequency];\r\n    D --> D3[多寄存器寻址Register-to-Register Addressing];\r\n    D --> D4[硬布线逻辑控制Hardwired Logic Control];\r\n    D --> D5[更适合流水线执行Better for Pipelining];\r\n    D --> D6[易于编译优化，支持高级语言Easier Compiler Optimization, HLL Support];\r\n\r\n    %% 样式定义\r\n    style A fill:#FFDAB9,stroke:#A0522D,stroke-width:2px;\r\n    style B fill:#ADD8E6,stroke:#4682B4;\r\n    style C fill:#FFFACD,stroke:#BDB76B;\r\n    style D fill:#D4EDDA,stroke:#28A745;\r\n\r\n    style C1 fill:#F0F8FF,stroke:#B0C4DE;\r\n    style C2 fill:#F0F8FF,stroke:#B0C4DE;\r\n    style C3 fill:#F0F8FF,stroke:#B0C4DE;\r\n    style C4 fill:#F0F8FF,stroke:#B0C4DE;\r\n    style C5 fill:#F0F8FF,stroke:#B0C4DE;\r\n\r\n    style D1 fill:#E6F3F9,stroke:#5BB0D8;\r\n    style D2 fill:#E6F3F9,stroke:#5BB0D8;\r\n    style D3 fill:#E6F3F9,stroke:#5BB0D8;\r\n    style D4 fill:#E6F3F9,stroke:#5BB0D8;\r\n    style D5 fill:#E6F3F9,stroke:#5BB0D8;\r\n    style D6 fill:#E6F3F9,stroke:#5BB0D8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特点 (Feature)\r\nCISC (复杂指令集计算机) Complex\r\nInstruction Set Computer\r\nRISC (精简指令集计算机) Reduced\r\nInstruction Set Computer\r\n\r\n\r\n\r\n\r\n\r\n想象一个“万能工具箱”。这个工具箱里有各种各样为特定复杂任务量身定制的”专业工具”（复杂指令），比如一个可以自动完成”钻孔、拧螺丝、涂漆”整个过程的”多功能一体机”。当有新任务时，就直接往工具箱里添加一个新工具。因此，工具种类繁多，但有些工具可能很少用到，有些则非常频繁。工具的使用方式（寻址方式）也多种多样。\r\n想象一个“乐高积木盒”。这个盒子只有少数几种”基本积木”（精简指令），比如”连接”、“旋转”、“移除”等。虽然积木种类少，但通过巧妙地组合这些基本积木，可以搭建出各种各样复杂的模型（实现复杂功能）。所有的积木都大小一致（定长指令），并且组装起来非常迅速（单周期执行）。由于积木数量有限，每种积木都会被频繁地重复使用。\r\n\r\n\r\n指令数量Instruction\r\nCount\r\n较多，通常为数百条(A large number,\r\nusually hundreds)\r\n较少，通常为几十条(A small number,\r\nusually dozens)\r\n\r\n\r\n指令复杂度Instruction\r\nComplexity\r\n复杂，一条指令可完成多步操作(Complex,\r\none instruction can perform multiple operations)\r\n精简，一条指令通常只完成一个基本操作(Simple,\r\none instruction usually performs one basic operation)\r\n\r\n\r\n指令长度格式Instruction\r\nLength Format\r\n变长格式 (Variable-length format)\r\n定长格式 (Fixed-length\r\nformat)\r\n\r\n\r\n寻址方式Addressing\r\nModes\r\n多种寻址方式，复杂多样(Multiple and\r\ncomplex addressing modes)\r\n较少，主要以多寄存器寻址为主(Fewer,\r\nprimarily register-to-register addressing)\r\n\r\n\r\n通用寄存器数量General-Purpose\r\nRegisters\r\n较少(Fewer)\r\n较多，增加通用寄存器以减少访存次数(More,\r\nincreased to reduce memory access)\r\n\r\n\r\n执行控制方式Execution\r\nControl\r\n以微程序控制为主\r\n(Microprogram control)\r\n以硬布线逻辑控制为主\r\n(Hardwired logic control)\r\n\r\n\r\n编译优化与高级语言支持Compiler\r\nOptimization &amp; HLL Support\r\n优化编译较困难，支持高级程序语言不如RISC(Harder\r\nfor compiler optimization, less HLL support than RISC)\r\n更易于优化编译，有效支持高级程序语言(Easier\r\nfor compiler optimization, effective HLL support)\r\n\r\n\r\n流水线执行Pipelining\r\nSuitability\r\n适合采用流水线技术(Suitable for\r\npipelining)\r\n更适合采用流水线技术(More\r\nsuitable for pipelining)\r\n\r\n\r\n\r\n流水线技术\r\n存储系统\r\n层次化存储\r\nCache\r\n主存编址计算\r\n输入输出技术\r\n总线\r\n可靠性\r\n性能指标\r\n","tags":["resume"]}]